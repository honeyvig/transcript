hey there fellow Learners welcome to
Simply learns exciting course on Java
programming if you're keen on becoming a
coding Mastro then you have picked up
the right language jav was a brainchild
of sun microsystem isn't just a
programming language it's a key player
in building applications that run the
world from web platforms to those Nifty
apps on your smartphone in this tutorial
we are not just going to talk about
syntax and algorithms but we will embark
on a journey exploring Java's and
crannies uncovering the magic behind
object-oriented programming and diving
into vast Java standard Library whether
you are a coding Ubi or a professional
developer this course has got everything
for you to become a Java developer now
before we move on to this course I
request you guys that do not forget to
hit the Subscribe button and click the
Bell icon for further updates accelerate
your career as a software developer
through this postgraduate program in
fullstack web development course in
collaboration with carch ctm me in just
few months you'll learn modern coding
techniques with boot cam level intensity
and gain all you need to be a full stack
technologist the key features of this
course are you will receive up to 25 cus
from calch CMEs you're going to attend
master class from the Caltech ctma
instructors there will be live virtual
classes led by industry experts Hands-On
projects and integrated Labs you will
also receive online convocation by
Caltech ctme program director where 20
lessons end to endend and five phase end
projects and four Capstone projects in
four domains and you are going to build
Capstone projects in for domain this
course is also going to help you build
your own portfolio on the GitHub and
finally simply learns job assistance is
going to help you to get notice by top
hiring companies so hurry up and join
the course now hello guys this is Vikes
and let's get started with the first
topic of this series which is about
introduction to Java so when we talk
about Java it is one of the most popular
programming language out there and it
was created way back in
1991 but it was publicly released only
in
1995 it was developed by one of the
famous developers of Our Generation who
is James goling at Sun Microsystems and
then later Java was acquired by orle and
today Oracle owns Java Java is very
simple and easy to use and we will look
at different aspects of how it is easy
and simple to use it's a right once Run
Anywhere type of programming language
again we will look at details into into
into this particular concept as well and
when we talk about the usage of java you
can use it to build web applications
mobile applications desktop applications
even command line applications and at
the same time you can also use it to
build complex applications like gaming
applications building microservice es or
building distributed computing Etc let's
talk about the features of java so one
of the most prominent features of java
is that it's a objectoriented
programming language which means that
everything which happens in Java happens
around objects objects enable the
execution of the program objects talk to
each other to exchange data and messages
we will look about look at the concept
of objects in details in the upcoming
lectures it's a platform independent
language
which means that uh again going back to
the previous point of write once Run
Anywhere uh it basically enables the
program to be run on any platform once
compiled so once you have prepared your
program and you have compiled your
program then your compile program can be
run on any platform it is a strong type
checking language which means that it
will force you to respect the contracts
of the variables to the data types for
example examp if you have created a
collection which should accept strings
then you can only insert strings in that
collection and it will not allow you to
add an a number or an integer into that
collection so it's a strongly
typechecking language so when you run
your program it's a two-step process in
Java you compile the program and then
you in then you execute the program
which we also call as interpretation so
you have a Java compiler and you have a
Java interpreter you first compile your
program and then you run the program
using the help of java interpreter Java
also provides automatic garbage
collection it's a really important
feature and if you talk about the
languages prior to Java like C or C++
they did not offer this capability and
this capability made Java really popular
because it could automatically find the
unused objects and variables and remove
them from the memory to free up memory
space for the program execution it also
provides multi-threading support which
means that you can build multi-threading
applications like a gaming application
if you take the example of a racing game
for example so there's there can be one
thread which is monitoring your
leaderboard score there can be another
thread which is displaying the speed of
the car there can be another thread
which is displaying the graphic there
can be another thread which is
displaying the sound so you'll see all
of these threads are working parallell
and Java provides the support to create
such applications using the
multi-threading capability it has
Java is secure by default because there
are no pointers in Java so there are no
possibilities of having any memory leaks
or any reference leaks from the
application again if you take the
example of uh programming languages like
C or C++ you had the concept of pointers
and we we witnessed lot of uh a lot of
scenarios and lot of incidents where
there was a memory leakage happening in
the in the production application which
was which was really a bad experience
for the organizations so Java removed
the concept of pointers totally from its
programming language it's also a very
robust language because it provides a
really great exception handling
framework out of the box which
developers can use and Implement to
build really resilient applications so
now let us understand how a Java program
is run so at first you basically write
your Java program and you store your
Java program into a Java file then you
compile your Java file with the help of
the Java compiler once the program is
compiled the compiler is going to
generate another file which is a class
file and this class file is basically
the compiled file or also known as The
Bite code file so this bite code or the
the do class file code can be run on any
platform be it a Linux platform or a
Windows platform or a Mac OS platform or
any other platform to give you some more
context the first two steps where you
write your Java program and you compile
your Java program can be run on any
machine let's take an example that you
ran these two steps on a Windows machine
so you ran your you write your program
and you compile your program on a
Windows machine which generated a DOT
class file then you transported this dot
class file to a Linux machine and it
also worked there you transported your
class file to a Mac OS machine and it
worked there as well and that's
brings the platform Independence concept
of java that you can write the program
once on any platform and once you have
the bite code available then you can run
this program on any other platform of
your choice okay so that was about how
the Java program execution works and how
the platform Independence is actually
achieved now uh let us spend some time
to understand the anatomy of java so
once you download Java and install Java
on your local machine you will hear the
term jdk actually if you we'll see that
in the next lecture that when you try to
download the Java it will say jdk
download jdk stands for Java development
kit so the Java development kit is the
installation of the Java this is what
you're going to install on your machine
once the jdk or Java development kit has
been installed the jdk will provide lot
of other components as well like Java
runtime environment or JRE Java virtual
machine or jvm some class libraries and
some other supporting libraries so let
us understand what happens when your
program is run and how these components
work together to make sure that your
program runs as expected let's start
from here so you install jdk or the Java
development kit you write your program
and then you compile your program with
the help of java compiler which is
provided by jdk once the program is
compiled filed your class file will be
generated and then you can uh run that
class file using JRE in fact if you just
run your program on your local machine
JRE will automatically kick in and run
your class file so the Java runtime
environment or JRE runs your class file
with the help of these three components
let's talk about first component which
is Java virtual machine or jvm so the
Java virtual machine is actually the
virtual environment inside which your
program runs this is the real main
environment inside your class file is
running so when uh when this program is
running how does it achieve this
environment for achieving this virtual
virtual machine environment it would
need some runtime libraries and that is
provided by these class libraries for
example they would be a runtime jar or
rt. jar as a shorthand which will be
supplied to the program at the Run time
to make sure that the program runs
smoothly then there are other supporting
libraries as well which your program may
be using for example if this program
this class file is let's say a
calculator program then it might be
using a square root function from java.
maath package so how do how does the
java. maath package get supplied at
runtime it would be supplied by the
other supporting libraries which are
present inside J so J will make sure
that your program runs inside the Java
virtual machine it gets the required
runtime libraries and it also gets the
libraries which are referred in your
program at runtime and this all together
will make sure that your program is
running so you can see jdk basically
provides gr automatically and jvm
automatically but you can also install
gr separately if you talk about that use
case where you compile your program on a
Windows machine using jdk and then you
export Ed your class file to another
machine and there you just installed the
JRE you don't install jdk there you just
installed the runtime environment and
you can run the class file just using
the runtime environment and that brings
us to the end of this lecture accelerate
your career as a software developer
through this post-graduate program and
fullstack web development course in
collaboration with ctech ctme let's get
started with installing Java we will
basically look at how we can install
Java on a Windows machine so the first
step to install Java is to download it
from the official Oracle website so for
that let's open a web browser and let's
type jdk Java download and hit enter
then you need to find the link which
says oracle.com because like we
discussed in the previous lecture uh
Java is owned by Oracle so we need to
download it from the official website
only so we can click on this link which
says Java jav SE downloads it will bring
us to the downloads page and we will see
different versions of java you can see
the Java se15 you can see Java se14 you
can also see Java se1 and all the
previous versions another thing which
you will notice that it says LTS here
which means long-term support basically
long-term support are the releases for
which Oracle is going to provide uh
long-term security patches and updates
for the non LTS releases Java will not
provide long-term support and long-term
patch fixes and long-term security fixes
so it's a good idea to analyze and
evaluate on which version you want to
develop your applications on for this
demo I think it is fine we can go with
the non-lts version and even for your uh
for your customer facing applications
you can start with a non-lts version and
then upgrade to the latest LTS version
whenever that is available so for this
demo we can download Java SC 15 and you
can also do the same on your machine it
will work exactly the same way as an LTS
works so you can click on the jdk
download option here let's click on that
it is going to bring up the downloads
detail page and you can see uh there are
multiple options given here uh in terms
of what platform you want to install
Java on whether it is a Linux platform
or it is a Mac OS machine or it is a
Windows platform so like I said in the
beginning of the demo that today we are
going to see how we can install this on
a Windows machine so I'm going to
download the windows x64 installer here
if you are working on a Linux machine or
a Mac OS machine you can download those
respective installers as well so you can
see the exe here so let's click on this
once we click on this we'll get this
popup which will ask us to accept the
Oracle technology Network license
agreement so we can hit this checkbox
and click on download jdk 15 and this
shall start the download and you will
see some some exe getting downloaded in
the in your download box here but as the
download is going to take some time and
uh I'm not going to wait for that and
that's the reason I have already
downloaded the jdk 15 for this
particular demo and that jdk is is
sitting here on my desktop which I've
downloaded PR prior to this demo so
we'll just run this particular exe which
is exactly the same exe as the one which
is being downloaded so let us double
click on this it will ask you for this
popup in some cases so you can just hit
yes basically it is asking whether you
trust this exe or not but as we
downloaded this from official Oracle
website then we can trust this
particular EXC so I will hit yes and now
the installer is going to unpack and you
might get a screen like this which will
be an installation viser for the Java SC
development kit 15 another thing which
before I proceed I just wanted to high
highlight that as well that you might
have noticed the word jdk here it's
exactly the same term which we covered
in the last lecture that when you
install Java you basically install the
jdk which is the Java development kit
and this is also visible here when it
says Java SE development kit 15 so let's
hit next then on this particular page
you have the option to change the
installation location of java if you
want to by default it is going to
install in C program files SL Java jdk
15 but if you want to change the
location and you want to install Java to
a particular custom location of your
choice that is also possible you just
hit change here and then you can choose
whatever directory or folder or place
you want to install this uh Java on and
you can CH basically select the
appropriate location for this particular
case I don't want to change that I'm
happy with the default location which is
available here so I'm just going to
proceed with this particular location
here so I I will just hit next and then
Java is going to install and it's it's
very fast installation It generally
takes few seconds as you will see in
this demo basically it is going to
unpack all the all the libraries and all
the runtime libraries and all the class
path libraries which we discussed in the
previous lecture and put all that into
the location which we specified to
install Java it will also set up the
rest of the prerequisite which are
required to run Java successfully so
looks like the Java has been
successfully installed as is visible in
this message and there's also a next
step if you want to uh access the
tutorials or the API documentations the
developer guides the release notes Etc I
don't want to do that so I will just hit
close here and now if we want to just
verify if Java is uh is installed or not
then we can verify that from the command
and prompt let me just exit this and
let's go to the command prompt to verify
to see if Java has been successfully
installed so to do that uh we'll we'll
just open the search bar and we'll type
CMD it is going to show us this command
prompt here we'll click on this and it
will open the command prompt for you
like it has opened for me and there you
just need to type Java hyphen version
and you hit enter if you get a message
like this it means Java has been
successfully installed if you get a
message saying that Java is not
recognized as a command it means that
Java is still not successfully installed
and something has gone wrong in your
installation and in that case you might
want to restart you might want to go
back and reinstall this Java exe again
so in this case it looks like it has
been successfully installed and we can
also get some interesting information
from here we can see which version of
java has been installed it says Java
version 15 we can also see that the JRE
is also installed the Java SE runtime
environment or JRE is also installed and
we can also see that the jvm is also
installed which is Java hotspot server
VM VM means the virtual machine so if I
connect this back to the previous
lecture we can see that uh the the Java
jdk basically installed the JRE as well
as the jvm as well and the complete Java
package has been successfully installed
now we are ready to use Java Java
program and run Java programs on this
machine and at this step I would like to
conclude this lecture in the next
session we will be discussing how we can
install Eclipse because that would be
the natural next step for any Java
developer that they want to install Java
and then they want to install eclipse
and start working let's get started with
installing eclipse on a Windows machine
so the first thing which we need to do
is to download Eclipse so for that I'm
just going to open my web browser and
type Eclipse download press enter ENT
and then you need to find the link which
says eclipse.org g/d downloads which is
the first link in my search results you
can also see it says Eclipse downloads
the eclipse foundation and Eclipse
Foundation is the is the organization
which maintains the eclipse installers
so we can click on this once we click on
this we will be redirected onto the
eclipse downloads page and there again
you will see bunch of options you will
see the default option highlighted which
would be the eclipse installer for for
JRE for Mac OS windows and Linux and
then you have some other tool platforms
option as well like Eclipse G or oron
which you might want to use for advanced
cases but for running Java applications
all you need is an eclipse installer
which is coming from here so based on
your machine Eclipse will automatically
detect whether you want a 64-bit
installer or a 32-bit installer and you
can just click on on this particular
link which says download 64bit here so
I'm just going to hit download 64bit it
is going to open this particular screen
where based on your current location
Eclipse will suggest the nearest
possible distribution mirror
distribution mirror is basically a
server which is present somewhere uh in
this world which contains this Eclipse
installer exe and Eclipse has created
these servers all across the Globes
these servers are basically called the
mirrors and based on your current
location which will be deducted taken
taken from your ISP from the internet IP
address from which you are accessing
this particular website so based on your
ISP location it is going to suggest you
the nearest possible mirror location so
that your download is the fastest so in
my case the nearest location is
Netherlands here as you can see and I
get a download option this is the file
name which says Eclipse installer JRE
windows 64.exe and if you think that
this mirror doesn't make sense just
click on this option select another
mirror and then you can choose another
mirror but generally it works really
well it works based on it works based on
your IP location and and it's generally
uh the download speed is pretty good
based on the suggested mirror so I'm not
going to change the mirror location
because I think this works fine for me
so and I'm just going to click on this
particular button which is going to
start the download of the eclipse
installer so now
I have hit the download button and you
can see right now an exe has been
download uh has begun to download uh it
is going to again take some time and uh
I have already downloaded this
particular exe just to save us some time
and I'm going to use that exe to
Showcase how we can install it another
thing just wanted to highlight is that
eclipse is an open-source organization
it works on donations so if you feel
generous about it and if you feel that
eclipse is doing really great work you
can also donate to it which will show
here so we can move to the next step
which is about installing so you can see
here I have an installer here an exe
file basically which I have
pre-downloaded to Showcase this demo I'm
just going to double click on this and
it is going to unpack the installer you
can see this uh this icon will be
presented to you which says Eclipse
installer by oomph oomph is basically
the provider for this particular
installer who manages the installer and
based on your computer's capacity and
speed it is is going to take few seconds
and in the background what it is doing
is basically it is unpacking this
installer and creating all the
installation files which it needs to
successfully install it on your computer
once that is done you will be presented
with this kind of screen and you will
see that Eclipse provides multiple
different kind of idees for different
set of developer communities you will
see an option which says Eclipse IDE for
Java developers you will also see
Eclipse IDE for Enterprise Java
developers you will see the IDE for C++
and C developers web and JavaScript PHP
Eclipse committers who basically
contribute to the eclipse organization
or RCP RP tester scientific Computing
there are tons of idees which Eclipse
maintains for our use case throughout
this series I think we will be focusing
on this particular IDE which says
Eclipse IDE for Enterprise Java
developers you can also use this
particular IDE but this is a very
barebone ID e with very limited set of
Integrations like it says it includes a
Java IDE a git client an XML editor a
maven plug-in and a gridle plugin but if
you look at the Enterprise you will get
more Integrations you can use this
particular IDE to work on whatever you
work here so these all will work here
but in addition you can also use this
IDE to build a web application build a
web service build a jpa application data
tools Java server Pages faces Etc so
this is more uh more advanced I would
say and we will go with this particular
IDE and uh you can also choose this ID
if you want to but for this demo we are
going to choose this one I will click on
this then it is going to show me which
virtual machine it is going to use so if
you remember in the previous lecture we
installed Java 15 it has automatically
detected that location by reading my C
program files folder and it has
automatically taken that if you have
multiple jdk installations on your
machine you can click on this icon and
change a different Java virtual machine
I'm going to leave it as is again the
installation folder is also by default
taken to your C users username SL
Eclipse SL the je version number and
again if you want to change this you can
also change a different installation
folder I'm going to leave everything as
default it will automatically create a
start menu entry and a desktop shortcut
and now I hit install it might come uh
ask you for a user agreement so you can
hit accept now and now it has begun the
installation the installation generally
takes a bit of time to complete in some
cases so again it depends upon your in
your in your computer's uh capacity and
speed basically if it's a good robust
machine with with good capacity the
installation might be very fast as you
can see in my computer and if you have a
computer which is not very strong on
configurations you can just be patient
and wait for some time and the
installation will be finished once the
installation is finished you will see
this launch option here you will also
have an option to keep an installer if
you want to show the readme file but I
think the the main option here which we
going to use is the launch option so if
you hit the launch option now the actual
IDE is going to start up it's again
going to set up some configuration files
and some bootstrap configuration files
which it needs to and then it will ask
you to choose a workspace again
workspace is up to you where do you
where you want to create your workspace
the workspace is basically the location
where you you will create your projects
it will store those project files and
the source code of those projects so it
is up to you where you want to create it
again I'm going to leave it as default
here but if you want to change it just
hit browse here and choose whatever
location you want to you can see you can
choose you can go to PC and you can
choose whatever location you want to I'm
going to leave it as is and you also
have a choice that you don't want
Eclipse to ask this every time so you
can check this box and next time eclipse
is not going to ask you to choose a
directory as workspace and every time
you start Eclipse it will automatically
go to this particular directory so you
can either check it or uncheck it based
on your convenience and hit launch once
you hit launch it is going to start the
actual IDE as a desktop application and
you will get a nice interface and a
welcome screen from Eclipse which will
which will basically show the basic uh
overview of the screen something like
this so now you can see that the eclipse
ID has started it has a welcome page
which has multiple options you can check
out a project from Git You Can import an
existing project you can go to the
marketplace create a Java web project or
whatever or you can just close this you
have a nice navigation project uh
project Explorer bar here so all the
projects which you're going to create
will be listed here there are also some
quick shortcuts here for creating
different kind of projects and if you
don't want to use that just go to file
new and choose a kind of project you
want to create whether it is a maven
project project or Enterprise
application project or dynamic web
project or just a project if you just
hit just a project you can CH choose a
basic Java project to start with click
next give a project name let's call it
test demo you can choose an execution
environment here the the JRE and
currently this particular IDE has
support up to 14 but I think this is
going to work fine we don't need to
worry about it we can also use a Project
Specific JRE like in this case Java 15
which is the current installation so I
can use this option because I want to
use Java 15 environment because I have
Java 15 installed so you can basically
choose whatever option you want to
choose it gives you a flexibility in
terms of choosing the JRE whether you
want to choose an external JRE whether
you want to choose a Project Specific J
or you want to use the default J jdk
installation so you can use this option
as well if you want to project layout is
create either you want to create
separate folders for source and classes
or you want to create the use the
project folder again this is these are
just basic configurations which you can
play around with if you want to I'm just
going to leave it as is and hit next and
that it is going to just give me a
review screen here if I want to change
anything I can otherwise I can just hit
finish I can create a module name here
if I want to but I don't want to create
it so I just hit on uh don't create and
open the Java perspective and that's it
you have a Java project here where you
can create your Java files under this
SRC and you can start executing those
files we will look out uh on those
details in the upcoming lectures but for
this lecture I think this is what we
wanted to achieve we wanted to show how
we can install eclipse and how we can
create a very sample uh Java CLI project
so this is it for this uh this session
in the next session we will look at some
of the data types in Java let's get
started with primitive data types in
Java we are going to learn about the
primitive data types in Java and we'll
also see a short demonstration of it so
let's get started let's first just learn
about those uh data types I've just
opened the official Oracle documentation
and don't worry if you see how this link
appears here you can just open a browser
window and just type Java primitive data
types and if you hit enter the first
link which you will be given is this
particular link and this is the same
link which I have opened so let's learn
about the data types now so Java has uh
these primitive data types which you can
see here some of them store numbers some
of them store Boolean values and some of
them store characters so the data types
which store numbers are bite short int
long float and double these six data
types basically are used to store any
kind of numeric value let's understand
these a bit more bite is the shortest
possible data type value which you can
use in Java to store numbers you can
only store numbers with within the range
of - 128 to + 127 so you can see the
range is very small and Java has created
this variable for use cases where you
want to store numbers which have very
small value in this range why do we
provide these kind of options just to
save memory because the smaller data
type will require less memory to be used
in the Java program similarly the next
bigger data type is short which is a bit
bigger than bite and the range of this
particular data type variables will
range from - 32678 to + 32 767 so that
is the range for this particular
variable and you can see that it has a
it has a very big range as compared to
the bite data type so if you want to
store VAR values which lie in this range
you can use short the next one is int
data type you can use this one to store
even larger values which range from
minus 2 ra to^ 31 to + 2^ 31 - 1 the
next one is long which is even bigger
than int and it can be used to store the
values within the range of - 2 to^ 63 to
+ 2 to^ 63 minus 1 so as you can see as
we go from top to bottom from bite to
Long the size of the value which can be
stored using this data type increases
and that's how you will basically take a
decision ision of whether you want to
use bite or you want to use short or int
or long based on what size of the value
that variable is going to contain then
the next ones are float and double these
two have been created for the use cases
where where you want to store the values
numeric values which have decimals which
are Precision values I should also
mention that bite short int and long are
only used for storing absolute numbers
which do not have any decimal
representation even if you try to store
a decimal value in these variables they
will automatically be trimmed the
decimal values will automatically be
removed and you will only be shown the
absolute values and in case of float and
double they can maintain those precision
and decimal values so we use float for
the use cases where you want to store
decimal representations of the values
and you can see that the float value can
store a smaller Precision value but
double can store even a bigger Precision
value so if you have really big
Precision values to be maintain very big
decimal values to be maintained you
should use double and the float is used
for storing a bit smaller size of the
Precision values I mean its range of
values basically beyond the scope of
this discussion if you want to read more
about this you can go to this particular
links which will explain this in detail
but the basic idea is that float is good
for storing two Precision values and if
you want to go beyond that you want to
use double in some cases some people
also use float to store even Beyond two
values as well so it completely depends
the main the decision factor is how long
the value you are going to store in the
decimal and that will take the decide
whether you want to use float or double
the next one is Boolean which is used
for storing the Boolean values Boolean
values can be either true or false so
there are only two possible values and
then we have car which is used for
storing characters it is using 16bit to
store the value and this is a very
popular Java question for beginner level
programmers that uh why does it store uh
need 16bit to store the character it's
because it stores a uni code
representation Unicode representation is
a representation which can be accepted
across platforms across the world in
different character encodings so let's
move on to Eclipse now where I have
prepared a very short and simple demo
I'm just creating a variable for each
data type and I'm printing them you also
see some things here like the these
keywords and don't worry about these
keywords I will cover these keywords in
detail in the upcoming lectures you also
see this and you can just for now you
can remember that system.out.print Len
is used for printing anything in Java
anything you want to print on the
console you would be using
system.out.println what is system what
is out and what is print Ln again we
will cover these in the uh upcoming
lectures for now I'm just creating a
bunch of data types here variables here
basically I'm creating a cap type
variable a bite type variable a short
type variable an in type variable a
float type variable a double and a
Boolean the way you create variables is
basically you put the data type name you
put the variable name which can be
anything you put an equal sign and you
put the value actual value which this
variable is going to store and I've done
the similar thing for all of these uh
variables Java wants semicolons to be
there when you write your statements so
please remember that your statements
always end with semicolons so I've
declared all of these variables here a
bite a short an INT float double and
Boolean and then I'm printing all of
them basically here I'm printing the car
variable here I'm printing the bite
variable here I'm printing the short and
so on so forth so how do we actually run
this application or this program we just
just double click on this or right click
on this you go to this run as option you
see this run as Java application option
so you can hit this option it will run
the application and it will present all
the output here in the console tab let
me just bring this up so you can see all
the variables have been printed here and
this is coming from these print
statements like I said this is used
system.out.print L is used to basically
print anything and I've used that to
print all the variables here first I'm
printing the car variable whose value is
a then I'm using the bite variable which
is denoted by B and whose value is two
so you can see the value is two here
then I'm printing the third variable
which is C which is a short type
variable which has a value 22 you can
see short and this is coming here the
next print statement is int so you can
see int here with the value 45 and this
value is coming from here then we have
have float you can see the float value
being printed here and you can see the
float value declared here you also see
an F here and this is the standard
naming convention which Java proposes
that whenever you declare float and
double you end them with f or D based on
whether it is float or it is double then
you see the double value which is having
which is having a bigger Precision than
float so I've printed the double value
using this particular print statement
which is printed here and then we have
the Boolean value which is stored as G
and the value of G is true and the same
value is printed here so whatever I
write here basically is printed here
this is just a placeholder and this is
the actual value so you can see that we
are able to use all the variables here
all the Primitive variables basically
which range from bite character bite
short int float double and Boolean and
that's it for this session in the next
session we will be discussing about the
non-primitive data types in Java let's
get started with non-primitive data
types in Java in the previous lecture we
talked about the primitive data types
and now we'll discuss about some of the
data types which are not primitive first
of all let's understand what is the
difference between primitive and
non-primitive so the primitive data
types are the ones which are by default
supported by Java and non- Primitives
are the one which are a bit custom in
nature where you as developer have the
Liberty to define the nature of that
data type we'll look at some examples of
that as well but when we talk about
which all are the non-primitive data
types we broadly talk about arrays we
talk about classes we talk about strings
as well and we will cover some of them
in today's lecture and we have the a
detailed lecture upcoming about the
classes as well in fact in the in the
after few lectures we'll we'll cover how
we'll create classes as well but for for
today's lecture we are going to focus on
string data type and array data type and
like I said for classes we have a
dedicated uh lecture upcoming so don't
worry about that and again for this
particular case as well I have already
prepared a demo for this and we'll
basically do some look at some Hands-On
examples to see how do we create these
variables what these what does these
variables mean and the first
non-primitive data type we are going to
talk about is string and before I go on
further I should also mention that it's
very debatable in the Java Community to
call string as a non-primitive data type
and actually technically speaking string
is a special data type it neither fully
lies in the Primitive category nor it
fully lies in the non-primitive
categories I'm covering this as as a
non-primitive data type because it's a
bit inclined towards the non-primitive
category why do we uh do this is because
Java does provide native support for
string handling in the jdk and that's
the reason some of the developers feel
that string is a primitive data type
which is primitively supported by Java
but at the same time string is so
customizable and it's so special in
nature it's the way it stores the value
the way it provides the operations and
handlings it's so different than
primitive data types that it cannot
fully be put in the same bucket as the
primitive data types so that's why I
said it's it's a special data type a bit
inclined towards the non-primitive
category so what is string basically we
covered about the car data type in the
previous lecture and in care data type
you can only store A Single Character
right but if you want to store a
complete name of somebody then it's a
list of character it's basically lot of
characters together then in that case
you would need a data type to store that
continuous sequence of characters and
that's what string does string can store
a continuous sequence of characters
technically string is basically a
character array you can call string as a
character array and don't worry if you
don't understand about the word array I
will explain that in the same lecture so
basically it stores The Continuous
sequence of characters that's how that's
how we Define string and you see this
string this is a basically the keyword
the data type basically in Java so
whenever you want to create a string you
need to write string with S capital you
need to give a name to this string this
can be anything and then you can provide
the value which is which this particular
string is going to contain so you can
see this is a continuous sequence of
characters t s are the four characters
which this string is going to contain
and after that again I'm printing this
particular value and like I said don't
worry about this we'll cover this when
we when we'll write our first program in
Java so this is just to print the string
value I'm just putting a string
placeholder here and then I'm actually
printing the printing the values of the
string variable now string can be
created in multiple ways in Java this is
one way of creating it there's another
way of creating a string variable which
is this one which says again the string
data type some variable name a keyword
called new again don't worry about what
is this new keyword we'll cover this
when we'll talk about our running our
first program in Java and writing the
first program from scratch then we again
say string and then we provide the value
so if I compare this line number four to
line number seven you can see the
difference is that I'm still storing the
same value test but the difference is
that here there is no new string keyword
but here we have this new string keyword
so what is the difference the difference
is this that in this case in this
particular case string is going to reuse
the same object multiple times but in
this case every time you call this it is
going to create a new object again what
is object it's just you can think of it
as for now you can think of it as a
memory block we'll Again cover objects
in details but these are two different
ways in which you can create string this
is generally the most popular way of
doing it because this is memory
efficient because you can reuse the same
variable again and again so I'm creating
the string variable here and creating
another string variable St str1 here and
printing both of them then I've created
this strange looking thing here which is
basically an array array like I said is
also
a non-primitive data type in Java and
array can store a continuous sequence of
anything that anything can be a number
that anything can be characters that
anything can be a a floating number as
well so basic idea is that if you want
to store a collection or or sequence of
multiple multiple uh values how do you
do that you do that with the help of
arrays array is a data structure a
non-primitive data structure in Java
which can store lot of values of similar
type we also call it as homogeneous data
structure which because it can only
store same data type values or
homogeneous data type values so the the
biggest way to identify array is this
square bracket whenever you see this
square bracket in Java it means it's an
it's an array variable so here I am
creating an integer array variable with
the name ARR this is the name of this
particular array it is only going to
store integer values because I've
specified int and the moment I provide
the square brackets it mean it means
that it is an array so you can declare
an array like this and then you need to
assign a size to the array size is
basically denoting how many values this
data structure is going to store so I'm
saying new again it's a keyword and I'm
saying that okay create a a memory block
for storing two integers so this
particular AR array ARR can store at Max
two values two values at continuous
locations the next thing about array is
that it stores the value in a zero index
based location so like I said it can
store two values so the first location
will always be array of zero and this is
how you specify the location or index of
the element which is going to be stored
so at the zeroth location of this array
I'm storing zero the first location of
the array I'm storing one one and this
is just to show an error scenario but I
will just comment this for now you can
just put double slashes and comment any
line so I'm just storing filling up this
array for two values and the two values
location would be zero index and first
index these are just continuous memory
locations and we denote those memory
locations as 0o and one array indexes
always start with zero and I'm just
putting some values here you can put any
values and then I'm printing the whole
array and I'm also printing the first
value of the array and we'll see how
this pans out and we'll also see how we
can change this so now we are going to
run this application so I'll just go to
run as and click on run as Java
application and once I hit that I get
this output here so let's understand
this output the first one is I'm just
printing the string which has the value
test and you can see it has printed here
it is coming from this line then the
next line which is printed is line
number eight where I'm saying another
string as str1 and Str str1 also had the
same value so you can see another string
has the same value and then I have
printed the array here the complete
array and you see the strange value here
it also tells us that if you want to
print the array then you cannot just put
the variable name and print it the
reason is because this is a
non-primitive data type and once you do
this it is basically printing the memory
footprint of this array the whole memory
location where this array is stored code
that's why you see this strange looking
number which is the memory hash code and
if you want to print any particular
value or any particular element inside
this array then you can do that by
providing the index location of that
element so here I've said that print the
zeroth location element of the array the
zeroth location array element of the
array was zero so you can see the value
zero here let me put some other value
just to just for fun and show you how
this works so just change the values and
now let's see what do we get for array
zero you can see now I get value three
because now the at the zeroth location
the three value is being stored and that
is what what is being printed here we
can also print the first value I'll just
go run as Java application you can see
now the array of first index is being
stored which is basically technically
the second element of the array but
because array always works on a zero
index based value format that's why when
we say array one the second element is
printed when I say array zero the first
element is printed so always remember
that array is a zero index based
collection or data structure basically
what happens if I do this now there is
no third element in this array because
the array has the size only of two
elements and when I say ARR of two which
means I'm trying to print the third
element in this array which does not
exist so let's see what happens in that
case I get an exception exception is
basically an error I get an error saying
that index 2 is out of bounds for length
two it means that the array length was
actually two and index 2 does not exist
remember it's saying index two not the
element two index two doesn't exist
because only index zero and index one
exist this makes two elements and the
actual size is also two it does not have
capacity to store third element it does
not have third element location anywhere
that's why it complains that you you are
trying to print a non-existing value so
this is where I would like to conclude
my lecture about the non-primitive data
types so we covered about string we
covered arrays and like I said we'll
cover classes in the upcoming lecture as
well uh in the next session we are going
to talk about tokens in Java let's get
started with tokens in Java when we talk
about tokens in Java these tokens are
basically some reserved expressions or
words or symbols which have a predefined
meaning in Java and you cannot overwrite
this meaning because this meaning is
already defined by Java and you can use
those expressions those symbols and
those words in only the way Java wants
you to there is no way you can change
the meaning of those terms or those
symbols so we will be covering those
tokens in today's lecture these tokens
are broadly divided into five different
categories these categories are keywords
ident identifiers constants special
symbols and operators so let's talk
about each of them one by one so when we
talk about keywords these are the words
which are reserved by Java and they have
a predefined meaning you might have
already seen some of these reserved
keywords for example we have used int
when we were working on the primitive
data type lecture we have seen this as
well though we haven't actually found
out the meaning of this but we will find
out the meaning of this in the coming
lectures so don't worry about that we
have seen Boolean as a as a data type
again we have seen bite so these Boolean
bite in uh class care catch super switch
synchronized all the all the keywords
which you see here these keywords have a
predefined meaning in Java and you use
these keywords so that you want to take
an action an expected action by Java for
example if you call something as int
then you want Java to treat it as int
int will only have a single meaning in
Java and there is no other meaning of
int in a in a Java program so that's the
intent with the keywords these are
reserved Words which have a predefined
meaning and we will cover these keywords
at length during this whole course the
next token is identifier and identifier
is is nothing but just a variable name
technically and we have already covered
this this kind of identifier when we
were showing the demonstrations for
primitive data types and non-primitive
data types Etc it's basically anything
which you declare as a variable is an
identifier and when you declare the
variable name again Java puts some sort
of restrictions as to what you can or
cannot do when you work with Java and
you declare the variable names for
example these variable names cannot
start with numbers so you cannot have a
variable name which starts with any
number you cannot have a variable name
which contains spaces in between them
you either have to fill those if if
there's a if there's a variable name
which you think has two parts for
example student name then you need to
write it as student underscore name so
that you can create the variable name
with the same impact and still does not
contain space so spaces will not be
allowed when you create the variable
names similarly you cannot have plus
hyphen and M perent in the variable
names as well these are the restrictions
which Java puts on the identifier tokens
when whenever you create identifiers the
next one is constants and we will cover
these constants in detail in the coming
lectures as well but to give you an idea
of what constants are so constants are
basically exactly what they sound like
they are the identifiers which you have
declared in your program whose value
cannot be changed once defined so if you
write something as final int I = to 5
then this value is fixed you cannot
change the value of I again in the
program Java will not allow you to
change the value of I again because I
has now become a constant because you
have put a final keyword in front of it
and again final is a keyword you see
final is a keyword basically so you so
these constants are treated specially by
Java that Java will make sure that their
values will never change during the
course of the execution of the program
this can come really handy when you have
situations where you do not want the
certain variables values to be to be
modified for example if you have an
application where you are counting the
number of applicants and if you have
declared the number of applicants as
final then every time you call the
application you can do a plus one to the
previous value the value will not be
reinitiated so it is very useful concept
and and it can be very handy in programs
where you don't want to change the
values the next is special symbols these
special symbols are the symbols which
again have a predefined meaning in Java
we have already seen this square bracket
symbol in our previous lecture when we
were creating arrays so whenever you use
these square brackets then Java would
understand that you are trying to either
access or create an array or you're are
trying to access or create a list Etc so
this is predefined you cannot use this
anywhere else or with any other meaning
similarly when we talk about these
braces these standard brackets or
standard braces these again have a
predefined meaning in Java generally
whenever you will write functions and
methods in Java you will use uh these
brackets to define the parameters of the
function now you cannot use these
brackets in any other meaning in Java
Java will not allow you to use this
anywhere else apart from using it in
method parameters similarly the next one
is uh the curly bra and and the curly
Braes are used to define a code Block in
Java you might have already noticed that
when we were looking at the previous
demos you could see some curly brushes
then some code and then the then the
curly brushes would end for example if I
show you here just it's just a sample
example and let me open the example
which we covered in the last lecture so
you can see this curly BR here and this
curly brass ends here right so this
defines a code Block in Java any code
block which you want Java to understand
will always be starting with a curly
braces and ending with a curly brace
remember I talked about the standard
braces you can see these are the
standard braces opening and ending and
this is where we are defining this
particular method's arguments now what
is Method what is argument don't worry
about that we will cover in detail but
just an introductory concept whenever
you are trying to define a method and
you want to pass any argument to the
method you use these brackets to do that
okay uh similarly this is semicolon is
used to uh close CL any Java statement
so you will see this semicolon here
every Java statement has to have a
semicolon as ending otherwise Java will
complain that it is a syntactical error
so it is part of the syntax you need to
put the semicolon and semicolon has only
one meaning in Java which is that your
statement is actually ending uh then we
have star and star is used for
multiplication and then we have equality
which is used for assigning any values
and again assigning any values is
everywhere you are seeing this equality
everywhere so these are all tokens
basically the last type of token we have
is operators and we will cover these
operators in the upcoming lectures in
detail with the examples but these
operators are basically some special
symbols like for arithmetic it would be
plus minus multiplication divide for
comparison it will be uh greater than
less than for logical it would be ENT
and and pipe operators bitwise again
we'll have some bitwise operation
operators so the so these are are
basically different categories of
operators and under each category of
operators there are certain symbols like
for arithmetic we have plus minus we
have for comparison we have greater than
less than Etc so these again symbols are
also reserved by Java under the operator
tokens category you cannot use these in
any other meaning or in any other way
and like I said we will look at a
detailed example of this as well in the
coming lectures so this was a quick
overview of what are different types of
tokens in Java so we have keywords we
have identifiers constants special
symbols and operators so this is it this
is all what I wanted to cover in today's
lecture and in the next session we will
be looking at data type conversions
let's get started with data type
conversions so when we talk about data
type conversion the whole idea is to
basically answer the question that
whether I can convert a int data type
variable aable into a long data type
variable or a long data type variable to
a float data type variable and also VI
Versa can I go back can I convert a
float variable into a long variable or
an INT variable and vice versa so this
lecture is about answering all of those
questions and we will basically look at
some examples to understand how the
conversion works but let me just explain
the basic principle the basic principle
is that smaller box can fit into larger
box but if you have to fit a larger box
into a smaller box you need to do
something else so what do we mean by
smaller box and larger box here the
smaller box is a variable or a data type
which has a smaller range if you
remember we talked about the range of
short bite int Etc and we could see that
as we go from short to bite to int to
long to float to double the ranges were
increasing right so we will follow the
same kind of analogy that if we have to
store a smaller range variable into a
larger range variable Java will
automatically do that but if I have to
store a larger range variable into a
smaller range variable then I have to
sacrifice some quality of the value and
we will look at the examples of that as
well so let's first look look at the
example where we can store a smaller
range variable into a larger range
variable we call this as implicit data
type conversion so here you can see I
have declared an INT variable with the
value 100 and I'm printing the int
variable then I have declared a long
variable and what I'm doing that I'm
assigning the value of int a to the long
variable B so I'm not assigning a new
value to this long variable but rather
I'm just passing on the existing integer
value into a variable of type long
similarly after that I am taking the
value of this variable of long type and
storing this value into a float type so
you can see int is basically smaller
than long and long has a smaller range
than float so I'm just storing a smaller
range variable into a larger range and
then a larger range variable into the
largest range and then I'm printing all
the variables values to see if this
actually is working can long
automatically store the value of a and
can float automatically store the value
of B here I'm just printing the
variables and again using the concept of
the previous lecture this is just to
print the values and I will cover this
in detail in the next lectures of how
this works but here you can understand
that we can use system.out.println to
basically print the values and here I'm
just printing a string and then the
value then again the string and the
value and and here also the string and
the value so this is what is happening
in this program and again don't worry
about these details I will cover about
what these concepts are in the upcoming
lectures so let's run this and see if
the data type conversion actually works
so I will just right click and do run as
and go to Java application and if I
click on this I get this output so the
first output is pretty straightforward
I'm just printing the int variable as is
so this works then I am storing the in
into a long and printing the long
representation of a which is B basically
and this also works without any errors
or any warnings by Java similarly when I
talk about storing the long variable
into a float variable C this also works
but here you see an additional decimal
Precision here because as we remember
from the previous sessions float is used
to store values which have decimals or
which have precisions so it will
automatically convert your absolute
number into into a number which has
decimals whenever you try to cast this
into float casting is also a word which
is used some people call it as implicit
data type conversion some people call it
as implicit data type casting so if you
hear the word data type casting or
implicit data type casting you can think
that it is exactly the same concept as
data type conversion so this is about
implicit data type conversion now let's
look at an example of explicit data type
conversion how does that work so using
the same analogy of the boxes now I will
try to store a larger ranging value
variable into a smaller range variable
and see how that looks like so I will
start with the largest which is which is
double variable so I have created a
double variable and as we know that
double is a is a variable which is used
to store decimal values so I'm storing
this value here and then I'm just
printing the double representation as is
without any changes then I'm trying to
store this variable's value into a float
variable so I'm trying to go to a
smaller box now I'm trying to grow from
double to float and if you remember I
told you that if you have to do that it
will not work out of the box but you
have to do a bit something special as
well and this is the special part this
is called type casting type casting is
basically a way to tell Java to
explicitly cast this variable's value
into this data types variables value and
you always need to do this Whenever
there is no implicit casting happening
if you are trying to store a larger
value variable into a smaller value
variable you have to do this otherwise
Java will complain you will get a
compilation error so that's what I'm
doing I'm I'm telling Java to store the
value of a as a float and store the
value in F and this is where I'm telling
to store the value as float so you just
put brackets and you define float and
then I'm printing the float
representation similarly in the next one
I am trying to store the value of this
double variable into a long so you can
see now I'm trying to go even uh from a
Precision data type to a non-precision
data type because long does not
understand decimal values so I'm trying
to store a variable which has decimal
values into a variable data type which
does not understand decimal values and
we will see how the output looks like
but here also you need to do the
explicit casting explicitly you need to
tell
which data type this a needs to be
converted into that's what I do here and
then I print the long variable here and
then next I will again go down further
and I will try to store a larger long
variable type into a smaller int
variable type so again I'm trying to
store the value of B into a smaller data
type which is integer and I'm naming the
variable as C here again I have to do
this explicit casting I'm telling that
telling Java to explicitly cast the
value of B which is a long data type
variable into an integer C which is an
in data type variable and then I'm just
printing the value so this is what is
happening in this program that from
double to float to long to int now let's
run this program and see what happens so
I will right click and go to run as and
choose the Java application option and
this is the output I get first of all
for the double representation the value
gets printed Zer is ignored then in the
float it works fine as well without any
Precision loss because float can also
print values up to one to two decimal
points without any problems even beyond
that actually so it works fine then when
we talk about the long representation we
are trying to convert a double variable
into a long variable and we see that the
Precision the decimal values are lost
this is expected because long does not
understand decimal values that's why
anything after the decimal or in fact
the whole decimal portion is gone when
you're trying to store double or float
into some Absolute Data type variables
like int or long and then in int
representation since you already have
this long this long can easily be casted
to int by just providing this explicit
casting and the int representation also
prints 50 so we started from this value
and we ended up with these values when
we try to store them as long or int so
this is all I wanted to cover in in
today's lecture so we covered basically
basically about the data type conversion
or data type casting Concepts how does
implicit data type casting works and how
does explicit data type casting works
and as we know the concept the basic
concept is that the uh the value can
easily be casted from a smaller range to
a larger range without any changes or
without any extra code but when you have
to go from a larger value to a smaller
value you have to provide these casting
instructions to Java to successfully
cast those variables in the next session
we will be looking at how we can write
the first hello world program in Java
and there we will actually cover all the
all these things which which I have been
saying that we will cover so we will
cover all these uh ways of how we can
write the first hello world program in
Java let's get started with how to write
your first program in Java so I have
been talking about this lecture and the
details of this lecture in the previous
lectures as well and today we are going
to focus exactly on how do we actually
write a Java program so as we have
already covered how you can install
eclipse and how you can create a sample
Java project in Eclipse if you haven't
seen that please go back to my previous
videos where you can actually see that
and once you have created your Java
project so your Java project might look
like something like this you will have
an SRC folder here so and under the SRC
folder uh you see some some name spaces
sort of things created here right we
call these as packages and in Java you
can think of package as something which
can group multiple related artifacts
together this is simply a grouping
mechanism I can say it's a way to put
all the related artifacts to a
particular business problem into a
certain place for example if you're are
working in an e-commerce application so
you have you might have created multiple
Java files for let's say for checkout
and then some more Java files for the uh
filters flow I would say then some other
Java files for Designing the
advertisements so you have multiple Java
files and these Java files now Bel
belong to these three different domains
so you want to group them together for
easy accessibility for referencing each
other uh files with uh within the code
so if you want to achieve that kind of
flexibility you would group the checkout
code files into a single package you can
name it as checkout package then you can
similarly do the same thing for the
advertisement package and for the
filters package so similarly uh I have
created some packages here which you can
see you see a package here which says IO
GitHub Vikes Pand hello world and how do
you create a package you just right
click on this so you go to the SRC and
you right click you go to new and here
you will see this option which says
package so you can just click on this
and write anything which you want as the
package name let's call it as test
package uh it says invalid because the
package is a keyword so it is not
allowing me to put package here but
let's call it test package one and you
can just click finish and you will see a
test package popping up here then you
can right click on this again go to new
and then you can create a Java class now
what is a Java class a class is
basically a blueprint for an object it's
basically the specifications of an
object like I covered in the very first
lecture everything in Java is an object
or most of the things in Java are object
I would say so object is basically an
instance of the class so let's say you
create a class for if I take the same
example of e-commerce you create a class
for writing the business logic of
checkout and then you create instance of
this particular class to work for a
particular customer order so class is
basically a blueprint it's the
specification it's the skeleton of the
object so once you click on this you can
create a class now e eclipse is a pretty
smart IDE it will provide you with bunch
of options on how you actually can
create a class what and it will also
provide you with some sensible defaults
for example it will automatically select
a source folder in your project which
you have created it will automatically
select a package in fact they currently
selected package and if you want to
change the package just hit browse and
choose any any other package which you
want to choose so your your class file
will be created in that package then you
can provide a name to the class so let's
call it as test hello world and you can
see I have followed a s sort of a naming
convention here the first character I've
kept it as capital and then any other
new word which is coming in my class
file name is also capitalized so Java
would expect you and it would encourage
you to follow this naming convention
that whenever you are creating a class
always start with a capital letter then
small letters and every new word you are
writing can start with a capital letter
again Java will not throw an error if
you don't do this uh h capital or W
Capital but it's a good practice the
next thing is the modifier we are going
to cover the modifiers in details in the
in the uh upcoming lectures but for now
you can understand that anything which
is marked as public is accessible to
every other Java class in this whole
project that's the basic meaning of
making a class as Public public as the
name uh suggests itself it means it's
visible to everyone you can select a
super class and again we'll talk about
the super class later but if this is the
Java Lang object is the super class of
all the classes which are created in
Java again interfac is again an advanced
concept and there are some other
interesting uh uh defaults it provides
for for example if you want to create a
main method now what is the main method
we'll just cover it in a while so I will
not do that I will leave everything as
default and I will click on finish so I
have this new file coming up here and
you can see it has automatically picked
up the package which I selected and it
has also written public class test hello
world with a starting and ending curly
Braes in the previous lecture we covered
about these curly Braes that all the
code block have to be in the curly
brushes whenever you write a Java class
the very first statement Java would
expect to have in the class is package
name so make sure that you have package
as the keyword and then the actual
package name as the package name for
that particular class you can see the
package follows a DOT convention and it
always ends with a semicolon like all
the Java statements end with semicolon
so that would be the first thing which
you will write in your class second
thing is the access modifier of the
class like I said you want this class to
be accessible to every other uh file in
this project then you can mark this
class as public the next thing is the
class keyword you need to write this
particular keyword as is otherwise your
class will not be detected so you write
this as class then you write test hello
world or whatever name you want to write
but make sure that whatever public class
name you provide here that name should
match with the file name these two
things should match the file name and
the class name if they don't match you
would experience weird behaviors as the
class will not be compiled or class
might might not be able to run Etc so
always make sure that whatever file name
you provide you always have a class with
that name in your file so my class
structure is is ready but there's
nothing here in this class in fact you
can you cannot even execute this class
because for executing the class for
executing any class in Java any class at
all in Java you would need a main method
in Java main method is the entry point
method of the Java whenever you are
trying to run any any application be it
a very small or very large Java
application you would always and always
need a main method in the in the class
in the project somewhere and you need to
tell the Java uh runtime to execute that
class and then the class will have a
main method and the your program will
start executing so always have a main
method otherwise your program will not
execute and how do you write the main
method so you first write public then
you write static then you write void and
then you write Main and then you provide
a parameter to this method as this now
let's understand what did I actually
write here first keyword is public
because this method has to be public
because like I said Java runtime needs
to be able to access this method so the
similar concept which applied on the
class is applied on this method as well
that the entry point method has to be
public otherwise Java will not be able
to find this method so you need to make
this method exactly as public the next
keyword is static you again need to uh
write this keyword as is and the reason
we write static here is because we we
want to run this particular class
without creating an object of the class
static is again a keyword which we'll
cover in the upcoming lectures but for
now you can understand that whenever you
want to access something within the
class without creating an object then
you need to create it as static the next
is void void is basically the return
type of this method the method name is
Main and it has to be main it cannot be
main one or main two otherwise if you do
that Java will not be able to run your
program because it will expect you to
write this particular method exactly as
what I have written here no changes at
all should be there if you make any
changes Java program will not run
because it will not be able to find the
entry point method which is the main
method so public static void main
remember that you need to have this in
your program so void is the return type
which means that this particular program
it will not return anything back to the
runtime because a method can have this
capability to either return something or
not return something for example a
method which can uh add two numbers will
return the result of addition right so
we return the result return is the word
here in this case this method is not
expected to return anything because
because there's nobody consuming it
right Java runtime will not do anything
with the with the return value of this
particular method that's why Java will
force you to write void here and Main is
the exact method name which you need to
use Java will expect you to supply a
string array argument if we covered
arrays in bit detail in the in the in
the previous lectures and we will cover
arrays in actually in the next lecture
in very detail but you can as we
discussed that array is basically a
sequence of characters or words or
integers or anything right so in this
case this is basically uh the mandatory
parameter which you need to write as is
this parameter name can be anything
obviously it can be ARG AR args or
whatever you want to write it as but the
basic fundamental is that Java will
basically supply all the command line
arguments using this particular string
array that's why you need to provide
this then let's write something in the
program because this is a Hello World
program so I will just write
system.out.println and I'll type A
String here which says hello world and a
semicolon so again I have been saying
that I will explain this and now I will
explain this why do we need this and
what does this mean so as I've told
earlier that whenever you want to print
something on the console in a Java
program you need to write
system.out.println now system here if
you just go if you just hover over it
Eclipse will show what it is so system
is basically a class which contains
several useful class fields and methods
it cannot be instantiated means uh you
cannot create an object of it and it
provides many facilities like standard
input standard output and error output
exactly what we want to focus here
because we want to use system class to
print something on the standard output
the standard output in this case is the
console so if you want to input
something or you want to output
something or you want to Output an error
then you need to use system class and
all of these standard input standard
output and error are streams and that's
what comes to the next word what is this
out out is a stream to print standard
output similarly we have system. err
which is for printing the error output
streams similarly we have system.in for
taking it standard input streams so
system.in system.out system. err these
all are these in out and err are streams
and then print Len is the actual method
let's hover over that let's first see
out here so you can see this is a stream
object which is used to print anything
which is ready to accept output data
basically and then we go to the print
Len method and it says prints a string
and then terminate the line so like I
mentioned earlier as well this whole
syntax is is used to print and actually
this is the core method this is the real
method which prints something on the
console so system class uses the output
stream to print something on the console
using the help of print Ln method there
is also a print method so there are two
methods one is print and one is print
Len the difference is that in case of
print method the print method will not
provide you or terminate on a next line
but in in system.out.print Ln the Ln
means line here it will print something
and it will bring the cursor to the next
line if you do not use this and if you
again use another print statement then
both of the statements will be printed
on the same line I will show that as
well but uh and then we provide any
random string here which we want to
print so you write click on this
particular program you go to run as and
you run as Java application and you want
to save this so you can say always save
resources before launching and you see
the output here so this is how you can
run your first Java program now let's
also see the difference between
system.out.print Ln and
system.out.print so I will just copy
this here and I'll say hello world 1
let's say and this time I will not use
system. out.println but I will use
system. out. print just put a space here
so that it's visible so if I use print
how does that look like I go to run and
I go to run as Java application so now
you see both of the outputs are printed
on the same line there is no this output
hasn't gone to the next line and now if
I run the same program with
system.out.print Ln methods now both of
these outputs will be divided on two
lines the first output then a line break
the hello world one goes to the next
line in the previous run the hello world
one was printing right next to it on the
same line so that is the difference so
this is how you can build your very
first program the hello world program in
Java in the next session we will be
discussing about arrays in in Java let's
get started with arrays in Java we
discussed about arrays uh in a bit
detail when we talked about the
nonprimitive data types but this is a
concept and a topic which needs to be
understood well so that's why we'll go
we'll do a deep dive on arrays in this
particular lecture so as I described
earlier that array is basically a
container which can store values or a
sequence of values or sequence of
numbers or sequence of characters
into itself we can think of it as a box
which can store all the values in a
continuous fashion as you can see here
this is a just a pictorial
representation and this is coming from
the official Java docs and you can see
that we if we create an array of size 10
then we have these 10 blocks created
here you can see 1 to 10th so the whole
length of boxes the number of boxes here
are 10 but the way arrays are designed
is that the index index is basically
used to access the element in this
particular box the index of the boxes
start from zero so it goes from 0 to 9
so remember the array length is 10 it
array the array can contain 10 elements
but the index of the array starts with
zero and will always end at length minus
1 which is 10 - 1 in this case which
comes as 9 so it will always be lenus 1
it will always start the index will
always start from zero and go till
length minus one length can be anything
in this case the length is 10 so the
index ends at 9 if the length was 20 the
last index will be 19 but in total you
have these 10 memory locations we also
call them as continuous memory locations
because they are continuously placed and
array basically blocks 10 memory
locations and creates a container over
it so this is how an array basically
looks like inside the memory and uh
whenever you want to access the elements
of the array you will say array of zero
or array of one or array of two you
basically need to specify the index to
access the element at index for example
if you want to access the element which
is sitting in this box you need to say
array of index 8 and we'll see how we
can do that but this is the basic uh
understand understanding and idea of the
concept of arrays so let's try to
understand this with the help of an
example I will switch switch back to
Eclipse IDE and I've created a very
simple program here to demonstrate the
functionality of arrays here so we
already covered in the previous lecture
of what is package and what is public
and what is class how do we give the
class name and what is the meaning of
this particular method so I'm not going
to cover that again we'll start directly
from here so here the first thing which
I'm doing is I'm declaring an array of
integer this is a variable name the
identifier basically it can be anything
and this is the data type it's an
integer array and as we as we covered
this as well that whenever you put
square bracket in front of a data type
it becomes an array data type so this is
an integer array representation now we
just declared an array but we still
haven't allocated a size to it so you
can do that with this particular uh
syntax so you can put the variable name
of the array and say new int and put the
right size here this size can be
anything and once you do this now array
will actually allocate those memory
boxes which we covered here the moment
you do new int 10 this box these boxes
continuous boxes will be placed in the
memory and the memory is allocated to
this array we call this memory
allocation this is how you allocate
memory to the array so we allocated
memory to this array for storing 10
integers the next thing is now we can
start storing elements in those boxes so
so like I said that the array index
always starts with zero so if you have
to store the first element you actually
have to store it at index zero location
so you give the array name you provide
these square brackets and you put the
index value within the square brackets
that is how you basically point to a
particular element inside the array so
we say an array of zero and we put the
value 100 then we initialize the second
element which will be index one then
will be the third element which will be
index 2 fourth element index 3 Fifth
Element index 4 Sixth Element index 5
and so on until we store till the last
element so this is the 10th element
which is accessible as index 9 and the
value is uh 1,000 basically so from 100
to 1,000 we stored 10 values in this
array and we stored them by accessing
the index and this is actually the only
way you can store values in the array by
pointing to the indexes so we go from 0
to 9 and we stored all the values 0
being the first element and array of 9
being the last and the 10th element
remember the length minus one concept
okay so now we will try to print all the
elements one by one that's pretty much
what we are doing now so as we covered
in the previous lecture that we use
system.out.println to print anything and
we understood the whole meaning of this
so I'm not going to repeat that now uh
we want to print the first element the
the first element is sitting at index
zero and we can access that element with
this syntax by providing the variable
name and the actual index value so I'm
just writing a random string here which
says elemented index zero and then I'm
putting this plus here and putting the
variable name this plus is basically
used to concatenate the output of a
static string with a random variable or
basically you can print anything uh with
using plus plus is used for
concatenation so I'm just trying to
print this whole value but here this is
a string value which is a static string
and then I have a value coming from the
array so whenever you have to print some
value from a particular data type or
variable or collection then you can use
this plus syntax to concatenate a string
static string with your actual value so
that's what I've done here by saying
plus and array zero and similarly for
index one I'm printing the the first
index then for 2 3 so far and so on so
forth till the index 9 so basically I'm
just printing the all the values of the
array starting from index 0 to index 9
so that's all which which is written in
this program now let's try to run this
program so I will right click go to run
as and go to Java application and hit on
this and now if I just expand this
console you can see all the
system.out.print and statements have
been executed and they printed this so
this is the static string part in fact
including the colon this is the static
string part element in index zero
printing exactly as is and then
dynamically the zeroth index element of
an array is printed here similarly we
have printed the index one location
element index 2 location element index 3
location element and so on so forth till
the index 9 location element so in total
these are the 10 elements but the index
always works from 0 to length minus 1 in
this case it will be going from 0 to 9
so this is basically all which I wanted
to cover in this lecture the whole idea
was to give you more understanding of
arrays and remember this is just an
integer array you can similarly create a
character array you can also create a
string array for uh for you as well so
it it it's completely uh it's completely
related to the data type you're using if
you create a car array then you can only
store characters in into it if you
create a string array then you can only
store strings into it and now you can
probably relate back to this particular
thing which I explained in the previous
lecture that we create this string array
for the reason that when you run this
particular program and if you want to
provide any command line values command
line arguments to the program those
arguments will automatically be stored
in this args and then you can access
this as args of Zer args of 1 Etc in
your program that's the whole concept so
these are this is the basically the Deep
dive on array which I wanted to cover
and in the next session we are going to
cover about operators in Java let's get
started with operators in Java when we
talk about operators in Java there are
multiple types of operators like
assignment operators arithmetic
operators unary operators then we have
conditional operators and logical
operators and we also have bitwise
operators and we will cover all of these
operators one by one we will understand
what what these operators are and how
they work and we will also look at a
demonstration of it so let's get started
the first operators we are going to
discuss is about arithmetic operators
and assignment operators and we will
also see if we can cover un operators so
when we talk about assignment operators
I've again opened the official Java docs
here if we understand assignment oper
operators we have been using this
operators all the while in all of the
demos so far and the basic idea is very
simple whenever you assign a value to a
variable you use the assignment operator
which is nothing but the equal sign we
have already covered this in multiple
demos so I will not cover this as part
of the demo but what I'm going to cover
in detail is about these arithmetic
operators so arithmetic operators are
basically used to perform perform any
kind of arithmetic operation on a Java
program it can be an addition operation
it can be a subtraction operation it can
be a multiplication operation a division
operation or an operation by which you
can find the remainder of the division
so we will look at each of these uh with
an example and as you can see the
symbols are expectedly what you
generally use in mathematics so you see
the the plus sign here which is for
addition you see the minus sign which is
for subtraction you see the star sign
which is for multiplication you see the
slash sign which is for division and you
see the percentage sign which is for
finding the remainder of a division so
let's see an example of each of these
and how we can use them in a in a Java
program so for the arithmetic operations
I have prepared a demonstration of it in
the Eclipse IDE again I'm using the same
Java project which have shown you we
created in the previous lectures so I
will for all the demonstrations I will
just continue in the same project so
again the way to create a class Remains
the Same exactly the same as how I
covered in the previous lecture in the
hello world program where we created a
class so here also I created a class I
named the class as arithmetic demo and I
have a public static void main method
inside this particular class and I have
basically tried to demonstrate each of
the operation so let's start with the
addition operation first so I create an
integer variable here named as result
and then I try to use the addition
operator to make this variable store the
result of this addition so it's a simple
1 + 2 you can also create two different
variables for 1 and two let's say x = 1
and y = 2 and you can also do int result
equal to x + y it will have the same
effect but just for Simplicity I have
put the literal numbers here so result
is storing the the expression value of 1
+ 2 and then I'm printing this value
here you can see I'm printing the result
variable here with using
system.out.println then I'm storing this
result into a variable into a new
variable original result with using the
assignment operator and then I'm trying
to subtract something from it so now I'm
saying result equal to result minus 1 it
means whatever the current value of
result is subtract minus1 from that
value so the value was three here and
here 3 - 1 becomes 2 so the new value of
result becomes two the original result
still holds three because it is storing
the old value the new value of result
has now become two so I'm printing the
original result and then what I'm doing
that I'm again assigning the new result
which is two to the original result so
now original result and result both are
at two then I move ahead and I try to
demonstrate the multiplication operation
so I take the same variable result and I
say multiply it by two so whatever the
value of result was which at this place
should be two multiply that value by two
so 2 into 2 the new value of result
should become four after this
multiplication operation and again I'm
assigning the value of original result
to this particular variable and then I'm
showcasing the fourth mathematical
arithmetic operation which is division
so you can result by two here so
basically I'm whatever the current value
of result is I'm dividing that value by
two so 4 divided by two should become
two so again the new value of the result
variable should become two then I'm
printing the value and again storing the
value back into the original result then
the next operation is again an addition
operation where I whatever the value of
result is at this particular point which
is two add 8 to that particular value so
the new result value becomes 10 and then
I'm printing that particular value again
assigning the original result to the
result and then to showcase the
remainder operation I'm doing result we
call this particular operator as mod or
modulus so result modulus 7 so the
current value here is in this case would
be 10 so I'm saying 10 mod 7 so 10 mod 7
would become three because if you divide
10 by 7 the remainder should be three
and this modulus operator is used to
calculate the remainder of a division
operation so that three will be stored
in this result variable and then we
print that particular variable so that
is what I'm doing if I take you back up
there I'll just minimize this window and
this window as well so if I take you
back to the starting I'm doing an
addition first here at line 7 then I'm
doing a subtraction at line 12 then I'm
doing a multiplication at line 177 and a
division at line 22 and then again an
addition at line 27 and then a modulus
at line 32 and I'm printing the
respective values so let us run this
program and see what results do we get
so I right click I go to run as I go to
Java application there is also a
shortcut for it if you want to use the
shortcut you can use that so I click on
this and the output is is displayed here
here so you can see let me bring this
output back to its original position
yeah I just dragged it here to the top
to the bottom so if we start from the
top and see what all results did we get
printed so line 9 says 1 + 2 equal to
the value of result so 1 + 2 equal to at
this particular point the result value
was 3 because 1 + 2 equal to 3 moving on
the next variable here is minus so the
current value was three we said 3 - 1
which becomes two and we store the value
of result or three into this result
variable and we print that value at line
14 so original result plus original
result is three then a string here minus
1 equal to so this is just a string and
then the actual current result value
which is two so far so good we move
ahead and then at line 19 we are
multiplying the current value of result
by two and again displaying the original
result and the current value so 2 is the
original result here because here 3 - 1
had become two so original result value
was 2 multiply that by two becomes 4
then moving on to the line 24 2 by 4 by
2 should become 2 so 4X 2 = 2 the
current value of result then again
moving on to the next variable uh at
line 29 now the result value should
become 10 because 2 + 8 is 10
and again we are printing the original
result and then the current result value
so the original result was two then we
added 8 to it and the new result value
had become 10 which is coming from this
particular variable moving on to line 34
we are again printing the original
result which was 10 here and then we are
saying this particular string which is
modulus 7 and the current value of
result is coming from this expression
which is 10 modulus 7 and like I said
modulus or operation is basically used
to calculate the remainder of a division
operation which so 10 / 7 remainder is 3
so that becomes three and that's why you
see the value three so this is a
demonstration to show you how we can use
the addition multiplication subtraction
Division and modulus operators which are
all the arithmetic operators so in the
next session we will be discussing about
the other operator types which are unary
operators and we will also discuss some
other interesting operators which are
popularly used in Java let's get started
with unary operators so when we talk
about unary operators technically they
are also arithmetic operators but they
provide us a short hand or they have a
more advanced meaning so if you see on
the screen these are the unary operators
we call them as Yar plus unary minus
increment Operator decrement Operator
and logical complement operator so when
we talk about the UN plus operator
basically it is used to indicate a
positive value so whatever value you are
having it will just make that number as
positive number you might be wondering
that this plus has an addition meaning
as well right which we saw in the
previous example yes that's correct but
when we use that addition symbol we use
that between two variables but when we
talk about un operators they are used
with a single variable that is by the
name unar because they are used with a
single variable they require only one
operant so unar plus basically makes any
number positive unary minus negates an
expression and makes that number
negative increment operator increments
the value by + one decrement operator
decreases the value by minus one and
logical complement operator inverts the
value of the expression from True to
false or false to True let's understand
this with the help of an example so I
have created a class here called unary
demo and I have a static void main
method here and I have created a
variable called result and the first
example is about using un plus so I'm
creating a variable called as result
assigning the value as one and just
putting one plus in front of it which
makes this as positive value though we
can argue that this also has the same
effect as this and yes that is true but
in case if this value was written as
something like minus1 instead of plus
then we could basically make that number
positive by just putting Plus in front
of it so that's basically the power of
unary operators and that's how you
generally use unary operators so I'll
just put it back to+ one the next
example is about decrement operators so
the current value of result was one
because we did this now we are saying
result minus minus which means whatever
the value of result is just just
decrement it by one so the current value
was one so now the new value of result
after this evaluation becomes zero so at
line 14 we print the current value of
result which is zero moving on at line
16 we are using the increment Plus+
operator here which means whatever the
current value of result is just
increment it by one so the current value
of result was Zero till this line so it
becomes one because this means increment
by 1 so line 18 will basically print
that value 1 and then at line 20 I'm
using the unary minus operator which
means whatever the value of result is
just negate it just put a negative in
front of it just make that number
negative so if I just say minus result
the current value of result was 1 so it
became minus one and then to showcase
the negation operation I created a
Boolean variable named it as success
assigned the value of this variable as
false and printed the value of success
variable as is first and then printed
the value of success with a negation in
front of it with an exclamation mark
which will basically flip the value or
invert the value of a Boolean variable
so if this was false line 28 should
print true if this was true line 28
should print false in this case this is
false so the line 28 should print true
so let's right click on this and run
this program and see if we get the
expected output and yes we see the
output here so let's try to interpret
the output now the line 10 should print
1 yes then line 14 should print zero we
see Zero here line 18 should print 1
because we use the increment Plus+ so 0
+ 1 became 1 then we use the unary minus
operator so the value should become
minus one yes we see minus one here and
then for Boolean variable we should see
first the false because the value is
printed as is and then we are printing a
negated value so we should flip the
value from false to true and yes it is
printing the value as true so this was
about unary operators now when we talk
about this increment and decrement
operators what if I put this particular
value in front of result what effect is
that going to happen let's analyze that
part as well so for that I have prepared
a separate demo again I've created a
class called prepost demo and it has a
public static void main method I'm
declaring an integer variable I with the
value as three so the I becomes 3 here
and then I'm saying I ++ as we have
already seen in the unary demo example
this should increment the value of three
to four so it will print four expected
right then at line number number N9 I'm
putting this Plus+ in front of I now
what will happen now it is going to
increment the value of I and then
basically assigning the value of I so
the whole difference between I ++ and
Plus+ I is that in this case the value
of I is assigned first and increment
later in this case the value of I is
incremented first and assigned later so
here the value from four becomes five so
at at line 11 if you see if we print I
it will print five because we have we
are saying that first increment the
value and then update the value of I so
increment happens on I equal to 4 and I
becomes 5 at line number 13 it it
becomes more interesting because here
inside the system.out.print Ln statement
itself I'm saying plus plus I now what
will happen like I explained first the
value will be incremented and then the
value will be assigned so before
printing the value is getting
incremented so the value from five
becomes six here at line 13 but if I try
to do this now I'm saying first assign
the value of I and then increment it so
I at this line is still six because I
has already been assigned six and as the
post increment says if you put this
Plus+ after the variable it means that
you first assigning the value and then
incrementing the value so anything which
happens after line 15 the value of I
will become seven but at line 15 the
value of I is still six because we are
using a post increment operator so the
value is still assigned to I as is and
then incremented and when we do
system.out.print Ln the assigned value
is printed not the incremented value so
like I said after line 15 the value of I
will become incremented by one and it
will become s so hope you understood
this example and the difference between
the pre-increment and post increment
remember the thumb rule that if we put
Plus+ before a variable like at line
number n the value will be incremented
first and then assigned so at line 13
the updated value will be printed
because the first we are doing the
increment and then we are printing the
value or assigning the value similarly
at line 15 we are first printing the
value and then incrementing the value so
when the value is printed at line 15 the
old value of I will be printed but after
line 15 the new value of I will be
accessible to the program so let's right
click on this and run this program and
now if we see the values we assigned I
to 3 we did a post increment here so I
becomes 4 we print the value of I so so
here the value of I is four you see four
here then at line line 9 we are saying
Plus+ I so 4 plus 1 becomes 5 though
this is a pre-increment but since we are
not printing this Plus+ I as is it does
not have any any change so the value of
four becomes five at line 11 we print
five then at line 13 we are saying Plus+
I which means increment the value of I
first and then assign it so the value of
five becomes six and then I gets updated
and printed similarly at line 15 first
the value of I is assigned and printed
and then incremented so at line 15 the
value is still six you see this six here
and then the value is incremented so
after line 15 the value becomes seven so
that's how we are basically using the
unary operators and this is where I
would like to end this particular
session in the next session we will be
discussing about other type of operators
which are comparison operators and
logical operators Etc let's get started
with equality and relational operators
when we talk about relational operators
they are sometimes also called
comparison operators and the basic idea
behind using these operators is to
compare things or compare the values of
variables or compare the objects in Java
so in Java if you need to compare
anything for example if you want to
compare if something is less than the
other thing or something is greater than
the other thing or something is equal to
the other thing then you need to use the
comparison operators which are provided
by Java here you can see I have opened
the official Java docs and you can see a
bunch of comparison or relational
operators both of the terms are used
interchangeably some people call them
comparison operators and some people
call them relation operators so you can
see if I want to compare if an object or
a value is equal to another value then I
use the double equal sign if I want to
compare for non-equality I will use
exclamation with an equal to which means
not equal to if I want to do a greater
than comparison then I will use the
mathematics greater than symbol if I
want to do the greater than equal to or
less than or less than equal to they
again follow the same kind of uh
terminology as we see in mathematics so
this is all we have in terms of the
relational operators so let's understand
the usage of these operators with the
help of some examples so as you can see
I have created a class here which is
called comparison operator there is a
public static wide main method inside
this class and this method has two
variables of integer type called value
one and value two value one has the
value one and value two has the value
two and then I am trying to compare the
value one and value two variables using
the different relational operators we
just covered for doing that I need to
use a conditional operator as well we
will be covering conditional operators
in much much detail in the upcoming
lectures but for now you can understand
that when we talk about conditional
operators we talk about if and L
statement so if is again a keyword in
Java which can be used to compare things
and the syntax is very St straight
forward you write the if keyword and
then you write the actual comparison
syntax or the actual comparison
expression so in the first example we
can see that I'm writing a condition
which says evaluate if value 1 is equal
to Value two I should put a curly braces
around here you can see there are no
curly braces here but that is for a case
when you have only one statement under
it but again I will cover this in detail
and and I don't want to confuse the
audience here so I will just put curly
braces around all of these if statements
so that it becomes easy to interpret
what is actually going on in these code
blocks as we know that these curly
brushes are used to define a code block
so the first if block says compare if
the value one is equal to the value two
if yes then this condition will become
true and the control of the program will
go at line number 10 if this condition
is not true then the control will not go
inside 10 because this condition is
false so it will never go to line 10 and
it will move to line 11 or 12 instead
similarly the next condition is we are
comparing the value 1 is not equal to
Value two so this condition will only be
true if these two values are not equal
or unequal and if that is the case then
line 14 will executed otherwise line 14
will not be executed similarly in this
condition I'm saying compare if value 1
is greater than value two or not so if
the actual value holded by value one
variable is greater than the value two
variable then this condition will become
true and the line 18 will be executed
otherwise it will be skipped then
similarly at line 20 I'm doing the
reverse I'm comparing if value one is
less than equal less than value two if
that is the case then line 22 will be
executed otherwise it will be skipped
and at last I'm also showcasing an
example of less than equal to operator
that you put less than and equal to
together and again you compare the two
variables similarly you can also use use
greater than equal to variable
comparison operator as well in this
example so we have an example of
equality not equal to greater than less
than and less than equal to let's run
this example to understand so for
running the example I will just right
click here go to run as and click on
Java application and we can see the
output here so as the value one holds
the value one and value two variable
holds the value two obviously 1 is not
equal to two so the first condition is
not going to be evaluated to true so
line 10 will never be executed because 1
is not equal to two similarly if I talk
about the next condition which was if
value 1 is not equal to Value two then
execute statement 14 and yes 1 is not
equal to two that's why we see this
particular system. out. print Len here
we see this printed moving on is value
one greater than value two so is 1
greater than 2 no it's not so line 18
will never be executed then the next one
is is value one less than value two so
yes 1 is less than two so line 22 will
be executed and we see the line 22
output here system. out. println output
moving on is 1 less than equal to 2 yes
1 is less than equal to two so this
particular condition is also true and
line 26 will be executed and that's why
we see this here and that's all so we
can see that we are able to use these
comparison or relational operators to
evaluate different conditions and we
write those conditions using the if
block and again if you do not understand
the if block fully don't worry we will
be covering the if blocks in detail but
the focus here is in using the operators
the not equal to operators the greater
than equal to operators less than equal
to operators Etc so I hope these
operators give you better understanding
of how to use them now moving on to the
next section of this comparison
operators sometimes we also use some
logical terms to do the comparison for
example if I just move down here and I
show you these conditions here we call
them conditional operators conditional
operators are used to evaluate the
conditions like and or or and we use
them in two two ways either we can use
it as ENT or double ENT or we can use
them as pipe or double pipes so the idea
is basically to evaluate if one
condition is true and other condition is
also true or one condition is true or
other condition is true so whenever you
want to combine two conditions together
that's where you're going to use these
logical operators or conditional
operators you can also use the simple
English keywords like and or or or you
can use the logical representation of
these keywords for example m perent m
perent or double m perent is equivalent
to and similarly double pipe is
equivalent to or so we can use these as
as well interchangeably you can e use
either of these operator representations
to run a conditional check in
composition meaning you can compare two
conditions saying okay if one is true
and second is true or one is true or
second is true so the whole focus is
here in and and or comparisons so let's
switch back to the IDE and let's look at
an example of this to understand this in
detail so I will again take the similar
kind of example again I have created two
variables here value one and value two
value one has value as one and second
variable value two has value as two and
then I'm writing two conditions this
time in the same if block you can see I
am writing first condition saying is
value 1 equal to equal to 1 and is value
two also equal to equal to two so this
whole if condition is only going to be
true only if both of the conditions are
true that's the property of and and will
force that both the conditions on the
left hand side of it and the right hand
side of it hold true and then only the
whole expression is going to hold true
even if one of the conditions evaluate
to false the whole if expression will
evaluate to false similarly for or or
conditions we again write a left hand
condition and a right hand condition and
in between we write this double pipe we
can also write o r or in English that
will also have the same effect and this
will evaluate in a way that this whole
expression this whole expression will
evaluate to true if even a single
condition either on left side or right
side of it becomes true so or will just
need one expression to be true to make
the whole if condition true whereas and
will force both of the conditions to be
true to make the whole expression as
true so and will require two truths to
actually become true but or condition
will require only one true to become
true so if we try to do understand this
logic here I'm saying that if value one
is equal to equal to 1 which is correct
and value two is equal to equal to 2
then make this condition as true so yes
in this case this condition will
evaluate to true because value one has
value one one and value two has value as
two so it will print the line 10 whereas
in the next condition I'm saying
evaluate if value 1 is equal to equal to
1 or value two is equal to equal to 1 so
either of the expression if becomes true
either the left side this expression or
the right side this expression either of
the expression becomes true this whole
condition will become true and line 14
will be executed line 14 will not be
executed only in a case when both of the
conditions here become false for example
if I write it like this then we know
that value 1 is not equal to 4 because
it's one and 2 is not equal to 5 because
it's true in that case both of the
expression will become false and then
line 14 will not be executed if I write
it like this then the left hand
expression is evaluated to true because
value one is one but the right hand
expression is false but it's fine the
line 14 will still be executed because
either of these side is true so the
whole expression becomes true similarly
here and will require both of the
Expressions to be true and if either of
them becomes false then the whole
expression becomes false so in the
current state line 10 will be executed
but if I change this to this then the
left hand side of this amp percent will
evaluate to false and the whole
expression will evaluate to false in
that case and line 10 will never be
executed let's try to run all of these
scenarios to make a better understanding
of this so in this case both of the
conditions should work fine so I will
just right click and run as Java
application and yes we see this line 10
being printed and we also see this line
13 being printed so both of the lines
are printed correctly both of the
conditions are evaluating to true now
let's try to play around with it let me
change this value to four so now value
one this left hand side expression is
false which should make the whole
expression is false and it should not
print the line 10 which is this
statement so let's run this program and
see if that works yes we see that this
particular line is not printed now
because this whole expression became
false because the left hand side of this
expression became false similarly in the
r case either of them has to have to be
true you can see currently value two
equal to equal to 5 condition will
actually result in a false condition
because this is not a true value two is
actually two not five and still we see
this particular expression because
either of them have to be true if I make
both of them as not true now both of the
conditions on the left hand side of pipe
and right hand side of pipe are false
conditions what will happen now nothing
will be printed the reason for that is
that value one is also that this
condition is also false and value two
condition is also false so the whole
expression became false and this was
already false so this is all I wanted to
cover in this lecture we covered about
the comparison operators and how to use
them and in the next lecture we are
going to talk about the bitwise
operators let's get started with bitwise
operators now bitwise operators are very
less commonly used in the Java
programming World generally we don't use
them and generally we don't need to use
them you would generally use them when
you are doing really complex bitwise
calculation where you need to manipulate
the bits now what are actually bits so
if you remember when we talked about the
integer type variables we talked about
how much memory each of the variable
type or data type was going to consume
we said that this will take one byte and
this will take two bytes Etc one bite is
basically made up of eight bits and bits
are nothing but positions where either a
zero is stored or one is stored actually
the whole machine will convert your
whole program ultimately in zeros and
once which are nothing but bits so if
you want to do the manipulation at that
level so now you can understand you are
you are actually working at right at the
Machine level understanding so if you
want to manipulate the bits which are
going to be understood by the machine at
that level then you can use bitwise
operators but like I said generally we
don't need to use them them now when we
talk about bitwise operators there are
multiple ways in which we can use them
we can use them with the standard and or
or operations if you remember we covered
this and or or operations in the
previous lecture you see a difference
here that in case of and we are using a
single ENT or and not double amp percent
this is one of the concept which we did
not cover in the previous lecture and I
would just like to brief you about this
concept that if you use double amp
perent that is also called a short
circuit operator and if you use a single
Amper scent that is called a standard
operator to build an understanding about
this I will just quickly recap of what
we covered in the last lecture and we'll
try to explain these Concepts as well so
let's go to The Logical operator demo
and here if you remember there were two
amp perents and two pipes this is also a
valid expression a single amp percent is
also a valid expression the only change
is in this case even if the left hand
condition evalu Ates to false still the
right hand condition will be evaluated
although we know that in case of and
either of the expression needs to be
false and the whole expression becomes
false so Java provides an advantage or
with that if you use double M percent
and if the left hand operation becomes
false then it will not cover the right
hand operation it will not even evaluate
the right- hand operation because it
doesn't matter if the left hand
operation has already returned to false
or evaluated to false then no matter
whether right side is true or false the
whole expression is still going to be
false right that's the property of and
one of the side has to be false and the
whole expression becomes false so why
why evaluate two sides why waste the
memory in evaluating the right side when
the left side has already turned as
false Java takes advantage of that and
that's why if you use double amp perent
you save a bit of processing power of
your computer
by just evaluating the left hand
condition and if the left hand condition
is false it will skip evaluating the
right hand condition and just make the
whole expression false but if you use
this a single M percent then both side
of the expression will be evaluated
irrespective of their output so in this
case even if the left hand expression is
false it is still going to evaluate the
right side expression and similarly it
works for the r case as well in this
case in R case as we know if one of the
condition is true the whole condition
becomes true the whole expression
becomes true so if the left hand side
becomes true and if you use a single
pipe then it will still evaluate the
right hand side but if you use double
pipe like this then if the left hand
side becomes true then it knows that it
does not matter if the right hand side
becomes true or false because ultimately
the whole expression is going to be true
if either of the side is true so if the
left hand side is already true it will
not evaluate the right hand side and it
will say the whole expression is true
that's why you see the single amp
percent being used for bitwise just to
explain why it why it is used and how it
is used for R operations in bitwise you
use this cap or whatever you want to
call it as and for the inclusive bitwise
or or operation you're going to use the
single pipe you also use some shift
operations where you shift the value of
bit of a particular variable to either
left or right right again these are
again very complex calculations if you
want to use that please read about this
and use that but in the in today's demo
what we are going to cover is the and
and or examples of bitwise operations so
here I have again created a class called
bitwise operator I have a public static
void main method I have two variables
here which are int a equal to 5 and int
b equal to 7 now these five and 7 are
actually stored
as bits as zeros and ones in the
computer's memory so how they are
actually stored they are stored in a
standard bit representation which you
may have studied in your mathematics if
to give you a recap this five will
basically be written in the memory as
this 0 1 0 1 and it starts from here 2
to^ 0 into 1 becomes 1 2 to^ 1 into 0
becomes 0 2 to^ 2 into 1 becomes 4 and
2^ 3 into 0 becomes 0 so 4 0 + 4 + 0 + 1
becomes 5 and that's how 5 is displayed
to you similarly for 7 2 to^ 0 into 1 is
1 plus 2 to^ 1 into 1 is 2 so 1 + 2 3 +
2^ 2 into 1 which is 4 so 1 + 2 + 4 7
and 2 to^ 3 into 0 is 0 so 0 + 4 + 2 + 1
which is 7 and that's how this 7 is
built and stored and now if you try to
do this if you try to write this
condition you can also write the
condition into a system.out.print l and
blog and it will basically evaluate this
condition so now if you say A and B in
this case this is going to do a bitwise
operation because this is bitwise upper
end it is going to do a bitwise
operation and the what would be the
result if you do an and on this
so again use the same logic as if in
case of and if one is false then the
whole expression is false so 0 and 0
becomes 0 1 and 1 becomes 1 0 and 1
becomes zero because Z means false and
one means true so if either of them is
false the whole evaluation becomes false
so that's why 0 or and 1 becomes zero
and 1 and 1 is always one
the value of this is again five as we
already have evaluated similarly if you
do a bitwise or and if you do this again
we are doing an R operation so 0 or zero
or basically false or false becomes
false true or true becomes true false or
true should be true because one of them
needs to be true so this is false but
this is true so the whole value becomes
true and the finally true or true is
also true true so this is the final
bitwise or result and if we convert this
into an integer representation that
becomes seven because 2 to^ 0 into 1 is
1 2 to^ 1 into 1 is 2 so 2 + 1 3 + 2^ 2
into 1 which is 4 so 4 + 2 + 1 which is
7 and + 2^ 3 into 0 which is 0 so 0 + 4
+ 2 + 1 becomes 7 and that's how you get
actually seven so let's see if we get
five or seven in this bitwise operation
yes we can see the values as five and
seven so this is a bitwise operation
happening similarly you can also use the
shift operations where in case if you're
using the this particular kind of
representation or this particular kind
of representation they are called bit
they are called left shift and right
shift operations so if you use this in
front of a variable then for example
this one will be shifted here and this
zero will be shifted here and this one
will be shifted here so that's how the
whole value is going to shift whole bits
are going to shift one by one towards
left similarly if you're using the right
shift then all the bits are going to be
shifted towards right by one bit that's
the whole concept of left shift and
right shift bitwise operations and if
you want to know more about this please
read some official examples from the
Java Doc and some other examples
available on the internet to build an
understanding on this so this is all I
wanted to cover in this lecture so in
the next session we are going to talk
about the control flow statements like
if else Etc let's get started with
control flow statements so what are
control flow statements and why do we
need them control flow statements are
the ones which can help you control and
Define the flow of execution in your
program now why do we need them is
because if we want to evaluate some
conditions or we want to create some
branches of execution saying that if
this condition becomes true do this and
if this condition becomes false do that
so you can see there are two different
branches of execution of a program in
this kind of approach and that's where
control flow statements can help us
there are lot of different types of
control flow statements like if then
else and switch and for and while and do
while and and we are going to cover all
of them in detail in this series so
let's get started with the first one
which is the if statement we covered
briefly about this when we talked about
operators and I promised you guys that I
will be covering this in detail and this
is the session where we be we will go
deeper into this concept as we have
already understood that if condition is
basically used to evaluate a condition
if it is true or false the result of an
if statement will always have only two
values it can either have a true value
or it can have a false value there is no
other possibility or there is no other
value of an if statement or of an if
expression now like I explained if you
want to do a simple uh programming
execution where you say if a particular
condition becomes true do this and if
this becomes false then do that it means
you need to write this lse condition as
well that if this doesn't hold true what
do I do and how do I write that so let's
understand that with the help of an
example for this particular example I've
created a class and there is a public
static void main method which is the
entry point of this program's execution
I have a variable which is called test
score this is an integer variable with
the value 76 and I have a care variable
which is grade basically what I'm doing
that based on the test score marks I'm
trying to define the grades which a
student will will get so for that I have
built a condition here so you can see it
starts with if which is a keyword then
you put these standard braces or
brackets and you write your condition
inside it in this case I'm writing the
condition saying that if test score is
greater than equal to 90 then the
student should get an grade A so here
I've defined this grade variable and
here I'm just assigning the value to the
grade variable at line 11 if the test
score is greater than 90 the grade
should be a but what if the score is not
90 what if this condition becomes false
and you want to do something in that
case you can write this else block here
we call this else block so you write
else as the keyword you start the curly
braces and then you define the grade if
the score is not greater than 90 what
should be the grade of the student so in
this case we are saying the grid is f so
if we try to run this example in our in
our mind we see that the value is of the
test score is 76 so 76 is not greater
than equal to 90 so this particular
condition will not be true so line 11
will not be executed but instead L's
block will be executed because if the
condition goes false then L's block
should be executed as for Java so this
block will be executed and grid will get
a value of F and then we are printing
this grid value by just writing a system
do out. print Ln a string plus the value
so let's run this particular program and
see what happens we get a grade equal to
F here in this CIS out or
system.out.print because this condition
was false so the control the flow of the
control of the program went to line 12
and then to line 30 because this was the
else block so this is one understanding
where we can write an if and else logic
you in some cases you might not need an
else block so else block is not mandat
Tre it's an optional block if you want
to remove this and if you just want to
do a sis out here that is also fine sis
Out means system.out.print Lin for Shand
we sometimes call it as sis out so you
can do something here as well if you
don't need Del's block if you need Del's
block feel free to write it but this is
an optional block but in some cases your
conditions will be more complicated than
just a single condition if you try to
understand it from a real world example
in real world you will not have only two
grades as a and F you will have more
grades right A B C D so on so forth so
what are you going to do in that case
for that kind of case Java provides us
with an keyword which is called else if
else if is just a continuation of if
saying that okay if this condition
doesn't hold true evaluate the next one
with an L if so I've commented out this
code let me put this code back into its
place and then we will walk through this
code to understand it okay so I have put
the code back to where it should be and
this is how it looks like so let's just
walk through this the line 10 and 11
doesn't change it's still the same but
then I have added some additional
conditions saying that okay if the score
is greater than equal to 90 the grade
should be a but if the score is not
greater than 90 but greater than equal
to 80 then the grd should be be
similarly if the score is not even
greater than 80 but greater than equal
to 70 then the grid should be C
similarly if the score is NE not even
greater than equal to 70 but greater
than equal to 60 which means basically
between 60 to 70 then the grid should be
D and if the score is even below 60 then
the grid should be F so you can see I
have basically defined the whole Logic
for defining the grades here and it
always works in a top down approach one
by one the way in the sequence in which
you will Define the else if block will
be the sequence in which they will be
executed so after the condition at line
10 and if this condition fails line 12
will be naturally executed if this
condition also fails line 14 will be
executed and so on so forth it will
never be the case that if this condition
fails then suddenly Line 6 is executed
and then again line 12 is executed it
will always work in a line by line
fashion so make sure whenever you are
using the LF statements write it in a
sequence in which you want the natural
program to be executed so this is all we
have here and now let's try to run this
example let me just bring the
system.out.println a line up save this
file right click run as Java application
so we see the value is grade equal to C
which means this particular code block
was actually executed only this
condition held it true now now let's try
to understand how this happened the
value was 76 so 76 greater than 90 no
this condition becomes false so line 11
is never executed it naturally goes to
line 12 because that's where we have
defined the next else if block is 76
greater than equal to 80 no it's not so
line 12 condition also becomes false
line 13 never gets executed and the
control shifts to line 14 and there we
have the condition saying that is 76
greater than equal to 70 yes this
condition is true so the line 15 gets
executed and once this condition gets
true none of the further conditions will
be executed because you only need one
true statement one true execution in the
whole if else if block if that one code
block gets true that code block is
executed and then the execution jumps
out of the uh if else if blocks and it
will directly go to line 22 and it will
execute that had it been the case that
this particular block was also evaluated
to false it would go to line 16 and if
this was also false it would go to the
block which is L's block let's see that
let's make this value as 56 so now 56 is
not greater than 70 so like 15 will
never be executed because this condition
will evaluate to false 56 is greater
than 60 no so this will also be false
and ultimately the grid should fall to
L's block where we are assigning the
grid as F let's see yes we get the grid
F because ultimately this block was
executed because all of the above
conditions evaluated to false so this is
all I wanted to cover in this if else if
demo there is another addition of
another way of writing if statements
which we call as nested if where we have
an if block inside an if block inside an
if block and so on so forth how do we
write that and how does the control
flows in that kind of an execution we
will cover that in the next session
let's get started with using nested if
statements in Java now in the previous
lecture we saw how we can use an if else
block and also an if else if else block
but there is another case where we can
use these if statements and that is when
you have nested if block
when would you use it let's take an
example let's say you have multiple
conditions to check on a particular
program and where the output of the
first condition is the input of the
second condition and the output of the
second condition is the input to the
third condition and so on so forth if
you have that kind of situation you can
write it in a nested if statement kind
of block so let's understand this with
the help of an example as you can see I
have opened an example here which is
about nested if statements I've created
a class which which is named as nested
if demo and I have created a public
static void main method inside this
particular class and now I have declared
an integer variable with the value 50
then I'm checking the first condition
saying if I equal to equal to 50 if that
condition is true then I will check the
next condition which is if I is less
than 75 and then I am adding one more
hypothe iCal condition saying if this is
true then also check if I is less than
55 so you can see if I equal to 50 holds
true then only this condition will be
executed similarly if I is less than 75
then only this condition will be
executed so they are dependent upon each
other this condition block is dependent
upon the previous block to be true and
this if condition block is dependent
upon this if block to be true if either
of these if blocks don't go through the
next subsequent nested if block will not
be executed so in this case I'm checking
it for first equality condition saying
if the value is equal to 50 then execute
this statement at line number 10 then
check if I is less than 75 if that is
also true execute the statement at line
number 12 and then if I is also less
than 55 then also execute line number 14
I can also add an else block as well
anywhere in this next hierarchy if I
want to if I add an L's block here that
El's block will be corresponding to this
block if I add an El's block here and
that else block will be corresponding to
this if block and if I add an else block
here then that L's block will be
corresponding to this particular if
block so you can also use those else if
and else blocks as well with nested if
blocks and make it as complicated as you
want it to be so that's about this
program and let's see if we run this
program what output do we get and let's
interpret that output so I've just right
click run as Java program and I see some
output in the console first I get I is
50 so line number 10 gets printed
because I is 50 then I also see the next
line output as I is smaller than 75 it
means this condition was also true
because 50 is less than 75 so line 12
also got executed and then I'm checking
if I is less than 55 so yes 50 is less
than 55 so line 14 also gets executed
and we get get this statement on the
console so this was a simple way to see
how we can implement the nested if
conditions now we are also going to talk
about another concept which is used in
writing the if conditional blocks which
is called tary operators so Turner
operators are used as a Shor hand of
writing if El's block as you can see
that these if blocks are quite verbose
we have to write a lot of code to
actually write some conditions in this
this case I'm executing three conditions
but the code is almost seven lines or
eight lines so we will see how we can
simplify this if we use a Turner
operator and for that I have created
another class which is called Turner
operator demo and this particular class
again has a public static void main
which is the entry point of this
particular program and then I have
declared couple of variables first is
int a = to 1 and second one is int Bal 2
I have also declared a result variable
and we will see how we can use this
result variable and at line 10 I have
written my if El's expression so you can
see this if El's expression doesn't look
like the one which we have seen before
so let's understand how do we write it
if you're trying to write an if else
expression with tary expressions or tary
statements then the first thing which
you need to understand is the structure
of it so here at first you will specify
the actual condition which you want to
test in your if block so this is my
condition then after that condition
you're going to put a question mark and
after the question mark you're going to
put the actual result which you want to
be executed if this condition becomes
true so if the if condition becomes true
what do you want to do whatever is that
you will write it here and then if the
condition becomes false then the logic
should go into the L's block and the L's
logic should come after this colon so
all you need to remember is this
question mark and this colon before the
question mark you're going to write the
condition after the question mark you're
going to write the statement which is
going to be executed if this if
condition becomes true and after the
colon you are going to write the else
block condition which is going to be
executed if this condition becomes false
another thing to notice is that Turner
operators can be used only in cases when
you have only one statement to execute
in if block and one statement to execute
in else block it canot not be more than
one statements so instead of this you
can also write system.out.println here
which will also be fine if I just write
this
system.out do print not print F but I
want to write print Ln so I'll just
write print Len you can also do this
this is also fine you don't need to
store the result obviously uh but but
you can also write this condition in a
way but this this only has to be a
single statement it cannot be more than
one statement because this expression
can only hold one statement at a time so
use it in situations where you have to
check a condition and do something in
the if block which is only one statement
and again one statement in the else
block the same expression can also be
written in a verbos if else way in which
we have been seeing it before and we'll
also I will also show that to you and
here where this A and B is going this is
getting stored in this variable called
result so if this if condition holds
true then the result is a and this is
going to be stored here and if it is
going into the lse block then B is going
to be stored in the result block let's
run this program so we can see we get
the value 1 because we have set the
condition as a less than b so yes 1 is
less than two so this particular
statement gets executed and this value
gets stored here in the result variable
so that's how you can use the tary
operators to write shorthand if L
statements the same expression can also
be written in a verbos way for example
you can write it in this way saying if a
is less than b then result equal to a
else result equal to B this code has
exactly the same effect as this one line
of code so you can see this is this is
pretty uh simple to write pretty short
to write the code which I'm writing here
in four lines can be written here in one
line and that's the power of tary
operators so this is all I wanted to
cover in today's session so we talked
about nested if statements and and the
Turner operators here how to use them in
the next session we are going to discuss
about switch case statements let's get
started with using switch statements in
Java so let us first understand why do
we need switch statements generally
whenever you want to check a condition
you can use an if else block but what if
you have multiple conditions to check
what if you have so many possible
execution paths that it becomes too
verbos to write it into an if else kind
of block what if you have to check on
constant values of certain Expressions
how do you do that it becomes even more
challenging and the code becomes even
more verbose so in such cases switch
statement can be used in which you can
write switch statement to have as many
possible execution paths as you want and
it will work with constant values as
well so let's understand this with the
help of an example as how and why will
we use the switch statements so so for
that I have created this class which is
called switch demo and it also has a
public static void main method which is
the entry point and in this program what
I'm doing is I'm trying to accept a
number as the month number in the
program and then uh with that particular
number I'm trying to print the
corresponding month's name so that's the
logic pick a month number and you should
get the month's actual name so now in
this case you can you can imagine there
will be at least 12 if LF blocks which
is a long line of IFL statements at the
same time if we try to do this for other
conditions where the value is constant
please understand that the value of
month is going to be constant it's going
to be the same number so it's not
similar to you evaluating a condition
it's similar to you evaluating a
condition to a particular constant value
imagine if you have to do some sort of a
classification of employees in higher
salaries and lower salaries and there
are hundreds of salary bands in the
company so are you going to write 100ls
Logics that is going to take a long time
and then what if new bands get new bands
get introduced then it gets even more
complex so we will use switch case
statements in cases where there are lots
of if else conditions and the expression
evaluates to a constant value remember
in the F El cases the expression
evaluates to a Boolean value so here I'm
supplying the month value as six then
I'm also creating a string month month
string variable just to print or store
the name of the month and then the way
you write the switch statement is to
write the switch keyword and then in the
brackets you supply the month integer
value and then you start writing your
conditions so you can see you write the
case as keyword and then you write the
number or the possible values this
particular variable or this particular
expression can hold so all the possible
values this particular expression can
hold will be written individually as
cases so case equal to one here one
means the value of month is one in that
case the month string which we created
here shall store January and then we see
a statement called break so break is
again a keyword in Java and this keyword
has a special meaning it has a special
usage you will use the keyword break to
abruptly break the control of execution
from the current code block and the code
block is identified with curly braces so
here you can see the curly BRD starts
from here and it ends down to line
number 51 at here so the moment your
Java program is going to encounter this
particular statement it is going to jump
out of the current code block execution
and continue thereafter that's the basic
logic and usage of break statement so
use it whenever you want to skip the
rest of the code after the break
statement if you don't want to execute
the rest of the code you will write
break and the moment the Java program
sees this particular statement it will
jump out of the current code block
specified by the curly bres and will
resume execution after the code block so
in this case it will resume the
execution after the line 51 that's the
usage and meaning of this expression
called break so in this case we are
saying that if the month value is one
which we denoted as here case one then
store the value of the month string as
January and break out of this particular
code block because we don't need to
execute any further we have found a
match then another case would be if the
month value is two so you write case
which is a keyword and then the exact
expression value value the constant
value which is two and if that's the
case then month string becomes February
and again you break because in this
particular case there will only be one
condition true at a time there will
never be a case that month with the
value two will have two meanings will
have two month names a month with the
value two will always have a meaning
called February it will never have two
meanings or two month names attached to
the same integer value and that's why
you do not want to ex Ute any further
and that's why you write this break
statement if you do not write this break
statement it is going to evaluate all of
the cases one by one even if the cases
are not going to be true but it is going
to waste lot of processing time
evaluating all the case conditions which
you have written here which does not
make sense because we know that only one
condition at a time can be true here
because we are evaluating and checking
for a constant value which is an integer
value so that's the reason we put a
break in each case if intentionally if
you want to check multiple cases do not
put a break statement but the program
can become really confusing in that case
so take your wise call so here we put a
break in each case similarly case three
the month string becomes March case 4
the month string becomes April case 5
becomes May case 6 becomes June case 7
we have month string as July case 8
month string is August case 9 we store
the month string as September case 10 as
October case 11 as November and case 12
as December after that you will also see
an interesting block called default this
is the another capability of switch
statement that what if none of the above
conditions hold true what if we specify
a value which is not between 1 and 12
and it will not match any of the cases
which we saw just above and if you want
to execute some code in that case if
none of the conditions matches you may
want to execute some default execution
all so in such cases you're going to use
default default is the code block which
will be executed if none of the case
matches so here you can see that if none
of the cases match then we are going to
store the value of month string variable
as invalid month and then we'll
eventually break out and once we break
out of this program we just want to
print the month string that's all we are
doing in this program that we take an
integer value as the month number and
then we print the corresponding month
name here by looking at the case blocks
and we also def Define a default case
block if none of the conditions hold
true so let's run this program we have
specified the value as six which should
result in the month name as June and yes
we can see we get June let's change the
value and let's put the value as 10 and
see what do we get so right click run as
Java application and we got October yes
exactly correct let's put an invalid
value as 13 and let's see what happens
now now we get invalid month so our
default code block just got executed
because we entered a value which is not
matching any of the case conditions
which we have specified so this is how
you're going to use the switch and Cas
statements while writing your conditions
whenever your condition evaluates to
multiple constant values remember the
the key here is to to understand if your
expression is evaluating to multiple
constant values which do not change and
in those cases using a switch case block
is a better idea than writing IFL
statements so that is all what we are
going to cover in today's session and in
the next session we are going to
understand something about
two-dimensional arrays and
multi-dimensional arrays as well let's
get started with understanding arrays in
detail we have been talking about arrays
throughout this course of java in the
previous sessions as well and we have
covered some basic understanding of how
to create arrays how to declare them how
to fill values in the array and how do
we print the array with positions as
well as the array as whole but whatever
examples which we took previously were
one-dimensional arrays because arrays
can have more than one Dimensions as
well you can create a onedimensional
array you can create a two-dimensional
array you can can create even a
three-dimensional array and you can go
up to as many dimensions as you can
handle in your Java program so it
depends upon the kind of complexity you
want to have in your program and the
kind of values the kind of structure
you're are going to store in your arrays
and based on that need you can choose
whether you want to use a 1D array or
onedimensional array or a 2d array or a
3D array and so on in these sessions we
are going to talk about 1D arrays 2D
arrays and 3D arrays and after that
we'll leave up to you to try out more
dimensionals if you want to we have
already covered the basic array
structures which were onedimensional
arrays so I will just give you a quick
walk through of how we actually handled
onedimensional arrays so this is a
sample program to demonstrate
onedimensional arrays if you remember
this is how we use to create arrays we
write the data type of the array and
then we write the square boxes which
denote that this is an integer array
data type we assign a variable to this
and then we initialize the array with
the size four so new is the keyword
which is used to initialize anything in
Java and we are going to use this
heavily when we talk about classes and
objects and even collections literally
any object which you want to create in
Java requires a new keyword so here I'm
writing new and then int 4 which means
create an array of size 4 and then I'm
filling the value of the four positions
which I have created as part of this
array and if you remember remember when
we create these kind of arrays we store
them in a zero index based position the
first value gets stored at zeroth index
position and then so on so forth so it
will always start from zero and never
start from one remember that and after
that we just print all the values of
individual positions of the elements in
the array and if I just run this program
all of the elements of this particular
array should be printed one by one so if
I just show the full console of the
output we can see that elemented index 0
was 10 elemented index 1 was 20 element
at index 2 was 30 and element at index 3
was 40 so this was just a quick
refresher of how onedimensional arrays
can be written and whenever you declare
a very simplistic array it will
generally be a onedimensional array now
let's look at the two-dimensional arrays
and how do we write them when do we need
them for that I have created another
example which is says two dimensional
array I just created a class and it has
a public static void main method and
I've created a two dimensional array
this time so let's understand this two
dimensional array in a bit detail and
when do we need that generally you would
need to use two dimensional arrays
whenever you are trying to do any Matrix
calculations if you if you understand
what do you mean by matrix it's
basically a 2X two structure which
stores the values in the form of rows
and columns so imagine a table of two
rows and two columns then it will be a
2x2 matrix so if you want to store that
particular table in a Java program you
would need to store that as a matrix as
a two-dimensional Matrix rows being the
onedimensional and colum beings the
other dimension and that's what we are
doing here and if you want to store that
2D Matrix in a Java program the approach
and the procedure for it is pretty
similar to how you create a
one-dimensional array with with slight
changes the first change is instead of a
single square bracket you're going to
write two square brackets because it is
a two-dimensional array so remember the
number of square brackets you are going
to put while initializing and declaring
the array is the number of Dimensions
which your array is going to have since
this is a two- dimensional array example
that's why you see two brackets here if
this was a three-dimensional array
example you will see three array three
square brackets here and so on so forth
so that's the first part of it second
part to understand is to how to store
the data remember I told you always
imagine the structure of rows and
columns whenever you are trying to store
a two-dimensional array in Java so what
are rows and what are values and how do
you represent them while you declare and
initialize a two-dimensional array so
you start with the curly braces as a
normal 1D array but inside the curly
braces you create nest Ed curly braces
blocks you can see three blocks here
they start with their own curly brace
and end with their own then this curly
brace starts here and ends here and then
this curly brace starts here and ends
here idea is that you provide this outer
curly braces to define the overall
structure and then inside each of the
curly braces is going to represent a row
in your two- dimensional array so each
of these values this blocks is going to
represent a row so I can say that this
is the first row this is the second row
and this is the third row and if I try
to visualize it in terms of columns then
this is the first row First Column first
row second column First Row Third column
similarly second row First Column second
row second column second row third
column and third row First Column third
row second column and third row third
column so in individual values are going
to be represented as columns and the
whole curly Braes is going to be
represented as arrays that's the basic
mental idea or mental image you should
have while declaring a two- dimensional
arrays remember to declare the rows
inside the nested curly braces and
whatever elements you have will
automatically be indexed as columns
another thing to remember that since
this is an array data structure
everything starts from zero and nothing
starts from one so this will be row Zer
this will be Row one and this will be
row two I'm talking about the position
we can still call it as first row second
row and third row but the position of
this particular row element is zero the
position of this particular row element
is one and this particular row element
is two similarly for column as well this
is column 0 column 1 and column two
similarly column 0 column 1 and column 2
and so on so forth once you understand
this data structure well and you have
defined it correctly then everything
should fall in place if you want to do a
matrix addition or if you want to do a
matrix multiplication or a DOT product
all of the kind of calculations can be
performed using the 2D array concept
here in this program what I'm doing is I
am printing the values of this
particular 2D array into a matrix style
and you see some strange code here which
is for ETC don't worry about this I'm
going to cover in detail what this four
means and how do you write this for now
what we can understand that we just want
to print this you might not need to
print this in your Java programs when
you write a production grid application
but you might want to do manipulations
on these uh arrays as metrix maybe you
want to create a transpose of a matrix
or you want to do a DOT product or
addition or subtraction or whatever be
your use case in this case just for
demonstration purpose I'm printing the
values as rows and columns nothing else
so this all of this code from line 8 to
line 14 or in fact line 13 is just
showing how to print the values you can
see some system.out and you can see some
construct here and like I said don't
worry about this I will cover this in
detail let's run this program and see if
my Java array is stored correctly and
how can I represent this so you can see
I have represented it in a style of a 2d
Matrix where this is the first row this
is the second row and this is the third
row similarly this is the First Column
containing the value 237 so column 0
will have value two and column 1 will
have this value three and column two
will have this value seven for row zero
let me also do something here which can
help you understand this concept better
let me do a system.out.print Ln and
let's print an individual value because
like I said the for Loop can be
confusing here to understand so let's
say I want to print ARR of zeroth row
First Column and see see what kind of
values do we get let me comment this
code comment is control back slash and
this code will be commented and this
code will not be executed and now only
line 15 will be executed instead of the
four block so if I run this I get the
value seven so row 0 and First Column
row zero First Column is seven let's try
with 1 one I want to print the row at Z
one position remember not the first row
but the one position row which is
basically technically the second row so
second row second column and see what
kind of values value do I get in this
case I get six so second row second
column similarly if you change this
value to two then third row second
column which should point to four yes we
get four similarly you can write a value
here as zero and you can write a value
here as let's say two this will print
the zeroth row and the second column so
similarly whatever kind kind of value
you want to write you or you want to
access you can access it in this fashion
and remember the column and row indexes
will always start from zero so this is a
simple demonstration of how you can use
two dimensional arrays and in this
session we also did a refresher of
onedimensional arrays so that's all for
this session and in the next session we
are going to be discussing how we can
Define threedimensional arrays and we'll
also see an example of it let's get
started with how to create create and
use a three-dimensional array or how to
go about using multi-dimensional arrays
in Java so as you can see from this
image we talked about 1D array which is
having just one axis then we talked
about 2D arrays in the last session
where we had rows and columns basically
an x-axis and a y axis and then we can
also have a 3D array which will have
three axises which will have an xais A Y
AIS
and also a z axis think of a simple box
which every box in this world will
always have at least three dimensions
and from from here you can go even build
more complex arrays which can have four
dimensions or five Dimensions or as many
dimensions as you want it to have and
today we are going to look at an example
of how can we build a 3D array and how
do we access those elements but this
picture is just to show you the mental
model of when you will be creating a 3D
array so for example generally an image
data is stored in in three dimensions so
you can you might want to store the
image data into a 3D array and there can
be many other use cases in the
mathematical and research computational
use cases where you might want to use a
3D array so but remember there's an
x-axis there's a y- axis and then there
is a third axis which is called the Z
axis so let us look at at a Java program
to understand how we can build a
three-dimensional array and for that I
have created this class which is called
multi-dimensional array it has a entry
point method which is the public static
vo main method and then I have created
an integer array and this time instead
of one or two square brackets I have
three square brackets and if you
remember I mentioned this in the
previous session as well the number of
square brackets which you're going to
put while initializing the array is the
number of dimensions of the array and
since in this particular program I'm
going to demonstrate a three-dimensional
array that's why you see three square
box boxes let me just minimize this y so
we have three square boxes here and we
have created the variable name as ARR or
short form as array then we start with
the outermost curly braces as is then we
put another curly bra which starts from
here and it ends here
then another set of curly bra which
starts from here and end here so this is
the this is the First Dimension this is
the second dimensions and these are the
third dimensions that's how you're going
to define the different dimensions
remember this is the First Dimension
when the first curvy brace starts then
you have the second dimension which
covers this hole and this hole and then
you have third dimension which are these
so that's how you're going to visualize
and and put the three dimensions in use
while declaring a three-dimensional
array and the values work in the same
fashion it's it's a zero index based
position so since we do not have an
official name for the third dimension so
I'm just going to use x-axis y axis and
Z axis to refer to the three axises so
this would be X of 0 this would be Y of0
and this would be Z of 0 similarly X of
1 y of 1 and Z of 1
and so on so forth so now if I try to
access the value which is at zeroth X
position first y position and second Z
position what's the value do we get here
let's run this program and understand
and interpret the output okay uh so when
we ran this program we got the output as
11 so let's understand this output so
when we say the zeroth position on X the
first position on Y and the second
position on Zed so this is the zeroth
position on X and this is the first
position on Y and then this element is
01 2 is the second position on the Z AIS
so to to describe it in a nutshell this
defines the x-axis so we have two
elements on the x-axis here this one and
this one then we have have two elements
on the y axis on each x-axis so this is
one this is two on the first xaxis and
this is one and this is two on the
second y second x axis so 2X and 2 Y and
then on the Z axis I have three elements
each so hope this helps you understand
and visualize this so xaxis and this one
is other x-axis and then Y axis y axis
and then elements inside this are Z axis
so I'm saying zeroth xais in this block
first on the y axis which is this block
and then second element or the Z or
second position element on this
particular a in this particular block
which is 11 and that's why we get 11 if
I print zero let's say I I change this
particular value as one so now the
output should be coming from this side
so second X position because it's one
second y position so this will go here
and then the two position which is the
third element of the Z AIS which is 13
so let's see if we get 13 yes we get 13
here so this is just to show you how you
can interpret this particular array and
always be mindful of how you are
structuring this array if your structure
is gone wrong then your program will
become useless and it will give you a
lot of unpredictable outputs which might
not make sense and which may introduce
errors in your program so be very
careful how you define the structure of
the elements here that's the key and
after that you just need to understand
the x axis the y axis and the Z axis
always remember all the accesses start
from zero so when I say two I'm
basically referring to the third element
and not the second element so this is
all I wanted to cover in this particular
session where we describe how we can use
a three-dimensional array and from here
you can go to any lens like I said you
can add more square brackets here and go
to four dimension or five dimension or
six dimension ion but remember the more
Dimensions you add the more complexity
of the program will be having the
program will become more and more
difficult to debug and understand so
always try to take a wise call as to how
many dimensions you want to use in your
array and that's it for this particular
session in the next session we are going
to talk about the different Loop
statements in Java let's get started
with today's topic which is about how to
use do while Loops now in the previous
session we covered the usage of while
Loops but we have another type of while
loop which is called a do while loop so
let's understand when do we need that
and how do you actually use that let me
switch to the Java documentation and if
I can find some syntax off it as well
yep so as you can see here if I just
highlight this portion this is how you
actually write a do while statement
block so you write do you start a code
block you write some executable
statements and then after the code block
ends you write a v expression and end it
with semicolon this is the syntax
basically it starts with do a curly
braces some executable statements a
while block or a v statement basically
with an expression ending with a
semicolon let's understand this with the
help of a program to understand the
structure better so for this I have
created a sample program here which is
called do while demo again having a
public static void main method and it
has a variable which is count and it is
initialized as one then I write do I
write this code block or the curly
braces and then I am just printing the
value of count then I am incrementing
the value of count and then I am writing
a condition which says while count is
less than 10 and semicolon if you
compare this with the previous demo we
ran if I just put them side by side we
had while condition statement and and
the and the state change condition here
we have do statement condition change
statement and then we check the
condition at the end so the idea is that
if you have a use case where before you
even evaluate the condition you want to
print something even before you evaluate
the condition if you want to do
something in that case you will use the
do while loop even before the while
actual while loop starts if you want to
execute a statement you will use do
while loop for example if you want to
print the initial value of the count
even before the condition checks then
you can use doy Loop if that is not your
use case you can use the simple y Loop
which is described here in this program
so coming back to the do while so I say
do and then I'm saying print this
particular statement without checking
anything this condition will be executed
for the first time without any condition
check at at all this will just work as
is like a normal Java statement after
that I'm incrementing the value of the
count and then I'm checking the
condition so remember when this
particular condition is being checked
the first increment has already happened
but in the while case we did the
comparison before even the first
increment the first comparison happened
with the original value of count but
here the first comparison is happening
with the incremented value of the count
hope you get the difference in a better
context now that you will use this when
you want to do some write some
initialization code before you actually
hit the condition so this condition will
be evaluated with 2 less than 10 and
then the value will be printed let's
print this example and we'll also try to
play around with this example a bit more
to bring to build our understanding
better if I run this program there is no
difference in output if you compare this
with the previous program we ran for the
while so it prints the count value so
this is coming here then it increments
the value then it checks the condition
saying is 2 less than 10 yes that holds
true if that holds true it will go back
to statement number nine again print
this again do an increment on the count
and again check the condition with the
updated value of the count which will
say 3 less than 10 now similarly print
the value increment check this will
continue to happen till this particular
condition becomes false and once this
condition is false it will exit out of
this whole do while loop and it will go
to the line number 12 and if you have
any statement written there you can uh
that statement will be executed in this
case so let's try to change some values
here and let's see if if if we can make
sense of this program if it change the
value let's say if I put 11 here what
will happen now let's run this program
you will say the now you will see that
this particular output is displ played
which says count is 11 so what happened
here that count was 11 it entered the
dovile block it went to this particular
statement which said count is 11 then it
incremented the value so the value
became 12 and obviously 12 is not less
than 10 so it did not print it again it
only printed once even if the first time
the condition was checked the first
condition execution itself resulted in
false still line number nine got success
sucessfully printed and that's the whole
that's the whole idea behind using the
do while what if I change this value to
10 let's see what happens and after that
we'll run one more combination to just
make it more interesting This Time Again
count is 10 line number 10 will be
printed as count is 10 then at line
number 10 the count is incremented to 11
and 11 is not less than 10 so in this
case the loop ends and it will move out
now what happens if I do this if I say
less than equal to here let's run this
program and interpret the output now
again only one statement is printed
because in this case the count is 10 10
is printed here and we are saying 10 + 1
11 11 is still not less than equal to 10
and that's why the loop just exits let's
make it nine and see what happens now
you see two values so count is nine it
enters the dowi loop goes to statement
number nine prints the current value of
count which is N9 then increments the
value to 10 then at line number 11 this
V statement is executed and the
condition is checked is 10 less than
equal to 10 yes 10 is not less than but
10 is equal to 10 so this condition will
hold true it will go back here print
count is 10 make count 11 again check
the condition is 11 less than equal to
10 no it's not and then the condition
will return to false and loop will be
exited so hope this will give you a
better understanding now since we ran
different permutations and combinations
of the values and we saw when this will
be executed and when this will not be
executed but the bottom line is very
straightforward that whenever you want
to write some pre-processing logic even
before checking the very first condition
of your Loop then in that case you will
be using a do while loop otherwise a
normal while loop or a for Loop will
absolutely work fine so that's the take
of I would like you to take away from
this particular session and that's all
for this particular session we talked
about do while and we also Tred to give
you some sort of a comparison between
while loops and do while Loops in the
next session we are going to be
discussing about for Loops in detail
let's get started with understanding the
loop statements in Java so first of all
understand why do we need Loop
statements so generally whenever you are
dealing with some data structure
structures in Java which can store
multiple elements for example we saw
array which can store multiple elements
string is also basically technically a
character array which is storing
multiple characters so whenever you have
these kind of data structures where you
have multiple elements being stored in
the same then in that case you would
like to have a way to iterate or access
all of the elements in a seamless
fashion one of the ways is to access
them individually one by one but that's
too much of work that's too much of code
there has to be a simpler way of
accessing all the elements one by one if
I want to and that's where the majority
of the use cases for using Loops coming
to picture now Java provides multiple
constructs to write Loops in Java there
is a while loop there is a do while loop
there is a for Loop there is also an
enhanced for Loop and in the previous
versions of java a use case of iterator
was was also very popular so there are
multiple ways in which you can actually
iterate over a collection and access all
the elements of the collection one by
one and you can use it to multiple
useful cases for example if you have a
huge array of employee salary and you
want to give bonus to each of the
employees and add the bonus to the
salary then you need to do this addition
for all the employees it would be nice
to have to return a while loop and the
while loop can automatically access all
the employees salary one by one and keep
adding the bonus to the salary this
would be an easier way to do this rather
than individually updating each employee
salary and the first Loop statement we
are going to understand is a while loop
so the syntax of while loop is very
straightforward you write the while
keyword you enter the actual condition
which will be evaluating to a Boolean
true or false so you write the
expression which will be a Boolean
expression exactly similar to the
condition
which you use to write in your if
statements so you write your condition
which will evaluate to either true or
false and then you write your statement
and these statements will keep executing
till the time this particular expression
evaluates to true so generally the way
it works is that it will enter the while
block it will evaluate the expression if
the expression becomes true then the
statements inside this particular while
block will be executed and after the uh
execution of the statement it will again
go back again evaluate the expression we
call them steps basically so it will go
to the next step again evaluate the
expression if this again if this still
holds true it will again go inside
execute the statement move on to the
next step it will again go to the
evaluation so this this Loop will
continue to go till the time this
condition will hold true if it still
doesn't make sense for you don't worry
we will have a demo of it to make you
understand how to use the V loops and
maybe it's a good idea to switch to the
IDE and look at an example of it so I
have already created V demo for it here
it is it looks very small and simple but
it will get to the point where we can
understand how and why we'll be we'll be
using the while Loops so I've created a
v demo class I've added a public static
void main method here which is the entry
point I have declared a variable which
is int count equal to 1 so the count
values one right now and then I'm
writing a condition here I'm saying
while count is less than 10 do this so
it will print the current value of count
and after that I'm using the post
increment unary operator if you remember
we covered this in the previous sessions
what is the meaning of this it basically
will increment the value of count by one
this expression is is equivalent to if I
write it in this way if I write count
equal to count + 1 this is exactly the
same as this no difference so this will
have the same impact I will just remove
this line because we already have have
the count Plus+ here so if we try to
understand this we are basically
incrementing the count and then checking
the condition again so at first time it
will be 1 less than 10 yes that is true
it will go inside and print the count
value the current count value which will
be one and then it does count Plus+ so
now the count value becomes two it will
again go back here again check the
condition saying is 2 less than 10 yes
that is true so the while condition
again becomes true it will again go
inside this print the current value of
count which is two then do count Plus+
so it will again increment the value of
count so the now the count value becomes
three again go back here at condition
and saying is 3 less than 10 yes that is
still true again come here print the
three again go here make count as four 4
less than 10 prints four again count
Plus+ count becomes five and so on so
forth it will keep doing that till the
value becomes 10 so at a step when count
Plus+ results in the count value being
updated to 10 it will go here and say is
10 less than 10 now that is not true
because 10 is equal to 10 but 10 is not
less than 10 so this condition will
become false and it will exit of this y
Loop and it will come here and it will
execute if there's if there was anything
written after the while loop that will
be executed so that's the idea that you
want to do something till a particular
condition holds true then you can use
the while loop Define your condition and
execute the statements and try try to do
something which changes the state of
this condition here I'm changing the
count so that every time a new
evaluation happens if I comment this
this will result in an infinite Loop
because 1 will always be less than 10 I
will not be incrementing the count here
and it will keep running forever it will
never stop it will just keep printing
one one one every time till your
computer program runs out of the memory
so always remember not to end up into an
infinite Loop that's probably one of the
biggest mistakes any beginner programmer
does so please try to be aware of that
particular loophole not try to run an
infinite Loop always try to write
something in the code block which can
change the state of the condition and
also make sure that that state condition
sometimes sometime should become false
you should also make sure that that that
always becomes false because if I do
this if I do this then this condition
will always remain true because it is
already one then it will become zero
then it will become minus 1 - 2 - 3 so
on so forth but that value of count will
forever be less than 10 and again you
will never be able to exit this Loop
your program will be stuck in this Loop
till your program runs out of the memory
so always remember to write a a
statement or a statement of execution in
your in your code block which can change
the state of the condition which results
in some eventual time when this
condition becomes false this condition
has to become false eventually otherwise
you will never come out of the loop
always remember that so if we run this
program now let's observe the output so
we can see here this particular
statement is printed for 1 2 3 4 5 6 7 8
9 and that's it after 9 the moment the
count Plus+ resulted into the count
value becoming 10 it checked that
condition and then it just came out of
the loop because 10 is not less than 10
and the condition became false so always
do something inside your code block
which results at least of one scenario
where this condition becomes false and
that is how you can use the while loop
now you can see this is a pretty generic
code and you can write any kind of
condition here write any code you want
to execute here and then do something to
change the state of the condition as
well in a positive way in a way which
results this particular condition to be
false at some point of time and then
your while loop will run fine so this is
all I wanted to cover in terms of the
while loop we have lot of more exciting
stuff coming in in terms of different
loops and in the next session we are
going to understand how a dowi loop
Works let's get started with for Loops
in Java so so far we covered about while
loops and do while loops and we also saw
different examples of using different
types of data structures like arrays but
one of the core requirements whenever
you are working with any kind of
collection is to iterate over it exactly
similar to what I explain explained in
the do while and while lectures that you
would often require to iterate over a
collection or a data structure and for
that one of the most sophisticated and
easiest way to do that is using for
Loops so let's understand the syntax of
for Loop first and then we will also
look at an example of it in the in the
Eclipse IDE so I have just opened the
official Java docs here so if you see
this is basically the syntax of a for
Loop statement so let's understand it
and let's also try to compare it with a
Y Loop so that we can understand how it
Compares with the while loop so if we
see the syntax we first see the term
initialization then we see the term
termination and then we see the term
called increment now if I try to compare
it with a Y Loop there also you
basically did these three things you
first initialized a variable outside the
while loop gr which is called
initialization and then you wrote a
condition which is your termination
condition you wrote a condition saying
let's say while I is greater than 10 or
while I is less than 10 so that is the
condition which is also the termination
statement the loop will continue to
execute till that condition evaluates to
false and that's when the loop
terminates that's why we call it as
termination and then the third piece of
it is the the increment the i++ which we
used to do in the while Loops so these
three portions together make or
constitute any kind of loop in any kind
of programming language and for Loop if
you see the the kind of code which you
use to write in a while loop in multiple
lines where you first initialize a
variable then you write a condition in
the while block and then inside the
while block you use to increment the
variable all of that can be done in a
single line in the for Loop and that's
why I said it it is the most
sophisticated and easiest way to write
Loops in Java so you write all of these
three things the initialization the
condition and the increment or decrement
values in the single line and then you
start with the curly braces and you
write the code which you want to keep
executing till the condition evaluates
to false that's the basic syntax of it
so let us try to understand this with
the help of an example so here I have
opened a class which is called for demo
and this is a class which will
demonstrate the usage of a for Loop so
again we have a public static void main
method which you can see here which is
the entry point and then I use the
keyword for I put standard braces or the
brackets and then I do the
initialization so this part is the
initialization part you initialize the
variable so I just say in I equal to 1
initialization done you end it with a
semicolon so that it is a single state
treatment understood by Java and then
you write this condition which is your
evaluation / termination condition so
this condition is basically the the
deciding factor of how long your Loops
should run it's exactly similar to what
you used to write in the while block if
I just show you the example this is what
we used to do so we did the
initialization at line number seven then
we wrote this termination condition
inside the while uh syntax or the
construct and then we did the increment
here so we are doing all of these three
steps but we are doing it in a single
line so this is our condition and then
we write our increment or decrement uh
values which are going to change the uh
evaluation condition every time at every
step so we are saying i++ so technically
what I am saying here is that start with
i equal to 1 and then check the
condition I less than 10 so in the in
the first step it will be checking if
one is less than 10 if the condition
holds true go inside the for Loop
execute the statement at line number
seven and then go back to this
particular statement so we do i++ so I
becomes two and then you again go back
to the condition and again you check if
2 is less than 10 yes it is so again you
go inside inside the for Loop and do
whatever is written there there can be
multiple statements here for now I have
just written one system.out.println so
that happens and once all the execution
is finished inside the block it will
again go back to the increment does the
increment so 2 + 1 becomes 3 again does
the evaluation exe and if the if the
condition holds true it will again go
inside so this will continue this
condition checking execution and
increment will continue till the time
this condition holds true the moment
this condition becomes false the control
will come out at line number nine so
that's the basic anatomy and control
flow it's very important to understand
the control flow of a for Loop otherwise
you might end up into a program which is
forever running and which will just eat
up all the memory available in your jvm
so be very sure of what you write in
your for Loop be very sure of especially
these two parts the condition and the
increment or decrement so this is very
important piece the initialization
happens only once and then this
condition evaluates if the condition
holds to True some code executes goes
back to the changing statement which can
be an increment decrement whatever and
again compares the updated value with a
condition so this will keep happening
let's run this code to interpret the
output so I will right click go to run
as Java application and if I interpret
the output here I can see that it
started with count is 1 2 3 4 5 6 7 8
and 9 it stopped at 9 so what happened
there let's try to evaluate the
termination condition so let's say I has
become 9 and 9 is less than 10 so it
goes inside and it prints count is 9
which is I then it goes here and it says
9 + 1 I ++ means 9 + 1 the current value
of 5 + 1 it becomes 10 and then it again
compares the condition so now 10 is not
less than 10 10 is equal to 10 but it is
not less than 10 so the condition
becomes false and count is 10 is never
printed because this condition has
become false it will jump out so let's
say if I do this if I put an equal to
here and if I now execute the same
program this time I will see 10 here and
because I have said that okay check the
condition if 10 is less than equal to 10
that will become true it will print
count is 10 then it will increment and
the count will become 11 the I will
become 11 and then it will check 11 is
less than equal to 10 no it is not so
condition becomes false and the control
comes out of the loop so that's how you
should always try to interpret the loops
you can also run some infinite Loops for
example if I say I = to 1 I leave it
that and I say IUS minus so what happens
I = to 1 1 is less than 10 yes it goes
here prints the value and then I
decrement the value I don't increment
the value I decrement the value so
whatever value comes out will always be
less than 10 and this Loop will run
forever for fun let's try to run this
and I will I will you have to kill this
program manually but just to show you
what happens and what you should not do
in your in your Java program so you see
it will continuously keep printing the
values till the program runs out of
memory till it eats up all the available
memory it is it is forever running it
will never stop because the condition
will never remain never never evaluate
to false this condition will forever be
true so the loop will run forever so I'm
just going to kill the program but this
is something which you should avoid
whenever you are writing Java code and
this happens quite often with beginner
programmers so this is all I wanted to
cover in today's session we talked in
detail about the for Loop and in the
next session we are going to talk about
another interesting way of writing for
Loops which is also called enhanced for
Loops accelerate your career as a
software developer through this
post-graduate program in fullstack web
development course in collaboration with
kch ctme let's get started with enhanced
for Loops in Java so we we covered about
the for loops and the structure of it
and the control flow of it in the
previous session and today we are just
going to talk about another way of
writing for Loops which is a bit even
more smarter than the traditional for
Loops which we call as enhanced for
Loops we generally use the enhanced for
Loops for scenarios whenever we have to
iterate over a collection of items or an
array of items those are the most
popular and common use cases of using
enhanced for Loop and this for Loop is
even simpler like I said it's even
simpler than writing a classic for Loop
and the syntax is simply like this you
again start with for put the standard
brackets and then let's start from the
rightmost because then I I will be able
to explain it better you specify the
collection in the rightmost side of the
bracket The Collection can be an array
it can be a list it can be a map so
whatever different kind of collections
which are available in Java and we are
going to cover collections in detail so
don't worry if you don't understand what
are lists and what are maps and what are
sets we will go into detail of each of
these one by one in the upcoming
sessions but the idea is that you put
the collection to the rightmost then you
put a colon and then you put a
representation of the member of this
collection so for example here this
numbers is basically an INT array so
this int array means that this array Can
Only Hold integer numbers and that's why
we write in here because this array is
only having integers then we put any
placeholder variable name this can be
anything you can even write it as I if
you want to you can write it as anything
any variable name which you want to
write this is a temporary variable so
now this code is going to execute in a
manner that it is going to iterate over
this array one by one one starting from
the first element going till the last
element you don't need to write any
initialization code you don't need to
write any termination condition code and
you don't need to write any increment or
decrement code also and how these thre
how these three values are actually
taken care of let's understand that as
well so when we talk about the
initialization as I have put an array
here a data structure here the automatic
initialization index IND is going to be
the first index so when we do the
iteration when this for Loop is going to
execute it is automatically going to
initialize a temporary variable with the
value at the first index which is the
index zero as you know that array is a
zero index based structure then comes
the condition part so the condition
evaluation is going to be again based on
the size of the array or the size of the
data structure which you're using it is
going to start from the first index
which is the index zero and it is going
to iterate till the arrays last element
is reached so technically start from the
index zero and go till the last element
that's your evaluation condition and
then comes the increment part so at each
step after it has successfully accessed
the first element automatically the
index is going to be updated to pointing
to the next element so if it starts from
here once the first step iteration is
complete I is automatically going to be
incremented to index one and then it
will basically this I will be holding
two then in the next iteration the same
I is going to be holding three similarly
I will keep holding the new value of the
collection item one by one till the
collection items last element is reached
so this is the basic premise that you
can write a collection variable here and
keep iterating over it and this whatever
variable you write here will hold the
current items value one by one so in the
first step this I is going to hold one
in the Second Step this I is going to
hold two in the third step this I is
going to hold three and so on so forth
that's the basic idea so now let's run
this program to see what kind of output
do we get so you can see we we basically
are able to print all the elements of
the array and that's probably one of the
most popular usage as well that if you
want to just print all the elements or
access all the elements of a array or a
collection one by one then just use
enhanced for Loop so you can see at each
step it is printing the value of I and
the value of I is basically the
subsequent elements of the array that's
the whole idea with enhanced for Loop
under the hoods if you talk about how
does it it work under the hood it is
actually using the classic for Loop
construct itself but for developers it
is making it easier because it knows
that if you are iterating over a
collection you will start with the first
element and you will go till the last
element so it knows the initialization
value the termination condition and it
also knows the increment condition and
that's the reason you will use enhanced
for Loops in Java for iterating over
Collections and in the next session we
will be talking about
the nested for Loops concept and we will
be looking at an example of how to
implement nested for loops and when do
we use nested for Loops let's get
started with nested for Loops in Java so
we talked about the while Loops the do
while Loops the classic for Loop also
the enhanced for Loop so now we are
going to look at a variation of the
classic for Loops in a in a condition
where we have to use more than one Loop
in a nested fashion and how do we do
that what are are the use cases when we
use that so in front of you you can see
an example which I have prepared for
nested for loops and in this particular
example I have created a two-dimensional
array as you can see on the line number
six I have created an integer array and
I have put two square brackets here
which are basically symbolizing that
this is a two-dimensional array so this
two dimensional array is going to hold
technically a 2d Matrix and we are going
to use the concept of nested for Loops
to print this 2D array in a 2d Matrix
style where you will be able to see the
rows and columns clearly let's first try
to inter interpret this particular 2D
array so we have a curly braces outside
and then we have these three Inner
Elements which symbolizes three rows
basically so this is the first row this
is the second row and this is the third
row and then each of the rows have three
elements ments each which symbolizes the
column values or the item values so it's
basically a 3 into 3 2D array which has
three rows and three columns so so we
can say that this is basically a 3 into
three array which has three dimensions
on the row side and three dimensions on
the column side or just a 3X3 Matrix or
3x3 2D array so as we know that in case
of arrays everything starts from zero
so technically if we talk about the
indexes it would be the index 0o index
one and index 2 on the row side and
similarly index0 index one and index 2
on the column side so that's that's
something which you should remember
because that we are going to use this
particular concept when we write the for
Loop so let's try to write the for Loop
now if you look at line number eight we
put this keyword called for and then we
write the initialization so we say int I
equal to0 then we are writing the
termination condition and we are saying
R run this particular Loop run this
whole Loop which ends at line 13 till I
is less than three and keep incrementing
I at every step that's what I'm doing in
the line number eight then inside the
for Loop I'm writing another for Loop
which has another different variable
called J it can be anything you can name
it anything you want and this also
starts with zero and this also has a
similar condition which is which says
run this particular Loop the line 10
basically or this Loop which is
signified by this curly braces run this
particular Loop till the time the value
of J is less than three and keep
incrementing J at every step and at line
number 10 print the element of array
which has the current value of I and the
current value of J these are basically
the positions these are not the elements
the element would be represented by this
whole but print the element which is at
current I and J's position values that's
what this code means so let's try to do
a dry run on this particular code to
understand how this is going to work so
at first we have I equal to 0 0 is less
than three and it goes inside it
initializes J as well with Zer and J is
0 is also less than three so this
condition went true that's why we went
to line number nine and line number nine
condition also went to true so we went
to line number 10 remember that in this
particular case at line number 10 the
values of I and J are 0 and 0
respectively and we are saying print the
array of 0 and 0 so zeroth rows zeroth
column element should be printed so this
is the zeroth row because this is the
first uh first subblock and this is the
first element so in this case in line
number 10 two should get print printed
then it goes here and it increments the
J to 1 so 0 + 1 becomes 1 it again
checks the condition is 1 less than
three so yes 1 is less than three it
goes here remember it did not go up at
line number eight it just came back from
line number nine so when it comes here I
is still zero but J has moved from 0 to
1 so now we are trying to access the
element which is at zeroth row First
Column which is going to be seven so 7
is going to get printed similarly on the
next iteration J is going to get
incremented from 1 to 2 and again the
condition will be evaluated so 2 is less
than three all good it will again come
back to line number 10 and now it will
say print the value of zero Row third or
the second column or the third element
so zeroth Row Third element which is the
9 so 9 will get printed then again J
will be incremented and J will become 3
2 + 1 1 3 and now the condition will be
evaluated is 3 less than three no it is
not less than three the condition
becomes false so it breaks out of the
loop goes to line number 12 prints an
empty line because we are not writing
anything here so it will just print a
blank line and now it will go back to
line number 8's condition and it will do
an increment of I and now I will move
from 0 to 1 and now the evaluation will
happen is 1 Less Than 3 yes 1 is is less
than three so it will again go to line
number n again initialize J with a fresh
zero the previous J got destroyed the
moment you came out of the loop so this
is a new J so this J again gets
initialized to 0o 0 is less than three
it goes here remember I was one in this
time so now it will print the value of
this 2D array which is sitting at 1
comma 0o basically second row first
element so second row first element
which is three again J is going going to
get incremented and it will become from
0 to 1 so 1 is less than three yes it
will again come here and it will print
the value of the array which is sitting
at array of 1 comma 1 for row equal to 1
and column equal to 1 which will be six
similarly J will get incremented again
again 2 is less than three come back
here we'll print one then again we'll
increment J J will become three 3 is
less than three no it's false the
condition is false so it jumps out of
the loop goes to line number 12 prints a
blank line again goes back to 8 line
number 8 increments I and I now becomes
2 2 is less than three yes it will again
go here initialize J again with zero and
again does the same thing for the row
two and column 012 and again it will
come out of the loop this time again
when it will go here the value will
become from 2 to 3 and 3 is not less
than three so then it will break out of
the outer loop so the idea is execute
the inner loop for every value of the
outer loop remember this line because
that is how you will be applying your
knowledge of nested for Loops to be used
in certain condition so whenever you
have a scenario where you have to
iterate over a collection based on a
certain value of another collection then
you can use nested for Loops or you have
a scenario where you have to iterate
over 2D or 3D arrays for example if we
were dealing with 3D arrays then you
would have seen three nested for Loops
here and where it will apply the same
logic that iterate over all the
collections all the values of the inner
loop on a particular value of the outer
loop then increment the value of the
outer loop and do the same thing again
iterate over all the values of the inner
loop based on a fixed value of the outer
loop so let's run this program and let's
see what kind of output do we get so
like I said our our motive our Target
was to print this in a in a metric style
and you can see that it is printing in
in a sort of a matrix representation so
the first row gets printed here then the
second row gets printed here and then
the third row gets printed here if you
try to decipher it it will work exactly
the same way as I explained so I equal
to 0 0 Less Than 3 condition becomes
true comes here J equal to 0 J Less Than
3 condition becomes true comes here
prints the array of 0a 0 which is two
then prints the array of 0a 1 which is 7
0a 2 which is 9 then J becomes three it
breaks out of the loop goes up here I
becomes from 0 to 1 1 is less than 3 Yes
again comes here reinitializes a fresh
for loop with a new J setting to zero
and it will it will print the array of 1
0 1 1 1 2 then similarly array of two 0
2 1 22 so that's basically what we are
doing we are iterating we are picking
the first row and iterating all elements
of it picking the second row iterating
all all elements over it and so on so
forth you can do this for any end
dimensional kind of array or a
collection so this is all I wanted to
cover in today's session where we
discussed about the nested for Loops
concept and how and where we will use it
and in the next session we will be
discussing about the Java Collections
framework let's get started with
collections in Java or the collections
framework in Java I must say that this
is probably the most important concept
of the Java programming language which
you will be using heavily whenever you
are working in any production grid
application so let's understand the
collections framework and the different
classes and the utilities available
inside the collections framework this is
going to be a theoretical lecture
because there is a lot of ground to
cover in this lecture so so we will only
focus on understanding the relationship
between the classes why those classes
are created because each class has a
different purpose in this framework and
we will obviously talk about the
hierarchy as well in the upcoming
sessions we will go into the Hands-On
exercise of some of the most popular
collections we will not be able to
provide Hands-On of all the collections
classes which you which you can see on
the screen because then it is going to
take a very very long time to complete
this concept but we will cover the most
popular ones or the most used ones out
of this particular framework so let's
get started as you can see let's first
understand some of the symbols here and
let me just zoom this in a bit so that
it's visible yep now the I have just
increased the resolution a bit so you
can see there are three different
symbols or Legends here you see this
oval shape which is called interface so
you can see some interfaces here then
you see this uh rectangular blue box
which is called abstract class and you
can see some of these blue boxes and
then you see the purple box which is
called the class and you see some
classes here these ones so for now we
are currently we haven't covered the
concept of interfaces and Abstract
classes but we will cover that in the
coming lectures and for understanding
the collections hierarchy right now the
at least the concepts of it you don't
need to be fully aware of the concept of
interfaces or abstract classes so let's
dive deeper into the framework it Trel
is basically an interface uh to to give
you a very simple definition of an
interface interface basically is sort of
a declaration which will tell you what
kind of classes will be present under
the interface for example if you have to
let's say store all the cars and all the
bikes and all the bicycles and all the
trucks from all around the world then
you can create an interface called
vehicle and create all of these classes
under the interface and these classes
will be about cars about trucks and
about other kind of vehicles so an
interface is a generic blueprint of
specific class implementation that's a
very simple definition of an interface
and like I said we will go deeper into
this concept in the upcoming lectures so
that was about interfaces similarly when
we talk about abstract classes the next
Legend here abstract classes are also
similar to interfaces where they provide
you a generalization but at the same
time abstract classes provide you a way
to also write some concrete
implementation for example if we take
the example of a bank account so there
in a bank you have different kinds of
accounts you have savings accounts you
have recurring accounts you have current
accounts and there are many other
different types of accounts so there
would be some common implementation and
logic which will be applicable to all
the account types for example an account
must have an account holder that account
holder must have a valid kyc done for
example so there would be some sort of
common logic which will be applicable to
all of these right so that common logic
so you have two options either you can
write that common logic again and again
in the savings account class in the
current account class in the loan
account class etc etc or you can write
it at a central place and just refer it
from there so that's where you will you
will use abstract classes so you will
create an abstract class of an account
and then you will create these child
classes under this account class which
will be the savings account class The
Loan account class the current account
class Etc so this is a very lightening
introduction to you about interfaces and
Abstract classes and class as we know is
basically a concrete blueprint which
holds data and logic together so here it
Trel is an interface which will just
specify that all the kinds of data
structure which can be iterated which
can be looped over should be present
under this particular interface that's
why we created this interface so under
it trable we have this collections
interface and this will govern that
everything which will present under the
collection interface will be holding
some sort of a collection of items now
we look at the next set of interfaces we
see a set interface we see a list
interface and we see a q interface when
we talk about the set interface these
three different types of interfaces
represent three different properties of
collection and these properties are
exclusive of each other for example if
we talk about set so set has a property
that everything which you put into set
will be unique it will never ever
tolerate or contain any duplicate
elements that's the property of set so
now you can see whenever you have a
scenario where there is a strict
constraint that your collection should
never have duplicates you will use sets
when we talk about lists list is
probably the most lenient representation
of a collection it can store anything it
can store duplicates as well it will not
raise an error or a warning if you store
same element multiple times it will
happily store it but at the same time
the list is basically an index based
collection you can access the elements
starting from the index zero till the
last element that's the basic value
proposition so whenever you have a
requirement where you want to access the
elements into a predefined sequence and
one by one then you should use list also
the order is fixed here the first
element will always come after the
zeroth element the second ele element
will always come after the first element
so whenever you iterate over this
particular list you will never have a
scenario where you do not know the order
of the elements being accessed they will
always be accessed in a predefined order
so it's basically we can call it as an
indexed ordered collection which can
hold duplicates then the third one is Q
here so Q is basically as you can this
is basically inspired from Real World so
think of any Q if you if you go to buy
something at a grocery store or if you
go to buy a ticket at a at a railway
station or you go to the checking
counter at the airports so you stand in
a queue and the concept of queue is that
it works on a concept of first in first
out the person who first went into the
queue will be the person first being
served and coming out of the queue and
if the second person come that has to be
standing behind the first person and
once the first person is served and and
goes out of the queue the second person
comes at the front of the queue and that
that particular person is served so you
can see it's if you have to store that
kind of behavior or if you have to
implement that kind of behavior in a
Java program then you would use Q's so
so this was about the top level
interfaces which are set list and Q and
out of these list and set are very very
popularly used very heavily used in any
kind of java Enterprise grid application
now there are more interfaces like
sorted set navigable set and DQ sorted
set is basically forcing additional
constraint on the set that the elements
will be unique at the same time you can
also have the elements into a sorted
order that sorting can be an incremental
sorting or decremental sorting that
depends but the whole idea is that it
will be sorted similarly navigable set
brings another navigation kind kind of
properties DQ is basically a
double-ended Q where the elements can be
inserted and removed both from the front
and from the back so there are the
different properties of these interfaces
but like I said the most popular ones
are these three ones now let's talk
about the abstract classes so the
abstract classes you see here are
abstract collection abstract set
abstract list abstract Q abstract
sequential list generally you will not
be using these directly you don't need
to use them directly but you should be
aware that they exist if you have a very
specific case where you want to use
these abstract classes you can use them
in Java program but most of the time you
don't need to use them and most of the
times you will be dealing with either
the interfaces or you will be dealing
with the concrete classes now this
lecture is is getting a bit long so I
will like to stop this lecture here so
we covered about the interfaces part of
the collection and we ALS also
understood a bit about the abstract
classes though we are not going to use
abstract classes in much detail in the
programs in the next session we will
cover the second part of this collection
framework or the remaining part of this
collections framework which is around
the classes let's get started with
discussing the concrete classes in the
collections framework in the previous
session we talked about the interfaces
part of it where we discussed about sets
the lists and the cues and we also Alo
touched a bit upon the abstract classes
and like I mentioned earlier you don't
need to generally use these abstract
classes directly in your Java program
but you must be aware that they exist
you see some arrows here right if you
see if I just scroll up you see multiple
kind of arrows here these arrows mean
that if the arrow goes from bottom to
top it means this particular element is
a type of the parent it's basically a
denoting a parent child kind of
relationship so for example here you see
tree set is basically a navigable set
and also extend extends abstract set
which extends set so similarly you can
see all kind of complex relationships
here and generally you don't need to
remember all of those you only need to
remember the few and those few are
basically easily can be spotted for
example whenever you see a tree set it
means it's basically a type of set
whenever you see a word called list that
means that it is a type of list and you
all whenever you see a word called Q
then it means that it is a type of Q so
let's understand these classes let's
first go to the list interface so you
can see list interface has the
relationship with abstract list and from
there it goes down to array list
abstract list has another child which is
called abstract sequential list which is
another abstract class and which has a
concrete class which is called link list
so let's understand these two
collections or these two uh types of
list right now so when we talk about
array list let's understand this we
already have covered arrays so what are
array lists they are very similar to
arrays in in a way that they are also
indexed based collections so you can
store elements and access them based on
the index position starting from zero
going to till the length minus one uh
index and this is an ordered collection
you can access the elements only in a
pre-defined sequence it can obviously
accept duplicates as well and these all
our properties are also applicable to
arrays the differentiating factor here
is that array list is a dynamic array
it's not a static array if you remember
when we talked about arrays we had to
initialize it or we had to specify a
fixed size of it while we initialize it
once you have initialized the array size
you cannot change the array size it is
static it is fixed so if you have
created an array of elements 10 and if
you're trying to store the 11th element
you are going to get an array of array
index bound of exception but in case of
array List It dynamically updates its
size based on the number of elements
stored you can still initialize it with
some some initial size let's say you
initialize an array list and you say
that you want to initialize it with a
size of 10 elements absolutely fine but
the moment you you try to store the 11th
element array list is going to
dynamically update its size from 10 to
something else so it will keep updating
its size based on the number number of
elements which are coming to the
collection that's the whole property of
array list so remember it's it's used in
the cases when you have an ordered
collection to store and you want to
access them based on the index and you
want a dynamic update of the size the
second sibling of it which is link list
is also a type of list but it has
slightly different properties than array
list in case of array list it was an
index based collection you access the
element based on the indexes but in link
list you access the elements based on
the previous and the next element that's
pretty much what it knows so an item can
only be accessed in a particular
sequence starting from head to the tail
and and when we talk about link list the
idea is that you have an element which
will have a data and it will also have a
pointer or a basically a reference that
reference will be pointing to the next
element in the link list similarly the
next element will store the value the
actual data and it will also store a
reference to the next element so you can
see if you have to go to The Fifth
Element you cannot directly say link
list of five the way you can say this in
Array list because array list is is an
index space position list right so you
can access the zeroth element or the
fifth element or the 10th element
directly just in one line or one go but
in case of Link list you cannot access
the fifth element or the last element of
the link list directly you have to start
from the first element and keep jumping
the references till you reach the last
element that's the property of Link list
so these are the two types of list now
let's talk about the type of set set a
type of set which is not mentioned here
is Hash set which is a very popular type
so a set generally has two popular types
hash set and preset so let's talk about
both of those if I talk about hash set
the property is that it will inherit the
existing properties of set which is that
element should be unique that's good but
along with that hash set will not
remember or honor the order in which the
elements are inserted into it it will if
let's say if you insert 15 or 20
different elements inside hash set and
then if you try to iterate over the hash
set every time the order in which the
elements are accessed and printed will
be different every time the order of
accession will be different every time
the the way in which the elements are
accessed their order will be different
you you cannot predict that and that's
the property of hash set whereas when we
talk about Treet in case of Treet set
you can have a sort of fixed order and a
tree hierarchy so a tree hierarchy if
you know about the tree data structure
from the data structure in algorithm
section you already would know what a
tree looks like basically it has a root
and it has child this is basically you
can call this a tree as well right so
whenever you have to store the values in
a in a tree fashion where you can
navigate through the parent and child's
then you would use the Tre set and
remember since it is a set it will still
inh init the uniqueness property of set
so that's about hash set and Treet so we
covered about list we covered about sets
now let's talk about these ones which
are vector stack and priority Q so let's
first understand about priority Q so you
would use a priority Q when you need a
fifo Arrangement but at the same time if
there are few elements in the queue
which cannot wait to be executed or
processed when their turn comes they
wanted to be executed on priority so
whenever you have such use case where
you want to to maintain a fif fashion
collection but at the same time you also
want to allow few elements of it to
override this fif Arrangement and get
processed ahead of their Q number so you
can use priority Q in those cases
talking about stack let's understand
stack first and stack is a Leo
Arrangement last in first out
so remember in your house when you when
you put plates uh the the normal dinner
plates over one one over each other
you're basically creating a stack so the
property is that the plate which is put
first on the table will be picked up at
the very last and the plate which is put
the last on the stack let's say you put
five plates on top of one one on top of
other then the fifth plate will be
consumed first anybody would pick the
plate from the very top they will not
pick the bottom plate because it's it's
almost impossible if you have a big
stack you cannot pull out the bottommost
plate the stack will fall down so you
will always pick out the elements from
the top so it has a leao Arrangement so
whenever you have to create a last in
first out kind of arrangement in your
program for storing collections you will
use stack talking about vectors vectors
are very similar to lists they're
exactly similar there is basically one
major difference is is that vectors are
thread safe and lists are not thread
safe Now list has provided a way to be
thread safe we will cover that later but
for now you can understand that whenever
you have a program in which you want to
access a collection in a thread safe
manner where two threads cannot modify
the same element at the same time then
you will use vectors so we covered about
the complete collections framework
classes the interfaces and the abstract
classes and always remember the uh the
reason why you will use array list or
link list or a hashset or a Treet or a
vector or a priority Q or a stack that
is the most important concept I want you
to take away from this session let's get
started with array lists in Java so when
we talk about AR list we are technically
talking about a list in the previous
session I covered in detail about the
various implementation of list interface
which were AR list and Link list and in
today's session session we'll be
focusing only on the AR list I have
opened the API documentation of the AR
list class so if we just scroll down we
will see a nice description which is
provided by Java and it broadly covers
all the points which I described in the
previous session which were that an
array list is basically an array based
implementation of a list it's an index
based implementation so you can access
the elements based on their index
position you can direct ly access any
element if you know its index it accepts
any kind of duplicates as well and by
default it is not thread safe if two
threads are trying to access the same
collection at the same time or maybe
trying to modify the collection then you
will get inconsistent Behavior so that
was about the basic description of AR
list there are it provides a lot of
interesting utility methods as well for
adding elements for adding multiple
elements for removing elements for
fetching ing an element from the arror
list and we will cover those methods in
detail in the demo and with that maybe
let's switch to the demo so for this I
have created a class which is called
array list demo it has a public static
void main method and it has an array
list example written inside it so at
line number 10 you see that there's an
initialization happening for the err
list and this is how you basically
initialize the ARR list to start with
you write the interface name you can
obviously write AR list as well here
instead of list you can write AR list
that is absolutely acceptable but the
reason I have written list here is
because it is a better practice or I
would say it is a best practice to
always initialize the concrete
implementations with the interface type
I'm making a very generic statement
which is applicable to collections and
at any other type of classes and objects
you might be creating in your program
always try to declare it with the type
of inter interace and then Define the
concrete implementation on the right
hand side so the LHS or the left hand
side will contain the interface
declaration and the right hand side will
contain the concrete implementation the
reason for this is that if tomorrow if
you have to change the representation of
this arror list to let's say a link list
then you don't need to do a lot of work
because the link list is also a child of
the list interface so since list
understands and knows about both of the
classes you can interchangeably use this
reference to point to any of those
implementations that's why it is
considered a best practice to basically
write the left hand side as the
interface and the right hand side as the
concrete implementation that's the first
bit of it second interesting thing you
notice is this so you see these
Expressions here and this basically
encloses any kind of generics or class
typ type what are generics we will cover
this in detail in the upcoming sessions
for now what you can understand and what
you should know that these are denoting
a class type of which the objects will
be stored inside this particular list so
once I say list of integer it means that
this particular list is only going to
hold integer objects if you try to
insert a string object or if you try to
insert a character object or if you try
to insert a float object or any kind of
object it will create an error because
remember in the very first lecture we
said that Java is strongly typed
language it has very strong checks for
these kind of data type mismatch so if
that's why it will expect you to specify
the object type here and whatever type
you have specified here that's the kind
of objects which are going to be stored
inside this list I have been using these
terms called classes and objects inter
interchangeably but for now what you can
understand that this is a type how we
how we write classes and how we write
objects and how we create objects again
I will cover this in detail in the
upcoming sessions so we have specified
the list interface and I'm saying that
this particular variable should hold any
list of integer type then on the right
hand side I'm specifying what type of
list this array list is and this array
list will be an array list Class Type
and again I have to specify the Class
Type specifications and then I'm
specifying a size here this is the size
of the err list the initial size of the
error list you can obviously write it
without this as well this is also a
perfectly fine statement in Java and in
this case the array list is going to be
initialized with its default size if you
specify a value then the array list will
be initialized with only that size it is
also considered a best practice to
always initialize the AR list with a
some known initial value let's say if
this s list is going to store only two
elements and the default size is
definitely way way bigger than two
elements then you're going to waste lot
of memories so that's why it is a best
practice to specify explicitly specify
some sort of an initial size this is
also acceptable because it is
automatically inferring the type from
the Declaration you don't need to
specify it again here in fact some of
these modern Ides will also show you a
warning if you write it here so the next
thing I'm going to do is basically going
to add some elements to this array list
so I've created an array list which
should hold only integer values and it
should hold to start with five values
but it will not complain if you try to
add the sixth value so for that I have
just written a small Loop here let me
just put curly braces around it for
readability so I'm saying in I equal to
1 I should be less than equal to 5 i++
and I keep doing array list. add so this
add method is the method which is used
to add elements to the array list so
whenever you have to add an element to
the array list remember you need to use
the method add and then specify the
actual element which is supposed to be
added so I'm adding 1 2 3 4 5 in this AR
list one by one using this Loop and then
I'm just printing the whole array list
that's what I'm doing here after that to
Showcase another operation of this array
list I'm removing an element and if you
have to remove an element from ARR list
just simply called ARR list do remove
and specify the index from which you
want to remove the element remember you
need to specify the index and as I said
in the beginning this is an array based
implementation so this is going to start
from zero so when I say remove the
element at index 3 technically it's the
fourth element of the ARR list after
that once we have removed the element
I'm again displaying the modified arror
list and then printing all the elements
of the uh error list one by one and for
for fetching the element if you see here
if you if you observe this particular
for Loop I'm using couple of more
interesting methods of the array list
let's understand those methods as well
and then I will run the program so here
you see that I'm saying I in I equal to
0 and then I'm saying I less than ARR
list do size so if this arror list has a
capacity initial capacity of storing
five elements and I've just added five
elements to it then the ARR list size
will be five but it says less than so it
will start from zero and run till I
equal to 4 because the moment I becomes
five 5 is not less than five and it will
come out of the loop so basically I'm
trying to start this Loop where I I's
value starts from zero and goes till
four and here I'm calling another ARR
list method which is used to fetch an
element from the array list so whenever
you have to get an element from the
array list just call called dog on the
array list so array list.get and I'm
specifying the I value so ARR list.get
of zero get of one get of two get of
three and get of four and that's
technically the five elements which are
stored in this array list so let's run
this program so and now let's observe
the outputs here let me just bring the
outputs down yeah so at first I'm just
printing the arror list so nothing
nothing I'm just adding the elements and
printing the complete arror list so if
you want to just print the whole array
list just put that inside
system.out.print and the whole array
list will be printed that's line 17 then
I remove the element at index 3 so if I
Traverse through this particular list
this is index zero index one index 2 and
index 3 so index 3 has an element which
has a value four and I'm saying ARR list
do remove the element at index 3 so this
particular element should be removed
from this particular list when I call
the line 20 and then if I print the
modified ER list at line 24 I can see
that four is gone now it's only 1 2 3 5
that's the remaining list you also
notice that whenever I call
system.out.print Len with ER list I get
this square brackets which is the
representation of an array list if you
don't want that you might not want that
always right if you want to print this
nicely without the square brackets then
you have to iterate over the array list
and that's what I'm doing here I'm going
from zero to ARR list. size and I'm
doing get of zero get of one get of two
and get of three and that's how I get
these values without four we can also
write the same Loop using for enhanced
Loop so let's say if I write for in I
colon array list and then inside it I
can just say
system.out.print Ln I and if I if I
comment this particular Loop for for a
moment and run this
program I see the values one by one
because it's Ln so every output comes on
on a new line but you can pretty much
see the same output if I remove this and
if I write it like this just adding an
extra space it will look a bit more nice
a bit more formatted like this so as you
can see that we can get the pretty much
the same output either using a classic
for Loop style which is a bit verbose or
you can use an enhanced for Loop which
is a much simpler and shorter and uh
less verbose way of doing exactly the
same thing you don't even need to call
the arror list. get I but I the reason I
put this example because I wanted to
show you the get functionality as well
so that's all we are going to talk about
in this session in the next session we
will be discussing about link list which
is the another implementation of the
list interface let's get started with
link lists in Java in the previous
session we talked about array lists and
today we are going to talk about the
another type of implementation of the
list interface which is called linked
list if you remember from the previous
sessions we discussed about the
properties of the link list and all
those properties are listed here as well
so basic idea is that whenever you want
to have a kind of implementation where
the order of the elements is strictly
maintained where the first element can
refer to the second second element the
second element can refer to the third
element and so on in those kind of cases
you are going to use Link list another
property of Link list is that you cannot
randomly access an element directly as
you as you could do in case of ARR list
in case of arist you just say you just
write arral list.get and you provide the
index location and you get the element
right away that's not possible in link
list in link list if you have to access
the let's say the second last element or
the fifth element in a 10 size element
uh list in that case you have to start
from the head which is the first element
and keep traversing Till The Fifth
Element that's the only way possible to
access the fifth element or any random
element so that's the property of Link
list it is also not synchronized so if
multiple threads are trying to access a
link list concurrently at least one of
the threads and and one of the threads
tries to modify the list then it must be
synchronized externally by some other
ways otherwise you'll get unpredictable
results and again this also provides a
bunch of utility methods and we will
cover some of those methods as you can
see add method for adding an element add
all add first contains get first get
last we will cover some of these methods
in the demonstration which follows this
particular documentation and with that
let's jump to the implementation so I
have prepared an example here for the
link list which is called link list demo
I've just created a class for it and we
have created a public static void main
method here and here you can see at line
number 10 I have declared a link list so
this looks very similar to the way we
declared an arror list you see if you
have noticed on the LHS I have I have
written the concrete class and I've not
written the interface reason being I'm
using some concrete methods and actual
methods which are only available in the
link list class so I am not looking at
the reusability aspect in this
particular example if you are then you
have to add extra code for it but here
I'm just writing link list and again in
this particular link list I'm saying
that I would only store string objects
so that's why inside these braces I
write string and then I say New Link
list string again I have not specified
the size so it will take the default
size as per the jvm implementation now I
have declared my link list and it's time
to add some elements to the link list
for that I have the method add which is
available in this link list class which
will provide me with the capability to
add elements so at line number 12 and
line number 13 I'm adding two elements
and if you remember I told you that it
works in a reference-based
implementation so at first an element a
will be added and when you try to add
element B element A's reference will be
updated to point to B
that's what will happen in this link
list and then at line 14 I'm using
another interesting utility method of
this link list class which says add last
what this method does that specifically
it will add the element at the very end
of the link list so that was about add
last and if I talk about line 15 I'm
using another interesting method of Link
list class which is called add first so
what this will do that this is going to
insert this element D at the very
beginning of this link list like even
before a d will be inserted so whatever
your link list looks like whenever you
call add first that element is going to
be inserted at the very head of the link
list or the very beginning of the link
list link list also provides another
variant of the add method so there's one
way to just add the string element
directly because this is a string link
list you can also add it based on the
position so you can say add e at the
second position inside the link list so
let's observe this output let me comment
all the code below line 18 because we
will be using some more methods here so
we'll cover that in a while but let's
first understand the output at line 18
if we run this program so right click
run as Java application and this is the
output we get so let's understand the
output or maybe let me do this let me
put this here one by one so that we can
interpret the output so I'm adding two
elements and printing the list then
calling add last and printing the new
list then calling add first printing the
new list and then calling list. add two
comma e and printing the list again so
let's observe these outputs one by one
I'll comment this and let's run this now
so if I run this particular program the
program till line 14 is executed because
rest of the code is all commented let me
comment this as well and if I run it
again yes this is the output I get so at
line 12 and 13 I've added two elements
and I print the list there are only two
elements and they're printed in the
fashion a comma B everything is good
here now let's uncomment this code and
now I'm calling add last method and
adding an element with string C which
should be added at the very last of this
particular list so let's see now what
happens let me comment this one so so
that we only see one list at the
output okay we see a comma B comma C so
C has been successfully added to the end
of the list now let's interpret this
particular method which is called add
first so I'm going to uncomment this and
comment the previous sis out so now
there's only one CIS out here so I'm
adding two elements adding C at the last
and now adding D at the very beginning
and printing out the list let's see what
happens okay so the D has been added at
the very beginning of the list even
before a so now it looks like d comma AA
B comma C so far so good now let's move
to this particular code and now I'm
saying add an element called called e at
the second position inside this list
remember second position so let's run
this list now this program now so now I
see D comma a if you remember the
previous output was d a BC if I just
uncomment this for a while just to make
it more clear clearer and if I run this
program the previous list was D comma a
comma B comma C and the new one says d a
e e has been inserted at the position
two so 0 1 2 position two has been added
with this new string e and my list is
modified now it's time to find some
interesting operations about the removal
so what happens if I try to remove
elements from this list and then we will
observe the output again so let's say if
I say list. remove B and so I'm saying
just drop this particular element so you
can directly specify that particular
element's value and that element will be
removed from the list and let's see what
output do I get if I just call list.
remove B and I comment the rest of the
code we should see a new output here
which should not have B so running the
program again yes so this was the old
collection and this is the new
collection from which B is gone because
I've called list. remove remove B now
you can also remove elements based on
the index position instead of specifying
the element explicitly you can specify
the index position and what happens if I
call list. remove 3 Let's observe the
output here as well so I'm just going to
copy paste this is out and we'll see
what output do we get if we remove the
element at third location okay so this
was the previous output after removing B
and if I call list. remove 3 so 0 1 2 3
C is the element which is at third
location and it is gone when I call
list. remove 3 C is gone and D comma a
comma e is only remaining now let's try
to understand this particular line which
says list. remove first expectedly this
is going to remove the element from the
very beginning so whatever element is
present at the beginning it is going to
remove the element and then we are going
to print the list the modified list so
we were here till D AE and D was the
element which was at the beginning and
if I called remove first D is removed
and now only a comma e is available and
now I use another interesting method
which is called list. remove last and
then I print the list the modified list
so this is the list remaining and I'm
calling remove last so e should be
dropped and only a should be left in
this particular list yes we only see a
here so this is basically what I wanted
to show you in this program that we can
perform different kind of operations
using different methods like add add
first add last remove remove first
remove last obviously there are more
interesting methods available in this
particular class do check out the API
documentation for it and there you can
see all the different interesting
methods which you can use while
implementing link list so this is all I
wanted to cover in this particular
session
and in the next session we going to
cover an interesting framework class
which is called set we going to learn
about sets in Java in the next session
let's get started with hash set in Java
if you remember I covered in the
collections framework session that hash
set is part of the set interface
hierarchy and sets have a property that
they keep the collections element unique
if you try to add duplicate elements to
the ass set it will not accept that and
it will still maintain the uniqueness
property of the collection hashset
provides some additional features to the
set which is that in this case the
elements would be accessed in a random
fashion they will not be accessed in a
fixed sequence rather they will be
accessed in a random fashion hence the
name hash set so if you read about this
particular class in the documentation it
will basically cover all the things
which I just described it also accepts
null elements if you want to insert null
but why would you try to insert null
that's the first question which you
should ask it again provides similar
kind of utility methods to the list
interface collection hierarchy we
covered like some utility methods to add
the elements to remove the elements to
check the size of the collection and to
check if an element exists in the
collection or not etc etc and we will
cover some of these methods in the demo
this is again not synchronized so this
is not a thread safe collection which
you should know so let's look at a
demonstration of hashset and how do we
actually create a hashset how do we
operate upon a hash set using different
utility methods so as you can see I have
created a class here which is called
hashset demo there's a public static
void main method and then at line number
10 you will see that I have created the
hash set and again it starts with the
concrete class here which says hash set
and you can obviously write it as set as
well which will also work fine so we
write the set type as string so this
particular set is going to hold only and
only string objects and nothing else and
this set is basically a type of hash set
again this is not mandatory so you can
remove that it will still not complain
and the program will run fine if you
want to specify a size please do that if
you do not want to specify the size
nothing goes wrong and it will be
initialized with the default memory
footprint but remember doing this wastes
a bit of memory so if you're running
this program on a machine which is
really tight on memory always put some
kind of initialization size based on
your knowledge of how many elements are
going to be stored in this collection so
after that at line number 12 we start
adding elements to this collection and
for adding the elements the method which
is provided by the hashset class is ADD
so you use the add method to add new
elements so at line number 12 line
number number 13 14 and 15 I use the
method again and again to add some
elements If You observe the line number
14 and the line number 15 these two
lines are adding the same element so I'm
trying to add C twice to this particular
hash set and we will observe the output
to see what happens if we try to add
duplicate elements in the hash set
because if you remember the sets are
supposed to be unique they should not be
storing duplicate elements that's the
property of sets so that's what I
demonstrate by by adding duplicate
elements to see how it behaves and let's
do that let me comment the rest of the
code for a while and let's run just this
part of the code where I add C twice and
I print the hashset and let's see what
happens so I go to run as and I click on
Java application and I only see three
elements even though I added four I only
see three and C has been added only one
once not twice now you might be
wondering whether this C is the C added
at line 14 or the C added at line 15 so
to understand that we need to understand
how hashsets add method works so this
add method is basically returning a
Boolean value if the element is added
successfully this add is going to return
true and if the element could not be
added successfully this add method is
going to return false so let's do that
let's store the result of these add
methods let's call this R1 and let's
call this one as
R2 okay and now we will try to print R1
and R2 and see what happens so if I
write
system.out do print Ln and I say R1 and
then I just copy this after line
16 and write R2 and now we will observe
OB ve the output of these to see which
when uh we did the add at 14 and when we
did the add at 16 which add actually
resulted in C getting added did C get
overwritten or did C did not add twice
what
happens so we see that uh when we do the
add at line 14 we get true so it means
that this ad was successful and C was
added here and when I did the add again
at line 16 this returned a false it
means the hash set rejected this add
operation so this C was not added so the
actual C was never over returned the
original C was maintained and when you
try to add a duplicate value with the
same value a duplicate element with the
same value hash set is going to reject
that so that actually proves that the
set will maintain the uh the uniqueness
property and it will reject all the
duplicates subsequently that was about
the add uh property now let's understand
another interesting property of the
contains method contains method of the
set class is used to find if an element
exists in the set or not so you can just
use the hash set variable name do
contains and just type the actual
element and this is going to return true
or false based on whether this element
is present in the hash set or not
present in the hash set if it is present
then this contains method is going to
return true otherwise it is going to
return f false so let's run this method
and observe the output at line
21 so it says list we are writing this
particular string which says does list
contain C or not and it returns true
because yes my hashset does contain C
now coming to line 23 I use another
method of the hash set which is the
remove operation which you can use to
remove an element from the set and then
I'm again doing a out and I'm asking the
to print the set set this should be set
and not list so then I'm checking if uh
what happens to my haset if I call the
remove method and I'm just printing the
modified haset at line 24 so let's see
what happens with the effect of remove
operation okay so after removing a this
is what remains in my hashset and a has
been successfully dropped if I call the
remove method and then I try to just
iterate over the hash set to show you
how does this iteration work it again
works on exactly the same way it has
been working for the list
implementations that on the rhs of this
column you write the collection name so
hash set and on the LHS of this colon
you write the representation of the
element so this hashset is going to
contain string and this is just a
placeholder it can be anything this is
just a temporary variable to store the
current value at the current step of the
hashset iteration and I'm printing all
the items one by one so if I run this
I'm able to print B and C because that's
all which is remaining in this hash set
so this was a very quick demo to show
you the functionalities of the hash set
how does hashset maintains uniqueness
how do you remove elements how do you
add elements how do you check for an
elements existence using contains
there's also a method to get the element
of the hashset if you want to so these
are all the different properties and
methods available in the hash set and do
check check out the uh API documentation
of the hash set to learn about more
methods so that's all I wanted to cover
in this particular session where we
focused only on hashset and in the next
session we we will be discussing about
presets and we will also see an example
of how do we Implement presets in Java
let's get started with presets in Java
so in the previous session we talked
about about hashset which is one of the
implementation of the set hierarchy and
today we'll be focusing on Treet and if
you remember when we talked about this
collection framework I discussed briefly
about Treet that the main reason you
will use Treet is basically when you
want to maintain natural ordering of the
elements if you're adding your custom
elements then you need to tell Java how
to compare and sort and order the
elements but that's for another day when
we'll cover about the detailed
comparable and comparator interfaces for
now what you can understand that
whenever you have to maintain the
natural order of the elements
automatically then you should use three
set along with that the set property
still holds true that this tree set
cannot have duplicate elements we should
also know that tree set is not
synchronized so it is not a thread safe
collection so be be be aware that
whenever you are trying to use preset in
a multi-threaded environment you need to
write more wiring code around it so that
Treet works as a expected okay that was
about the brief uh theory about the
Treet you can read about about it in
detail in this tree set documentation
class and with that let's switch to a
demonstration of the Treet class so I
have prepared a class here which is
called Treet demo as you can see it has
a public static void main method and at
line number eight I'm initializing the
Treet again it's again the standard
representation of initializing a
collection which we have been using
throughout the different examples of the
collections so Treet of string so this
particular Treet is going to hold only
and only string elements if you try to
add another element it is going to
through a compilation error and the on
the rhs I'm just saying new reset and
again this is not mandatory so I can
remove that and it will still work you
can specify the size whenever you know
about the scope of the collection you
should always specify the size for this
demonstration it's a lightweight program
so it's fine after that from line line
number 10 till line number 13 I'm again
going to add some elements and again if
you see I'm adding elements in random
order I'm adding B and then I'm adding
adding a then I am adding C twice just
to show you the uniqueness property of
the Treet does it still hold true or not
we will be able to figure that out from
this particular example and we will also
see if I'm adding B before a will it be
printed in a fashion called b a c or
will it be printed in a fashion called
ABC we should also know that so let's
try to run this program and understand
the
output so if we look at the output we
see a before B but here when we added
the elements we saw B before a we added
B first and then we added a and then we
added C twice and as for the uniqueness
property of the set the second uh
addition statement at line number 13
returned false and set rejected this
addition because it could could see that
c was already present in this particular
collection so C is added only once but
what's interesting is that b is added
first but B is added B is printed after
a so the natural order of the elements
in this collection is automatically
maintained by Treet so what under the H
Treet does here that it looks at the
type which is a predefined type in Java
string is a predefined class in Java so
it will use its own sorting algor gthm
to sort the strings based on their
natural order of sequence and in the
natural order of sequence a will always
come before B and B will always come
before c so it will automatically apply
that sorting and will present the result
to you if you're using a custom class
here let's say your own student class or
your own customer class or your own
account class in that case that account
class or student class or customer class
needs to tell Java how to sort elements
and for that you need to write
comparable and comparator
implementations which we will cover in
detail in the future sessions but for
now you you must understand that
whatever the type of class you're
specifying here should tell Java how to
sort the elements either Java should
know it automatically if it's a
predefined class like string or integer
or float or double then Java would
automatically know by default how to
sort the elements but if you're creating
a custom class of yours in the Treet and
specifying that as as a Treet type then
you should also tell Java how to sort
the customers whether you want to sort
them based on your first name whether
you want to sort them based on their age
their salary Java doesn't know that so
you need you need to tell Java about
that if you're trying to use a custom
class as the type entry set in this
particular example I'm using string here
and it will apply the natural ordering
let's put C here in the very beginning
to see what happens and I can comment
this as we have already maintained and
verified that c is only print printed
once and added once so I'm adding CBA
and let's run this program I still get
ABC because again the natural order is
implemented contrary to this when we
talked about hashset remember I told
that hashset is a random access uh
element collection list so if you run
the hash set if you try to print the
hash set again and again and again you
might see a different order sometimes if
I use a hashset here sometimes it will
print ABC sometimes it will print B EAC
sometimes it might print cab any kind of
sequence any kind of random sequence it
will pick automatically that's the
property of hashset but in case of Treet
no matter how many times you run it you
will always get the same order based on
the Sorting implementation available in
the class type so that's all I wanted to
cover about Treet please read about read
about its Java documentation in the API
docs to understand what all other
methods and utilities Treet provides but
it's pretty much similar to what we we
saw in the hashset example like remove
or get etc etc and contains Etc so all
the all similar methods are available in
the Treet class as well and that's all
we'll focus on on this particular
session and in the next session we're
going to talk about an interesting
framework called Maps let's get started
with maps in Java so first of all before
we understand this particular diagram
and the classes in this map framework
let's understand why do we need map so
there would be instances when you would
write a Java program or any kind of
program there would be always be
instances where you would need to store
a key value kind of arrangement a very
simple example can be that you want to
maintain a company database and you want
to just bring the whole uh mapping of
the employee ID to the employee name
into the Java program how do you do that
you need a key value sort of arrangement
where you can store the employee ID as
the keys and each of the employee ID key
would correspond to an employee name
which will be called the value so you
need a key and value arrangement in a
Java program to store that kind of
information and use that kind of
information in your program and that's
where map comes into picture whenever
you have to store a key value
Arrangement remember you would always
think about maps maps should be the
right collection or the right data
structure to be used if you want to
store any key value arrangement in your
program so that's about map and here you
can see a nice uh framework
representation of map and this is going
to be a theoretical lecture where we
will understand how this uh map
framework Works what is the property and
what are the different implementation
classes and then in the future sessions
we will again look at some examples of
the most popular map implementation
classes which are used in the Java world
so again uh the orange oval are
interfaces the blue boxes or the light
blue boxes are the abstract classes and
the purple boxes are the concrete
classes so map is an interface which
will provide this kind of a blueprint
that every class underneath it would be
working on a key value Arrangement when
we talk about this key value arrangement
so we have this keys and we have the
values so the keys here are supposed to
be unique the values can contain
duplicates remember this is a very
important concept then in map the keys
will be unique and the values can have
duplicate and because we want to
maintain the uniqueness in the keys part
that's why the keys are technically
stored as a set because we know that set
cannot contain duplicate sets are by
designed made to be storing only unique
elements so map uses the set class to
store its keys and to store the values
It generally uses a list class so you
can see map is basically reusing the
classes from the collections framework
sets for storing the keys and lists for
storing the values that's the basic
anatomy and basic idea of how map is
working now you see some classes here
called abstract map and sorted map and
again similar to the set hierarchy
whenever you see the sorted word and if
you look at the concrete class which is
called tree map this is going to provide
you some sort of an order sorting order
automatically and then you have the hash
map class and this class is going to be
providing a random access this will not
maintain the insertion order this will
not provide you a natural sorting order
this is just to store elements in random
order and the element here a single
element here is basically consisting of
two parts which is key and value always
remember that you also have hash table
here hash table is basically a
synchronized representation this is a
thread safe hash map and tree map are
non-thread safe so multiple threads if
you try to work in a multi-threading
program with these Ash map and tree map
you're going to get very unpredictable
results but if you use hash table then
it is inherently thread save so it will
only allow
one thread to be to access the hash
table at a particular time you will ALS
you will also be thinking then then it's
always better to use hashtable right
because you will never get into those
weird errors and you don't have to
migrate your program uh to a
multi-threaded environment whenever you
are trying to use hash tables yes that
is true but hash tables are slower for
the same reason because only one thread
can can access it at a time and that's
why has tables are slower and hashmap
and tree map are way way faster because
they allowed multiple access at the same
time so you have to always be mindful of
what kind of collection type you're
using there are some external ways as
well to make these hash maps and tree
maps and hash set and Treet and and
array list and Link list as synchronized
as well and we will talk about that in a
future session but for now you can
understand that hashmap and tree map are
non-thread safe and hash table are
thread save there's another class which
is uh which is coming out from the
hashmap class which is called linked
hashmap and linked hashmap as the name
shows it will basically carry two
properties it will carry the property of
hashmap where the elements are stored or
displayed or accessed in random order
and at the same time it is also
providing the linked uh property of the
link list where the sequence is
maintained so you can see you can
actually get the insertion order if you
use a linked hashmap the way in which
you insert the elements would always be
the way in which the elements will be
accessed so you are getting sort of a
ordering property but the order is the
insertion order it's not the natural
sort order it's the insertion order
that's why the name linked hashmap
because it brings the link list part of
the link property inside the hashmap
where the elements would be presented to
you in the order they are inserted when
you call the add method so that's what
we covered here we covered about map
interface we covered about hashmap class
which is going to store the values and
the access will be random the value
means the element means a key and value
we sometime also call this as an element
you will see that representation
Sometimes some some uh people also call
it as itable element it's all the same
thing but it's a key and value
Arrangement remap also stores the key
value Arrangement but it will provide
you a a sorted representation and here
the Sorting will happen on the keys not
on the values the Sorting will be
happening the natural order of sort
which will be maintained by the tree map
is only applicable to the Keys here
similarly linked hash map it will insert
the elements but when you try to access
it it will maintain the insertion order
no matter how many times you access it
it will only be presented to you in the
order the elements were inserted and
hash table is very similar to hashmap
with the difference that hashtable is
thread safe multiple threads cannot
manipulate the hashtable at a time it
will only let a single thread access
itself at a time so that's the property
of hash table the most popular classes
are generally these ones hashmap tree
map and linked hashmap very rarely you
will also see hash table but since we
have some uh ways to get these
synchronized so generally you would not
see much of the hash table
implementation and that's all I wanted
to cover in this particular lecture
where we walk you through the concepts
and the theory of the map framework and
in the upcoming sessions we'll go deeper
into the concrete classes and in the
next session we'll specifically be
discussing about hashmap so we will
understand how hashmap works we will
create a hashmap and we will again look
at some utility methods which are
provided by the hashmap class through
the demonstration let's get started with
hashmaps in Java
in the previous session I covered about
the theoretical concepts of map and the
key value Arrangement and the keys being
basically a set and the values basically
being a list and now we are looking at
the API documentation of the hashmap
class you can see the K comma V here
these are the types of the key and the
value which the hashmap will accept you
can see K is basically the type of keys
and V is basically the type of mapped
Val values uh like I explained it's
basically keys are stored in a set
fashion and values are stored in a list
collection fashion this is not by
default synchronized so if you want a
thread safe collection then you would
have to do something else which I will
cover in the future sessions this is a
very brief overview of what hashmap is
but let's look at the example to
understand better and then I will be
able to explain it in bit more detail so
now we are looking at an example which
is basically a class which is called
called hashmap demo I have a main method
here and then at line number 10 I'm
initializing the map and as you can see
that on the LHS we see the concrete
class hashmap and I can do this and this
will still work provided you have the
import here I had the import here so it
will work fine and I'm saying that this
map is going to contain a key value
Arrangement where the keys are the
string type and the values are of the
type integer and it's ultimately a
hashmap here I I don't need to again
provide the generics because I have
already provideed the generics here the
name of the map is just simply a map and
again you can specify a size or you can
skip the size based on the memory
requirements and the program
requirements now coming to the point
where you want to add elements to the
map now since this is a key value
Arrangement here the name of the method
through which you're going to add
elements is put so you call map dop put
and then you provide the key comma you
provide the value that's the Syntax for
adding an element or we technically call
that element an entry this key value
together is called entry so if you have
to add an entry to the map you have to
write it in this way where key comma
value is the convention so I'm adding
three elements or three entries here
which is a comma 10 B comma 20 and and C
comma 30 a b c are basically the keys
and 10 20 and 30 are the corresponding
values of these Keys
respectively after that I'm I'm
showcasing another utility method of
this particular class which you can use
to find the size of the map so you can
just call map do size and it will print
the size of the map after that I'm
printing the actual map the whole map
and then I'm using some more methods but
again let's comment this code and let's
understand understand this code one by
one so that there is no confusion so to
start with I'm going to add some
elements some entries and I'm going to
print the size of the map and the map
itself let's run this program so here
you can see the size of the map is
printed as three because I've added
three entries and then when I call map
inside the system.out.print Ln method I
get the whole map printed here and this
is how the map will look like like when
it is printed we can see key equal to
Value syntax here where a equal to 10 b
equal to 20 and Cal to 30 are the key
value representations or the entries
here separated by comma enclosed by the
curly braces that's how our map looks
like so far so good the next thing which
I'm going to Showcase to you is the
contains method and since the map has
this set which is the keys basically
that's why map provides a method called
contains key basically you can check if
the particular key is present in the map
or not and if you know the keys present
then it's very easy to get the value
from the key math will provide a method
also where you can supply the key and
get the value so knowing the key is the
most important part and that's why map
provides a method called contains key so
you can call this method specify the key
which you want to check for the present
pres in the map it it is going to check
whether a is present in this map's key
set or not if the a is available in this
Keys we can see a is available then this
condition is going to hold true and then
like I said if you want to fetch the
value then you can call the get method
providing the key you can fetch the
value from the key that's the that's the
core idea which you should remember so I
call map. getet specify the key and this
is going to spit out the value which is
being pointed by this particular key in
this case a is pointing to 10 when I say
pointing it's not pointer remember it's
just a reference so map. get of a is
going to get the actual value which this
key is pointing to which is 10 and then
I am printing this integer a which is
the actual value pointed by this
particular key so let's run this program
and see if this works so we get these
two outputs from the above and then this
is the output put which is coming from
the if block so it checked whether the
map is containing a key with the name a
yes it was able to find that and then we
asked the Java program to fetch the
value corresponding to this particular
key so we just called map. getet of a
and it fetched 10 and it printed 10 here
that's why you see 10 here okay so
that's how you can basically use the
contains key method and the get method
now what if you want to iterate over all
the keys
what if you the what if you have to use
the all the keys and you have to make
some pattern or make some observation
about all the keys in your map you can
do that by iterating over the key set
and for that map provides a method
called key set so you just called
map.key set and this is going to fetch
all the keys in a set representation and
will be provided to you so here when I
call map. Key set this is basically
giving me a set which is containing all
the keys and then I'm iterating over the
keys one by one you would be familiar
with this syntax by now which is the
enhanced for Loop syntax and inside this
I'm printing the key which is the
current temporary variable holding the
current key and the value pointed by
that particular key at that particular
step and I'm again using the same method
get which I which I showed you uh here
same method so you provide the key and
you will get the value so I'm going to
get all the keys iate over the keys and
then print the key and the value let's
see how this looks like so till this we
were good and here you will see the
output which is coming out from this
particular for loop from this particular
for Loop line 25 to line 27 where I'm
iterating over the key set printing the
key and value 1 by one so this is how to
show you if you just have access to the
key set you can still iterate over the
whole map but what if you know
everything you have access to the key
set you have access to the values and if
you was if you just want to iterate over
it then you can use this particular way
and instead of map. keyset you're going
to use map. entry set if you remember
map treats each key value Arrangement as
a single entry entry is the keyword here
so map. entry set is going to give me
all the entries in the map and then each
entry is basically of type entry class
this is the representation of each entry
and we know how this representation
formed entry is the class basically
which is coming out of this map
collection hierarchy and then let me
just save this and then string is the
key and integer is the value held by
each entry inside the map so that's what
we are going to do we are going to pick
up all the entries in the map and going
to iterate over the entries one by one
by writing this enhanced for Loop and
entry is the temporary variable which is
going to to hold each entry one by one
at each step and then it's very simple
you call entry. getet Key you'll get the
key and you call entry. get value and
you will get the value so it's much much
simpler than this one where you had to
do map. getet to understand here it's
very implicit get key is going to get
you the key and get value is going to
get you the value so you just need to
call map. entry set iterate over the
entry set and get each entry's key and
value and print them or do whatever your
program requires to be done that's how
you will use it so let's run this one as
well to verify if this works okay so
this is the output which is coming from
the last Loop this Loop basically you
can see key I did not put any space
that's why you see key a key B and Key C
together let me put a space here and put
a hyphen so that the output looks better
and let me rerun this y this is much
better so you can see the key a value 10
key B value 20 and Key C value 30 this
is coming from this particular for Loop
which I just showed you so this is all I
wanted to cover in this particular
session we went deeper into the hashmap
representation and we saw bunch of
methods contains key key set entry set
get put Etc and we showed how we can use
the hashmap for different purposes in
the program in the next session we'll go
deeper into the tree map concept and
we'll also look at a demo of tree map
and we'll understand how it works let's
get started with with tree maps in Java
now if you remember in the last lecture
we talked about hashmaps in Java and we
also had a look at an example where we
saw how a hashmap works and how we can
use a hashmap we also had a look at
different utility methods of the hashmap
as well now in today's lecture we are
going to focus on tree Maps which is an
another type of map as we discussed when
we were discussing about the map
framework and the main property of a
tree map is that when you enter elements
into a map they will naturally be sorted
or naturally be ordered now when I say
naturally ordered what it means that if
you put the keys as let's say integer
then the tree map will automatically
sort all the map entries in an integer
sorted fashion where you'll see the
natural number sorting Behavior like 1 2
3 and so on similarly if you store
alphabets or strings then they then
those will be sorted in a natural
sorting alphabetical order starting from
A to Z so these are the uh these are the
data types which the Java is already
aware of on how to sort them like
integers doubles floats strings Etc but
there can be a case where you have your
custom key this particular key is your
own custom class if that is the behavior
or if that is the scenario then in that
case you will have to provide an
implementation to Java to know how to
sort those elements because Java doesn't
know for example a student class or an
account class Java doesn't know how to
sort that so if you have that kind of
scenario then in those cases you will
have to provide your own sorting
implementation and we will cover about
what kind of sorting implementation you
can provide in those kind of scenarios
in the upcoming lectures for now we will
look at have a look at an example of
tree map where you can see I have
created a class which is called tree map
demo and I have initialized a tree map
with the keys as integer and the values
as string so this means that each entry
of the map will have key as the integer
value and the value of that particular
entry will be of string type so
basically an integer to string mapping
is what each entry of this tree map is
going to store so nothing uh different
here you would have already seen this
kind of this kind of initialization for
any kind of map and after that at line
11 I use the standard put method of the
map and I I started storing the values
so at line 11 I'm saying store three and
a so three is the key and string a
remember this is not a character this is
a string because I have specified string
here if you specify a character here and
if you try to store a string this is
going to throw an error uh and you need
to fix that so I store three as the key
and a as string as the value similarly
at line 12 I store two as the key and B
as the value and at line c i store one
as the key and C as the value so these
integers are the keys and the string are
the values and if I just put them and if
I just try to print them what happens
what kind of order can we expect let's
try to analyze that so I right click on
this I go to run as and I go to run as
Java application it will run the program
because I have a static vo main method
and now you see that the map is printed
in a different fashion than the way it
was added we added the map elements in
this sequence that we added 3 a first 2
b second and 1 C as the third element
but when we started printing them we saw
1 C printed first 2B printed second and
3 c 3 a printed third so what this
denotes that this tree map because the
key was integer here it automatically
sorted these Keys into a natural order
sorting and it provided when I tried to
access the map it provided the access in
that sorted sequence only no matter how
many times you run this particular
program it is always going to return the
map in the same format in the same
sequence the sequence of representation
of the elements is not going to change
and you can basically do the similar
behavior for example if I just change
this to string and integer let's do it
like this and if I again swap the
elements here as well I say a comma 3
and I say B comma 2 and here I can say C
comma 1 if I do this I just switch the
keys and values position now the string
is the key and the integer is the value
and let me just put these two before a
so that we can demonstrate the behavior
of the tree map properly so I'm
inserting B2 first and C1 2 and
a33 and I just save this file and now
let's run this file and let's see how
the output comes so now you can see that
since the key is now string it has
applied it has automatically applied the
natural sorting ordering of strings
which is starting from a going till z
and that's why you see a entry as the
first entry B entry as the second entry
and the C entry as the third entry again
no matter how many times you run it or
you iterate over it you try to access it
you will always get the sequence in the
same fashion so this is a basic overview
of how tree Maps work now you can and I
would strongly recommend you to go and
read about all the other methods which
are available in the tree map which you
can use for example how can you remove
elements how can you uh how can you
iterate the elements of the tree map Etc
in fact the iteration is is going to be
exactly the same way as we have seen in
the case of hashmaps because iteration
Behavior doesn't change but to uh if you
want to see what all different kinds of
methods treap support it supports a lot
of different methods we can't cover all
of them in this short tutorial but I
would strongly recommend you to go and
read the Java docs API of the tree map
to get familiar with those methods so
that you know what kind of
functionalities treap can provide in the
next session we are going to have a look
at how we can use stacks and we will
look at a Hands-On example of how we can
build stack and how we can use them in a
real life scenario let's get started
with Stacks in Java now if you remember
when we were covering about the
collections framework I walked through a
complete hierarchy of uh interfaces
abstract classes and concrete classes
and I briefly talked about what are
stacks and what kind of functionality
they provide in which scenarios you
would use them so let's do a quick
refresher of what Stacks are and why do
you need them so stack is basically uh a
kind of list we can say technically a
list but it's not exactly a list so
never say that stack is a list it's it's
just a because it is extending the list
interface that is why you can say it is
a type of list but actually it's not a
type of list it has its own
representation you will use tack in the
cases where you will have to maintain a
Leo representation of the objects now
what is a leao representation it means
last in first out that's the basically
the full form of the Leo acronym and
what it means that the element which
goes at the last in the inside the
collection will be the first to come out
think of it as a stack of plates at your
dining table where you you put plates
over one another and the last plate
which you put on that plate stack will
be the first one to be picked up by
somebody who wants to eat something
because people will not take out the
bottommost plate otherwise the whole
stack will fall that's why they will
take the topmost plate and that's why we
call that plate representation as stack
of plates and this representation in
Java is exactly inspired from that and
we call this stack you see a bracket
here you see a a generics representation
here which says e which means that stack
you need to Define what kind of Stack it
will be be whether it will be a stack
holding integer values or string values
or any of your custom class values so
that is the basic property that the uh
the last element to be going inside the
collection will be the first element to
be coming out so let's have a look at an
example of how you can use stack and
what are the different properties which
we can leverage while working with
Stacks so for that let me switch back to
eclipse and you can see I have a class
created here which is called stack demo
and it has a public static void main
method which is making this particular
class executable and here you can see I
have created the I have initialized the
stack so stack of the Class Type so you
provide the class type as string which
means that this particular stack is
going to store string objects and then
you just say new stack and you provide
the same generics here actually you can
skip that if you do this as well this is
going to work fine so that is how you
can basically initialize a stack you can
see the import here which you need to
import to make this work it's basically
part of the java. util package what are
packages again we will we will cover
that in detail when we'll cover classes
and Constructors and Etc so now at line
11 I'm using a method called push now
the push method is used to insert
elements inside the stack but we call it
push because like I said stack is a is a
special type of collection that's why it
doesn't use the add method rather it has
a method which is called push which is
used for inserting elements or pushing
elements on the top of the stack so at
line 11 you say stack. push basically
this stack is is holding the list of all
the countries or the entries of all the
countries so you say America at line 11
then at line 12 I'm again doing stack do
push and entering Germany at line 13 I'm
again doing another stack. push and
entering India so basically I have added
three countries names inside this stack
now if you if you can think about the
mental representation or if you try to
build a mental representation of this
then stack. push America is basically
the first entry then when you added
Germany this entry went on top of
America because that's how the the stack
of of plates work right and then India
uh entry will come on top of Germany so
the America is the bottommost entry then
we have the Germany which is sitting in
the middle and then at the top we will
have the entry for the India string and
after that at line 15 I'm just printing
the
stack so if if you want to just observe
the output till 15 let's comment this
particular section for now and we will
just focus till line 15 and once we have
figured that out then we will move to
the rest of the uh code here so let's
run this particular program and observe
the
output so you can see this is the
system.out.print Len which is getting
printed so I'm printing a stack string
and then I'm printing the stack as is
and you can see it's printed in the
sequence in which the elements were
inserted so when you print the stack you
will not be able to figure out which is
the bottom and which is the top because
you don't need to know that while you
are just printing the whole stack when
you actually want to understand and
observe that behavior is when you will
start taking elements out of the stack
at that time it would be critical to
know which element is at the top and
which element is at the bottom but for
now we can see that we are able to
successfully add elements or push
elements to a stack and we are able to
successfully print the stack now let's
uncomment this particular code and
understand what is happening here so at
line 17 I'm using another method of the
stack which is called pop so the push
method was used to push elements or
insert elements into the stack and the
pop method is used to take elements out
of the stack and remember the Leo
property of the stack which means that
if I call the pop method which is
basically I'm telling stack to remove an
element it is going to remove the
topmost element from the stack and it is
also going to return the element
remember that part if you want to remove
the element and if you want to see which
was the topmost element which got
removed then you can actually store the
output of this particular execution into
a variable and you can see which element
was popped or removed and and that's the
basic property of a Leo right that when
you have a Leo collection when you po
the element when you call the pop method
on the stack you would expect the
topmost element to be coming out and
that's why we store that into this
particular string and then we print that
popped element to verify and see which
element was actually popped and after
that because I have removed one element
here then I print the modified stack to
just see what all is remained in the
stack so let's run this particular
program uh now we'll let's comment the
first part maybe this particular sis out
is not needed because we have already
observed the output of this so let's
observe the these two output after pop
which was the element which was popped
and how the stack looks like after the
removal or popping of one element from
the stack so I right click run as Java
application and now uh if you remember
when we inserted the elements we
inserted the elements in this fashion
America Germany and India and when I
called pop the topmost element of the
stack should get removed so it it so the
basically the Java looked at this
particular stack and it could see that
the element India was added at the very
last which means this element was
sitting on the top of the stack and when
you called stack. popop this method or
this string basically got popped out
this element got removed from the stack
and we stored that element into this
particular variable we printed that
element and here you can see that output
that the popped element is actually
India because India string was at the
top of the stack in this particular case
at line 20 now I'm printing the modified
stack basically printing what is
remaining inside the stack after we
called this pop and we can see that the
string India is gone from the stack and
now Germany is the new top if I call
this again let's call this again to
verify if Germany is at the top actually
so I'm calling the stock uh stack. pop
again let's just call it poed element
one for Simplicity don't do that in
production code always give nice
variable names but for the sake of demo
uh we can do this so let's see what
happens if after we have these two
elements left in the stack and if I call
Pop again which element gets popped so I
right click run as Java application and
we can see that this was the
representation here at line 20 then I
called po and the poed element was
Germany because now this Germany was the
new top and after Germany has been
removed from this particular stack then
the stack has only one element which was
which is America so this is how you can
work with the stack and these are the
most two popular methods which are push
and pop which you would basically
require to uh to be to to use in your
program if working with stack and let's
say you have a scenario where you just
want to view which element is at the top
you don't want to remove it because pop
is also going to remove the element
right so if you don't want to remove it
but just want to view which element is
sitting at the at the very top of the
stack then you can call the Peak method
so this peak method is basically going
to return the topmost element but it is
not going to remove the element from the
stack so let me just verify that as well
for you contrl C and after we do the
peak I'm going to print the element
again let me just call it as peaked or
let's say just call it as top
element and then we print the stack
again so let me just comment out this
one as well and now we'll run the full
program let me call this as original
stack so we'll first print the original
stack then we'll remove one element and
we'll print that element and we print
the modified stack then I call the Peak
method and and then again I print the
stack to see if Peak also removed the
the top element or it just returned the
top element so let's run as Java
application and observe the output so
the original stack was uh this where
India was the topmost element and
Germany was in the middle and America
was at the bottom of this particular
stack and then we popped the top element
which was India and then the St stack
got modified and we had only two
elements left into it then here we
called Peak at line line 22 and we just
at line 23 we printed the peaked element
or the top element so in this particular
stack if we call Peak we got Germany but
if we printed the stack again we can see
that Germany is still there because Peak
just returned the top element but it did
not remove the top element whereas pop
will remove the top element and also
will return that element to if you want
to store it so that's all I wanted to
cover in this particular session where
we talked in depth about the stack
features and like I always say please
also go to the Java do API and read
about all other methods and
functionalities which are provided by
the stack collection in the next session
we are going to focus on cues and we'll
look at a Hands-On demo of cues as well
let's get started with cues in Java so
again taking it back to the time when we
discussed about the collections
framework we briefly discussed about the
Q interface and what is the property of
the of a particular que so cues were
again inspired from real life cues which
you form when you whenever you try to go
to a particular place where you want to
get your things done you generally stand
in a queue and this queue interface is
directly inspired from that particular
scenario itself that it works on a fifo
Arrangement so now if you think about
the fif Arrangement and let's connect it
back to the previous lecture where we
discussed about stacks and we said that
Stacks are a Leo Arrangement so in case
of a Leo Arrangement you had the last in
first out philosophy but in case of Q's
you have the first in first out
philosophy it means the first element
which enters the queue will be the first
element removed from the que that is the
basic premise around which the Q uh
interface or the Q collection is formed
so remember that particular concept
whenever you have a situation in your
project where you need to implement this
kind of mechanism that the element which
got inside the collection should be the
first one coming out of the collection
then you should be always thinking about
cues whereas if you have an arrangement
where the last element inserted should
be the first element out of the
collection then in that case you should
think about stacks so remember the value
proposition of each of these collection
types which will help you take a
decision as to which particular uh
collection to be used in which scenario
so talking about q q is again an
interface again like I said uh we we are
very soon going to cover the concept of
classes and interfaces and Abstract
classes so just hold tight on that
particular concept but connecting it
again back to the theory lecture where
we talked about the collections
framework we can think of an interface
as just a blueprint just a skeleton with
nothing concrete implementation details
inside that interface so the Q is again
an interface and there are few
implementations of it one of the most
popular implementation of Q interface is
a priority Q class so the priority Q
class is again technically it is a que
which basically works on the concept of
first in first out but at the same time
it also works on a priority you can
assign a priority to the
elements which will decide when uh which
element is going to come first and which
which element is going to come second
and that concept is basically again
governed by the same natural ordering
logic which we have been seeing in other
ordered collections like tree set and
tree map so that's the basic idea about
priority q and let me take you to a
Hands-On example so that you can relate
it better so here I have uh a class
which is called Q demo it has a public
static void main method and then at line
number n I'm initializing the Q I'm
saying that this particular Q should
hold only string objects and it is a
type of priority q and like I mentioned
if you use priority Q you can see the
import of it here uh if you see the
priority Q then you get that natural
sorting or natural order ordering logic
phenomena out of the box because we are
using strings here so Java already knows
how to sort strings and it is going to
sort string in the alphabetical sorting
order if you are providing a custom
class of yours maybe let's say Q of
students then in that case you need to
tell Java how to sort those elements and
like I mentioned in the previous
sessions we are going to cover in detail
about how do we write that sorting we
provide that sorting uh implementation
or sorting logic to Java in case of
custom classes but we'll cover that when
we cover about that sorting Logic for
now for the demo sake we are just taking
a string
Q of strings basically which is of type
priority q and then again following the
same example as we saw in the case of
stacks just so that you can build some
sort of similarity I'm again inserting
few strings here which are country names
so at first I'm inserting India then I'm
inserting Germany and then I'm inserting
America so I have basically added three
entries into this particular queue then
at line 15 I'm just printing the queue
and I just want you to see if I inserted
elements in this order where India with
an I go first Germany with a G goes
second and America with an a goes third
and if it is a priority Q does it
automatically sort the elements or not
so let's first observe that part and let
me comment the rest of the code we will
cover the rest of the code slowly so
that we build a sort of cognitive flow
so let me comment this code and let's
just print the queue for now so I'm
inserting the elements into the queue
and just printing the element Q has a
concept of head and tail remember that
so the very first element in the Q is is
basically the head and the very last
element is the tail so whenever you see
the term head and tail you can remember
that head is the first element and tail
is the last element so now let's try to
run this code and see what happens if
you just print the Q as is you're not
iterating over it you not accessing any
particular element but you're just
printing it so if you do this we see the
output here which says original Q this
particular one says America India and
Germany now this might be looking
confusing right because if I apply
natural sorting then America should come
first which is okay then Germany should
come because after a the G is the the is
the next natural alphabet starting point
and then India should come but we see
India in the middle here the reason is
because when you call this call this
inside the
system.out.println method let me just go
back if you print it inside this
particular uh system.out.println method
automatically when you try to print a
variable it's two string method is
called so technically under the hood
this is what is getting called though we
don't need to write the two string but
the moment you try to print any variable
inside the system.out.println
automatically its two string method is
getting called and in the interesting
part is if you call the two string
method it will call the abstract
collection classes two string method
which does not understand sorting so
remember that very well if you're
working with priority cues then in that
case if you just try to print the queue
you will not get the natural order but
once you try to add elements or remove
elements or Peak the elements in those
cases you will get the natural ordering
sequence but if you just print the Q as
is you will not be able to get the
natural order and it will be random
order that's why you see a random order
but let's try to build an understanding
around the natural order so once we have
printed the que now let's understand the
other method of the queue which is the
remove method and if you remember I told
you that this is a F4 Q so if you try to
remove an element the head of the que is
going to get removed the head in this
case is this string America which should
be removed from this particular
collection if I call remove method so
I'm just calling the remove method and
then printing the REM remaining Q again
this Q will be printed in random fashion
but but if it is respecting the priority
Q's natural ordering sequence then
America should get removed when cyol
remove so let's verify our understanding
so I can see the Q after removing the
head element remains as Germany and
India these are the elements which are
left now and America is removed from
this particular Q now so that verifies
our understanding that when you call
remove the head of the Q will be removed
and the head will be the alphabetically
sorted first element of the Q there's
another interesting method in the queue
similar to Stacks we have a peak method
if you just want to view which element
is sitting at the head of the queue if
you just want to view it you don't want
to remove the element but you just want
to view the element in that case you can
call the Peak method so I'm just calling
q. Peak and storing the output of q.
Peak into a variable called head and
then just printing the head so let's see
what happens in this case okay so I'm
getting this message which says head of
the Q is Germany because Germany is now
the new head after America was removed
from this particular collection so that
is our head and like I said whenever you
call these methods these will respect
natural sorting order CIS out will not
respect natural sorting order remember
that another interesting method is pole
so pole method is basically used to
remove the element and also return the
element so you can see which is the uh
head and it will also remove the head
both at the same time but in case of
remove you were just removing the
element you were not able to see which
element was removed in this case you
will be able to see which element is
sitting at the head and also at the same
time the head will also be removed so
for that you need to call the pole
method so I'm calling q. pole and
storing this again in in the same
variable head so the head variables
value will get just overwritten if I
reuse it again and then I'm printing the
removed head let's see so I'm right I'm
just running this application again and
I see this message removed head Germany
which is coming from here so when you
call the q. pole the current head of the
Q got removed which was Germany and it
also was returned from the pole method
so you can store the removed element and
use that removed element for for further
processing in your program and after
that only one element in the queue
should be remaining which is India so at
the last line number 26 I'm just
printing the remaining parts portions of
the queue so yes now only India is
remaining so you can see all the outputs
here this was where we started from then
we removed the head element of the que
so this element got removed and we were
left with Germany and India you can see
here India Germany was in this order and
here the order was changed because it is
random order when you use it under sis
out then we wanted to just get the head
of the queue but we did not want to
remove it so we use the peak method and
we got Germany then we wanted to remove
the head so we removed the head with the
help of pole method and it also returned
the removed element which is Germany and
after the removal the Q looks like this
which is having just one element left in
the queue and in this case the head and
the tail both is IND this case so this
string will be both a head and the tail
this is a special case if the if the que
has only one element left so this is all
I wanted to cover in the case of q's and
like I mentioned in the all the previous
sessions as well do go and check out the
Java docs API of the Q interface and the
priority Q classes learn and just get
familiar with all the different methods
which are available in this class so
that when you start using these cues
types or these collection types you you
know what all utilities and methods are
available and even if you don't know
like I always mentioned if you just do
dot here it will automattic any any good
ide will automatically show you all the
methods which are available here uh
which you can read about in the
documentation here and understand what
each method does and you can use that
method as well so that is also possible
so that's it I wanted to that's all I
wanted to cover in today's lecture and
in the next session we are going to talk
about classes and objects let's get
started with classes and objects in Java
so like I have been promising in the
previous sessions that I will cover this
in a dedicated session and this is the
session where we will go deeper into the
concept of classes and objects you have
been seeing this keyword all along in
the all the sessions wherever I ran the
different examples and let's understand
what this means technically if you go by
the definition a class is basically a
blueprint of an object which brings the
question as what is object an object is
basically an instance of the class I
know this becomes more confusing so
let's break it down into simpler
definitions a class is technically a
logical entity it's you can think of it
as any entity in the world if you have
to let's say if you have to build a
student management system or a college
management system then all the real life
objects which you see we always say that
Java is heavily inspired from real life
examples and classes and objects are the
reason we say that because whatever you
see in the world is always basically
some entity human beings are an entity
cars are an entity students are an
entity lecturers are an entity so who
all the actors all the actors which you
see in the world are basically entities
and you can map them as classes in the
Java program now why do you want to map
them because these entities
have basically two uh kind of
specifications one is every entity will
have some attributes and it will have
some behavior and actually that is how
you identify an entity for example human
beings have attributes like we have
hands we have eyes we have ears legs Etc
these are our attributes then we have
our behaviors behaviors are actions you
can think of them as a human being can
speak so can speak is an action it's a
behavior can listen is an is an action
it's a behavior can walk is an action is
a behavior similarly can eat is also an
action or a behavior so that's how you
basically represent an entity that's how
basically you identify an entity that an
entity will have some attributes and
some Behavior if you see those two
specifications in any entity you can map
that entity or you can write that entity
inside a Java program as a class because
a class in Java will exactly have these
two properties it will have some
attributes which we call as properties
and it will have some behaviors which
technically are called as methods so it
will have attributes it will have
properties and methods similar to real
world entity where we have attributes
and behavior Behavior are methods and
attributes are properties that's how it
is so if you if you apply this simple
philosophy whenever you are taking
requirements from a customer for a
particular project always try to ident
identify these entities these actors in
your program once you have identified
those you will be able to write a
corresponding Java class in your Java
program which can represent those
entities and without representation of
those entities you cannot write the
program so Java will kind of force you
to think in this direction to find
entities which will have attributes and
behaviors so taking that philosophy
further and taking that example further
here for you I have prepared an example
where I am creating a student class so
basically let's say if you have to build
a college management system or a student
management system then student is
probably one of the main entities which
will be talked about when you take the
requirements so if you think about the
attributes and the behavior concept A
student will have a name will have an
age will have an address and at the same
time a student can also have some
behaviors like can enroll in a
particular course course can attend a
lecture can take a leave can take exam
Etc these are all behaviors let's
understand this in in a more detail with
the help of this example where I've
created a class which is named a student
and you see the public keyword here
again I will cover access modifier
public is basically an access modifier
and I will cover this in very detail in
the upcoming sessions for now let's
focus on this part so we have created a
class to represent our entity you put a
curly braces around it it ends here and
after that you provide the attributes so
here I'm saying that a student will have
a name it will have an age and it will
have an address it has three properties
so the technical name of attributes is
properties after that let's skip this
part and I will come back to this part
once you have declared these properties
you would want to provide a way for the
name to be filled or replaced or
received for example if you have created
the student class how do you insert the
name inside the student class or how do
you insert the age or how do you insert
the address or modify the age name or
address properties for that we have
these Setters and Getters methods we
call them Setters and Getters because
they start with this keyword not keyword
but they start with a string called set
it is not a keyword you can actually
write it as anything you can call it as
modify name that will also be absolutely
fine Java will not not give you an error
but the standard naming convention given
by Java is to start the methods as
starting with set and get this is the
this is the standard naming convention
and like I said it's a naming convention
it's not a compulsion but if you write
this way your code developers and the
people who are going to maintain this
project in the longer run will be very
happy otherwise they will be very angry
if you use strange methods because like
I said this is the standard naming
convention
so now you are going to write a Setter
method for each of the properties in
this particular class for name age and
address so we call set name again you
put public void because this is not
supposed to return anything this is just
supposed to set the value of name with
whatever value you specifi then you call
set name and then you provide the value
which you are supposed to set uh against
the name so whatever value like like any
random name John or Jane whatever you
need to supply that name here while you
while you call this method and that name
whatever you name you supply will be set
against the name property of this
particular class and remember I use the
word this here intentionally because the
way you are going to represent this is
with the help of this keyword this
keyword means current object it means
that you are when you use this do name
it is referring to the Cur object's name
property and this name is is basically
corresponding to the name which is
coming in when somebody is trying to set
a name similarly for set age age is a
numeric number if you if you observed
it's basically an integer then I'm
saying int age and whatever value of age
will be coming will be set in this
particular object's age then similarly
for set address we have a string address
uh argument being passed into into this
method and this gets set inside the
current objects address property
so I've provided a way for the external
world to set the values of name age and
address because for each student you
would need to set these values now you
also need to provide a way to receive
the values or to return the values or to
read the values for reading operation
you need to provide the getter method so
you see this get again this is not a
keyword it's a standard naming
convention so similar when you write
when you wrote Set name similarly you
will write a get name method this get
name method is supposed to be reading
the current objects names properties
value and will return that value since
name is a string that's why you see the
return type as string here similarly get
age is going to return the age which is
an integer and address is going to
return the address you can also write it
like this which is absolutely fine it is
not going to complain because
technically it is returning the current
objects name properties and age property
and the address property now let's talk
about this what is what what is this
section so this section is basically
called a Constructor and I have a whole
session dedicated on the constructors
but let's understand why we need this
remember when I told you the definition
of the class I said that class is a
blueprint of an object so you have
created a student class and you have
5,000 students in your college now you
need to create a new student object for
each of those student you need to
initialize this student class 5,000
times how do you do that to do that we
do that with the help of Constructors we
call this Constructor this is a special
type of method remember this is a
special type of method which is provided
by Java to initialize any classes
objects if you want to create multiple
objects of the student class you can
repeatedly call this student Constructor
we call this Constructor so you put
public here because we want this
Constructor to be accessible to the
outside world then you put the exact
class name so whatever class name you
have provided here you need to put the
exact class name here if you don't do
that Java is going to raise an error if
I do this here it is going to you see a
red line here because Java failed to
compile this Constructor it does not
understand what is student triple 1 but
it does understand what is student so
this is how it is going to be and then
you provide all the properties which are
going to create the student object so
you're going to create the name the age
and the address so the name age and
address and then you set those values
again similar to the setter methods we
have seen the reason we need to use this
here because if you don't if you if you
write it like this then Java doesn't
understand the difference between the
current object's name and the name
coming from the argument so to
differentiate that you need to use this
here if you use n here and if I just use
n here then this is fine because there's
only single name variable in this whole
class then but if I write it like this
then and if I write it like this then
Java doesn't know if this name is
basically the student classes name or
this name is student class's name it
will get confused like you are getting
confused if you if you try to just find
this in mind mapping so that's why we
need to write this here so that it's
clearly differentiable that whenever I
use this do name I'm refering to the
classes name property and when I'm just
using the name I'm referring to the
method argument that's what we do in
this uh in this Constructor so you
basically initialize all the properties
of your class with some values with the
help of Constructor so we have the
Constructor we have the setter we have
the getter we can cover about this two
string basically this two string is to
print print something but we can cover
that later now uh let's initialize this
particular class so I'm similar to the
initialization we have seen so far you
just write student you write the object
name this can be anything and then you
use the new keyword which is is used to
initialize anything in Java new is a
keyword in Java which you can use to
initialize literally anything in Java so
you use new student and when you say new
student you can provide all the values
which should match its Constructor so
here we have three values string integer
and string and here also we are
supplying three values string integer
and string again so remember to match
this exactly with one of the
constructors which is available in the
class if it doesn't match it is going to
fail it will not work so if I for
example if I do this then I'm supplying
four arguments to the student class but
there is no Constructor matching four
arguments so it is going to complain you
see this red line and the code is not
compiling if I remove this then it is
matching it and that's how you basically
create a student object so an object is
basically an instance of the class
remember that very well an object is an
instance of the class once you have
created an instance of the class then
you can call any method like say let's
say you want to read the name so you can
call get name you can read the name
similarly if you want to so if you if
you want to read the age of the uh uh
student then you can do that as well so
let me just copy this and to this let's
call get age I want to print the name I
want to print the age and I also want to
print the address so get control space I
get suggestion address yep so I'm
printing the name I'm printing the age
and I'm printing the address after I
have initialized the object successfully
by using this Constructor representation
using the new keyword so now let's run
this method or run this class
basically okay so when I run this class
the whole class got compiled The
Constructor the Getters and the Setters
and the properties and their types
everything was set then the main got
called and I created a new object from
this classes blueprint the object object
name was John then I called john. getet
name to print the name which is stored
inside this particular instance of the
student class similarly the age of age
which is stored in this particular
instance so we stored the name as John
so when we call john. getet name we get
John we got when we call john. getet age
we get the age 25 and when we call john.
getet address We call we get this
particular address whatever values you
specified here the Constructor got
called here and the name John got set to
the student's name value the age value
which you supplied got set against the
students age and the address value which
you supplied got set against the
students address and that's how you are
going to create a class so remember
whenever you create a class identify the
properties and the behaviors like
Setters and Getters write a Constructor
which can cover all the values which you
want to initialize and after that just
initialize that class create an object
of that particular class basically and
once you have the object then you can
call Getters you can also call this in
this way if I don't Supply any of this
then it currently it complains and why
it complains I will cover that in the
following session when whenever when I
will cover the multiple Constructors
concept but remember you see this
Behavior here that if you have created a
Constructor which accepts some arguments
and if you supply this kind kind of
initialization then student class does
not have a Constructor which is
parameter less student class has only
one Constructor which is taking three
parameters and that's why Java complains
because it is not able to find a
representation of a Constructor which
accepts no parameter but like I said we
will cover this we will find a solution
to this particular problem in the in the
coming uh in the coming session but for
this session this is all we are going to
cover we covered about classes we
covered about objects and we also saw
how we can write Getters and Setters we
can initialize those methods initialize
those objects and we can access the
properties of those objects using the
Getters and we can also call the Setters
to modify the values as well similar to
this so this is all I wanted to cover in
today's session and in the next session
we are going to dive deeper in the
concept of Constructors and how we can
write different types of Constructors
let's get started with Constructors in
Java now if you remember in the previous
session we covered about the concept of
classes and we walked us through with an
example student class where we had a
Constructor if I just open this back
this is the class which we covered in
the last lecture and we had this
Constructor where we supplied the
required the necessary number of
arguments which can match my students
properties and then I set those
properties calling this do property
equal to the argument like this but what
if you have a use case where some of the
values are mandatory and some of the the
values are optional in these property
section for example what if all the
students have same address although this
is a very hypothetical situation but
let's assume if if you have a scenario
where you have a particular entity you
have identified the entity but there are
certain properties in the entity which
remain constant for all the objects if
you have such case then it does not make
sense to supply an argument for that
particular property which is going to
remain the same for all the objects what
if you can just initialize it with with
some default values that would be
simpler right because let's say for
example if this property is going to
remain constant for all the student
objects then you can just Supply these
two properties these two arguments in
your Constructor and you don't need to
supply the address let's go further what
if you have a class where you have more
than one property let's say if your
class has 10 properties and eight of
them are remaining constant or are are
optional and only two are changing and
mandatory then how would you write that
and what if you have a different use
case for the same class let's make it
even more complicated that you have a
single class the same class or entity is
being used by different consuming
applications one application would
expect let's say these two to be
mandatory and this one to be optional
other consumer application wants these
two to be mandatory and this one to be
optional the third consuming applic
wants all three to be mandatory the
fourth consuming application wants none
of these to be mandatory then how are
you going to do that the answer is
multiple Constructors you can write
multiple Constructors for each of those
consuming applications and whichever
application wants whichever Constructor
they can use that Constructor to
initialize the object of the class so
taking that concept further I have
created a class called cuboid and I have
three different properties written in
this class as we know that a cuboid has
basically three properties which are
width height and depth so I'm taking
that example here creating a class for a
cuboid providing the width height and
depth for Simplicity I'm taking this as
integers but generally you will see this
as doubles probably because the values
can be in decimal points but for
Simplicity sake I'm just keeping
everything as integer here then with a
standard use case if you have to create
create an object of this cuboid class
you would need a Constructor where you
can supply all these three values and
here it is this is the Constructor which
can be called to provide these three
values so I'm supplying the width I'm
supplying the height I'm supplying the
depth depth and then I am setting all of
these values with the this keyword say
this do width equal to the coming width
this object's height will be the height
which is coming from here and this
object's depth will be the depth which
is coming from here now for another use
case where let's say there's another
consumer application where it would
expect the depth to be constant for all
of its objects let's say a value 10 and
it only wants width and height to be
supplied then you can create another
Constructor Java does allow the use of
multiple Constructors in the same class
remember that concept so you can create
another Constructor for that
representation where you supply on the
width and height and you keep the depth
constant now if a consumer application
calls this Constructor 100 times all of
those 100 cuboid objects will have the
depth as 10 only that will be the fixed
value and only width and height will be
the changing values similarly if there's
another consumer application which wants
to have the same height and width and
depth for the cuboid then it would just
require a single parameter whatever ever
value the consumer application is
providing you're setting the same value
to the width to the height and to the
and to the depth so technically this is
basically becoming a cube because then
the three dimensions the height width
and depth are same and what if you have
another consumer application which does
not intend to supply any of the values
because for it all the objects are going
to hold the exact same values for all
the properties let's say there's a
consumer application which would always
expect the width the height and the
depth to be 10 then you can create a
Constructor with new arguments you can
see there is no argument here you can
create a Constructor like this and you
can supply all the default values which
are static values so in this case I have
created four Constructor so I have
created this Constructor here which
accepts all the values and whenever you
call this particular object you will
have to specify three values and each
object will have the width height and
depth different Second Use case where a
consumer application wants the depth to
be constant with the value 10 and only
wants the width and height to be
variable for each of the objects then
this particular Constructor can be
called similarly for another consumer
application which would want to create
just Supply a single value and it would
want whatever value IT Supplies it would
want the height the width and the depth
to be exactly the same as that value
supplied then it will supply only one
value and the same value is going to be
set against height depth and
width and the fourth use case is where
the consumer application does not intend
to supply anything at all but it would
want the class to set some static values
for all of its objects so then it can
call this
Constructor and then I Define a behavior
remember the concept of behaviors I
Define a behavior here I have not
defined the gets and Setters here but
you can definitely do that there's
nothing stopping us from doing that but
for Simplicity I just skipped that here
then I Define a behavior to basically
this class will provide a behavior which
will be to create the calculate the Val
volume based on the values which you
supply so whatever value you supply
based on that the cuboid is going to
calculate the volume and as we know the
formula of volume is width into height
into depth that is how we are going to
calculate the volume of a cuboid based
on whatever values of width height and
depth are supplied so let's see this in
action I've created a public static void
main method I've initialized a variable
called volume which is an integer
variable we'll see how we can use that
variable and first let's create a
standard cuboid so I call this
particular Constructor with three
arguments so when I do this this
particular Constructor gets called and
the width height and depth values which
I Supply here three values will get set
and I get a standard cuboid and then I
can call the standard cuid do volume
then this particular method will be
invoked and the volume will be
calculated with this formula with these
values that's how we going to calculate
the volume for a standard simple cuboid
and I'm printing that volume value
exactly here so this is basically the uh
standard Constructor being called with
three arguments calling the volume
method and then just printing the volume
Second Use case where I'm calling the
Constructor with two arguments and the
third value should be set automatically
so I'm just supplying two values here
when I call the Constructor with two
values a matching Constructor should be
found here with two values here it is so
width and height will be set with the
values which I am supplying and depth
will automatically be set to 10 this is
what is happening here cuboid with some
defaults and then I again calculate the
volume and print the volume I'm just
reusing the same volume variable here in
the third use case I'm calling the
Constructor with a single parameter so
I'm just providing one value and the
same value should should get be should
be set against all the width height and
depth values and technically it becomes
a cube so I just called it as cube here
then I'm calculating the volume of the
cube and printing the volume of the cube
and then at last I'm using the
Constructor with the new arguments I'm
calling this as default cuboid because
I'm not supplying any values and then
I'm again calling the volume method on
this and printing the volume so these
are the four Constructor invocations so
this class is demonstrating four
different kinds of Constructor
invocations let's run this class and
observe the output
okay so let's start from here I called
this particular uh Constructor with
three arguments 10 20 and 15 and then
the volume was calculated which would be
10 into 20 into 15 which is 3,000 so
this sis out basically prints this
output then move on to the next one
where I'm saying cuboid with defaults
which is having the value 10 and 20 and
the third value of depth is
automatically being set to 10 so
technically when I call the volume it
will become 10 into 10 into 20 which is
2,000 and that's how the volume of the
cuboard with default depth is printed
from the line 47 going on to the next
one at line 51 the volume of the cube is
basically the volume which is calculated
after calling this particular
Constructor and calling the volume
method so here the height the width and
the depth all three are set to 10 so it
will technically be when we call the
volume method it will be 10 into 10 into
10 which is th000 and that's you get
this output which says volume of the
cube is th000 and then I call the
default cuboid method which is simply
providing no values and we expect
everything to be set with some defaults
and the default Constructor is setting
the value as 10 for height width and
depth so in this case if I'm calling the
volume method and if I'm printing the
volume it should be printed as th
because 10 into 10 into 10 is th000 so
this is basically to Showcase you how
you can use different Constructors
there's another thing which you should
know is if you do not provide any
Constructor to this particular class let
me just comment out all the constructors
in this class and let me comment out
most of the code here as well so now if
you see I have not provided any
Constructor in this particular class
right there's no Constructor let me just
maximize this so there's no Constructor
being called here there's no Constructor
being left here everything is commented
so there's no constru in this class but
this line still passes there's no
compilation error there is no red line
on this particular line the reason is if
you do not provide a Constructor to a
class Java by default will provide a
Constructor which will be the no
parameter Constructor so remember that
whenever you don't Supply any
Constructor you can still create objects
of that class with this
non-parameterized Constructor
representation like student student
equal to new student without any
parameters that will work if you have
not provided any Constructor
implementation inside your class and if
we do that let's see what what value do
we get because I have commented the
default Constructor everything here
right so let's print the value if I go
to run as I get the value as zero so
what happened here when I call this
particular line the default Constructor
provided by Java gets called and Java
will set the values of all the
properties to the default values which
are supported
by the data type an integer primitive
data types default value in Java is zero
if you do not provide any if you do not
assign a value to an integer variable by
default it is going to be initialized
with zero that's the Java's behavior and
that's what is happening here because we
did not provided a default Constructor
so when we called this new cuid here
without any parameters without any
arguments the default Constructor of
java gets called and it sets everything
with the default values which is 0 0 0
and then if we call the volume method
it's basically 0 * 0 * 0 which will
eventually be the output as zero and
that's how you get this zero output
let's try one more thing what if I
enable one Constructor let's enable any
one Constructor which is non which is
having at least one parameter let's say
this one so I have enabled one
Constructor I've have commented in I've
just removed the comments from one
Constructor which takes a single
argument and let's go down now you see
an error so this is something again a
Javas behavior that if you provide even
a single Constructor in your class which
is non which is having at least one
parameter I just repeat that if you
create any Constructor in your class
which is having at least one parameter
then the default Constructor
implementation of java will not
automatically work in this case you will
have to explicitly provide a default
construct constuctor as well the default
Constructor will only and only work if
you have not provided any Constructor at
all in your class the moment you provide
even a single Constructor which is
having even a single parameter in your
class then the default Constructor out
of the box will not work and you will
have to explicitly provide a default
Constructor so to make this work I have
to just enable the default Constructor
code and then only it will pass so if no
Constructor it will work without any
parameter but the moment you provide
even a single Constructor with even a
single argument then you have to either
use that parameterized Constructor or
you have to provide your own default
Constructor implementation because Java
will not use its own default Constructor
implementation in that class so I hope
you find this particular concept useful
and remember this concept because this
is again uh this can be confusing when
you are reading somebody else's code you
need to always understand what all
Constructors are there and in the next
session we are going to talk about
another very interesting and exciting
Concept in Java which is about streams
let's get started with streams in Java
before I go any further I just wanted to
clarify that when I say stream I am not
talking about the input output stream
but I'm talking about stream as a
concept in general this is a slightly
newer concept which was introduced in
Java 8 and has been there and it is
extremely popular and the reason Java
introduced this the concept of streams
to to the jdk was to promote the
functional programming Paradigm what we
have been seeing so far is basically an
objectoriented Paradigm where you
execute one line at a time but
functional programming provides you more
optimized way to run multiple lines of
code with a as a sequence of functions
in a single line so the same lines of
code which you would write in Java in an
in a classic objectoriented way in like
let's say 10 lines the same line of code
the whole 10 lines of code can be
written in a single single line using
the functional programming Paradigm so
let's understand the concept of streams
first so the basic concept of streams is
to help you iterating and manipulating
collections so remember all the classes
which we covered in the collections
framework the list the set the map Etc
streams provide you with a better and
optimized way to basically allow you to
manipulate those collections iterate
over those collections change the
representation of the collection types
at Etc so to understand why we need
streams let's understand what is how the
streaming works so let's take a very
simple example if you if you watch a
YouTube video it is B basically streamed
to your device and when we say stream it
means the whole object the whole video
size is not downloaded at once on your
device and it is being downloaded bit by
bit to your device piece by piece to
your device this is better in lot of
ways your device does not need the full
memory to store the complete video
because it is only going to process one
BTE at a time and just throw it away
once it has been watched so the
streaming will basically help you work
on a very large size item in a using a
very small memory footprint That's The
Power of streams contrary to that you
can also let's say if you if you're
watching a 1 gigabytes video then you
can either download the whole 1 GB video
on your mobile which is going to consume
complete 1 GB space on your memory or
you can stream that 1 GB video onto your
mobile device where maybe only a few
megabytes will be required to watch the
whole video because at a time it will
only consume few megabytes and it does
not need 1 GB of complete space to
stream that video so that's the basic
idea and that's why streams are very
popular and very optimal way to work
with Collections and let's understand
with the help of an example actually
I've prepared multiple examples of
multiple capabilities of the streams API
so streams is basically an API which is
provided after Java 8 and you can use
that to iterate over collections or
manipulate collections let's see that
and let's also compare that with how you
have been doing this before Java 8 so
here I have created a list you can see
it's basically an integer list and I
have created an array list here I have
added few numbers to this particular
array list so numbers are 10 20 30 and
40 so precisely four elements are
inserted into the list now you have a
requirement in your project that you
need to basically calculate the square
of each of the elements of the list and
prepare a new list that is the
requirement so if you were not using
streams you would write code something
like this you will initialize the list a
new list basically which will which you
can call it as anything for example you
can call it as squares list and then you
are going to call an enhanced for Loop
here iterating over the numbers list one
by one taking each element calculating
the square of it and then adding that
element to the new list and that's how
you're going to write this logic if you
were not using streams so you can see
it's basically technically 1 2 3 four
lines of code just to get the list if
you were using streams then you can do
this with a single line let me just
comment out the old old code and let me
just bring this to the same line to show
you that it's a single line code so the
same logic which you wrote here can be
written just like this you can see it's
so optimal so simple for the processor
to compile this code is also very fast
because they can process a single
instruction very fast and very quickly
and streams do utilize the multi-core
capabilities as well so now is the time
and the and the era of multicore
processors and that's why streams are
more beneficial to use rather than
writing the verbos instructions so let's
understand how this works to convert a
particular collection into a stream you
need to call the collection type. stream
so here the numbers list was the
collection variable so once you call
this do stream you will get a stream
representation now the elements of the
list are being streamed one by one they
are not being sent at all at once they
are streamed one by one now so you get a
stream the moment you call stream then
now the stream API has multiple methods
utility methods which you can read about
for example if I just write a DOT here
you will see lots of utility methods
which the stream API provides you which
you can use in different conditions we
are going to cover few of the very
important and very popular methods but
again please do read out the streams API
documentation to get the hang of all the
other methods so once we have the stream
then the first method which I'm going to
Showcase to you out of the stream API is
the map method map method can be used to
change the representation of the
elements one by one and that's what we
need to do right we need to change the
representation of these elements to the
square of these elements
so remember that that line which I said
whenever you have to change the
representation of the elements inside
the collection think of map think of the
map method this is not the map
collection this is not the map
collection this is the map method of the
stream API so if you're using stream API
you have a use case to convert the
representation of the elements of the
collection think about Maps always so I
call the map method here and then you
see the strange syntax here this is
basically a lamp Lambda function syntax
so Lambda function is another concept
which Java introduced in Java 8 Lambda
is as a concept has been there in in
some other programming languages like
Scala for a very long time but it's been
introduced in Java of late in Java 8
only and Lambda is basically you can say
is the Paradigm which will enable you to
write functional programming constructs
in Java and the syntax of Lambda is very
straightforward you provide a
representation of the element here so
each element here 1 by one is going to
be represented to X then you write this
Arrow here basically a hyphen and a
greater than sign and after that you
write what is the final value which you
want to see for that particular element
so here my requirement was that I want
to convert the representation of the
element to the square of its element so
I just do X into X because X is the
current element I want to change this to
this so whatever destination
representation you have in your mind
write that on the right hand side of
this arrow on the left hand side it will
be the element on the right hand side it
would be the representation which you
want to work with so you have written
your conversion logic inside the map
method with a Lambda function
representation under the hood if you
want to know more technical details
about it it's basically working on the
concept of functional interfaces do read
about the functional interfaces concept
as well that will help you build the con
the usage of Lambda functions and how
this whole construct is return so read
about function interfaces and Lambda
functions to understand map in detail
and but but for to to work with it like
I said this the left hand side will be
the element and the right hand side
would be the uh final representation
which you want to have for that
particular element once you have done
that still this till this particular
point you have converted the collection
into the stream it is streaming the
elements one by one and you have
successfully also calculate calculated
the square of each element but this is
still a stream now you need to convert
this stream back to a list which can be
used further in your program so to do
that you can use the collect method
which we also call as the terminal
methods this is another concept which
I'm just introducing to you right now so
there is an intermediate method concept
and there is a terminal method concept
this is what streams understand Java
stream understands when you say
intermediate method those methods are or
those operators are basically the ones
which are used before the final
collection is prepared like the map
method is basically a intermediate
operation and then you have some uh
terminal operations like collect once
you call the terminal operations after
that the stream has been concluded the
stream is dead so once you call this
collect method and if you try to do
something here again let's say if you
want to do something it will not work
because the moment you use the collect
method stream will expand this to be the
last method which you want to use in
this particular instruction after that
the stream is dead and you will get
strange exceptions if you try to write
any further operation after collect so
do so also do read about what are the
all the different terminal operations
available and what are all the
intermediate operations available I'm
going to cover a bunch of these in this
in the different examples I prepared in
this particular class but because I will
not be able to cover all of the methods
so do read about those methods what are
the intermediate operations and what are
the terminal operations and the concept
I just explained you intermediate
operations can be used in in a in a
chaining fashion after this map you can
use another dot map another dot map
another dot map you can again like like
do this this will this will work fine
you can keep concatenating multiple map
methods and multiple filter methods and
any of the other intermediate operations
which are available but once you have
called the collect method after this you
cannot call another map if you try to do
this it is going to fail it will not
work because collect is a terminal
operation and what I want to do in the
terminal operation is I want to convert
this new stream which is having the
square of the elements convert that back
into a new list and to do that I can
call the collectors. to list method the
moment you write this method inside the
collect method it is going to take the
stream of the elements one by one just
collate that stream into a single stream
into a single collection and then return
that collection back into the list which
you want to store is it in so remember
the collect method terminal operation
and the moment you you do collectors. to
list the whole streams elements is going
to be uh converted into a list and that
list is going to be stored into whatever
leftand variable you have written and
that is how you can basically write this
whole code which we wrote in four lines
into just a one line and then you can
print the squares list so let's do that
let me comment this particular code as
well so that we don't get any strange uh
errors or strange outputs let me comment
this part as well we will cover this one
by one and let me cover all of this as
well I'm just going to comment
everything here and we'll focus on only
the square list which we have prepared
using the streams API so right click run
as Java application there you go you
have the output here so the first number
was 10 the square of it is 100 so yes
you get 100 second number is 20 the
square of it is 400 third number is 30
the square of it is 900 fourth number is
40 the square of it is 1,600 so you get
all the values squared by using the
stream API and like I said you can write
the same code in the old way as well but
this is the efficient and the better way
of writing the same code in a single
line this is all I wanted to cover in
today's session let's get started with
streams API in Java in the previous
session also we covered some basic
functionality of the streams API of how
we can convert a list of numbers into
the squares of the numbers of the same
list today we are going to look at an
extension of the same kind of
functionality let's say you have a
requirement where you have a list and
you are asked to convert that list into
a set and while you convert the list
into set you also have to calculate the
square of each number so instead of just
converting the list of numbers into a
set you have to convert the square of
those numbers into a set collection that
is our objective so I'm going to use the
same list which I had created in the
previous example which you can see see
here I have a numbers list and I've
added four elements to it 10 20 30 and
40 and then if I did not have to use
stream or if I did not have the option
to use stream this is how the code would
look like where you would explicitly
create a set of type hash set and then
you will iterate over the numbers list
and then you'll pick each item of the
numbers list and multiply it by itself
hence calculating the square and then
you will be adding those that that
result into to the destination set this
is what I'm doing here just to show you
the different comparison of how do you
write it in the classical way and then
in a while we will look at how we can
write the same kind of functionality
using the streams API so let's first run
this particular approach where I'm
adding all the square of all the
elements into a set which is a hash set
type so the order of the set is not
guaranteed because I'm using a hash set
and then I'm just printing the hash
setet so let's try to run this program
so I go to run as Java application
and I get the output and you can see if
you look at the list here the results
are not in the same sequence in which
the elements were added into the list it
is because of the nature of the hash set
but we do get the result as expected now
if I have to write the same kind of
functionality using the streams API then
this is how I will write it I will just
uncomment this one and will comment out
this one so now if I look at this new
code it's doing the exact same thing but
in a functional programming approach and
using the streams API approach so I'm
again calling stream hence converting
the list into a stream then calling map
which is to use to uh change the
representation of the elements of the
collection so I'm changing the
representation from the single number to
the square of it and then calling do
collect which is a terminal operator
where I'm converting this stream into a
set by calling collectors. two set so
two set is the method here which is is
going to convert this into a set and
then I'm printing the square set so
let's run this program and observe the
output if I run the program I get the
same output so I can achieve the same
kind of functionality but much more
efficiently using the streams API so
this was an example where I could use
the collectors. two set method to create
a set out of a list now let us move
forward to another interesting and very
popular functionality which is filtering
so let me comment this code again so
that we don't get multiple outputs and
let me uncomment this code
here so what I'm doing here is I'm
creating a list of languages which is an
array list and then I'm adding three
elements to this particular array list
which are Java Python and Scala and this
is a string of uh the list of strings
here so I'm adding three strings here
these strings can be anything I've just
taken the example of programming
languages here but this can be anything
so technically we have a list of string
objects and then my task is to get a a
new list out of this existing list which
will have the elements which start with
the letter P let's say that is your
requirement that you have to get only
the elements of this list where the name
of the element starts with the letter P
if that is your requirement probably
this is how you will be writing the code
if you are not using the streams API
where you will create a new list an
empty list basically and then you will
iterate over the old list which is the
languages so you will iterate over the
languages list and then you will pick
the each element of this particular list
and check if that string starts with the
letter P if yes then you will add that
particular uh string element into the
new filter list by calling the add
method and then you can print that
particular list that is how you will be
doing it if you were not using streams
so let's run this program and understand
the output so I'm again going to right
click run as Java application and the
output I get is python because that is
the only string in the list which starts
with the letter P so we get the expected
output now let's try to write the same
code using the streams API so let me
comment this code and I will save the
file and let's look at how we can do the
same thing in a single line using the
streams API so to use to write the same
kind of logic using the stream API I we
start with the same kind of syntax where
we take languages. stream to convert the
list into a stream and then we call a
new method called filter so filter is
the method which you will be using
whenever you have to write any
conditional Logic on all the elements of
the list remember whenever you have to
write a filtering or a conditional Logic
on a particular list then you will be
using the filter method of the streams
API so you will convert The Collection
into the stream and then you will apply
the filter method to apply the condition
this condition can be anything in this
case the condition is that the elements
should start with P it can be anything
for for example it can be based on the
string length if you want if it's a
numbers collection it can be if a number
is greater than 100 or not so any kind
of if logic which you might have to run
on a particular collection can be run
using the filters method so we call the
filter method and we again follow the
same Lambda function syntax where we
here this particular s denotes each
element one by one and this Arrow
represents the Lambda notation and then
what we want to do that we want to run
this condition on each of the element of
the stream 1 by one and the condition is
that the element should start with the
letter P if that is true then whichever
elements satisfy this particular
condition will be getting out after this
execution so the block which I've
selected once the filter method has
completed its execution after that only
the elements which have satisfied this
filtering condition will be left in the
Stream rest of the elements have been
filtered out so once you have the
filtered result then you can again call
the collect method which is the terminal
operator and you call collectors. to
list same as the example in covered in
the previous session so I'm running the
filtering logic and getting a new list
which will have only the elements which
satisfy this condition so I get the
collectors two list result back into a
new list which is called filter result
and then I'm printing the filter result
so let's see if we get the same kind of
output if we use this logic yes we do
get the same kind of output and this is
something which validates how we can use
the filter operation seamlessly by
applying exactly the same kind of logic
which we used to apply by writing this
much verbos code another benefit is that
the streams API are more efficient in
using the multicore processors which are
common now days on any machine so this
is all I want to cover in today's
session I don't want to elas this
session to be even more longer so we
will conclude today's session at this
particular point and in the next session
we are going to have a look at some more
functionalities of the stream API seeing
how we can sort the collections how we
can iterate over the collections because
even this code is a bit too much for the
uh for for the streams API to iterate
over a collection so we will look at a
smarter way of the streams API by which
we can rate over the collection we will
also have a look at how we can sort
collections let's get started with how
we can use the streams API to sort
Collections and also to iterate over
Collections and I'm going to use the
same collections which we have used in
the previous sessions just to build some
sort of continuity here so I'm going to
use the same array list which I created
in the previous session which is storing
a string of elements which is having
three strings which is Java Python and
Scala these these are just three strings
which I'm storing into a list which is
called languages and now my task is to
sort this particular collection I have
to sort the elements of this particular
list so that when I access the list I
get the elements accessed in a natural
sorting order so I should get the result
Java first then python as a second
result and Scala as the third result
let's make it bit more interesting let
me put this at the beginning so now I
have an let element starting with s
being added first then an element
starting with J being added second and
the third element being added which
starts with p let me add one more string
to it just to make it bit more
interesting and practical so let me add
a new language here which can be let's
call Basic so now I have four elements
Here and Now I want to sort this
particular collection so for sorting
streams API provide a very
straightforward way to sort any kind of
collection which is to use the dot
sorted method and we will follow the
same kind of semantics which we have
followed in the previous session which
is you pick the current collection call
the do stream method on it which will
convert The Collection into a stream and
once the stream has been created then
you call the do sorted method on the
stream which is going to sort all the
elements of the stream in a natural
sorting order remember we are using
strings here so Java already knows how
to sort strings if you were using a
custom class let's say list of students
or list of customers then you have to
specify your sorting implementation to
Java because Java doesn't know how to
sort customers or how to sort students
so you in that case you will have to
provide your own sorting implementation
and we will cover that in the upcoming
sessions but for now let's understand
this example by using one of the
pre-built data types which is string and
we call the do sorted method which is
going to sort this particular stream and
then we use the terminal operator which
is do collect to convert this stream
back to a list and we do that by calling
collectors. to list we do that and we
get the list out we store that list into
a variable called sorted list and then
we print the sorted list so let's run
this program and understand the output
remember that we have these strings
added here so right click run as Java
application and this is the result I get
I get basic as the first element when I
get the new list which has all the
sorted elements then I get Java with a J
then I get python with a p and then I
get Scala with an S so you can see that
these strings are presented in a natural
sorted sequential order here and that is
what is happening because we call the
sorted method and this is how you can
use the streams API to sort any kind of
collection hope this is helpful to
understand the concept of sorting now
let's move on to another concept which
is about how do you iterate over
collections using the streams API we
already have a way of itating over the
collections using the enhanced for Loop
remember we covered this at length in
different sessions in the past so we can
definitely use this particular logic it
doesn't break it will not stop us from
using this we can still continue using
the enhanced for Loop logic to iterate
over any kind of collection but streams
API provides even a smarter way to
iterate over the collections let's see
how we can do that so let me uncomment
this particular code here and now if I
look at this particular code and if I
try to understand it I will see a sort
of similarity with the way we have been
working with streams so we'll follow the
same drill we'll pick up the existing
collection call the do stream method on
it this is going to convert The
Collection into a stream and then we
call Dot for each method this is the
method which you need to use whenever
you want to iterate over a collection
using the streams API so we call the dot
for each method again follow the same
Lambda construct where this is each of
the element y represents each of the
element here and then I write the code
which is supposed to be executed for
each element so in this case I want to
just print every element that is my
requirement when I'm iterating over this
particular collection so I can just put
this Arrow here let me put just spaces
here to make it more legible so each
element should be applied this
particular Logic on and we are printing
each of the element one by one if I do
that let's observe the output and let me
comment this particular code which we
just covered for the Sorting logic so we
get only one output let's run this code
now so here we see we get some output
here uh first of all this sis out gets
printed which says printing all elements
one by one yes that's there and then
here we are saying element is which is a
static string and then every element one
by one is supposed to be printed and
that is what we see here we get all the
elements one by one and here it's not a
sorted order because we are not doing
any sorting here it's just printing all
the elements so this is how you can use
the for each method to iterate over any
collection in a single line of code
instead of writing all of that code now
you might be wondering what if I do have
to I have to do more than just printing
the element what is it is a multiple
lines of code which I have to run for
each element how do I do that it's
pretty straightforward we just put curly
braces here in the starting and in the
end of the code block inside the for
each method and let me just put an enter
here just to make it more readable so
here you can write the code whatever you
want to in terms of the kind of logic
you want to apply on each element so
once you have have put this curly braces
you can write as many lines of logic as
required inside this code in inside this
curly B braces block and this code is
going to be executed for each of the
element one by one if you have just one
line of code you do not need to and you
should not put the curly Braes if it's
just one line of code just drop this
curly Braes completely remove the
semicolon as well along with the curly
bres and this is how you will run a
single line of code but if you have a
multiple lines of code which suppose
which is required to be run for each of
the element then you put the curly
braces and then you follow the normal
Java construct which is to end every
statement with a semicolon the usual
Java programming code basically which
can go inside the curly bra so that's
how you can use for each for any simple
and complex iteration logic which you
want to apply on a particular program
and this is all I want to cover in
today's session so we talked about how
we can use the do sorted method to sort
a particular collection and we also had
a look at how we can use the streams API
for each method to iterate over the
collections in the next session we are
going to talk about a very interesting
method of the streams API and a very
popular one which is called the reduce
functionality let's get started with
using the reduced functionality in the
streams API before we go to the
implementation of the reduced
functionality let us understand why do
we need it and how the constructs of the
reduced functionality work so let's
understand first about the requirement
why do we need it so imagine a
requirement where you have a list of
numbers and you are asked to calculate
the sum of all the elements inside the
list a very straightforward requirement
that you have a collection and you are
asked to calculate the sum of all the
elements of the collection now if you do
not use the streams API you can go ahead
and very well write a complex for each
logic or enhanced for Loop logic to
basically run that code and write the
logic where you pick one element all the
elements one by one and keep adding them
to the new element but we can do the
same kind of thing by using the reduce
method and to put it in a generic way if
we have to understand why we need reduce
methods so whenever you have to change
the whole collection representation into
a single result remember that line
whenever you have to change the
representation of the complete
collection into a single result in those
cases you will use the reduce method of
the streams API and if you apply this
definition to the example I gave you I
have a collection of numbers and I want
to calculate the sum of all the elements
of this collection which is a single
result which is a single number so yes
my example does apply correctly to the
generic definition of the reduced method
so remember this generic definition this
will help you understand when to use
this the reduce me method in your
program so how does the reduce method
work you can see I have shown you an
example of the syntax of the reduce
method and it looks a bit complex here
so let's try to understand what is
happening here to understand the
functionality of the reduce method we
have to understand three terms which are
identity accumulator and a combiner
let's understand each of them one by one
identity is basically an element which
is the default or the initial value of
the reduction operation this value will
be used if the stream itself is empty or
it will be used as the first value of
the result which you want to get out
eventually so in this case if I have to
summate all the elements of a collection
the initial value can be set as zero and
that is the first thing which you have
to pass inside the reduce method so you
can see Zero here the next thing is the
accumulator so accumulator is is a
function which will take two parameters
the first parameter would be the ongoing
partial result let's say if you have to
calculate the sum of the all elements
and let's say if you have iterated two
elements so far so the sum of those two
elements is your temporary or partial
result right so you need to store that
partial result somewhere and that is the
first argument of the accumulator method
in this case it is this variable which
is shorthanded as a ANS or answer
so the first argument is the partial
result and the second argument of the
accumulator function is the next element
of the stream so whatever the next
element is which is supposed to be added
to the existing result is going to be
the next argument of the accumulator
function which is I in this case so we
talked about the identity we talked
about about the accumulator function
then we have a third one which is called
combiner and this is sort of an optional
not in all cases but in some cases it is
optional let's understand why do we need
combiner so combiner is an optional
function which you will be required to
use if you want to sum the two elements
which do not have the same data type
what I mean is here this a ANS or answer
and I both are integer if both of the
arguments of your accumulator function
are of the same data type you do not
need a combiner and that's why there's
no combiner here
but if there is a requirement where you
are let's say adding a a current sum to
a student object then it doesn't work
right because a student object is a
custom object and the current sum is a
number object so a student object cannot
be just added to a number object it can
work if you can do student. get age
which is a number object so a current
answer plus the student. get age might
work but current answer comma student
will not work in those cases where you
you have mismatching data types in those
cases you will have to write a combiner
function but for this case you don't
need to write a combiner function
because both of the elements or the
arguments of the accumulator function
are of the same data type so you specify
that argument function functions
arguments basically and then you provide
the implementation of the accumulator
function which is this one this is the
implementation again using a Lambda
construct here so you provide the
implementation of this particular
accumulator function and then there is
no comma here to provide further com
combiner functions specifications so
there's no combiner here if there was a
combiner there would be a comma here and
then you will write the combiner
specification where you will cast the
current object into the type which is
the same as the partial result so you
don't need that here and you can just
say the partial result plus the current
element and that should work fine so
this is how you will write the reduce
logic and if you have written this logic
correctly then it should automatically
ially just Summit all the elements one
by one and produce a single result and
remember I'm using the numbers list here
which is written here in the very
beginning where I have four elements to
it which are 10 20 30 and 40 so if the
reduce operation works fine with with my
intended objective then 40 + 30 which is
70 + 20 is 90 + 10 is 100 so I should
get the 100 as the as the final result
of this reduce operation you will also
notice that after this particular method
you don't need to call any collector
method or any collect method at all the
reason is because this particular
function itself will return a single
result which you can store in the
desired variable so now let's try to run
this particular example and see the
output so right click run as Java
application and I get the result as 100
which is coming from this particular sis
out where I'm printing the sum so yes
this is working as per our expectation
where it basically at created the sum of
all the elements of this particular
collection so remember when you will use
the reduce operation remember the
generic definition whenever you have to
convert the whole collection into a
single result that would be the use case
where you will use the reduce operation
that's one thing remember the identity
operators definition remember the how
the accumulator function works and also
remember when to use the combiner
function a reminder of when to use the
combiner function is whenever you have
these two AR ents of different data
types that would be the use case where
you would need to write a combiner
function it is also used if you have to
write parall streams but parallel
streams is an advanced concept which we
are not covering in this particular Tut
but if you want to learn about the the
whole parallel stream concept do check
out the API dos for that and you can
also have a look at some examples from
the Java tutorial official website
itself and that's all I want to cover in
today's session in the next session we
are going to talk about the access
modifiers in Java let's get started with
access modifiers in Java so when we talk
about access modifiers let's understand
what is the underlying philosophy of the
reasoning behind this and the reasoning
is very straightforward it can be even
wrapped into a single word which is
called security the reason is that you
will be creating multiple kinds of
objects and variables while you write
your Java program and you should always
write your Java program or any program
in a manner that only the intended
classes packages modules or applications
should be able to see what they're
supposed to see so as a consumer
application I should only be able to
consume the variables which I am
expected to consume I should not get any
variable or I should not even have
access to any variable which I am not
supposed to access so the idea is
providing the least privilege principle
give access to different different
functions different variables different
programs only by providing them the the
kind of access which they need to run
run efficiently and do not give them
complete access so with that notion in
mind Java created the concept of access
modifiers and it created these three
modifiers which are called public
protected and private if you do not
provide any modifier then it goes to no
modifier or some people also call it as
default modifier which is also a type of
access ifier so let's understand
theoretically first how it works and
then we will try to have a look at an
example let's understand the first one
first of all these modifiers are
keywords and you can use these keywords
in front of classes in front of
variables and also in front of
methods and you might have already
noticed this particular keyword called
public in front of all the classes I've
created or even when we talked about the
public static void main method we saw
this public as a keyword word it is
basically an access modifier and
whenever you put public in front of a
class or a variable or a method that
particular component becomes available
to the whole of the program it will be
available to the whole world basically
any subass or any package or any other
class which might have been written in
your Java program will be able to access
that particular class or variable or
method if you put public in front of
that the second modif fire level is
protected one of the other thing which
you you will understand as I explain
this is that as you move down into this
particular table the access level will
start getting more and more restricted
and by restriction I mean that less and
less components will be able to get
access to those modifiers so if you
write protected in front of a class or
in front of a method or in front of a
variable then everything within that
particular class will still be able to
access it everything within the package
will still be able to access it I still
haven't covered the concept of package
but I briefly touched upon it showing
you how whenever we write a class we
have a package in front of it and
package is technically is just an
aggregation of the classes if you have
to write write multiple classes and wrap
all of those classes into a single
logical bundle that would be called a
package just to show you an example
these all are packages which you see
here you see this Square box here and
you see the these names these all are
packages and these packages contain
multiple classes and technically that's
all the packages mean that you can wrap
multiple related classes into a single
package so coming back to the access
modifier whenever you write protected in
front of a class or a variable or a
method then that particular component
will be accessible to everybody within
the same class everybody within the same
package it will also be accessible to
everybody which is a subass class of the
class this is again A New Concept which
I have not covered but this basically
means a child of this class now what is
a child of the class we will cover at
that Concept in detail when we will talk
about inheritance but for now you can
understand that it is a basically an
extension of the class so when the
moment you declare something as
protected it can easily be accessible
within the same class in which this
protected component was declared it can
be accessed in the package it can also
be accessed in the subclasses of the
class but anything outside the package
will not be able to access it because
you see an N here then we have the
default access modifier or no modifier
if you do not write anything in front of
a class or a method or a variable it
gets the default access modifier
Privileges and that privilege mean that
anybody within the same class will be
able to access that default variable or
a default component anybody within the
package will also be able to access it
the sub classes of the class where the
default component was declared those
subclasses will not be able to access it
and anybody outside the package will
obviously not be able to access it then
comes the last one which is the most
restricted privilege which is called
private so if you put private in front
of a class or in front of a method or in
front of a variable that component will
only be accessible within the class
where it was declared it will not be
accessible in the package it will not be
accessible in the sub classes and
definitely not be accessible to anybody
outside the package so private is the
least privileged or least access
permission level you have in Java once
you write private in front of any
component that only the the classes
other variables the the same class in
which you declare this particular
private variable only that class itself
will be able to access it and nobody
else will be able to access it and as
you move above the accesses become more
and more linear you can see there's just
one y and 3 n here the moment you move a
bit above to the default modifier you
get two y's so everybody in the class
and everybody in the package will be
able to access that particular component
rest of for the rest of the other world
it is still a no when you write
something as protected then everything
in the class everything in the package
and everything in the sub classes will
also be able to access it rest of the
world cannot access it and if you write
something as public then anybody can
access it it's like y everywhere so so
that is how the access levels work now
let us understand this with the help of
example so I will go here and I've just
written a very simple dummy class here
which has a which is a class called test
and I have a method here which is a
display method so very simple class
nothing fancy here and if you if you
notice I have not put any kind of public
private or uh or protected modifier in
front of the class so this will get the
default privilege if something has
default privilege then the whole world
will not be able to access it so let's
go to a different package let's go to
this package which is here and let's try
to access this particular test class so
we will try to access this test. Java
here in the main
class so let's try to do that let's say
test t equal to new test I'm just
initializing the same class so what do I
get I get a compile error let me try to
fix it if I can and I cannot fix it if
you see I'm just trying to use this
particular test class into a different
package but that package is not able to
see the class at all I'm getting a
compilation error and if I try to click
on the error generally Eclipse provide
me suggestions to fix the to import this
particular class but eclipse is not able
to fight find any class with the name of
test which can be imported in this
package which is a different package
than the one of the test class so we
cannot access it because it's in the
default access now let's go back to the
test class and let's make make it public
so I've just made it public here and now
if I click on this again I get the
suggestion if you see this suggestion
was not there earlier now it says import
test and if I click on this double click
it gets imported and everything is happy
so you can see the whole access modifier
in effect here the default versus versus
public you can also try the other other
kind of uh access modifiers let's try
private as well I think private will
also have the same effect because it
will still not be accessible from the
package or from the subass or from the
from the whole world we already saw this
particular in effect but we'll we'll see
the private in a in a different way now
so going back to the test class I've
made the class as public but the method
here is default I've not exposed this
method to be used outside the class
let's see what happens if I try to call
this display method from the main class
so I have successfully initialized the
class and if I say t Dot and if I look
at the suggestions here I do not get the
suggestion of the display method why
because it is default if I go back make
it private can I now access it let's try
again nope still we can't access it
eclipse is not even able to find it
inside this package because it is
private let's go back and make it public
so I've made it just public now going
back to the main class and again saying
T dot now I get that display suggestion
as the first suggested method here and
now I am able to use the display method
once I have made it public so you see
the moment you change the uh the access
modifiers the changes are are propagated
immediately and you can see the public
versus default versus private in play
here we can even go into further detail
by using the protected but for protected
I have to explain the concept of sub
classes so I will cover this protected
versus subclasses concept when I talk
about inheritance and there we will see
the usage of protected variables and the
protected access modifier but we saw the
usage of public the default modifier and
the private modifier do check out the
documentation for these access modifiers
and I would strongly suggest you to play
around with this get more comfortable
with these concept of different kind of
modifiers let's also run an example for
for understanding the default modifier
in a better sense because we can see
that for the package it says why right
so let's go back to eclipse and within
the same package where we created test
class let's create another class let's
call it test
demo so I will just click finish I get a
new class let me also write the public
static void main method here so I get
the public static void main method here
and let's try to access the test class
here within the same package so let me
again go back to the default privilege
here so I put the test class access as
the default class or default access and
same goes for display so can other
classes in the same package access
access the test class now let's see that
if I go to test demo and here if I try
to get the test class initialized does
it work or does it give me a compilation
error yes it works it works because the
test class and the test demo are in the
same package and test class has that
default access uh privilege so let's try
to run one more variation of it to
understand the usage of the private
method better going back to the test
class this display method has the
default privilege right now
so going by that logic if I say t dot I
should be able to get access to the
display method and yes that is possible
if I run this particular program I will
be able to get whatever is given out by
the display method which is hello world
now let's try to make this particular
method as private and let's try to
access this method from one of the other
class in the same package as of the test
class the class is default the method is
private and if you see this class has
already turned red there is a
compilation error because now the
display method is not accessible to the
test demo class even if it was in the
same package it's not accessible because
the display methods privilege or access
modifier has gone to private now exactly
the same as explained here because it
has become private so the package level
members cannot access it there's an N
here so this is this was another
variation to show you how you can use
public protected and private together to
only expose the members methods and
classes which are supposed to be exposed
to the consumer this is a very critical
and very important concept to be used in
Java and it is used from a very simple
program to all the highly complex
application this is sort of the bare
bone or the found laying foundation for
any kind of basic security level premise
which you need to build in an
application so that's all I want to
cover in today's session where we
discussed about the different access
levels in the next session we are we
going to talk about the concept of
inheritance let's get started with
inheritance so inheritance is basically
one of the most important properties of
any object-oriented programming language
it's basically a concept and the concept
says that what if you have a scenario
where you want multiple classes to share
similar behavior and similar properties
let's understand this with the help of
an example let's take the example of a
bank when you go to a bank to open an
account there are multiple types of
accounts there can be a savings account
it can be a type of current account
there can also be a different offering
for personal account and Commercial
account such as for businesses then you
may also have loan accounts which are
having different kind of properties so
all of these types of accounts are still
technically accounts and they will share
some similar properties for example all
of them will have to maintain some sort
of an interest rate for example all of
them will be used to either deposit
money or withdraw money so there would
be some kind of similarity across all of
these types of account classes but at
the same time there will also be some
sort of differentiality amongst these
classes the way you will calculate the
interest rate for a current account will
be different from the way you will
calculate the interest rate for a
savings account and the same applies for
commercial account personal account Loan
account Etc so you see that we have some
common Behavior but at the same time we
also have some different Behavior so
whenever you have such scenario always
think about applying the concept of
inheritance in your application there's
another simple way to spot whether
inheritance can be used at a particular
place or not inheritance is also called
is a relationship so whenever you read
the requirements from a customer just
try to find the words which use this
particular phrase is a for example car
is a vehicle savings account is a type
of account similarly you will find many
other types of similar examples so
whenever you will see that is a
relationship between two different kinds
of objects or two different kind of
entities that means that there might be
an inheritance relationship being
applied between them and that's how you
will spot the usage of inheritance so so
far we have understood this concept that
there would be some sort of relationship
between the two classes what will be
this Rel relationship the relationship
will be of parent child type there will
be a parent class some people also call
that as base class and then there will
be a child class so the child class will
be inheriting the properties and the
behaviors from the base class or from
the parent class I will be using Base
Class and parent class terms
interchangeably during this session but
the basic idea and basic premise is like
that only that there will be a child
class and there will be a parent class
and the child class class is EXT
extending from the parents class
remember the word extend because we are
going to use that and I've just shown
you the uh what you see here is
basically the official definition which
is given by Java docs here we can read
the definition as well and the basic
idea which I told you lies in the parent
and child relationship and this is how
you can conceptualize it that you will
have a base class or a parent class and
then you will you can have multiple
children of it and then those children
can again have their own children and so
on so forth so this hierarchy this whole
inheritance hierarchy can go as deep as
you want it to be and that's the basic
idea and basic conceptualization of how
you understand and how you visualize
inheritance now let's move to Eclipse
IDE and try to understand this with the
help of an example so for this
particular case I have created a set of
classes basically which we will be using
to demonstrate the relationship of
inheritance and I've taken the simple
example of of a bicycle so a bicycle is
again a very generic definition of any
two- wheeler and bicycles can have
multiple types there can be an all Teran
bike there can be a mountain bike there
can be a city bike there can be a bike
which is specific specifically made for
ladies and similarly there can be
multiple different types of bikes but
all of these bikes will have some
similar properties for example all of
them will have two wheels all of them
will have a seat all of them will have
break all of them will have some sort of
of some sort of speeding mechanism
whether they can accelerate or de
accelerate so there will be some
commonality but at the same time a
mountain bike's features might be very
different from a city bike feature a
mountain bike features might Fe mountain
bike might have gears for example
whereas a city bike might not have gears
because you don't need that much of a
variation in in inclination and
declination when you drive down the road
so so I'm trying to conceptualize the
same example here where I've created a
class called bicycle and this is my base
class I Define two properties in the in
the bicycle class which is gear and
speed we will come back to protected in
a while but let's let's leave that there
so I have two properties which is gear
and speed I have a Constructor where I'm
initializing the starting speed and the
starting gear and then I have three
methods here which says set gear apply
brake and speed up when I apply break
the speed is going to get reduced so
that's why you see minus equal to Unity
operator and when I'm trying to speed up
the speed is going to increase that's
why I'm using the plus equal to un
operator so when you use the method
speed up the speed is going to be
increased by the value you supply in the
method similarly when you apply the
break the speed is going to get reduced
by the amount you supply in the method
argument and that is my Base Class
bicycle gear speed and three methods now
let's have a look at the child class so
the way you will Define The Inheritance
relationship in Java is by using this
extends keyword remember I told you to
remember the extends keyword so what you
will do that you will write your class
name as usual and then you will use
extends keyword and then you will use
the parent class name or the Base Class
name so here I'm saying class mountain
bike extends bicycle and here I'm
providing an additional property
remember the whole commonality versus
differentiality equation so a mountain
bike might have an extra property to
adjust the seat height so that's the
extra property which mountain bike is
having and then since this mountain bike
is extending the bicycle class this
mountain bike class has the
responsibility to initialize the bicycle
class as well and the way it will
fulfill that responsibility is by taking
all all the arguments of bicycle class
plus the mountain bike class in its
Constructor and that's why you see three
different properties here you see the
start height property which is the
property of this particular class which
is the seat height and then you see the
start Speed and start gear property
which directly are not available in this
class but this class is inheriting those
properties from The Base Class remember
the keyword inheritance here and then
once you do that how do you initialize
the Base Class con structor is by
calling the super method this is again a
keyword in Java and you will use this
super keyword to refer to the base class
Constructor in this way so what you will
do technically is that you will write
super and you will supply the arguments
which is required by The Base Class
Constructor if I go back the Base Class
Constructor requires two arguments start
Speed and start gear so I write super
and then I write start Speed and start
gear so whatever I got from here in the
Constructor of mountain bike I'm
supplying those values as is to Super
and Java will automatically take care of
invoking this particular Constructor the
moment it it uh Encounters this kind of
statement another another thing to
notice is that this super keyword or
super statement has to be the first
statement inside your Constructor
remember that whenever you are dealing
with inheritance and whenever you have
to initialize the super class
Constructor or the Base Class
Constructor use the super Constructor
invocation as the very first statement
inside your child class Constructor
otherwise Java will not compile the
program and then you will initialize the
local variable I should call this as
this remember I we discussed about this
in this uh in the classes session okay
and then it just has a method of set
height so there's no extra method which
this mountain bike is providing but this
mountain bike will have access to to all
the methods which have been provided
here and all the properties which have
been provided here this mountain bike
can access everything from the bicycle
class and that's the whole idea of
inheritance that the child class can
access the properties of the Base Class
by extending the base class now let's
look at how do we invoke this particular
class so for that I have a simple class
named as inheritance demo which has a
public static Point main method and then
I am initializing the mountain bike
class I'm supplying three values as 20
10 and 1 so the 20 goes to start height
the 10 here goes to start Speed and one
here goes to gear or the start gear and
that's on setting the values so when I
call this particular Constructor here
the mountain bike Constructor is going
to this mountain bike Constructor is
going to get called and which in turn is
going to call the Base Class bicycle
class Constructor as well and everything
will be set accordingly and then let's
try to access the gear property remember
gear is not directly available in the
mountain bike class but I'm still able
to do mountain bike. gear because child
class can access the parents class
properties similarly the same thing goes
for Speed as well and seat height is the
local property of this particular class
mountain bike so it will anyways be
accessible so I can access all the
properties of the base class and the the
child class itself seamlessly without
any differentiation now let's try to
call a method so here I'm calling the
method apply break remember apply break
was defined in the Base Class not in the
child class it's defined here so I'm
calling the apply break method and I
want to reduce the speed the current
speed by one and then I'm printing the
current speed saying that bike speed
after applying breake is Mountain bike.
speeed so let's run this particular
program and observe the
outputs Okay so the the first statement
which gets printed is at line number
seven which says gear is one because
it's coming from here then the seat
height is Mountain bike. seat height
which is 20 which is the first argument
here and then the bike speed is 10 which
is coming as here and getting printed
here and then when I apply the break
let's go back to the apply break method
the logic is that whatever is the
current speed reduce it by the value I
Supply in the method so if I Supply 1 10
- 1 becomes 9 and that becomes the
current speed if I Supply 5 here the
current speed will be 10 - 5 = 5 let's
assert that particular assumption as
well yes we can see that and similarly
you can access other methods of the base
class as well if I just do control space
here and you can see apply break is
accessible set gear set height speed up
all the methods which are defined in the
base class are accessible in the child
class as well this is the power of
inheritance one more thing which I said
I will come back to is around the usage
of protected access modifier remember
when we discussed about the access
modifiers in the previous session I said
that protected is used when you are
dealing with inheritance that whenever
you define something as protected it
will be available to be accessible in
the child classes of the base class so
if I Define this particular variable as
as protected then this particular
property will be accessible in the child
class Mountain bike as well let's play
around this let's make this as private
and see what happens so if I make this
private now when when I say private the
scope of this particular variable is
within the class only and nobody outside
the class will be able to see it and you
can see the effect of it I can see an
error being coming here in my
inheritance demo class because now
mountain bike object cannot access the
gear property because the gear property
is defined in the base class and now it
is private that's why the child class
now mountain bike class cannot access
the property gear and the moment you
make make it back to protected it will
be accessible the error is gone there's
no red line here so that's how you can
you can use the protected access
modifiers it is always always
recommended to use them when you when
you write any kind of inheritance logic
and in inheritance logic as well
intentionally if you want to hide a
particular property from the child
classes just make it private and that's
all I want to cover in this particular
session where we uh dive deep into the
concept of inheritance we had a look at
an example using the bicycle and
mountain bike kind of construct and you
can apply the same kind of construct on
any kind of other other kind of uh
business requirement remember that is a
relationship so that's all I want to
cover in this particular session and in
the next session we are going to talk
about another very interesting concept
of java which is about encapsulation
let's get started with encapsulation so
again let's understand what is
encapsulation in general and then we
will apply that concept to Java
encapsulation if you try to break that
word if I just write it here in the form
of a comment it's
encapsulation just trying to break this
word into to to make it more visual so
so you see a word called capsule here so
if if you try to imagine a capsule why
do you create that and what's the
concept of a capsule capsule tries to
lot of things inside a small tube like
shape and the concept of encapsulation
is sort of inspired from that not
exactly not literally but that's the
basic idea of of this root word which is
called encapsulation so encapsulation
basically means to restrict accessing
the properties of a class to the outside
world if you want to protect the
properties of your class how do you do
that you do that with the help of the
concept called encapsulation so here you
this is a sort of a security feature you
can think it of think of it as a
security feature that you want to
protect the properties of your class and
you will use encapsulation to protect
the properties how you implement
encapsulation let's have a look at that
now so basic idea is to encapsulate the
objects create sort of a capsule around
the object which can provide that
protection layer and you will Define how
the outside world is going to access the
properties of the class if needed so
I've created a simple class here and
it's if you if you remember one of the
previous examples when we discussed
about classes I use the same class which
was the student class and I'm just using
the same class for continuity so I've
created a student class here and I have
created three different properties of
this particular class which is name name
of the student age of the student
and address of the student you see
intentionally I have used the keyword
private in front of these three
properties and that is the first thing
which you need to do to implement
encapsulation on your object that you
hide all the properties from the outside
world remember the moment you make
anything as private only the class which
is the student class itself only the
class itself can see these variables or
these properties nothing outside the
student class will be able to access the
name or age or the address directly from
the student class it's not possible
that's the whole idea of making it
private because you don't want the
outside world to access these properties
so you make those properties as private
then you create a Constructor The
Constructor has to be public so that
anybody can initialize the student
object because you want your object to
be accessible remember so you want the
objects to be accessible but you want
the restriction
on the access of the properties of the
object and these are the properties of
the object so you have restricted them
by making it private but that doesn't
solve the problem because there will be
some illegitimate consumers of the
student object which should not have
access to the student properties but
there will also be some legitimate
consumers of the student object which
should be having access to the
properties of the student for example
the payroll application will need access
to these particular uh properties the
examination application will require
access to these particular properties so
how do you do that you create Getters we
call them Getters because they start
with the keyword get so you create a
getter method for each of the property
you create the method called as get name
and this is the naming convention with
Java promotes that you write get and
then you write the name of the property
in camel case so you write get name and
this property is supposed to return the
name property of this particular object
and you here you say return name so
you're returning the the name which is
being stored by the current student
object whenever somebody calls student
object. get name and this is the way you
have restricted the access of this
particular object as well so remember
you made it private so that nobody can
access it and then you defined your own
way of providing access to the name
property of this particular class now if
anybody wants to access the name value
of your student object there's only one
and one way to do that which is via
calling get name so you have provided
restrictions and you have also provided
prescriptive guidance on how you are
going to expose the properties of your
class that's the second uh thing which
you need to do to implement correct form
of encapsulation on your object that
that is to provide the getter methods
with the right visibility you want to
make them public so that anybody can
call them but since you are governing
which is what is written inside the
method you have full control on what
kind of exposure you want to give for
this particular property similarly you
create a getter for age calling get age
which Returns the age and then you call
get you write get address and return the
address here it is simply returning it
but if you want to do more stuff here
feel free to do that like I said you
govern the control of how do you want to
return the name maybe you don't want to
return the complete name and you want to
just return the initials then you can
split the string trim the string and
return only the initials so that's the
basic idea of Getters now after you have
created the object there might be use
cases where somebody needs to overwrite
the values of the properties like name
age P or address what if a student's
name was incorrectly mentioned when they
called The Constructor and now they want
to overwrite the name or fix the name so
basically they have to replace the
existing value of the name with a new
name so in that case you need to provide
what we call as Setters and they start
with set that's why we call them Setters
and we follow the same kind of logic
that you provide the Setters for all the
properties of your class so you had
three properties which were named age
and address and you provided the Setters
for all three of them and how do you
provide that you write you again make
them as public because you want the
outside world to access this uh Setter
method to overwrite the values of the
name this method is not going to return
anything so it is going to be void then
you write the name of the method which
starts with set and then the property
name in camel case and then you provide
the new value which is the value which
should be which should be the new value
and this is the value which should
replace the existing value so whatever
new value you want to supply you supply
that as the argument of the setter
methods for set name for set age or for
set address and then you write this
particular line which says set the
current name property of this particular
object with the name which is coming in
from the argument so this do name
remember this dot name represents the
current objects property because this
represents the current object so
whatever is the current object property
value of the name is just overwrite that
value with the argument coming in do the
same thing for age in set age method and
do the same thing for set address in the
in the set address method so this is how
you are going to provide the Setters and
the Getters so Setters and Getters can
also be generated in smart ID e like
like Eclipse so you just right click you
go to source and here you will see the
option of generate get and Setters if
you click on this it will give you the
list of the fields which are available
to be to be having Getters and Setters
currently it says no fields or all
Fields have Getters and Setters already
Yes because they have it let me just
comment this and show this how this work
so for example let me comment all the
Getters and Setters so I'm commenting
them and if I right click Source
generate Getters and Setters I get all
the fields available for which Setters
and Getters can be generated so you can
select them and leave everything as
default hit generate and it is
automatically going to generate the
getter and the setter you see all the
code of the getter and Setter is
automatically generated you don't not
even need to write it and this is the
power of the smart ID e let me just uh
rward what I did so you created
everything as all the properties as
private and then you define how you want
to replace the values by providing the
Setters and you define how you want the
outside world to access your properties
so you have full control of the class
now you you control the visibility you
control how they are going to get
initialized you you are controlling how
the properties are going to be over
written or set and you control how the
properties are going to be returned so
you have complete control of the class
so you have created a perfect capsule
here a perfect form of encapsulation in
this class and this is how you can
Implement encapsulation and that's all
I'm going to cover for this particular
session in the next session we are going
to discuss about abstraction let's get
started with abstraction let's first
understand the definition of abstraction
before we relate this to Java
abstraction generally means hiding
something when you want to hide some
details of of a particular object from
the outside world you apply the concept
of abstraction for example when you
drive a particular particular car you
just hit the accelerator and the car
speeds up now it's not only one action
when you hit the accelerator the whole
Machinery of the car and the all the
components different parts of the car
work together to speed up there would be
engine there would be propulsion there
would be fuel there would be there might
be some if if it's an electric car there
would batteries uh there would be whole
different kinds of pistons and plugs
which will make the car speed up it's
not only a single component it's lot of
different comp components under the hood
and that's the concept of abstraction
that we only show the relevant parts to
the user and we hide all the internal
details from the user that's the basic
idea of abstraction so a car
manufacturer abstracts away all the
inner technical details from the driver
and just gives the driver a single pedal
to speed up the car for a user it's a
very good experience because he doesn't
need to know about all the internals of
the car but the car manufacturer can
hide all the details and provide a very
simple interface for the driver to
interact with which is just a gas padle
and that's the basic idea of abstraction
and we try to apply the same kind of
concept to Java in the form of
abstraction and Java provides this kind
of uh concept implementation with the
help of a keyword which is called
abstract now abstract is a keyword which
can be used in front of a class or a
method when you use it in front of a
class the whole class becomes abstract
abstract class is a type of class so the
class itself becomes an abstract class
one of the things to remember is that
abstract class cannot be instantiated
but can be subclassed remember we talked
about the concept of subass and the
parent class when we talked about
inheritance so if you make a class as
abstract class you cannot call The
Constructor of the class because you
cannot instantiate it but you can extend
the abstract class and create a child
class class out of it that's the concept
of abstract class another concept is
abstract method you can also use the
abstract keyword in front of a method
and when you use abstract keyword in
front of a method then that method is
only declared without an implementation
you are not going to provide any
implementation of the method and you're
just going to declare the method
something like this we will see a
similar example in the in the hands on
as well but that's the basic idea that
you just declare the method you are not
providing an implementation as to what
does move to Method actually does
because that's the whole concept of
abstraction and it is the responsibility
of the child classes which inherit the
particular class in which the abstract
method would be sitting so that child
class will be having the responsibility
to provide a concrete implementation of
the declared method let's understand
this better with the help of an example
so here I have created a class called
graphic object and I have made the class
class as abstract class this is the
keyword which you need to use in front
before the class keyword and the class
becomes an abstract class now when you
create an abstract class it
automatically gets some properties the
first property is that this particular
class must have at least one abstract
method and this is how you define the
abstract methods where you just provide
the Declaration but you do not provide
the implementation of the draw method or
the resize method and the way you will
create the abstract methods is by using
the abstract keyword before the actual
method declaration starts so General
method declaration would look like this
and if you use abstract in front of it
this becomes an abstract method
declaration abstract class can also have
concrete methods so that is the Liberty
which abstract class gives you that you
can have abstract methods which are just
declared but you can also have normal
methods which are uh which uh where you
can also provide the implementation so
you can have normal methods and abstract
methods as well in an abstract class so
this is the abstract class now if if you
want to provide an implementation of the
draw and resize method you have to
extend this abstract class so we extend
this abstract class by creating two
child classes out of this particular
abstract class which is circle. Java
where you can see I create a normal
class and I use the extends keyword for
inheritance and I'm saying that Circle
class is inheriting from the graphic
object class which was my abstract class
and once I use this extends keyword then
I have the responsibility of providing
the implementation of the abstract
methods actually Java will force me to
provide the implementation of these two
methods if I do not provide all the
declared methods so there are two
declared methods here so if the circuit
class does not provide the the
implementation for both draw and resize
methods then Java will throw an error
and it will ask ask you to take an
action which can be either Define all
the methods meaning provide
implementation for all the methods or
make the circle class itself as abstract
let's see if I just comment this
particular out I get an error you see a
red line here and if you click on this
particular balloon here it will say
either you can add the unimplemented
methods or you can make the circle type
as abstract these are the two options
which you will get to fix this
particular error so an abstract class
can be extended by another abstract
class if the child abstract class is not
implementing all the methods of the
parent if you want to implement all the
methods then just Implement them and
keep keep it as a normal class and
that's what I've done here I've just
created a normal class here and provided
the implementation and once you provide
the implementation of both of the
methods the error is gone similarly I've
also provided another child class
because it's uh there can be uh there
can be multiple children of a particular
parent so angle also extends from the
graphic object and it also provides its
own implementation of drawing and resize
because generally the way you will draw
a rectangle and you resize a rectangle
will be different than drawing or
resizing a circle here I'm not doing
anything in the methods because this is
just to show you the demonstration I'm
just printing a sis out saying drawing a
circle and resizing a drawing a
rectangle and resizing a rectangle and
in the circle class drawing a circle and
resizing a circle so one class as the
parent class which is the graphic object
and two children Circle and rectangle
both providing the implementation of the
abstract methods which were declared in
the base class now let's go to the main
class where I've def defined the public
static void main method and here you see
I have created two different kind of
blocks of code here one block is where
I'm saying graphic object creating a
reference of the graphic object named as
Circle and initial izing the circle
object now you see a difference here
here is the abstract class and here is
the concrete class so whatever you
define on the right hand side whatever
is the type of object will be the type
of methods being caught so if you
created a circle object and then if you
called the draw method and resize method
these methods will be called from the
circle class if you initialized it as
new rectangle then you are creating a
rectangle class object and then the draw
and the resize method will be called
from the rectangle class that's the
basic construct and that's how you will
initialize a particular class which is
using an abstract class so I I call uh
graphic object Circle New Circle and I
call Circle do draw and circle do resize
similarly graphic object rectangle equal
to new rectangle and rectangle do draw
rectangle do resize let's run this
program and observe the output so when I
call this particular block of code
Circle object gets initialized and then
Circle do draw method prints drawing a
circle and circle do resize method
prints drawing resizing a circle
similarly when I create the rectangle
class object referencing it with the
graphic object class rectangle do draw
prints this particular line drawing a
rectangle and rectangle. resize prints
this particular line which is resizing a
rectangle and this is how you will use
the concept of abstraction there's
another very interesting thing which
which is which is going on here remember
remember I told you that the abstract
classes cannot be instantiated so if I
go here and I try to create a
Constructor of the graphic object class
let's see what happens if I do this and
I I create I just put a system out here
base abstract plus so if I do this here
if I create if I still write a
Constructor do Java says that it cannot
be instantiated if I still write a
Constructor of it and I do not do any
changes here here and if I run this
particular program let's see what
happens you'll see the base abstract
class being called here let me just
reformat it by putting Ln here so that
we get a better output so if I run this
particular program you see base abstract
class is getting printed somehow though
we said that abstract classes cannot be
instantiated but still the Constructor
of this is still getting called somehow
when I create a circle class The Base
Class Constructor gets called and when I
create a rectangle class again the Base
Class Constructor gets called this is
this is the power of inheritance because
in inheritance remember how it works
when you call when you initialize a
particular child object referencing it
with the parent object see the reference
is of the parent class and the object is
of the child class so whenever you do it
like this first the default Constructor
because I'm calling the default
Constructor here the default Constructor
of the circle class will get called
which will go here remember I told you
that Java provides the default
Constructor automatically if you don't
provide it so the default Constructor of
circle gets called but Java sees that
you are writing this code here which
says Circle extends graphic object so
Java is automatically going to call the
parent class and going to initialize the
parent class as well because that's how
it will be able to see these methods and
so so that's why it will automatically
call The Base Class Constructor even if
you don't call it explicitly in fact you
cannot call it explicitly Java will not
allow you to initialize the graphic
object class explicitly it can only and
only be called by Java itself indirectly
via the concept of inheritance if you
try to do this let's try to do this for
fun and and also for better
understanding so if I write graphic
object go equal to new graphic object
you see I don't even get an option but
let's write it and let's see what
happens so you see that this particular
it gives basically an error because it's
not able to find the Constructor of the
graphic object class though even I have
defined the default Constructor here but
still Java is not able to find it
because this class is abstract so hence
proved abstract classes cannot be
instantiated explicitly they can only be
instantiated by the child classes
through the internal mechanisms of java
itself and that's all I want to talk
about in this particular session where
we looked in detail about the concept of
abstraction couple of more things which
I did not cover in the previous session
I just want to call them out for clarity
Java does not support multiple
inheritance when I say multiple
inheritance what it means that you will
not have a scenario where a child will
be extending from two base classes Java
does not support it it does support it
with the with the help of interfaces but
I will talk about interfaces in the
coming sessions but here just understand
this that you cannot use multiple
inheritance with classes in Java a child
cannot have two parent or two base
classes in Java Java will not allow that
it it is also called The Diamond problem
because the child class does not know
whether to follow the route of Base one
class or the base two class if if it is
extending from two different base one
and base two classes so a class can only
extend from one class in Java we can
find a workaround of it by using the
concept of interfaces but that's
something which will be coming later
another thing to understand is that when
you create an abstract class here these
variables you can declare declare these
variables as well and these variables
will be accessible by all the child
classes as you access them so that's all
for this particular session and in the
next session we are going to talk about
interfaces let's get started with
interfaces in Java now again let's
understand what do we mean by an
interface in general and then we will
see how do we apply the concept of
interfaces in Java so imagine let's
let's take the same example of of
vehicle industry because that's
something which we see every day around
ourself and we can relate to it so
imagine if all the car manufacturers
were creating a different way of driving
a car what if in one car you have a
steering but in other car you do not
have a steering but you have something
else which is which may be called
something else in one car you have the
gas paddle to speed up in other car you
have a button to speed up similarly in
in one car you may have uh different
kind of doors and in other car you may
have different kind of doors which are
completely different looking it's not
even a single simple handle to open it
so you see the problem here the problem
here is that all the car manufacturers
are not working on a single contract
they are not respecting a single
interface which will create a poor user
experience because the users whenever
the users have to buy a new car or they
have to switch from one manufacturer to
other manufacturer they are completely
clueless as to how to drive that
particular class because the interface
they were using in the previous car is
completely different from the interface
they are being shown in the other car
and that's that's the basic need for the
concept of interface think of it as an
contract agreement you see it is also
mentioned here that if you apply the
same kind of concept to programming
World imagine if every programmer was
writing their own logic in their own way
without following a single contract or a
single guideline soon it is going to
create a problem and that's the kind of
problem uh interfaces try to solve so
interface is again a keyword in Java and
the basic idea or the basic construct is
that the interfaces are going to define
the specifications of how a class would
act let me repeat this in a more generic
way interfaces are going to define the
contract or the specification which is
going to govern how an application or
code or programming Lo logic will behave
that's the basic idea of interfaces so
interfaces are their own type and the
basic property of interface is that it
can only contain constants method
declarations similar to abstract classes
and some default methods or static
methods or nested types what is nested
type we will cover that later default
methods we'll touch upon a bit here and
the static methods as well but the basic
idea is that when you create when you
create an interface in Java you cannot
write anything concrete in terms of the
behavior of the interface when I say
Behavior always think of that as method
so you cannot Define a concrete method
in an interface you can only declare
methods you can also declare constants
you can create a particular type of
concrete method by using the default
keyword but use it in very special
circumstances you can also create static
methods as well which are only going to
belong to the interface and nobody else
now let's look at an example and and
also before we go to the example let me
also phrase this here that if an
interface cannot Define a conrete
implementation of the methods then
naturally the interface is going to be
extended by a child class a concrete
class which is going to provide the
implementation of the methods declared
in the interface
it does sound like abstract classes but
there is a difference let's understand
the difference with the help of an
example this is how an interface will
look like I've used the same construct
of bicycle and mountain bike just to
maintain some continuity and less
context switching but this is how an
interface will look like you will not
use the class keyword but instead
instead of that you will use the
interface keyword you can only declare
methods you cannot Define methods
remember when we looked at the abstract
classes example we were able to Define
concrete methods as well but in
interface that's a strict no no you
cannot Define concrete methods let me
show you the abstract class in the case
of abstraction which we used this was
the abstract class and it did have a
concrete method right but bicycle. Java
here which is because it's an interface
it is not going to allow you to create a
concrete method another thing is that if
you try to declare a variable inside the
class there will have to be constant you
cannot just declare them without any
value for example I cannot do this if I
do this it is going to give an error you
see an error here and it says initialize
field X at declaration something like
this public static final so interface is
going to force you to declare all the
variables as public static final with
some value if you try to use them inside
interface so that is also something
which interface will mandate so you see
inter interfaces are more strict they
are more strict in terms of what you can
do you can only declare public static
final variables and you can only declare
methods you cannot Define methods so
abstract class is less restrictive
interface is more restrictive and that
is the differentiation which you have to
keep in mind whether to use abstract
classes or whether to use interfaces
that is also a very common confusing
question in the interviews as well and
remember that interfaces are only for
contracts or specifications where in
case of abstract class you can write a
concrete Behavior as well in terms of a
concrete method in the Base Class
interfaces there's no concrete
implementation in the Base Class
abstract classes yes there can be a
concrete implementation in the base
class that's the basic difference moving
on I have created a child class here
which is again mountain bike and it has
three properties seat height gear and
speed similar to the previous example it
has a Constructor and remember in again
interfaces cannot be uh initialized
directly so you don't not even need to
call a super method here because there
is nothing to initialize you initialize
a class to create a state state is
denoted by the properties but interfaces
will force you to write a public static
final property and initialize its value
automatically so you do not need a
Constructor for the interface because
there is nothing to initialize
everything has been initialized in terms
of the variables and the methods are
anywhere just declared that's why you
don't need to call Super here after that
the moment you write this particular
keyword here implements and that is how
you will basically extend from the from
the interface you will use the
implements bicycle keyword here
implements is the keyword and bicycle is
the name of the interface if you write
this here then Java is going to force
you to provide the implementation of
these two methods if I if I do this
implements bicycle and if I comment out
these two methods which is coming from
the base class it is going to give an
error and if I read out this error it
says either you add the unimplemented
methods or you make the mountain bike
class as abstract there are two ways to
fix this particular class similar to
abstract classes it will force you to
write the implementation of the Base
Class declared methods another thing
which Java will will suggest you and
will will also Force you via some idees
as well is that you use this particular
annotation we use this particular
annotation to tell Java that we are over
writing this method from The Base Class
since apply break and speed up methods
were defined here in the base class and
this child class is supposed to provide
the implementation of the methods by
overriding them overriding is again a
concept which we will talk about in
detail in the coming sessions but for
now remember that you need to write this
annotation here on the methods which
have been taken from the base class to
provide an implementation and the
implementation is similar to what we
have seen before so whatever value you
supply in the apply break the speed is
going to get decremented by that
particular value and in case of speed up
whatever value you supply in the
argument that value is going to be added
to the current speed and the speed is
going to go up let's look at the main
class here which is called interface
demo it has a public static void main
method and here I'm again initializing
the child class nothing nothing strange
here and then I'm using the getter
method here because I have made
everything as price here and rest of the
things are just here as is I have the
Getters and Setters here for all the
properties and I'm using those here so
I'm using the Getters to just get the
value of gear seat height and speed and
then I'm applying the brake and then I'm
printing the current speed after
applying the brakes let me just expand
this a bit more and then I'm using the
speed up method trying to increase the
current speed of the bike by 10 and then
printing the new speed again so using
the apply brake and speed up methods
which are concretely defined in the
child class by using this override
annotation and these were the methods
which were declared in the interface in
the base interface and that's all which
is happening in this particular class
let's run this particular program and
these are the values I get I get the
gear as one which is coming from here I
get the seat height as 20 which is
coming from here I get the current bike
speed as 10 this was the value which it
was initialized with then I'm applying
the brake and after applying the breake
the speed of the bike gets reduced and
it becomes 10 - 1 which becomes 9 and
that's what gets printed here and then
I'm speeding up the bike by 10 so the
current value of the current value of
the speed of the bike is 9 and if I
incremented it by 10 it becomes 19 and
that's what gets printed here and that's
all I want to cover in in this
particular session where we had a look
at an example of how we can use
interfaces in Java and how we can use
interfaces with the concept of
inheritance and in the next session we
are going to have a look at the concept
of multiple inheritance using interfaces
let's get started with multiple
inheritance in Java using interfaces if
you remember in the previous sessions I
said that multiple inheritance is not
possible in Java and it is not possible
because of the diamond problem or simply
put of one child cannot have two parent
classes that's what Java says and let's
understand why this is a problem so I
have created a very simplistic diagram
to to demonstrate the problem of
multiple inheritance and then we will
see how we can solve that so let's say
you have a class C a normal class then
you created two parents of Class C so
basically Class C is extending Class A
and you also want the class C to extend
Class B first of all it is not possible
in Java and why it is not possible is
because of there can be a super class
which is extending Class A and Class B
as well so you started with class C you
wanted to have you wanted Class C to
have two parents which is a and b But A
and B also had a common parent which is
super class so now as you know that the
child classes can see the properties of
the base classes as well then if Class C
wants to access something from Super
class which route should it take should
it take this route or should it take
this route that is the problem which
will be called as the diamond problem
and that is the reason why Java
prohibits using multiple inheritance
using classes so that's the problem
statement that we don't have a clear
route to reach to the super class from
class C and we try to solve it using
interfaces so let's jump right into the
Eclipse IDE to understand how we can
solve it so here I have prepared an
example for this particular uh problem
and the solution of it so again I'm
using the same bicycle and mountain bike
example for the sake of continuity I
have created an interface of bicycle
which has two declarations which is for
applying brake and speed up this is my
simple interface and then I have a
mountain bike class which is
implementing the bicycle interface and
providing the implementation of apply
brake and speed up this is something
which we have already seen in the
previous example so nothing new here and
then you have other Getters and Setters
and you have a main class where you can
initialize the mountain bike and get the
gear get the seat height get the speed
we have covered all of this there's
nothing new here but now let's say you
have a requirement that you have another
interface which is called vehicle and
your mountain bike should extend or
implement this interface as well is that
possible let's try that remember
mountain bike was already implementing
bicycle interface what if you want to
have two parents of this mountain bike
using interfaces like I said previously
that interfaces does solve the problem
of multiple inheritance so let's see if
it does solve that problem so I can just
say vehicle here and see if the code
compiles the code doesn't compile here
and the reason is pretty expected it's
because vehicle has a declared method
which is called can drive and mountain
bike now needs to provide the
implementation of that particular method
so if you click on this balloon and hit
on ADD unimplemented methods just double
click on that and you will get an empty
method definition of that can drive
method and let's put a sis out for
Simplicity and say mountain bike can be
driven so this is how you can see this
this code is working fine and now this
particular child class has two parents
it has a bicycle parent and it also has
a vehicle parent so if bicycle and
vehicle would have been concrete classes
then this would have caused an error let
me quickly show you that if you if I can
so let me go to bicycle and I just
change this to class and I put an empty
definition for both of the methods and
then let's go to the vehicle class and
convert uh interface and convert that
into class as well and again provide an
empty implementation so I've just
converted the vehicle interface and the
bicycle interface into classes and now
if I go back to the mountain bike and if
I change this to extends I get whole lot
of Errors if I go here it says multiple
markers and it it doesn't give you the
right error but the right error is
happening because you cannot extend from
two concrete classes now bicycle and
vehicle are both classes and mountain
bike cannot do that because Java does
not support multiple inheritance from
classes but if you go back to the
previous state if I just quickly do
contrl Z here and contrl Z here in case
of vehicle as well converting both of
them back to interfaces and putting the
implements back here everything goes
fine so using interfaces you can
Implement multiple uh inheritance but
using classes you cannot do that let's
cover one more interesting scenario what
if you have a need to extend from let's
say one interface and one more class is
that possible because we saw the com we
saw the combination of two classes that
was not possible we are seeing the
combination of two interfaces which is
possible now is it possible to extend
from a base class and Implement an
interface let's see what happens if we
try to do that and I have another class
this is not an interface but this is a
class called two- wheeler so technically
speaking mountain bike is a two- wheeler
and at the same time mountain bike is
also a vehicle and mountain bike is also
a bicycle so what if you have a
requirement that your mountain bike
should also extend from two- wheeler
class can you do that let's see if I can
do that I will just write extends uh two
wheeler and let's see if that works it
doesn't work here but let's put it here
if I put it here does it work now yes it
works there's no compilation error here
which means Java does accept this
particular construct so what happened
here first thing when I put this extends
to after implements Java did not allow
which means that the extends keyword has
to come right after the child class it
cannot come after the implements Clause
it has to come right after the child
class that's first thing second thing is
a normal class a normal child class can
extend from one concrete class and can
also Implement any number of interfaces
you see I have two interfaces so now
technically this mountain bike has three
parents it has a concrete class two
wheeler as the parent it has bicycle
interface as the parent and it also has
vehical interface as the parent so three
parents so this this basically uh
justifies the philosophy or justifies
the concept that a class can extend from
only and only one base class but can
Implement any number of interfaces you
can have more interfaces here as many as
you want so number of interfaces is not
a restriction but number of concrete
classes is a restriction a child class
will have only one concrete based class
but can have any number of interfaces
being implemented from this particular
class that's the basic property and then
the main in the main method uh you can
access any of the vehicle or two-
wheeler or bicycle interfaces methods
and the classes methods as well if you
want to so for example if I want to just
type this and if I just to dot here I
can see I can access can drive as well
now can drive was implemented in the
vehicle interface or declared in the
vehicle interface similarly if I look
for the two wheeler method can I see the
two wheeler method as well let's see if
I can yes and this you can see this is
the two wheeler class method which says
can rotate two wheels so I can call this
particular method which is coming from
the two- wheeler class I can call the
vehicle class declared method which was
can drive so this is also possible and
this is possible because mountain bike
is implementing the interface of vehicle
so let's run this particular program and
understand the output so at first I
initialize the mountain bike class and I
print the gear the seat height and the
bike speed values you have already seen
this then I apply the break and I speed
up so after applying the break the speed
becomes 10 - 1 9 and after speeding up
the new speed becomes 9 + 10 as 19 then
I call mountain bike do can rotate two
wheelers two wheels which is going to
invoke the method which is defined in
the two wheeler class which is printing
a simple sis out so I get the same sis
out here this method is being invoked
from the mountain bike object due to the
concept of inheritance similarly when I
say Mountain bike. can drive the SC
Drive was declared in the interface
vehicle and then when mountain bike
implemented this interface Java forced
it to provide an a definite of this
particular method and this is a
definition which is again a sis out and
you can see that sis out being printed
here so this is how you can Implement
multiple inheritance in Java using the
power of interfaces and you can also
combine the classes and the interfaces
the condition is that only one class
should be the parent class and then you
can have any number of interfaces as the
parent entity if you want to and that's
all I want to cover in this particular
session in the next session we are going
to discuss disc about method overloading
Concepts in Java accelerate your career
as a software developer through this
postgraduate program in fullstack web
development course in collaboration with
ctech CME let's get started with
polymorphism so polymorphism is a very
generic concept which means that a
particular object can take multiple form
let's not even call it as object let's
make it more generic a particular entity
can take multiple forms if any entity in
Java exhibits that kind of behavior then
we say that polymorphism is in action
that entity can be a class or an object
or even a method and in today's session
we are going to talk about that type of
polymorphism which is exhibited by
methods so we will see how a particular
method in Java can take many different
forms containing different Logics but
still having the same name and that
concept is called method overloading so
whenever you hear the word that you need
to overload a particular method or or
this is Method overloading happening
technically or conceptually it's
basically polymorphism in action and
polymorphism is being applied on a
method here and that phenomena we call
as method overloading so in today's
session we are going to have a look at
how we can Implement method overloading
in Java so the basic idea of method
overloading is that the name of the
method should remain the same so you see
in this particular class which I have
created to demonstrate the method
overloading so this is the class name
and the method name which I am going to
overload is called multiply and that is
probably the first thing which you need
to remember to implement over method
overloading correctly that the method
name is going to remain the same the
type of the return of the method may
change here you see it's returning int
here in the first instance in the second
instance also it is returning int but in
the third instance it is returning
double so the return type of an
overloaded method can change another
another thing which you which can be
varied between same method being defined
again and again is that the number of
arguments and the type of arguments the
first multiply method takes two
arguments of integer type the second
multiply method takes three arguments of
integer type and the third multiply
method takes two arguments of double
type so by using method overloading you
can vary the number of arguments and
also the type of arguments so the basic
idea is that you declare you define the
method using the same name but you do a
variation in the arguments or the return
types and that's how you technically
Implement method overloading in this
case in this particular case the
multiply is the method being overloaded
and in the first case case it is
accepting two integer arguments and
returning the result of multiplication
of those arguments in the second case
the same method name multiply here the
same visibility public and the same
return type but this time three
different types of integer values can be
accepted and this method multiply method
is going to return the multiplication of
three integer numbers in the third case
at line 15 I again use the same multiply
name the method name but this time the
return type becomes double and this
method accepts two double arguments and
Returns the result of the multiplication
of these double values so the method
name is same but the arguments vary and
also the return type may also vary
that's the basic premise of how you
implement method overloading so whenever
you want to implement it keep the method
name same vary the arguments and return
types and after that I'm just created a
public static void main method here here
I have initialized the class here this
particular class itself method
overloading demo and then I am calling
the multiply method on the object and
based on the number of arguments I
Supply the corresponding method will get
invoked that is something which Java
will take care automatically that
whatever type and the number of
arguments you supply in the call in the
invocation based on the number and the
type of the arguments Java will try to
find a matching method in the overloaded
methods if it is able to find a method
it's going to get invoked if it is not
able to find the method you will get an
error in fact you'll get a compile error
itself while you invoke a method which
for which the definition is not
available for example if I try to just
copy this and make an invalid invalid
method invocation let's provide four
arguments and if I do that here itself I
will get the error because Java is not
able to find a multiply method in this
particular class which is accepting four
integer arguments so you will get the
compilation error itself before you can
even run the program but the basic idea
is that you use overloading with
multiple different types and the number
of variables so I'm calling multiply
three times let's run this particular
program and observe the output so let me
just bring this output down yep so first
I call demo. multiply and pass two
integer values 10 and 20 when this
happens this particular particular
method gets invoked and it it returns a
result of 10 into 20 which is 200 in the
second invocation I'm calling again the
multiply method but this time with three
arguments three integer arguments
specifically and this call is going to
match this particular method signature
and it is going to execute whatever is
written inside this particular method
which is the multiplication of the three
arguments being supplied so 10 into 20
into 30 which is 6,000 the third case
let's go back here at line 25 the third
case of invocation of the multiply
method is accepting two decimal based
arguments 10.5 and 20.5 so Java is going
to look at the class and trying to find
a method which can accept decimal values
and there it is this is the method
signature which is going to match the
invocation Java is going to do this
matching automatically for you and here
whatever logic you have written inside
this particular method we will get
executed so 10.5 into 20.5 returns
21525 and that's the output you get so
this is how you can use method
overloading in Java this is a rather
fairly simple example but you can make
it as complex as you want but a word of
caution do not use it too extensively in
fact lot of expert programmers do not
recommend using method overloading
because it becomes very confusing use it
only when you do not have any other way
out use it only where this is the only
way to write correct form of methods
with the right readability otherwise
generally there would be other ways to
avoid method overloading by writing
concrete purpose friendly method names
themselves maybe you don't need to use
the multiply name again and again you
can call it as multiply two numbers
multiply three numbers multiply doubles
so that the method name itself is more
explicit and understandable rather than
juggling around different signatures of
the same method especially it becomes
more confusing if you are creating an
interface which is to be consumed by a
third party developers or third party
application so try to use it with
caution that's what I'm trying to stress
here and that's all I want to cover in
this particular session and in the next
session we are going to talk about
method overriding let's get started with
method overriding in Java so in the
previous session we discussed about
method overloading concept now now in
this session we'll focus on another
interesting concept by which you can
have the same signature of the method
again and again be used in your code but
in a different way and this concept is
called method overriding method
overriding basically is used together
with the concept of inheritance you
won't you will not be able to use the
concept of method overriding without
using the concept of inheritance
remember when we talked about
inheritance I spoke about the subclass
and the parent class concept sometimes
we also call the parent class as super
class so the basic idea is that if a
super class defines a method remember
I'm using the word Define here if the
super class uses the defines a
particular method and then the subass
again tries to define the method with
the exact same signature this phenomena
is called method overriding now when you
do method method overriding there are
some uh rules to follow and I'm showing
you a tabular structure here a table
basically which will show you what is
possible and what is not possible when
it comes to Method over writing so let's
try to understand this table so if you
try to define a method with the same
signature as a super class method the
rules follow as per this table let's go
with the first one if you have an
instance method defined in the super
class instance method is the normal
method which you defined in your in your
classes so if you have defined an
instance method in your super class and
if you define a method in the subass
with the exact same signature then that
concept is called method overriding and
it will be a successful override
override also let me also explain what
override means here override means that
once you try to initialize the subass
object you will be able to invoke its
own overridden method definition if you
call that particular method the
subclasses own instance method is going
to get invoked rather than the super
class is instance method we'll look at
that when we look at the example as well
but that's the normal scenario when
where your super class defines an
instance method and subclass also
defines the an instance method with the
exact same method signature that concept
is called method overriding what if your
super class defines a static method
static method is is basically a method
which belongs to the class but not to
the object instance method is called
instance method a normal method is
called instance method because it
belongs to the object you call the
method on the object but static methods
are called by class so you say class
name do static method name but when you
when you call instance methods you just
call object name do instance method name
so that is the basic difference the
static methods belong to the class once
you have defined a static method the
same static method will be available to
all the objects of the class but
instance method are unique to each
object so that was a short tour of what
static methods mean so if if you define
a static method in the super class and
then if you try to Define an instance
method with the same signature in the
sub class you will get a compilation
error it will not be allowed it's not
allowed in Java to override a static
method from Super class that's what it
says next one if your super class has an
normal instance method and then the
subclass tries to use the same signature
but create a static method out of it
then again you will get a compilation
error so that the overriding of an
instance method to a static method is
not allowed and the last concept is
again a very interesting concept and a
very popular interview question about
method hiding so if the super class
defines a static method and the subclass
also defines the static method with the
exact same signature then the super
classes static method gets hidden it
basically hides the superclass method so
that's the basic idea behind over method
overriding so if you see technically
it's a form of polymorphism because the
same method is having multiple
definitions but when we looked at the
previous example the multiple
definitions were in the same class here
the multiple definitions are in
different classes and those classes are
having a parent child relationship that
was about the theory of let's go to an
example of it to understand it better
and I've used again the same construct
of bicycle and mountain bike which we
have been using in this in this series
just to maintain continuity so I have a
parent class called bicycle here which
has two uh properties gear and speed it
has a Constructor nothing unusual there
and then it has defined three methods
set gear apply brake and speed up set
gear is just setting the new value as
the gear value apply break is going to
decrement the speed by the value you
supply and speed up is going to
increment the speed by the value you
supply simple this is exactly what we
have seen before now mountain bike tries
to extend bicycle so mountain bike
becomes a child class it defines a
variable called seat height defines a
Constructor calls super hair nothing
unusual so far also defines a Setter for
height Setter for the seat height not
exactly following the setter construct
but this is just to set the height but
here things get get interesting let me
just bring this down a bit Yeah so here
it is overriding all the three methods
of the base class and by overriding it
is providing its own implementation of
the same methods let's compare them here
when it overrides the gear and whatever
value you supply it adds two to the plus
two uh to that value and then sets that
value as the gear value but but in case
of Base Class it was just setting the
new value as the gear value so for for
instance if you supplied one here the
gear value becomes one but here if you
supplied one the gear value becomes
three similarly when you apply breake on
the mountain bike class whatever value
you supply will be subtracted from the
current speed and 10 would be subtracted
even more so if the speed is let's say
50 and you decrement you supply the
decrement value as 10 so it will be 50us
- 10 - 10 = to 30 but in case of bicycle
if the speed was 50 and you supply 10
then it would be just 50 - 10 40 so
there is and there is extra 10 being
subtracted from the speed when you apply
brake in case of a mountain bike
similarly for speed up it's increment of
10 in addition to what's what value you
supply so again if the speed was 10 and
you supplied 10 here in the argument so
10 + 10 + 10 30 will become the new
speed in case of mountain bike but in in
case of bicycle if you supply 10 and if
the current speed was also 10 then it
becomes 10 + 10 only 20 so that's the
difference so the basic idea I hope you
get the basic idea here is that you
overwrite the methods and your own class
provide its own implementation of those
methods that's the basic premise of
method overwriting all good so far and
you do not have a a an uh an obligation
to override all of the methods because
here we have the concrete implementation
of the methods so here here in case of
mountain bike you can skip overriding
one of the methods if you like to this
is also fine there will be no
compilation error because speed up has a
concrete implementation in the bicycle
class as well so it's up to you how much
you want to
override so let's move to the main class
now so in the main class we have created
the public static void main method here
and let's look at what is happening
inside the class first we initialize the
bicycle class so bicycle class CL
reference and bicycle class object
nothing unusual here we Supply the gear
value and the speed value then we print
the gear and the speed value we apply
breake on the bicycle and then we
observe the new speed of the bicycle
after applying the brakes let me comment
out the rest of the code and let's
observe the output for only this part of
the code which we just walked through
for this section so if I run this as a
Java application and if I show you what
I'm getting what I'm getting here so by
bicycle gear is one which is what you
supplied in the Constructor bicycle
speed is 10 which is again what you
supplied in the Constructor then you
applied break and when you apply break
this logic gets executed and you
supplied one here so current speed was
10 so 10 minus 1 becomes 9 and the new
speed becomes 9 which is what you are
printing here so far so good let's move
on to the next section let me comment
out the previous section now and let me
uncomment this section so here I have a
bicycle reference but the object is of
mountain bike remember this concept this
is this is called Dynamic object binding
concept or dynamic binding concept again
this might be asked in your interviews
so here I'm initializing the mountain
bike with a reference of bicycle
remember whatever is written on the
right hand side will govern the
variables and the methods usage we will
We we'll see how that works out what I
just said so I'm supplying three values
here 50 50 and three in the mountain
bike uh if I go here in the mountain
bike Constructor so the start height
start Speed and gear are the three
values which is supplied as 50 50 and 3
then I'm accessing the gear and the
speed now remember gear and speed are
declared in the bicycle class but they
are accessible in the child class due to
the inheritance phenomena which we have
already covered so if I print only this
part I should get the expected values
mountain bike gear is three which which
is what I have supplied here and
mountain bike speed is 50 which is which
is what I have supplied here then I
apply the brakes now let's move on to
the this section I apply the break
Supply the value as one and then I want
to see what would be the new speed after
applying the brakes so let's see what
happens when we run this particular code
so if I run this code after applying the
brakes the speed becomes 39 before
applying the brakes the speed was 50 so
what happened here is 50us 1 basically
this this logic is getting executed here
50 - 1 - 10 which becomes 39 that's why
you get the value as 39 as the new speed
similarly if you want to call another
method as speed up speed up method was
also defined here where I'm saying speed
plus the arguments supplied plus 10 so
the current speed is 39 right now then
I'm speeding It Up by 10 so by this
logic 39 + 10 + 10 which will become 59
and then I'm printing the new speed
after speeding up so let's see what
happens so if I go to run as Java
application and if I observe all the
outputs the speed was 50 initially after
applying the brakes the speed became 39
and after speeding up the speed became
59 so this was a quick demo to show you
the power of method overriding and how
you can override the behavior which is
defined in the base class so this is all
I want to cover in this particular
particular session let's get started
with the static keyword in Java now
let's first understand the need of the
static keyword and then we'll talk about
how Java implements the static keyword
imagine a scenario let's take the
example of a class which we have been
using in our in our different tutorials
in this particular series which is about
the student class so if you are building
a college management system you have a
student class there and if you have an
entry uh a property in the student class
which is storing the name name of the
college then the name of the college is
going to be the same for all of the
students of that particular College it's
not going to change another example
let's say you are building a employee
management system for a organization and
you want to maintain the employee
numbers for the first object the
employee number should be one for the
second object the employee number should
be two for the third object the employee
number should be three so on so forth so
when you ini ize all the employee
objects the last employee object has the
final total employee count and you can
also treat this employee count as let's
say the employee number as the employee
ID so starting from the first employee
to the last employee the employee number
is the employee ID which is a way to
uniquely identify an employee so we
talked about two different cases in the
first case we had a particular value
which was same for all of the objects
which was the student and the college
relationship and then in the second
example which I quoted where all the
employees objects have to share a
particular property amongst them because
if the second object did not know the
previous value of the employee number it
will not be able to get to the new
number it needs to know what was the
previous value so that it can do plus
one so each of the object needs to know
the state of the previous object two
different cases two different scenarios
one single solution which is static
keyword so the static keywords are used
for those members which belong to the
class now apply this definition to the
examples which I gave you if I make a
member of the student class let's say
the college is the property of the
student class and if I make that
property as static now that static that
member that static member becomes the
property of the class and not the
property of the object it means it
belongs to to the class it also means
that all of the objects will get the
same copy of this static member variable
and that's that's one of the first usage
and you can you can make any property or
any member of the class as static by
just putting the static keyword in front
of it we also call the static member
variables as class variables like I just
described so use it for the cases where
the value across the different objects
doesn't change you can make those class
variable and those variables as class
variables or St variables similarly also
try to identify the cases where a
particular value has to be shared in
terms of knowing the previous state in
those cases as well you can use a
particular member in that particular
class and make that static for example
in this case we have a bicycle class and
we have a static variable which says
number of bicycles so every time you
initialize the bicycle object this
number will be shared and you can see I
mean this is here it is incrementing the
number of bicycles so every time you
create the object the ID becomes plus
one to the previous count of the number
of bicycles exactly same example as they
gave you for the employee number so
every time you create an object you do a
plus one to the previous value next
object will take the previous Value Plus
One and so on so forth so you can use
the static uh keyword in front of a
property of the class and make it a
class level variable which will be tied
to the class and not tied to the objects
you can also make the methods as static
as well and the same kind of rule will
apply on the methods as well that the
methods will become will belong to the
class instead of belonging to the
objects let's say you have again a
common functionality which you want to
share amongst objects just make that
common functionality as a static method
and that would be shared amongst the
objects for example you want to get the
total number of bicycles for the
previous example which I just shared in
this particular doc here so you can just
create that method as static and any
object which will call this method will
get the latest
count of the number of bicycles you can
also make these uh these static
variables as constants by putting the
final modifier in front of it so if a
variable in a particular class is static
and final both then technically it
becomes a constant so these are some of
the interesting uh use cases and uh
constraints of the static methods and
static variables there's also a thing
called Static block which is just a code
block which you can write inside your
class and we will have a look at that
example as well so let's shift to the
IDE and let's have a look at how we can
use this static keyword so I have used
the again uh the same class which I have
been using using in other examples which
is student. Java and you can see I have
this same class you have you would have
seen these properties earlier as well
and the code below is exactly the same
just Setters and Getters and
Constructors and it has an additional
property which is college and the
college name XYZ is the same for all the
students so I have just hardcoded it but
you see what is happening here is that
every time you create a student object
this variable gets initialized even
though the variable for all the objects
has the same value still it gets
initialized again and again and again so
technically it's a waste of memory
you're just wasting memory of an of a
new allocation every time even though
the value is same what if we create this
object once and this member variable
once and just use it across objects you
can do that by just writing static in
front of it
if you do that then you see this becomes
sort of italic here and that's Java's
convention to show that this particular
variable is a static variable you can
also see the static keyword in front of
it and then whatever value you have
specified this will be initialized only
when the class is loaded remember I'm
not talking about the object
initialization I'm talking about the
loading of the class in the jvm so the
first time the class is loaded this
particular variable will be initialized
and that's it after that no matter how
many student objects you create the same
College reference will be used again and
again and the college variable will not
be initialized again it will be
initialized once and the same College
reference will be used again and again
that's the power of static variables for
example if I want to access this
particular College variable how do I do
that so let's look at a main class where
I have initialized this particular
student class with an object named as
John and I've specified the name the age
and the address and I'm printing those
values how do access the static variable
if I say John dot do I get access to the
college variable yes I do have access to
it but does it work let's see you see a
yellow line here and we will come to
that yellow line in a while but let's
first see if this works yes it works I
can see that the college name is printed
here as Xyz which I have set now let's
look at the error or the warning it says
the static field student. col college
should be accessed in a static way
because the way you are accessing it
right now is the instance way of
accessing a particular member this is
not a static way of accessing a member
so if you want to access a static member
of a class you should access it with the
class name and not the object name why
going back to my original definition
that the static variables belong to
class they do not belong to object and
that's why Java will warn you if you are
not accessing the static variables via
the class because they are supposed to
be accessible via class it will not give
you a compilation error but if you're
working in a Enterprise project this is
going to raise lot of violations and lot
of questions for you as to why you are
not accessing it via the class name so
this is the correct way of accessing it
and you will get the same output now no
matter how many objects you create of
the student class you can always access
the student. col and you can always get
the same value of the college name
that's the first use case second second
thing is about static methods so you
will use the static methods in a case
where I described about the uh counting
the employee numbers and let's say if we
have the same kind of scenario where you
have to count the number of students
because you can use that particular
count as let's say the role number of
the student so if you have that kind of
requirement then you need to create a
static method because you need to share
the state of the object across objects
remember that so what you can do simply
is create a static method so let's say I
create a normal method and then I just
put static in front of it saying static
void student count and now I want to
count the student so I can let's create
a simple count variable and let's start
it with zero and then I can increment
the count variable again and again in
the static method right but you see I
get an error here the error is if you go
to the balloon it says cannot make a
static reference to a non-static field
count this is one of of the properties
of the static methods the moment you
make a method as static then that
particular method can only access the
static member variables of the class the
static methods will not be able to
access the non-static variables count is
a non-static variable count is a normal
instance variable so a normal instance
variable for that matter name or age or
address nothing would be accessible here
if I try to access let's say try access
name here so if I just say s out and I
say name it will also give me give me
the same kind of error if I go here it
gives me the exact same error because
static method cannot access the
non-static member variables of the class
so you have to make this count variable
as static as well and then only this
compilation error will be fixed I can
remove this one and now this method is
fine now I can uh increment the count
every time that object is created and
that is one of the use case of using the
static method that you can share the
state across the different objects and
if you want to fetch this particular
variable then you can simply write a
getter for this saying int count return
count and then you can return the count
you can see that now an instance method
can access the static member so the
reverse is is fine a non-static me me
can access a static variable but a
static method cannot access a non-static
variable remember that a static method
can not access a non-static variable but
a non-static method can very well access
anything including the static variable
that's second thing the third concept is
of static block and static block also
has a similar usage that if you have a
block of code it's not just a variable
it's not just a method but but you have
a block of logic which you want to
execute only once when the class is
loaded into the runtime if that is your
requirement then you can write a static
block and the way you will write it
generally we write it at the beginning
of the class and the way you will write
it is it as you write static and you put
curly brushes and you start writing code
here as to whatever you can say
initializer and you can write whatever
code you want to write the only caveat
is that in the static block you will
only be able to access only the static
member variables of the class so you
will not be able to access these
variables you can only access these two
variables you can very well move these
two variables here if you want to so if
I go here I can paste this and I can
drop the static keyword because
everything in the static block is
automatically static so I don't need to
explicitly call out static variable and
now this code is fine you get some
warning because it's not used anywhere
in the class but that's fine because
this is just a simple demo but the whole
point is that you can write the static
block and you can write all the
initializer code which you want to write
here which you only want to execute once
during the whole execution of your
program just to show you the the reason
and the the way it works let's try to
see if the static block works and let me
comment all the static code which I
wrote here and let's go back to the
static demo and let me remove this one
as well so now I just will run this
student. Java I will I will create an
object of student. java and I will see
if the static block gets executed or not
so let's run this particular class which
is the main class and I have a main
method I have a student CL object
initialized and I'm printing the name
age and
address if I run this you see the first
line of code which gets printed in the
output console is the static block code
which is what I wrote here and let me do
one more thing just for fun sake let me
create more objects of it let me just
call them 1 2 three and four and let's
see and let's see how many times the
initializer code gets printed you see
that the code still gets printed only
once even when I created five different
objects of the student class and that's
the property of the static block that it
will be executed only once when the
program is loaded into the runtime and
that's all and that's pretty much all
what I want to cover in this particular
session let's get started with nested
classes in Java so so far we have seen
that we can create classes in Java and
we can create objects of those classes
to interact between those classes and
objects and other properties as well but
what if you have a use case or what if
there is a need that you need to define
a class within a class so that's the
concept of n Ed classes that Java does
allow you to create classes within the
classes now you might be wondering as to
why do you want to do that and the
simple answer is encapsulation you would
be facing some scenarios while writing
Enterprise grade applications where you
have a class which has its own scope but
that whole scope or the existence of
that class is justified by another class
for example if you try to design an
objectoriented design for a house then a
kitchen cannot exist without a house
because the kitchen exists inside the
house right so if you have that kind of
relationship then probably kitchen class
has to be inside the house class somehow
and that's where this nested class
concept will come into picture and
that's why we have this nested class
concept here as you can see what I'm
showing on the diagram that Java
programming language allows you to
define a class within a class and that
is called nested class now when we talk
about nested classes you will hear two
different terms basically nested classes
are divided into two categories which
are static classes or static nested
classes and non-static nested classes
now static nested classes are called
simply static nested classes and the
non-static nested classes are called
inner classes because they are
non-static they are just normal inner
class exactly similar to the way we say
normal method and a static method
similarly if you put a static keyword in
front of in front of a nested class that
becomes a static nested class and if you
do not put static keyword in front of a
nested class then it is simply treated
as a general inner class that's the
overall concept now there are some more
drivers of why you would like to use it
one example is I gave you about the
existence of an object within an object
or or technically speaking the existence
of a class within a class the whole
house and kitchen and technology which I
just shared with you but broadly you
will see three different reasons these
different reasons due to which you will
be using nested classes first of all
it's a way to logically group all the
related classes that are only used in
one place what it means is that if you
have a class which is only serving the
purpose for a larger class then it's
better to group those two classes
together inside a single class or simply
nest the smaller class inside the bigger
class we I might be using the term inner
class and outer class to point out the
static nested inner class and the outer
class that's the first reason the second
reason is like I said it increases
encapsulation because now you have full
control over what you can Expose and
what you cannot expose or what you
should Expose and what you should not
expose because inner classes will also
come with its own set of visibility
constructs like private protected Etc so
you you get more fine grain control in
terms of what you want to expose to the
outside world collectively from the
outer and the inner class and it can
lead to more readable and maintainable
code though I would honestly say that
this is debatable because in lot of
programming languages static nested
classes are not promoted because they
drop readability imagine if you have 10
classes if you have a single class and
if you have a nested hierarchy of 10
classes it becomes super confusing and
super complex to track the visibility of
the variables and also to understand the
code better so this is debatable whether
it improves to readability and
maintainability or not maintainability
yes to a sense because you have a single
class which is containing the logic of a
inner helper class and the outer class
readability yes or no it depends if uh
if the classes are small size then yes
it does improve readability if they if
they grow larger then it's better to
move the class outside and just make
that class maybe a package private or
something so this is the basic premise
of why we use nested classes now let's
talk about an example which by which we
can demonstrate how to work with the
static nested classes so here I have
created a class it's a simple class but
I've just named it as outer class so
that we understand that this is the
outer class so I have a class here which
is named as outer class and at line five
I am defining a static variable inside
the class you can see the static keyword
here and I've just called it as outer
static member then I have a simple
instance variable this is something
which you have seen normally in in all
the different examples I have given you
and then I have another static variable
but this is private so this one is a
normal static variable this one is a
normal instance variable and this one is
a private static outer variable all
these three variables are sitting in the
outer class but this is private this is
static this is private private static
and this is a normal instance method and
we will see how we can access these
variables inside the static nested class
to define the static nested class the
way you will write it as you will be
inside the class opening and closing
braces and you will start writing like
this static class and the name of your
class that is how you're going to define
a static nested class and then you put
the curly brushes and whatever goes
inside it is just like any other normal
class you would write so let's say
inside the static nested class I have
defined a method called display and now
I am trying to access this particular
variable which was a static variable
defined in the outside class or the
outer class we will see if we can access
the static variables from the outside
class or not so that is what this
system.out.print is doing I'm just
accessing this directly you can see you
can directly access the outer class
static member variable inside the static
nested inner class then in the next
statement I am accessing the outer
private member this one so the outer
private member which is also static so
these two static variables are being
accessed here in these two lines
basically and then I have commented out
one more thing to try out if I can
access the normal instance member also
remember the concept which I uh which I
taught you in the previous session that
a static method or a static block can
only access static variables a static
block will not be able to access
non-static variables so these two are
static variables and this is a
non-static variable so we will see if
the same construct still applies on this
particular class or not so inside the
display method I have these two SS outs
and this one is commented out I will
come back to that later so you have the
you have your outer class and your
static nested class ready with a sample
method uh now let's see how we can
invoke these outer and inner classes how
do we create the objects of an inner
class so for that I have this static
nested demo class it's basically
containing a public static void main
method as you can see here and let's try
accessing a static nested class so if
you want to initialize or access the
inner static nested class then you have
to follow this kind of construct where
you say outer class Dot inner class name
then you give a reference to it and
again you follow the same construct you
say new outer class do static nested
class name and a simple parenthesis and
this is how you are going to create an
object of the static nested class which
you have defined inside your outer class
remember the syntax this is how you're
going to do this that you type outer
class. static nested class once you have
done that it will call the default
Constructor of static nested class and
you will get an object now you will also
see the dependency which I talked about
there is no way that you can initialize
this static nested class without
referring it from the outer class you
always have to write this outer class
dot to access the static nested class
you will not be able to access or use
this static nested class directly
anywhere in your program so the whole
concept of the inner class only existing
with the outer class holds true here
because you can the inner class only can
exist if you refer it from the outer
class once you have the object you call
the do display method and let's see what
happens so if I run this particular
program and let's see what kind of
output do I get I get two lines of
output when I call the display method so
let's go to the display method where I
am doing a sis out for the static member
of the outer class which was this
variable so that value gets printed as
10 and then I'm printing the private
static member of the outer class and
that also is accessible so it means that
you can access the normal static
variable of the outer class and also the
private static variable of the outer
class inside a static nested class
that's one part of it now let's
uncomment this and see if this works you
see that you directly get a compilation
error and you don't even have to wait
for the program to be run you see that
this particular variable instance member
this instance member variable is not
accessible so this this also verifies
our understanding which which was built
previously in the previous session that
static blocks can only access static
members and those static blocks will not
be able to access any non-static
variable or member and this was a
non-static member so that's all I want
to cover in this particular session
where we talked about the nested classes
concept the static nested classes
Concepts basically and we also had a
look at what the static nested class can
access or cannot access and we also saw
how do we initialize an object of a
static nested class in the next session
we are going to talk about the second
category of the nested classes which is
the normal inner classes or the
non-static uh nested classes let's get
started with inner classes in Java so in
the previous session we talked about the
static nested classes and in today's
session we are going to focus on the
non-static nested classes we also call
them simply as inner classes so whenever
you hear the word inner classes always
clarify whether they mean the static
nested inner classes or the non-static
nested inner classes because people may
use different terminologies but the
official or the standard terminology is
whenever somebody says inner classes it
means the normal nested class and when
somebody wants to convey static nested
classes they will use explicitly the
word as static nested classes so when we
talk about inner classes they look a bit
similar to the static nested classes
with the difference that you will not
see a static keyword while you define
the inner class that's the one type of
the simplest inner class you can create
it follows pretty much the same kind of
construct where you define the outer
class and you define the inner class and
you write the logic inside the inner
class so let's understand this with the
help of an example and we will also talk
about the other type of in our classes
which we have so with that I want to
switch back to the Eclipse IDE and let
me comment this one out because I will
cover this in a while and let me fix an
error here as well so I will comment
this as well okay so let's talk about uh
the demo which we which I have prepared
it's a very simplistic demo just to
understand the concept and please do
practice all of these Concepts in detail
to get get more confident about this so
I start defining a normal class just
naming it as outer class and then you
can create a class within a class I'm
calling it as inner class you can
obviously name it as anything you want
and you can write any logic which you
want to write inside your inner class
here I just have a display method where
I have a simple sis out which is
verifying if I can invoke this
particular method or not so if you have
this simple kind of construct of outer
class or inner class how do you how do
you initialize the inner class remember
when we talked about the static nested
classes and if you wanted to initialize
the static nested class I had to follow
this particular syntax where I said
outer class do inner class on both sides
when I try to initialize the object but
if I want to initialize a normal inner
class or a nonat non-static nested class
the way to do that is like this so on
the left hand side you again follow the
same kind of construct where you say
outer class dot inner class class you
write a reference for it and then you
say new outer class here you are
creating an object of it dot new inner
class so you basically first initialize
the outer class create an object of the
outer class and then that object of the
outer class can be used to create an
object of the inner class so this is the
difference if I take you back to the
static nested classes initialization
here on the right hand side it was
simply outer class inner class and then
the parenthesis because this was a
static member so you access the static
members by the class name that's why
class name. static member but you access
the normal instance members via the
instance and not the class name so you
need to create the instance first and
then once you have created that instance
then you can access any member variable
of this class and inner class
technically is just a member variable
which has been initialized here so this
is how you're going to initialize an
inner class then you get an object of it
and once you have got the object of the
inner class then you can call the
display method and whatever is written
in the display method shall be executed
let's run this program yes I can see
that the display method is getting
called and it is printing whatever was
written inside the display method in the
display method I just simply had a sis
out which said this is a inner class
method and that's what is getting
printed here that's one type of the
inner class which is looking very simple
another a bit more complex and special
type of inner class is called method
local inner class when I say method
local inner class the name itself
explains what it means that you are
trying to create a class inside a method
of the outer class so let me just
uncomment this part so this is a normal
method normal instance method of the
outer class and inside the method I
create a class you see inside the method
all also you can create an inner class
that is also something which is
supported by Java and that's what I'm
trying to Showcase here that when I
Define the outer class method I write my
whatever logic I want to write in my
method and then I can create an inner
class a method local class basically
I've just named it as method local class
to uh to just look it more readable and
then you can Define anything you want to
write inside your method local class
here I have just defined a simple method
called local inner method and I have
just printed a statement inside the
local inner method which says in the
method local class method once I've
defined the class then within the method
I can also initialize the class if I
want you can see I'm creating an object
of the method local class within the
enclosing method that is also possible
so I create an object called mlc and
then once I have the object I can invoke
this method by the object and and that
is what I'm doing here so this whole
logic can be just embedded inside a
particular method and we call this type
of class as method local inner classes
this is also a type of inner class but
this is just to show you that you can
also create method local inner classes
so this is what I've done here and if I
if I invoke this outer class method what
happens let's see that so here I have
written the code to Simply initialize
the outer class nothing new here this is
normal initialization and once I've done
that once I've got an instance then I
say outer class do outer class method I
simply call the instance method and once
I call the instance method everything is
written inside the instance method gets
executed so first I should get this
statement then the class will get loaded
and compiled then an instance of the
class will be created and then whatever
is written inside the local inner method
will be executed so technically I should
see this sis out and ultimately this is
out if I run those two lines let me
comment the first part so that we can
observe the output correctly and I run
this as a Java application and I get
these two lines so I get the in the
outer class method statement which is
coming from here and then I this this
whole code gets executed and eventually
when this method gets called I get this
statement as well which is in the method
local class method so this is to show
you how you can invoke the local classes
basically there's nothing new here it's
just a normal class you instantiate the
normal class and then you call the
objects or you get an object and you
call the method on the object of the
method local class now there is another
type of inner class which is called
Anonymous inner class which we haven't
covered so far Anonymous inner classes
are not very common but sometimes you
you might need to do that you might need
to create Anonymous in the classes but
always first understand and discuss with
your teammates as to if there is a way
to avoid Anonymous inner classes because
they are not very readable but let me
cover that as well as part of this
curriculum so if you have to implement
Anonymous inner classes let's first
understand why do we need to implement
Anonymous inner classes and I would like
to do that with the help of a
demonstration so I have again created a
simple interface of bicycle and I will
create an implementation class called
mountain bike so you see a bicycle
interface and I have two methods which
says can speed up
and can apply break just simple two
interface methods being declared here
then I created an implementation class
called mountain bike which implements
bicycle and if it implements bicycle it
has to provide the implementation of
those two declared methods in the
interface and that's what it does here
and for the sake of Simplicity I'm just
printing assis out here all good so far
and then if you have to access or create
an object of this mountain bike class
the way you do that is simply by just
saying bicycle Mountain equal to new
mountain bike remember I'm using the
bicycle reference here and but the
object is of mountain bike so when I
call anything on the mountain bike then
that implementation of the mountain bike
will be invoked so I'm just invoking the
can apply Brak method and can speed up
methods nothing new here you have
already seen this when we were talking
about interfaces session but what if you
want to create an object of the bicycle
class itself you don't want to create a
mountain bike class at all is there a
way to avoid creating mountain bike
class and still being able to write this
logic yes there is a way and that is the
anonymous in way so I can just say
bicycle bicycle equal to new bicycle if
I say new bicycle remember I'm not
saying new mountain bike because
mountain bike does not exist or I don't
want to create Mountain bik class then
you can write this instantiation right
for the interface class but the moment
you hit control space and you will get
this option where it will say okay I
will get you an object of bicycle
interface but it has to be of anonymous
inner type which is of which is lying in
this particular package so if you just
click on this this whole code will be
generated for you so you see the moment
you double click on this this whole code
was generated automatically for you
which is providing everything
technically everything which you wrote
in the mountain bike class so the whole
logic which you write in a child class
gets embedded right into the
instantiation code itself and this is
your Anonymous inner class you see it
automatically looks a bit ugly and
imagine if you're writing this for a
real production code where each of the
methods may have lot of logic and you
may have lot of methods then it can grow
very long and it can look very ugly
that's why I was saying always try to
create a child class instead it can be a
simple uh use case but try to create a
child class or try to avoid writing
Anonymous in classes if you can if there
is no way out then this is the way you
do it you can there's also a bit nicer
way to do this using using Lambda
function for functional interfaces but
that is also something which will not uh
improve the readability a lot though it
will make the code look smaller so here
you can write the exact logic which you
want to write in can speed up and can
apply break basically whatever you wrote
in the in those two methods in the
mountain bike class can very well be
written here and the code will still be
executed so let's let's just do that
quickly so I will just go here and copy
the sis out from speed up method I'll
just put it here and I will copy the can
apply break method and I will put it
here and I will comment the mountain by
code so I'm creating I've created the
object of bicycle class here and now if
I say bicycle dot can apply breake and I
can say bicycle dot can speed up so now
I can access these two methods and the
implementation will will be invoked from
this Anonymous inner class
implementation so if I run this I will
get pretty much the same output yes you
can see I get exactly the same output
it's currently printing both of these
sis outs as the same because I did not
change the sis out here and yeah I have
written the exactly same text in both of
the cases so if I just change this text
to say can apply break and I do the same
thing here I say can apply break and if
I run this so you get the same output
and if you uncomment if you comment this
back and if you use the above code you
also get the same output yep so that's
the basic construct of anonymous inner
classes that you can use the interface
instantiation if you do not want to
create a child class of it just
instantiate the interface and Java will
automatically generate the concrete
override implementation for all the
methods which are declared in your
interface and then you can provide the
implementation of those methods in line
and that's all I want to cover for this
particular particular session so we
covered a whole lot we covered about the
normal iner classes we covered the
method local iner classes and we covered
the Anonymous iner classes let's get
started with packages in Java now I have
been using the concept of packages all
the while in all the sessions but we
never focused particularly on packages
and why we need them how do we create
them what are the thumb rules so we will
focus on all of those questions in this
particular session so first of all just
to get the definition out a package is
basically a grouping of related types
now these types can be classes they can
be interfaces they can be abstract
classes uh they can be uh nested classes
or whatnot but the basic idea is that
you try to keep everything which is
related to each other at one place it's
quite similar to how you arrange your
house or how you arrange your office or
how you arrange your work desk you try
to keep the similar kind of stuff
together for example you might have a
particular uh rack in your alira where
you keep all the books you might have a
different track where you keep clothes
generally you won't mix books and
clothes together in a single rack right
because they don't belong together and
that's the concept basically which Java
packages try to put you or give you to
implement in your programming language
and your project as well so it's a
logical way of grouping related classes
and types together that's what packages
do and if I take you back to the eclipse
p E before I go any further you will see
all these Square looking objects right
these all are packages you see the
square icons these boxes these are
packages and the way you create packages
is basically if you just go to the SRC
let me go back to the SRC and you right
click on this you go to new you will get
an option of package so you can go click
here and write any name of your package
let's say test. package couple of things
to note is that packages follow this
convention of Dot and that is how you
Nest a package into other or that is how
you create a hierarchy of packages and
sub packages so you can create this as a
package which is fine and you can also
create dot something dot something else
do something else do something else and
you can go further as well other thing
to notice is that this will not accept
keywords you can see it says else is not
a valid Java identifier because else is
a keyword a reserved keyword in Java so
make sure that you're not using those
reserved keyword names in the in this
particular package name so it can be
test DOT test 1 DOT test 2 DOT test 3
whatever so just make sure that you're
not using keywords here and you can
create the hierarchy now how do you name
them different organizations and
different project teams follow different
naming conventions this is your area
this is fully customizable so you can
write it write it the way you want it
generally what companies do is they put
their domain name from The Backwards so
for example uh google.com might have a
package called com. gooogle similarly
amazon.com might had a package called
com. Amazon internally this this is
something which might have been there
but they can they they might have chosen
something else but this is sort of the
standard convention that you just
reverse the domain name of your
application and you write the package
name backwards that is the general
convention and after that once you have
written that let's say if you have
written com. Google this is the top
domain name now after that you specify
what you want to do let's say you you
are implementing a web package then you
can be even more specific okay web
package is a is a huge huge package what
is specifically your this package will
be doing inside the web package so let's
say HTML HTML might not be a right
example but uh let's say some uh
frontend code front-end Au logic let's
say so now this can be a valid package
because if somebody reads the package
they can understand what would be lying
inside the package this hugely improves
readability and please do spend good
amount of time in naming your packages
right because once you write the code
the code is going to be living for many
many years to come and many other
developers once you leave the
organization many other developers will
be looking at that code and you would
like to make their lives easy by by
understanding The Code by just looking
at the package name so please name the
package names correctly and once you
have written this package name as for
example in this case frontend Au logic
or let me say frontend do Au logic once
you have written this package name as Au
logic then make sure that only the
classes which belong to this particular
business requirement are present inside
this package no other unrelated class
should go inside the package that is
something also which developer have to
take care of so this is again the
responsibilities of the developers that
they make sure that whatever goes inside
this this particular package is only
relevant to the package there's no
irrelevant stuff which should go inside
the package again this is to improve
readability searchability
maintainability and tons of other uh out
of the box uh benefits you get so that
is how you create the packages now let
me go back to the documentation and talk
about why would you use that let's look
at some of the more benefits of it so if
you scroll down in this official
documentation you will find bunch of
reasons and benefits of it first of all
you and other programmers can easily
determine that these types are related
because if something if some classes and
some types are sitting inside a package
then there is an expectation that those
classes and types serve the purpose of
that package only you also it also
provides a benefit that you and other
programmers can can easily find the
types that can provide a particular type
of functionality again the same concept
concept of aggregating simple uh single
functional classes into these packages
that if you are writing let's say a a
banking application and if you have if
you have a package called interest rates
then everything inside the calculation
of the interest rate and the
specification of the interest rates
should sit inside that particular
package only similarly the names of your
type will not conflict with the type
names in the other packages that is also
a huge benefit of packages that you once
you start writing a particular class
inside a package and if you make that
particular class as private package then
that particular class will be visible
only within the package and you can
again recreate the exact same class with
the exact same name in another package
let me give you an example so if I go to
uh let's say The Inheritance example
here I have a class called bicycle this
is a bicycle class and if you see
strategically I have not put public here
I have removed the public identifier
here so this class is only visible
within this package called do
inheritance this particular class will
only be visible in this package to these
other classes now if I go let's say if I
go to Method overriding I have another
bicycle. Java here if I open this this
is also a class these two classes are
exactly the same but they don't conflict
with each other because both of them are
package private and they live in
different packages and only those
packages can see them this particular
class is present in this particular
package which ends with method
overriding and this particular class
ends in a package which ends with do
inheritance so if I go here let's see if
I go to the main class and if I try to
type bicycle and I put control space you
see I only get the suggestion of this
package private bicycle class which is
sitting inside the method overriding
package itself what if I change this the
visibility of this inheritance package
bicycle class to public let's make it
public and now if I go back to the
method overriding demo which is sitting
in the method overriding package where I
already have a bicycle class and now if
I type bicycle and I do control space I
get two options one is from the local
package and because I have made the
other bicycle class as public I get that
as well as a suggestion and if I import
this one you see now the inheritance
package bicycle class has been imported
in the method overriding package it can
create a lot of confusion that's why it
is always a good practice to work with
the access modifiers really well and try
to restrict the visibility of the
classes to what they should be
accessible at and that's why it's a good
practice to keep the classes within the
package private visibility so that
they're only visible within the package
this will help you in lot of ways uh
providing any kind of uh any kind of
problems around ambiguity so ambiguity
is a big problem when you have huge
projects with lot of similar class names
so that's all I want to cover in the in
the session of packages and you can
obviously Nest packages within one other
you can go as long as the package name
you want to be just make sure that there
are no keywords in those package names
so that's all for this particular
session let's get started with recursion
in Java so let's first understand what
do we mean by recursion and then we will
look at uh the details of the class
which you are seeing on your screen so
recursion is the phenomena of an a
method calling itself so so we we have
the scenarios where we call a particular
method on an object right but what if
you have a scenario where a method wants
to call itself now you might be
wondering why a method would call itself
because this will go into an infinite
Loop right if you write a method called
sum and then the sum inside the Su
method you again invoke the Su method
then this will keep running into loops
till your program goes out of memory I
will show you the example of that as
well but the basic idea is the use case
where if you have a need where the where
the method wants to call itself that is
where you will use the recursion concept
another thing whatever you can achieve
with recursion generally you can achieve
the same output using for Loops as well
but when you use it for for Loops it
will require you to write lot of code
recursion will reduce the number of
lines you need to write and manage in
your code but on the other side
recursion can get a bit complex because
it requires an advanced understanding of
how methods actually work in Java so
before I go any further understand that
methods whatever you define inside the
method that goes onto a stack remember I
covered about stacks and it's a Leo
Arrangement so whatever you define
inside your method all those variables
and all those statements they go onto a
stack and then the stack gets emptied
one by one executing the statement which
is sitting on the top of the stack that
is the concept of the method execution
that under the hood it is using a stack
now when we talk about uh the recursion
it also follows the same stack uh
insertion and stack item removal concept
that how do you insert elements into the
stack and how do you remove them so I'm
we are going to walk through an example
of recursion with the help of a use case
called factorial now if you if you have
studied about factorial in your in your
school classes you might remember that
factorial is a way where let's say if I
have to calculate the factorial of 10
then it would be 10 into the factorial
of 9 into the factorial of 8 into the
factorial of 7 so you see I'm repeating
the concept of calculating the factorial
again and again first I'm calculating
the factorial of 10 in 10 into factorial
of 9 then I say 9 into factorial of 8
then I say 8 into factorial of 7 then I
say 7 into factorial of 6 and so on so
forth so this is the concept of how do
you calculate factorials another example
where you can use recursion is a
Fibonacci series so when we talk about
the Fibonacci series the basic idea is
that you sum the previous two elements
and that's how you create the next
element then this then you sum the
immediate previous two and you create
the next element so again you perform
the operation of summing the past two
elements again and again to calculate
the next element so you see again you're
repeating the same operation again and
again so try to identify that particular
thing where you have to repeat the
particular operation again and again on
the whole sequence that would be the use
case where you might be needing to use a
recursion concept so here I have
prepared an example for calculating the
factorial of a number so what you see on
your screen is a class called complex
function and then it has a method called
calculate factorial and inside the
method you supply an argument which is
basically a number for which you want to
calculate the factorial so if you supply
five a factorial of five will be
calculated if you supply 10 a factorial
of 10 will be calculated now the first
thing which you need to do when you
write a recursion function is to know
the exit condition that is probably the
most important concept when you write
recursion you should know when to end
the program if you get it wrong then
your program will stuck will be stuck in
to an infinite Loop and it will only
exit when there would be a stack
Overflow basically there will not be
enough memory inside the jvm to run your
program it will crash technically so
remember always to define a exit
condition some people also call it as a
base condition but remember the base
case or base condition or the exit
condition either of the terms can be
used interchangeably but always remember
to First Define the base condition so
here when do you end calculating the
factorial you know the factorial of 1 is
is one and it cannot go any further so
that would be your base condition that
once if if you if you encounter a
scenario where somebody inputs one as an
argument then you simply return one
because the factorial of one will be one
so this is your base case this is what
is going to make sure that your program
exits smoothly if you get it wrong your
program will never end it will go into
an endless mode then in the else
condition you write the factorial logic
based on the recursion so like I said
what does a factorial function does is
if you calculate the factorial of 5 then
it would be 5 into factorial of 4 4 into
factorial of 3 3 into factorial of 2 2
into factorial of 1 and that's when it
will end so here I'm saying let's say if
n was 5 so you say 5 into you again call
back the same function 5 into calculate
factorial of 5 - 1 so now again the
function will be invoked with an Nal to
4 it will go here this condition will
not be met because n is is four it will
go to the L's block again the same thing
will happen 4 into calculate factorial
of 3 so you are again invoking the same
function but this time supplying n as
three so it will go here n will be
supplied as three it will again check
the base condition n is still not 3 n is
still not 1 so it will go to the lse
block so 3 into calculate factorial of 2
it will again go up and again it will
invoke the calculate factorial method
but this time with Nal to 2 this
condition is still false because n is
still two it will go to the lse block
and it will say 2 into calculate
factorial of 1 it will again go up this
time it will invoke with n equal to 1
and it will go here and it will satisfy
the condition and that's where your
program will have its first output you
remember previous execution of 5 into
factorial 4 into factorial 3 into
factorial 2 did not result into an
output these were the executions of the
method call which were just going on the
stack so you were just at first you had
the calculate factorial of five on the
stack on top of it you had the calculate
factorial 4 on this stack then you had
calculate factorial 3 on the stack then
you had two and then you had one but
when you had one your program did re uh
uh received or reached an particular end
so that was your first output once you
have your first output ready then you go
back to the previous one so the first
statement has been popped now you go
back to the calculate factorial of two
and you calculate that once you have the
output of that then you go back to
calculate factorial of three and so so
you basically unpack the stack now you
basically try to remove the elements
from the stack to visualize this this is
how it will look like that you first
call the factorial 5 let me just change
the name of it just to make it look
exactly how it will go on the stack so
this is how it is going to go on the
stack so you first you call the
calculate factorial of five which turn
called the calculate factorial 4 which
in turn called calculate factorial 3
calculate factorial 2 calculate
factorial 1 and once you had the
calculate factorial 1 you got the first
output and once you had the first output
then you start unpacking it because you
had the value of the calculate factorial
1 so you can say 2 into calculate
factorial 1's output calculate factorial
1's output was 1 so 2 into 1 becomes 2
and this is the output of calculate
factorial 2 right then it goes to the
next step basically this one sorry this
one and calculate factorial 3 was
demonstrated as 3 into calculate
factorial of 2 so 3 into calculate
factorial of 2 which is this one 2 so
this gets replaced here two and you get
the output as six now you have this one
also resolved the next one on the stack
was calculate factorial of four which
was written as 4 into calculate
factorial of 3 so 4 into calculate
factorial of 3 output so this function
calls output this function's called
output was 6 it goes back and it says 4
into 6 24 and you have this one also
calculated now you go to the last
statement which was calculate factorial
of five which was written as 5 into
calculate factorial of 4 and calculate
factorial of 4 has been already computed
as 24 so now you can simply say 5 into
24 which is the output of calculate
factorial 4 and you get the output as
120 and this is the final return
statement which will be returned to you
so if you try to understand this till
this particular point you were just
calling function after function after
function with a different value of N and
everything started getting into a result
due to the base condition this was the
base condition and that's why the base
condition is very important now imagine
there was no base condition then this
would never return and it will keep
calling calculate factorial calculate
factorial and it will keep going down
the stairs it will never be a able to
come up because there is no base
condition and that's why base condition
is very important at the same time also
understanding how recursion works is
also very important Al always remember
that the output of the first execution
gets supplied in the second execution
the output of the second execution gets
supplied in the third execution and
that's how the stack unpacks or empties
itself so here I'm just doing the normal
drill here where I'm uh saying complex
function complex function equal to new
complex function and then calling the
calculate factorial method passing five
to it and then printing the eventual
result and if I run this I get the
output as 120 which I just walked you
through so remember how to use the
recursion why to use the recursion how
to define the base condition all of
these things will will be of of very
much importance when you try to
implement recursions practice this a lot
recursion is a concept which takes time
to to get used to so practice many
different examp examples and many
questions of recursion and you will be
more confident about it read more about
this concept in the Java docs look at
different examples on the internet that
will help you build more knowledge
around this and that's all I want to
cover in this particular session and in
the next session we are going to talk
about how do we call methods basically
how the method calling works we will
look at different examples and the pass
by value concept Etc when we look at the
method calling let's get started with
method calling in Java now when it comes
to defining the methods I have been
talking about methods throughout this
particular series and the syntax is
pretty familiar where you first specify
the access modifier then you specify the
return type then you specify the actual
name of the method and after that you
specify all the arguments which this
method is going to accept and inside the
curly braces you do your calculation and
based on the return type you return an
appropriate value we have seen many
examples of it and let me show you a
quick example to just understand the
method Anatomy better and then we will
talk about how do we pass arguments to
methods so in this simple class student
I have some properties I have
Constructor and then I have methods
these all are also simply methods you
can see we have an access modifier which
will decide whether this particular
method should be visible to the outside
world or not you can also either remove
this particular access modifier or make
the method private if you want or you
can also make the method protected if
you want so all of the possibilities are
there and that uh and what what kind of
access modifier will you keep depends
upon upon your use case so that is the
access modifier and then if your method
is not supposed to return anything then
you would just say void void is the
default keyword in Java which is used
for use cases when you do not want to
return something void just means empty
or nothing so when you have nothing to
return you are going to put void you
cannot skip this if you remove if you
remove this the method signature is not
complete so you have to provide this
there is no way around it so you need to
provide the method return type after
that you provide the name of the method
this is a free text string and you can
name it whatever you want just follow
the casing convention where you start
with a small alphabet and for every new
word in the method name you start with
the first letter as capital after that
you put normal braces and you supply the
arguments which this particular method
is going to accept for example if this
method was about calculating interest
then probably you might Supply the
interest rate as the argument and the
principle as the argument if this method
was about calculating the price of the
car then you might Supply all the
different mileage details and the
manufacturing details which would decide
the price of the car so it depends upon
what you are doing and that's how you
will understand what kind of arguments
your method is going to need when you
define the arguments you need to define
the data type of the argument and again
a name which you can give it give it as
anything this is again a free text
string and after that it depends upon
you what kind of logic you want to write
inside the method the basic need for
writing a method is to not do the same
thing again and again at every place if
you have a functionality let's say if I
take the same example if you have to
calculate interest and the interest
calculation logic is required at let's
say 15 different places in your
application then just create a single
method for calculating the interest rate
or the interest and then just reuse that
method again and again uh at different
points in your application just call
that method that's that's how we use it
so that that is the basic idea of
creating a method to keep reusing the
functionality over and over again across
all the different methods in your
application let's take another example
of this particular method because it has
a return statement again I specify a
public access modifier I specify the
return type which is string in this case
then I specify a name of the method and
I can also choose not to supply any
argument if the method does not need any
argument to do its computation or to run
its logic if you put a return type any
any other return type than V than void
here then you have to provide a return
statement the return statement will be
the last execution step of your method
remember that the return statement will
be the last execution step of your
method execution this has to be provided
if you provide a return type other than
void inside your method in this
particular case this method expect a
string return type which means when I
call get name I should get a result back
which should be of type string then I
need to write a return statement and
return a variable which should be of
string type for example if I just change
this method to say let's say if I say
int I equal to 1 and if I say return I
this is going to give you an error you
see there's a compilation error and if
you hover over the balloon icon it says
cannot convert from int to string it is
trying to convert this particular return
type and trying to match this into this
particular return type and it's not able
to match into two string so you get you
get an error so it has to exactly match
the return type the data type of the of
the return uh value which you have put
here it has to match match exactly with
the the return statement variable type
if it doesn't match you're going to get
a compilation error that's the first
thing now there might be scenarios where
you have multiple branches of execution
in your method for example if you have
if let's say say if I just uh use this
condition of I equal to 1 and I write if
I equal to equal to one then return
let's say a test string else return the
name I'll just cut this and put it here
and we'll change this to name this is
also possible and this is possible
because of the same statement which I
told you earlier that return statement
has to be the last execution step of
your method execution in this particular
method there are two branches of
execution this is one branch and this is
the other Branch at a particular time
either the if block or the else block is
going to get executed there would never
be a case that both of the blocks get
executed in the same execution cycle it
will always be either this block or this
block and that's why if you use these
kind of statements then you have to
provide return type in each of the
branches you can also do something like
this let's say if I say string return
where equal to null and then I say crl c
crl v I assign test string to the return
V and then here also I assign name
String to the return V and at the end I
say a single return and I say return V
this is also fine because here I am just
assigning different values in the if
block and the else block and then then
just returning the placeholder variable
which is also absolutely fine so you can
use either of the way the better way is
to return from within the branch itself
so this was a quick tour for you to see
how methods work and what kind of
anatomy method represent now let me just
quickly revert everything which I did
here and bring it back to return name
that's good and now let's talk about the
method calling patterns and how do we
call the methods so for that I have
prepared a class called method calling
demo it has a public static void main
method and here I have just declared a
simple variable I and initialized the
value of i as one then then I'm calling
a method which is named as change value
and if you go to this particular method
it has a very simple implementation it
is accepting the argument which I
created here I'm I'm passing this
particular variable as an argument to
this method and then whatever argument I
Supply I'm incrementing that argument by
one and just return and not returning
anything from here just incrementing the
value of I and that's it and after that
I'm printing I so what would be your
guess here what would be the value here
I'm going to pause here for a moment and
to let you think about what is going to
happen okay I hope you have you would
have done some calculations in your head
to see what is going to happen and what
is the value of I eventually at line 8
let's run this program to understand
that okay so I had initialized I as one
then I passed the value of I in this
particular argument and I said I equal
to I + 1 so it should be 1 + 1 = to 2
and I the new value of I should be 2 but
but at line 8 I still get I as one why
is that happening it's happening because
of the concept of pass by value remember
that concept that in Java every argument
which you pass to a method is passed by
value and not by reference in simple
language what does it mean is that when
you pass this particular argument a copy
of this particular argument is a copy of
this particular variable is passed to
the method argument it's not the exact
same variable we are not passing the
same reference of I here we are passing
a copy of it a unique local copy of it
that's why whatever you do with I inside
this meth particular method is not going
to change the state of I which is
defined here because it is passed by
value or in simple language the object
is copied over locally to the method
it's not the same reference which is
being passed upon that's why you see
this value if you want to get the return
value then the one way is to just change
the return type and say return I and
then just store this return I value here
saying int result equal to whatever is
returned from here and we are returning
the new I here and then you can print
the result and you will get two if I run
this now I get is2 so this is to just to
validate that this is everything in Java
is pass by value there is no concept of
pass by reference when we talk about
method calling in Java let's take a more
complicated example this was a simple
variable let's go back to the student.
Java so I have the student class here
let's create some objects of it and try
to follow the same pattern so here I
have created an object of the student
class named John age 25 address 23 East
California I'm doing some sis outs which
are not really important here but let me
just uncomment this particular method so
here what I'm doing is I'm calling a
method I'm basically defining a method
which says change name in the the same
object and I'm supplying the student
object so the student object gets here
and then I'm overwriting the name in the
student object that's what I'm doing
here so now let's just call this
particular method and see what happens
so I'm going to call this particular
method here and pass the object John
inside it and then let's try to print
the name of the object referenced by
John if I say get name so I'm calling
this particular method passing the
uh uh John object here where I'm
overwriting the name John with Jane and
then I'm printing the new name of the
John object let's see what happens now
so if I run this particular program yes
I can see that the name has been
overwritten from John to Jane now this
happened because you passed the
reference pointed to the object inside
the method and then you overwrote the
name in on the
object which was pointed by this
particular reference so here you might
think that this is pass by reference but
this is still pass by value because this
reference is not the same reference as
this one this is a different reference
but both references are pointing to the
same object that is the only commonality
here so you can mutate a particular
object inside a method and be very
careful of that do not ever try to do
that because it is going to create lot
of unpredictable results for you because
it might be possible that you're calling
a particular method from some other
application which is doing lot of
changes in the same argument object
which you supplied and then you don't
know what is the state of it so it's a
very dangerous pattern and very
dangerous way to mutate the objects do
not do this let's find another way to
deal with this problem if I don't want
to mutate the same object how do I solve
that problem so we can solve that
problem simply by creating a new object
and changing whatever we want to change
so I have one more method here which
says change name in a different object
it is also accepting the student object
and then here it is creating a new
student object and here it is
overwriting the name but getting the age
and the address as the same values from
the argument so we keep the age and the
address same but we create a new name
but we don't overwrite the same object
we create a new object and then we can
return this particular new object if we
want to I can do clear this and I can
say return new student and then I can
store the value of this particular
method calling I can call this method
here Supply the same argument as John
let me comment this one and then I can
store the value of the result student
result obj and I get the value here and
then I can say result obj doget name and
if I run this program now remember I'm
calling a different method now which is
going to create a new object and then uh
change the value I do get the same
effect but now my previous object John
is not touching at all it is safe and
sound I can reuse this John object
anywhere in my method in my application
and I can be assured that nothing is
changing in terms of the state of the
object so always follow this particular
pattern whenever you are calling methods
and passing arguments to the method and
if those arguments happen to be your
custom classes and even Java classes in
fact then always try to create a new
copy of the object inside the method if
you intend to mutate or change the state
of the object let's get started with
today's topic which is about exceptions
in Java let's first understand what are
exceptions and why do we actually need
this concept the simple reason for
having exceptions existence is that
developers make mistake we do create
bugs and errors while we write code it's
natural it always happens that whenever
you write code you might miss out some
condition or the other which creates a
bug in the application which creates a
defect in the application and then the
testing team finds that defect and then
we fix that defect and that's how a
normal software development life cycle
works so to handle those kind of
exceptions and errors every programming
language provides their own exception
and error framework to support the
developer in spotting those errors and
fixing those errors and handling those
errors instead and Java also provides
its own exception framework so what you
see on the screen right now is basically
the a snapshot of the exception
framework of java and you see it has a
long hierarchy of different classes here
this is also an inheritance hierarchy
just to give you context and the whole
exception framework hierarchy starts
with a class called throwable so
throwable is is the class which is the
root or the parent class of handling all
types of exceptions and errors and
that's where the next differentiation
comes exceptions and errors Java treats
these two things differently and I will
go in detail as to what is an exception
and what is an error but let's first
understand the hierarchy further under
the exception hierarchy you see some
exceptions like IO exceptions which is
an exception which comes when something
goes wrong in the file writing or file
reading or the file handling operations
then you have SQL exception which comes
whenever you are talking to the database
writing SQL queries and something goes
wrong you also have class not found
exception which comes when a class is
not found in the in the runtime or in
the OR at the time when the class is
being loaded in the jvm and then you
have also runtime exceptions which are
like arithmetic number format and there
are lot and lots more of this type of
exceptions as well on the right hand
side you have the error type and then
you have some errors like jvm error
memory error and framework error so now
coming to the differentiation between
exception and error exception is a type
of problem which can be recovered in a
program from which the program can be
recovered which the developers should
handle so exception is a type where the
developer focus is the developer is
responsible to make sure that none of
these exceptions occur in the program
and if these exceptions occur in the
program then the developer has the
responsibility to handle these
exceptions properly we will look at the
examples of how the developer can handle
these exceptions on the right hand side
is the error type where the developer
does not have any control you cannot do
anything if the jvm has an error or if
the underlying memory of the computer or
the jvm memory gets an error or the the
whole framework or the Java itself
Library itself has an error you can't do
anything about that and those are the
kind of problems which go into the
category of error that's why Java has
created these two different categories
one is exceptions which is the
responsibility of the developer and
other is error which are not the
responsibility of the developer and in
fact developer cannot do anything if
this happens so this was a quick tour uh
to you to what kind of the exception
framework is present in Java do read
about this framework in detail in the
Java docs as well but just to uh extend
this uh understanding further we'll have
a look at some examples of the
exceptions and how these exceptions
occur so with that I'm going to switch
switch to the Eclipse IDE and I have
created bunch of classes to show
different types of exceptions so let's
go through the first class which is
named as simple exception demo it has a
main method it has a variable of int
type the variable name is data and what
I'm doing here is I'm dividing 100 by
0er so if you see this carefully you
know that this is going to result in an
infinite value you cannot divide any
number by zero and Java also prohibits
doing the same because it doesn't make
sense to divide anything by zero so if
you run this particular line if you
execute this particular line this is
going to throw a runtime exception these
are the runtime exceptions remember so
let's try to comment rest of the code
and let's quickly try to run this so I
run this program and there you go I get
an exception which says exception in the
thread main main is the main thread
which the exception type is java. lang.
arithmetic exception and this is the
exception type divide by zero and it
will also give you the line number at
which the exception happens if you click
on this it will directly take you to the
exact line at which the exception
happened and this is you know if you see
now this helps the developer a lot this
information which is printed here is
called exception stack trace and you can
look at this stack Trace go to the last
line and this would be the line from
where the exception actually originated
if you click on that particular line it
will take you exactly at the place where
the exception might have occurred and
then you can look at the line fix the
code and rerun the program to see if the
exception is gone that's why I said that
developer has to handle this exception
now as far as handling these exceptions
is concerned I'm going to cover that in
the next session but in the in this
particular session we are just going to
focus on the types of exceptions and how
they occur this was an example of
arithmetic exception where we are trying
to divide something by zero let's take
another example let me uncomment this
particular line of code and comment back
this one so here I am creating a string
a but the string is null and null means
nothing it's it's a it's a void
reference it has nothing in it and now
if I try to do some operation on this
particular string so remember a is null
and whenever you are trying to operate
something on a null object Java is going
to throw you an exception because you
can't operate on null because null means
nothing empty it it is it is a dummy
thing so you cannot do anything on this
particular null reference and if I run
this program I get an exception which
says null pointer exception java. lang.
null pointer exception and it will give
you the exact reason cannot invoke
string do Care at int string dot this is
a string type string. Care at int
because a is null so it will give you
the exact reason as to why this program
failed and then again if you click on
this particular line it will take you
the exact line where the problem is and
then you can fix the problem maybe you
need to initialize the string properly
to make sure that this error doesn't
occur so these are all the runtime
exceptions which the developer has to
take care of which the developer has to
fix to make sure that the program runs
smoothly if they don't handle it the
program is going to fail and the program
will actually force them to fix because
the program will not run unless they fix
those exceptions now these are the
examples of runtime exceptions you can
also create these kind of exceptions
which are called checked exceptions
runtime exceptions are also called
unchecked exceptions you might hear this
term as well some some people use the
term runtime exception instead of
unchecked exception and use both of them
interchangeably so runtime exceptions
are also called unchecked exceptions and
these exceptions are called checked
exceptions why do we call them checked
and unchecked is because these
exceptions are something which you do
not have to explicitly specify in your
program in this program I did not have
toally specify this particular because I
don't know if this line of code is going
to result into a null pointer exception
or not but these exceptions are
something which Java will force you to
handle let's look at an example of this
so I have created one more class which
is named as checked exception demo and
I'm doing some file operations basically
reading a file writing to a file Etc I'm
using some classes of java named as file
reader and some methods like read line
and close and if you see the moment I'm
trying to read a file this line has a
has a red marker there's a compilation
error if you scroll over it it says
unhandled exception type file not found
exception so Java is forcing you to
handle this this particular exception
because file not found is a checked
exception so if your expression your
line of code is throwing a checked
exception then Java will force you to do
something about it it will not compile
the code until you either handle this
exception or you rethrow this exception
again how do we handle this is something
which we will cover in the next session
but you can you can always rethrow this
exception but you have to do something
about it you cannot just skip it so what
I can do if I don't want to handle this
is I will pass on the responsibility of
handling this exception to the Callie
program so whoever is going to call this
m method has the responsibility now to
handle the file not found exception
because I've just thrown it I've just
passed it on I've just passed my
responsibility to the collie and you can
do similar thing here as well if I go
here you see it says unhandled type
exception IO exception and if you
remember IO exception is here it is a
checked exception so I can do one more
throws here comma V and now if I just
resolve the import whoever is calling
the main method has the responsibility
of handling the file not found or IU
exception you can also handle it like a
said or you can just add throws Clause
to the method signature and then the
caller has the responsibility to fix or
handle the exception so this is how the
checked exceptions work remember in the
unchecked exception in the runtime
exception we we can see that these two
lines do throw exceptions but there is
no forced Way by Java to tell us that I
have to fix it because Java doesn't care
about unchecked exceptions at the
compiled time it will only encounter
those runtime exceptions at the run time
that's why they are called runtime
exceptions but checked exceptions are
compile time exceptions and you have to
fix them handle them or throw them right
at the time of compiling the code so
that was about checked exception now
there's also a possibility that you can
create your own exception if you want to
so for that I've just created a very
simple class here called my exception
and the way you create your own custom
exception is by just extending your
class with exception class you just
write this extends exception and you can
write a default Constructor or a
parameterized Constructor whichever
makes sense for you and this is your
exception class ready to use and you can
just invoke this exception explicitly
remember whenever you are creating
custom exception It Is by default a
checked exception so your program has to
handle it for example if I go back to
this particular class and if I do this
let me just comment all of this code now
and remove the throws Clause as well so
if I go here and I'm saying throw new my
exception my exception was my class so
I'm explicitly throwing an exception
which was my custom exception and I
again get the error if I hover over it
it says unhandled exception type my
exception so I have to handle this
exception or I can just throw this
exception and let the caller handle it
so this also works so this basically
builds are understanding that broadly
there are three different types of
exceptions which we work with there is a
runtime exception which is also called
unchecked exception which happens
because of developers mistakes in the
program like this one then there is a
checked exception which developer might
not be responsible for creating the
exception but developer has to handle it
and there are some classes in Java which
throw those checked exceptions like file
not found exception and IO exception
whenever you are working with file
handling operations Java will force you
to handle those checked exceptions or
rethrow those checked exception using
the throws Clause similarly the third
type is when you create your custom
exception type and custom exception
types are also checked exceptions by
default and whenever you are explicitly
throwing your own custom exceptions you
again have to either handle the
exception within your enclosing code or
you can just rethrow the exception and
let the caller handle it so this is a
quick tour of different types of
exception and including this exception
hierarchy and let's get started with
exception handling in Java using try and
catch blocks so in the previous session
we had a look at the scenarios where an
exception can occur how do we uh see
that there's a runtime exception or
there's a checked exception or there's
an unchecked exception or there is a
custom exception
now we did not talk about how to handle
those exceptions and now we are going to
focus on the handling part so whenever
you have to handle those exceptions the
way Java provides for that is using the
TR catch block so TR catch block is
basically a bunch of syntax which you
have to follow to handle different types
of exceptions in your programming code
and the syntax of the TR catch block is
pretty straightforward you write try and
you put curly braces and then you write
whatever code which might throw an
exception you don't know that but it's
always safer to enclose your code in a
TR catch block so that you know that if
an exception occurs in the tri block
then you can handle it in the catch
block so it's a it's always considered a
better practice to enclose your
application code in a TR catch block so
that you can handle the exceptions so
you put this triy block and write write
all the suspicious or non-suspicious
code which may or may not thr an
exception inside the tri block once you
have done the tri block part then comes
the catch block part so let me go to the
catch
block so this is how the syntax look
like once you have written the tri block
then you write catch and you put braces
and you write the exception type which
this block of code might throw or the
exception type which you are interested
in catching you might not be interested
in catching all the different exceptions
but only a few Ones based on your
business requirements so whatever
exception type you want to catch you are
going to catch it like this and if an
exception occurs in the tri code let's
say you have specified an arithmetic
exception here and if any line of code
in the tri block throws an arithmetic
exception then this catch block is going
to catch that exception and then inside
these curly bres you can decide what to
do with that exception whether you want
to log that exception or whether you
want to rethrow that exception whether
you want to uh embed some error code or
get an error code out of it or convert
that exception into a business or custom
exception of your own choice so it's up
to you what you want to do with that but
catch block will be able to catch that
arithmetic
exception similarly you can can specify
as many exception types to be caught as
you want and keep adding more and more
catch blocks remember that these catch
blocks work in a in a sequential fashion
so if an exception occurs here it will
first go to this particular block to
match the exception type if it didn't
match then only it will move to the
second type if it did match the first
type it is not going to execute the
second type so that is how the try catch
block
work you can see an example here that if
the code here is throwing an index out
of bond exception then it is going to be
caught here and we are just printing the
index out of bond exceptions message if
it is throwing an IO exception then I
can do this so you can keep adding
different checked and unchecked
exceptions in the catch
block you can also catch more than one
type of exception with one exception
Handler so rather than writing these
multiple catch Blocks individually you
can combine these exceptions together if
your logic of processing both of these
exceptions is the same remember if the
logic of processing these two exceptions
is the same logic means whatever you
write inside these curly brushes so if
that code is going to be the same for
both of these exceptions then why bother
writing two catch blocks just write one
catch block like this use the pipe
operator to separate different types of
exceptions and write the common code
which is going to be applied if your Tri
block is going to through an IO ction or
an SQL exception so that depends upon
you that's the second piece the third
piece of the tri block is the finally
block so we talked about the tri block
we talked about the catch block now
there's a finally block as well remember
this is finally and not final the
finally block is used together with a
tri catch block when you want to perform
some cleanup
operations imagine you are opening up a
file Handler in the tri block you're
doing something with it and then you
want to just close the file Handler
irrespective of the fact if there was an
exception in the tri block or not
because even if there was an exception
the file Handler resource is going to
remain open and is going to consume
memory in your application you might you
don't want to do that similarly if you
opened a database connection inside your
Tri block irrespective of the fact of
what happens in the tri block you always
would like to close the database
connection and you can write that
closing code in the finally block that's
the purpose of the finally block that
you can write the code inside the
finally block which is supposed to be
always executed irrespective of the fact
whether an exception occurs or doesn't
occur so now we have built a good
understanding of what is the try catch
what is what is the tri block catch
block and the finally block now if you
just put it all together this is how it
is going to look like that you write the
tri block you do something inside the
tri block then you write the catch
blocks after that you write the finally
block you can write the finally block
without the catch block as well remember
that if you do not have any exception to
catch but you have some resources to
close or free up after executing the try
block you can skip the catch block and
just write try finally that is also
possible with that understanding let's
switch to the IDE and let's look at some
example so I have writer helper class
which is having a method called Write
list I have a tri block here and this
Tri block is basically initializing an
error list adding an item to the error
list and then I'm accessing list.get one
remember when I added this particular
value let me make it 10 to make it more
understandable when I added 10 to this
particular list this goes to the index
zero position and here I'm trying to
access index one position which does not
have
anything so in such case it might throw
an error because there's nothing at
list. get one so this is my method where
I put the tri block code and then
because I don't want to end up in a
position where I get an index out of
bond exception index out of bond
exception comes if you are trying to
access an index which is illegal which
is does not having any value so I'm
putting a catch block and catching the
index out of bound exception
and just printing the message of the
exception and then I'm for just for
Simplicity I'm showing a finally block
as well do I do not have any resource to
close here but this is just to show you
how this looks like in the code this is
just to show you that I'm printing I'm
printing assist out here this is what my
method is and if I go to the main class
the TR catch demo class I'm creating an
object of the writer helper class and
calling the right list method which we
just walked through let's run this
program and see what
happens okay so first I get this
statement saying entering TR statement
so if I go
here I call this method the execution
goes inside the tri block and I get this
this out which says entering try
statement then I try to access the
second element in the list because the
position is one this is going to index
zero and I'm trying to access index one
there is nothing at index one so I get
an error saying index out of bounds
exception index one out of bounds for
length one because the total length of
the list currently is one because
there's just one element and that one
element is sitting at zero and not one
so I get the exception which is the
index out of bond exception but the
index out of bond exception is caught by
my catch block and the system. error do
print Len is something which gets
executed and I get this
particular line this particular line
from this line number 17 and then
irrespective of the fact whether an
exception occurred or not my finally
block always gets executed let's fix
this and see if the finally block gets
executed even if there is no exception
so now I'm accessing get zero and let's
see what
happens yep I access the element 10 no
exception but the finally block still
gets executed so this is to are
understanding that the finally block
will always be executed irrespective of
the fact whether there was an exception
or there
wasn't now you can also Nest different
Tri blocks if you want to let's look at
an example where I have multiple Tri
blocks so you can in you can write a try
within a try within a try if you want
and you can go as deep as you want but
remember the more indentations the more
hierarchy you create the program is
going to get more and more complex so
always remember
to have that kind of
tradeoff so I write multiple Tri blogs I
initialize an array I print array 10
obviously array 10 does not exist
because this array has just four
elements so this is bound to thr an
index out of bound exception and I'm
catching that exception immediately in
the catch block this is the exception
printing assis out and just rethrowing
the exception you can also rethrow the
Exception by just using the throw
keyword remember this throw is different
from the throws keyword
which comes in the method signature this
is just to throw any exception from your
code so this is array index Auto Bond
exception for this Tri block then I have
another array index out ofb exception
for this Tri block which starts from
here block two and then I have another
catch block for the block one Tri block
so you can see it is already getting a
bit complicated where I have multiple
hierarchies but you can do that so this
is what is happening in this particular
program now now let's try to run this
and see what happens and try to decipher
the
output okay so at first I get this
particular line which
says array index out of bounds exception
in block three what happens here is that
this line gets executed it throws an
array index out of bounds
exception at line 13 that array index
out of bounds exception is CAU which was
generated from this line and then we go
inside the catch block we execute this
sis out this is what you see here the
same sis out and then we rethrow the
exception if we rethrow the exception
the exception goes to the enclosing Tri
block the enclosing Tri block is this
one there was an exception rethrown from
this Tri block and now it has gone to
this Tri block and now this Tri block
block two will try to see if it can
catch this array index outof bound
exception yes we can catch it so it can
so so the block two again has a catch
block which catches the array index out
of bound and it prints assis out here
which says exception in Block two which
we see here and it again rethrows the
exception and if it rethrows the
exception so now the block
two now the block two is rethrowing the
exception so this whole code is now
rethrowing the exception if this block
two is rethrowing the exception it goes
to block one just going one hierarchy up
and then it sees if it can handle the
exception in the catch block of this
block one so yes the block one Tri block
also had a catch exception which said
array index out of bound E4 and here it
just had a sis out so if I just bring
back the output yes we do get this
particular exception printed here which
says ARR index out of bounds exception
in Block one one this is what you see
here and this is where the exception
just stops going propagated because I'm
not rethrowing the exception from this
particular catch block so that's where
the exception ends the reason you see a
hyperlink here is because the text the
text which I have printed here exactly
matches with the name of the exception
so Java is pretty smart in that case if
you use the exact same name exception it
will link it to the matching class name
in Java which is cool I also have a
redundant catch block here which does
not have a tri block this is just to
show you that you can write a catch
block without a tri block but it doesn't
make sense it is of no use so I can just
remove this particular catch block and
the program still will compile fine so
this was a quick demo to show you how
you can use try catch and finally blocks
and when would you use the finally block
and if you want you can use a nested
hierarchy of Tri blocks and you can
rethrow the exception from within the
catch block only to be caught in the
outside or the outer or the enclosing
block so this is all I want to cover in
this particular session let's get
started with equals and hash code in
Java this is probably one of the most
important and interesting Concept in
Java and extremely extremely popular
when it comes to Java interview
questions so let's cover this in detail
to understand why we need equals and
hash code and what equals and hash code
is all about let's first understand the
object class of java remember I'm
calling it an object class and not just
an object object is a class as well in
Java and it is the super super class of
any class you create in Java so anything
you do in Java any class you create it
will automatically be inherited by the
object class object class is the super
class of any class created in Java and
if you look at this documentation and if
you come here you will see that object
class defines this equals method which
indicates whether some other object is
equal to this one or not and it also
defines a hash code method which returns
a hash code value for the object so
let's understand both of them one by one
first of all let's establish that this
uh these methods have their concrete
implementations available inside the
object class
but how do you do that and how do how
does it come into
effect remember when we talked about
hashset and I said that hashset will
maintain uniqueness automatically how
does it maintain uniqueness
automatically it is because of the
equals method implementation which it
inherits from the object class that's
how it maintains uniqueness and if you
remember I also told that you can do you
you can maintain uniqueness in a hashset
if it's a built-in data type like
integer or string or float or double
Etc but what if you are trying to create
a hashset of student objects then Java
does not know how to perform equality on
two student objects because student is a
custom object Java doesn't know how to
run equality and that's where equals and
hash code comes into picture so the
contract is that whenever you are Crea
creating your own custom objects and you
have a need to perform equality on those
objects you must override the equals
method in your own class you have to
override that if you do not overwrite
that then two student objects will be
compared based on the reference and not
based on the actual object values we
will see all of that with the help of an
example another thing which says that
whenever you are overriding equals you
should also override hash code method
reason is because hash code is also used
in certain Collections and we will cover
that in a while but let's just focus on
equals first and let me switch back to
the Eclipse IDE where I have a student
class again it's a very familiar class
which we have covered in other lectures
as well and I have three different
properties here role number name and
address I have a Constructor and I have
Setters and
gets now if I go here and I create three
different objects of the student class
you see I have created three different
objects this student object has a role
number one name John and the address is
the same one second object has a role
number
two and the name John and the address is
the same as this one and third one again
has a different role number but the name
and address is the same it's a
hypothetical
situation so let's do one thing let's
make this role number as one as well so
now these two student objects are
exactly
identical so what happens if I compare
JN with John 2 by looking at Naked Eyes
these two objects look exactly the same
so John equals John 2 should return true
let's run this
program but we get false the reason we
get false is because the default
implementation of equals is being run on
the on comparing the student objects
because Java still does not know how to
equate these two objects why you are
getting false because these two are
different references Java created a new
memory location somewhere and put this
object created a reference drawn to it
then Java created one more new object in
this line and created a new reference
John 2 so these two different references
are pointing to two different memory
locations of the objects though their
internal values are same but their
memory locations are
different that's why you get this
particular value as false because these
are pointing to two different memory
locations and that brings me to the hash
code contract you need to override the
hash code contract as well along with
the equals to make sure that your
equality runs
perfectly let's go back to the student
class and let's fix this problem because
we can see that these are identical
objects you don't want to store the same
student twice in your database right so
you need to fix this so I go back to the
student. Java and I have commented this
equals method and let me uncomment this
now so what I do that I override the
equals method and the equals method
contract looks like this where you
supply an object which is an which is a
foreign object and now you need to
compare this foreign object with your
current object of the student class
which is
this so at first you need to run this
particular condition which says are
these two objects these two references
that this reference and the obj
reference pointing to the same object if
they're pointing to the same object then
this will return true and then we will
say that the object is that that
equality holds true because both are
pointing to the same object so obj
equals
this if that doesn't hold true if this
doesn't hold true then it moves on to
line 5050 and it runs a condition saying
that is obj null or obj dog class is not
equal to this.g class get class is a
method which will tell you the Class
Type here we are checking is the obj
class object is of the type student or
not if it's of different type let's say
vehicle or something then then
definitely they will not be equal and we
can directly return false so that's why
I'm checking that it should not be null
or the class types should be matching if
these two conditions are if either of
these conditions are holding true then I
return false and I say that objects are
not equal so I've covered this condition
where both of the references were
pointing to the same object I covered
this condition where the class types
were not matching or the obj itself was
null then all then we return false if we
passed all of these sanity checks then
we do the actual comparison
before doing the actual comparison I
need to do this explicit casting so I
cast the obj object into the student
type if you remember this this is how we
did this this casting for other data
types as well once you have converted
this obj into the student object then
you need to Define your own business
logic based on which you are going to
Define uniqueness so how are you going
to uniquely identify a student in your
application will govern this logic in
this particular example I'm saying that
I am going to identify a unique student
based on its role number so even if two
students have exact same matching
details but if their role numbers are
different then these are two different
objects for me but if two objects have
are having the same role number and even
if they have a different name and
address I'm going to say that those two
objects are duplicate so role number is
the is the condition on which I'm
defining
uniqueness equality and duplicity so I
Define this and say if the role numbers
are equal then the object is equal
objects are same basically or duplicate
and if the RO numbers are different then
these two are different
objects good so far coming back to the
main class so now I have the same role
number here let me change the name just
for fun and address as well so I have a
different name and a different address
but the role number is exactly the same
remember we have defined the equality
condition based on the role number and
here we are comparing if John is equal
to John 2 or not so let's run this
program now I get true the reason I get
true is because this equals method is is
used to run this equals
comparison so this establishes how we
can use the equ
contract to maintain uniqueness now I
also said that whenever you have you are
defining the equals method you also have
to override the hash code method and to
understand why do we need hash code as
well let's go back to how hashmap Works
remember in the hashmap or or let's say
even hash set in the hash set you have
to maintain uniqueness now Java
maintains uniqueness using both equals
and hash code hash code is nothing but a
memory bucket
in the in Java's memory where your
object is stored it's basically a memory
location so every object has a hash code
and that hash code is the actual memory
footprint where the object is
stored and whenever you're dealing with
hash set or hash Maps you will be
required to override both of these
methods let's understand how this works
so if you have a hash set and you are
trying to insert an element then first
Java will use your equals method
definition to check if an object similar
to the object being inserted is already
present in the hashset or not if it
finds an object it will basically flag
that this is a duplicate object and it
will not insert it let's understand how
an object is fetched from hashset let me
open a hashset example just to give you
some sort of a visual representation of
what I'm talking about so if I go to my
hash set example Le in in the
collections package
somewhere and let's open a hash set demo
class yeah so when we were doing these
insertions though this is this was a
string object so it was the Java already
knew how to use the equals and hash code
of it but if it was a student object and
you were doing multiple G uh add and
then when you were actually fetching the
element or you were doing the contains
then how does it work is basically first
it is going to calculate the hash code
of the object let's say you you saying
hashset doget b or hashset doget John
one then it is going to calculate the
hash code of your John one
object hash code is a memory footprint
and hash code and the way it is going to
calculate the hash code is going to be
based on the definition which you have
provided so the definition which you
have provided this hash code will be run
to calculate the memory footprint and
then that particular memory Java will go
to that particular memory footprint and
see if there is an object present there
or not now Java has a memory location
right and there can be multiple objects
stored at that particular memory
location this is possible in Java so if
there are multiple objects present in
that particular memory location which
was calculated based on the your
hashcode implementation then Java is
going to run the equals method to find
the exact matching object so just to try
to visualize this if I try to visualize
this let's say you have this memory
locations and let's say your hash code
came up to memory location two and then
at two memory location you had multiple
objects
obj1
obj2 obj3 Etc this is possible multiple
objects can point to the same memory
location so if this happens then Java is
going to use the equals contract to
compare your John one object with obj1
with obj2 and with obj3 this is where
the equals will come into use so you see
the both hash code and equals are being
used here to point to the right memory
location and that's why I said that hash
set and hash maps are where equals and
hash code will come in full force where
you will be required to implement this
and it's a good practice to always
override the equals and hash code in
your application whenever you are
creating classes the reason is that you
don't know when and where these classes
will be stored into a hash set
collection or a hashmap collection so
it's always a good idea to have equals
and hash code being implemented and when
you implement hash code the rule the
thumb rule is that you should use the
same parameters which have been used in
the equals contract in the hash code
contract as well the reason for that is
what if you used here let's say you used
name here and you used role number here
then two different properties are being
used to find memory location and un and
the uniqueness and remember this logic
which I just gave you here both hash
code and equals are working together to
find the right object so if you are
going if you make any mistakes in
defining the equals and hash code or if
you made any mistake in defining the
Symmetry between equals and hash code
then you may get unpredicted results how
you define your hash code up to you but
make sure to use the same properties
which you have used to define the
equality always keep this consistent to
avoid any unexpected
results you can also do this just say
return one and every and what happens
what will happen that when you use this
particular student class in a hash set
all the objects are going to be stored
at a single memory location and then
this particular situation will occur
where you will have a single memory
location and all of your objects will be
present at that memory location and when
you are trying to fetch anything the
hash code will always point to the same
memory location and then equals will
make sure to find out the right object
you're trying to fetch from the hash set
so this is all about equals and hash
code which I wanted to cover in this
particular lecture do read about this in
detail there are tons of article
available on this particular concept
because this is a very important and
popular concept both from implementation
perspective and from interview
perspective and that's all we are going
to cover in this particular session
let's get started with comparable in
Java and before we go there let's
understand why do we need comparable the
need for comparable comes from the
requirement whenever you have to sort
your collections so to understand that
let's move over to the Java docs to
understand how this works so the basic
idea is that you want to sort your
collection and to do that Java provides
you with a method called collections.
sort you just provide you just Supply
your list or your collection inside the
sort method and all the elements or
objects inside your collection will be
sorted based on the natural sorted
ordering this holds true for built-in
data types but what if your list is of
type student objects then again the same
constraint applies that Java does not
know how to sort student objects it
knows to sort strings and inss and
floats and doubles because those are
built-in data types but student is a
custom type and Java doesn't know how to
sort it and to solve that problem Java
provides an interface called comparable
so comparable is the interface which you
need to implement from your class
whenever you have a need to sort your
objects or of your class type so this is
the interface which your class class
needs to implement this interface
provides a single method which says
compare to and it provides the foreign
object and then you need to compare this
foreign object with your current
object so let's go back to the Java
class and understand how do we work with
this comparable
interface so again I have used the
student class for the sake of continuity
and I have the same properties as role
number name and age but this time I say
implements comp parable of type student
this is a generics type we are we will
be covering generics in a bit more
detail in this in this whole series but
the basic idea is that to Define that
this comparable interface will only work
for student types you define the type in
this particular construct which we also
call a generic type so you do this and
the moment you do this Java will force
you to provide the implementation of the
compar to method which I have provided
here
so the way this uh implementation works
is you have a foreign object here but
this time this foreign object since I
have defined this as of type student so
if you the moment you do this Java will
ask you to override this method and
using Eclipse IDE if you override this
then you will get this signature
automatically let me show you this how
this works so if you do this you will
get an error here and if you click on
this balloon it will say add
unimplemented methods if you double
click on this you will see a compar to
implementation here and this is exactly
the skeleton which you see here by
default it says return zero but I'll
just come back to that in a
while so this is how this method came up
here and once you have this signature
available then you need to provide your
implementation on how do you want to
sort the objects remember you need to
Define your your logic here so again I
would like to sort my students based on
the role number which is the natural
sorting order for me for the student
objects so this is your custom sorting
logic which you which you can call As
Natural custom logic sorting order for
your student objects so I want to sort
them based on role number but you see
I've done a strange thing here I've done
a minus here so what I'm doing is that
the current objects role number minus
the foreign objects role number so if
this
value comes as a positive number then
this this object is going to take
priority this is going to be sitting
before the
student if this result returns in a
negative value then this object will
come first and this will come second so
the student object will come first and
this object the current object will come
second and if this returns zero then it
means both of the object deserve the
same priority or the same order priority
and any one of them can come after the
other so the basic idea is that if this
if this results in greater than zero
then the current object is going to take
precedence if this is going to return in
a negative value then the foreign object
which you're supplying here is going to
take precedence and if this returns in
zero then any one of them can take
precedence so you need to Define your
compara to logic in the compared to
override
implementation once you have done that
let's understand this with the help of
an example I have created a comparable
demo class which has a public static
void main method and I create an array
list and I create three different
student objects first student object is
named as John second is Jane and third
is Tom the first has a role number of
three so John has a three RO number of
three Jane has a role number of one and
Tom has a ro number of two so if my
compare to logic runs perfectly then
Jane should be coming first after after
I sort this collection after I add these
three elements into my list and once I
sort this collection then Jane should
come first Tom should come second and
John should come third based on my
natural ordering ordering custom logic
which I have implemented in the compara
to method and that's what I'm doing here
after I've sorted the list I'm just
printing the list by using the for each
construct of the streams API I'm just
printing the name to see which one comes
first and which one comes second so
let's run this
program and this is how it looks like so
Jane comes first because she had a role
number one Tom Tom came second because
he had a role number two and John came
third because his role number was three
so no matter how many times you run this
program you're going to get the
collection in the same sorted sequence
and this is happening because of the
compared to implementation which you
provided here now if you comment this
implementation let's see what happens
and I remove this implements comparable
as well from here I just create a simple
student class and now I try to run the
sort now you see that you get an error
here and if you hover over this balloon
it says that the method sort in the type
collection is not applicable to the
argument array list of student Java does
not know how to sort this so it will
force you to provide a sorted
implementation and the moment you
provide comparable implementation here
and if you go back to the main class the
error is gone so this also will force
you to provide your comparable
implementation now you can use this
sorting for any kind of collection
sorting as well and whenever you are
doing this always make sure to provide
the compare to implementation and
remember that contract which I gave you
about greater than zero less than zero
and equal and that's all I'm going to
cover in this particular session let's
get started with comparators in Java in
the previous session we talked about
comparable where we said that whenever
we want to implement a naturally
occurring sorting order where you just
say collection do sort and you sit back
and relax if you have provided the
compare to implementation you would
expect things to work but what if you
have a custom sorting requirement let's
take a hypothetical scenario where you
created an application and your
application has a student object and you
created a collection of student objects
and now you have different consumer
applications let's say you have a
payroll application you have a
attendance system you have an
examination system you have another
extracurricular activity system and all
of them want to get the student
collection but all of them have
different sorting requirements payroll
wants to have the Sorting based on the
role number uh attendance want to have
the Sorting on some other mechanism
extracurricular application want to have
the Sorting on some other mechanism so
how do you implement custom sorting or
multiple sorting Logics for your
collection and that's where comparators
comes into picture comparator is again
an interface as you can see here in the
signature and this interface provides
you the flexibility to Define your own
custom sorting logic multiple times so
you can create multiple comparator
implementations and each comparator
implementation will focus on a
particular sorting order so that's
that's the basic need of sorting so
remember whenever you want to sort the
object in an order other than natural
ordering or ordering or you want to sort
some object that don't Implement
comparable so whenever you have these
kind of conditions always think of
comparator apart from that always think
of comparator when you have to provide
multiple sorting implementations on the
same collection so let's see how can we
do that with the help of an
example so here again I have the same
student class and I have the same
properties currently by default I have
provided a comparable student
implementation which is exactly the same
as we covered last uh in the last
session and if we use this particular
implementation uh you we create an array
list we created multiple student objects
we added them to the list and we called
sort so what happens if I just comment
the new code and if I just run this
particular
code remember the Sorting is happening
on the role number so here role number
one Jane will come first role number two
Tom will come second and RO number three
John will come third but then you had
one more application which wanted to
have the Sorting based on the age of the
student so these are the age values of
the students and some application wants
you to provide the Sorting
implementation for the age now age is a
custom sorting logic which you need to
provide and whenever you have that kind
of situation create a comparator how do
you create a comparator like this simply
create a class name your comparator
anything
try to end it with the suffix comparator
so that you know that this is a
comparator implementation and then you
say Implements comparator of the class
type this is what you need to do and the
moment you need to you do this it will
force you to override this compare
method remember the comparable
interface provided compare two method
where you supplied the just the foreign
object it its name was compared to with
single object in comparator the name is
just
compare and you have two objects here
student one and student two let me just
call them student one and student two
for Simplicity o1 and O2 look a bit
weird so I've just refactored this one
and I will refactor this one as well so
I have student one and student two and
this is an age comparator so I want to
apply the Sorting logic based on age
simply put Whoever has whoever is
younger should come first and whoever is
older should come later in the
collection once I sort
it so let's see how this sorting logic
is
implemented this is a single line code
so let me just put braces around it so
that it's more easily readable you can
write it without braces as well if you
have a single statement inside the if
block or else block but you can always
write it like this
this and let me
just format this as
well okay so this is the compare
implementation the first logic which
I've run is saying which says that if
the first student's age is less than the
second student's age then return minus
one
similarly if the first students
age is greater than the second student
age then return + one and if both of the
students age are same then return
zero so this is your custom logic and
this is where you need to Define your
logic and remember this will also govern
whether the Sorting is going to be
ascending or descending so for example
if you have provided that student once
age is less than student 2's age then
return minus one then this is going to
maintain the natural sorting or the
ascending order
sorting now if you want to have a
descending order sorting just change
these values saying that if this is less
then return one and if it is greater
then return minus one and this is going
to run the Sorting in a descending order
fashion now so it depends upon what kind
of sorting order you want and based on
that you can Define the values but the
default is always like this that
whenever the first object's value is
less than the second object value return
minus one and if the first object's
value is greater than the second
object's value then return + one
otherwise return zero minus one means
this one this one will get precedence
over this one so this is how you have
provided your age comparator going back
to the main class and uncommenting the
other part of the
code here I have called the sort method
where I want to sort the list but since
I want to supply a custom sorting
operator or a custom sorting comparator
here I need to provide that comparator
object here so remember the age
comparator which you created here you
just need to provide the comparator you
need to tell Java how to sort this
particular list if you do not tell Java
how to sort this Java is going to look
for the comparable implementation in the
student class and it will sort the
student objects based on the compare to
implementation provided inside the
student class but if you want to have
more custom control over sorting then
you need to tell Java how to do that
sorting and if you see this is an
overloaded representation this is a
method overloading example as well where
the method signature is same but just
the number of arguments are different so
this is how you provide your custom
sorting you supply your comparator now
you can create multiple comparators you
can comp create another comparator based
on let's say name you can had have one
more property here create one more
comparator so you can have as many
comparators as you want just keep
creating them and keep supplying them
individually one by one in the sort
method you can just duplicate this and
add one more
comparator so this is how you are going
to have more control and if you have
multiple consumer application call
multiple sort methods Supply their
corresponding comparator and you'll get
the sorted collection so here I'm just
printing the list based on the age
comparator
sorting and these are the objects so
let's see how this
works and understand the output from the
beginning so the natural sorting order
is something which we have already
covered which was done based on the role
numbers so Jane comes first Tom comes
second and John comes
third and this is how you get this this
particular output now coming to the age
comparator you you print this particular
statement which is coming here and then
you print these values so let's see how
the age comparator is working the
youngest here is John so John comes
first then we have Tom who is 20 years
old so Tom comes here and then we have
Jane who is 21 years old and Jane comes
in the last so we can see that our age
comparator has fired here and it has
sorted this in an ascending order now
let's flip the
values I'm going to change the values
here and now it should work in a
descending sorting order for the age
comparator so let's run this application
again and now you see Jane comes first
who is 21 then Tom comes who is 20 and
then John comes who is 18 so now the age
comparator is working in a descending
order so this is all I want to cover in
this particular session and in the next
session we are going to have a look at a
project which will cover all the
concepts which we have talked about so
far accelerate your career as a software
developer through this postgraduate
program and fullstack web development
course in collaboration with carch ctme
today we will be discussing about the
core Java projects so before we begin I
would like to tell you guys that we have
daily up dates on multiple Technologies
so if you are a tech geek in a
continuous handun for latest
technological Trends then consider
getting subscribed to our YouTube
channel and hit that Bell icon to never
miss an update from us now let's have a
quick look on the agenda for today's
discussion so we will be dealing with
two projects today which is ATM machine
and calculator application and the
source codes for these particular
projects is linked in the description
box below you can have a check on it and
you can try the projects on your own as
well I hope I made myself clear with the
agenda now over to the training expert
hello guys this is Vikes and let's get
started with today's topic which is
about walking through a particular
project using all the concepts which we
have learned so far so in this session
we are going to focus on a particular
project and the project we are going to
focus is is about an ATM application so
you might have interacted with different
ATM Stores in your cities where you go
in you insert your card you enter your
PIN and then you can view the balance
you can withdraw some amount you can
also deposit some amount from the ATM so
we will try to look at it from that
perspective and and we will see what
kind of different uh Java and oops
Concepts we can use to build such ATM
application this is not a super
versatile application but this is just
to give you the idea of how to use those
oops Concepts to build a simp simple or
a complex Java application so let's
start from the options menu class
because that will give us the
understanding of what kind of
functionality I'm using and here you
will use that I'm using different
concepts which I have taught you so far
in this particular Series so for example
we are using the IU exception we are
using the hashmap class we also using a
scanner class which is used to take
input from the command
line so this option menu class is
extending the account class and I will
come to the account class in a while but
let's see what this option menu class is
doing this particular class has a uh it
is using a decimal format money format
class which is to denote what kind of
format of money you have then we have a
hashmap which is storing the couple of
uh Records of account number to pin
mapping so we create an map and inside
the get login method we we add couple of
entries to the map here the first entry
the first integer is pointing to the
customer number and the second integer
is pointing to the pin of the account of
this particular customer
number so if we call the get login
method this method will insert the
data after that it will ask the customer
to enter the customer number which has
to be one of these two if you provide
any other value then there should be a
logic in the application to reject the
input so whatever a customer number the
customer inputs we pass that inside this
particular method called set customer
number again I will come back to that
and once we have provided a valid
customer number then this method is
going to ask you to enter a PIN number
and remember I told you this is the
customer number to the pin number
mapping so whatever customer number you
select from here you will be providing
the corresponding pin number and again
if you provide an invalid pin number you
will get an
error so that will all happen inside
this Tri block and if you enter any
invalid characters in the pin number or
the ATM uh customer number then you will
get an exception which I am writing
inside the catch block this is all what
we have seen so
far after the successful enter of the
customer number and the pin number I
fetch those values from these two
methods again I will talk about what
these methods are doing and again I'm
doing some basic validation checks but
things get interesting in this method so
what we covered so far was the get login
method let me close this method here so
we covered the get login method the
second method which is defined in this
particular class is the account type so
here the we will ask the once the
customer has provided the customer
number and the pin number we will ask
the customer to provide the account type
this application supports two different
account types which are checking account
or a savings account so whatever so the
customer has to choose one of them again
we will be taking the input from the
command line using the scanner class and
then I'm using a switch case if the
customer entered one then I will execute
some code for the checking account which
is defined here in the case one and if
the customer entered two then the case
two will be executed and if the if it
enters three then I will exit the
application
by just printing a sis out so here I'm
using the switch case construct to
provide different options to the
customer there's also a default case
specified here which says invalid choice
so this is what is happening in the get
account type
method the next method is if the
customer has used the option
one then we call the get checking method
so let's go to the get checking method
which is the next method which is
defined in this particular class so if
the customer has selected a checking
account then we provide the following
functionality to the customer which is
the customer can view the balance
customer can withdraw the funds customer
can deposit the funds to the checking
account or they can just exit the
application and again I'm using a switch
case here based on the customer types 1
2 3 or four the corresponding case block
will be executed for example if the
customer wants to view the balance then
this block will get executed and and I
call the get account type
method if the customer selects the two
as the withdraw fund then get checkings
with withdraw input method gets called
and then get account type gets called
similarly if the customer enters three
then we deposit the fund and for that
also I have defined a method I will go
to the definition of these methods as we
go along but right now we just building
the framework so the get checking
deposit input method will be called
whenever the customer select the option
three and for option four we just exit
the
application so this is what is happening
in the get checking method now if from
the account selection if the customer
selected second option which was savings
account then we were calling get saving
method so this is where the get saving
method is defined and again it is
following the exact same format as we
saw in the get checking method where we
pres present the following options like
viewing balance withdrawing the funds
and depositing the funds in the savings
account and I have some methods defined
here for example get saving withdraw
input get saving deposit
input so we Define the switch case here
based on the customer choices here and
that is what is happening in the get
saving method so let me close this
method as well and that's all what is
defined inside the option menu class so
we ask the customer to enter the
customer number the pin number from from
this get login method then based on that
we provide the customer the options to
choose the account type whether they can
choose the savings account or the
checking account and based on that
whatever account type they use we call
the get checking or get saving method
and inside this method we provide the
customer the other options to either
withdraw the money deposit the money or
view the balance that is what is
happening inside this option menu class
now let's go to the account class and
all the methods which we saw here will
be provided a definition in the account
class you also see this option menu is
extending the accounts class so an
inheritance concept is being used here
let's go to the account class now so
this is the account class where I have
defined some private member variables
like customer number so now you will be
familiar with the customer number pin
number which I just described and also
with the checking balance and the
savings balance you can also divide this
account class into two child classes
where you have a savings account class
and a checking account class but for
Simplicity I've kept it to one class I'm
initializing a scanner input which will
be used at multiple places and then I
have the Setters and gets for these four
member variables so you see set customer
number get customer number if you
remember this set customer number was
called in the option menu class if I go
back to the get login once we ask the
customer to enter the customer number we
call the set customer number which gets
called
here
similarly we call the set PIN number
which gets called
here similarly once we have set that we
then we were fetching the values using
the get customer number and the get pin
number and that is that is also defined
here in terms of the Getters get pin
number and get customer
number similarly we also have the the
Getters for the checking balance and the
saving balance member variables we do
not have the Setters for them because
they are not technically Setters but we
have to calculate the balance it's not a
simple Setter where you can just return
the
value so now let's look at some of the
business functions of the account class
how do you deposit how do you view the
balance how do you withdraw the balance
Etc so you see these two methods which
are specifically when the customer is
trying to withdraw the money from their
account and these methods are basically
called internally by other methods so we
will come to that let's just understand
that we have two methods for calculating
the withdrawable amount or executing the
withdraw transaction for the checking
account account and the savings account
similarly I have two more methods here
which are calculating the depositing for
the checking account and calculating the
depositing for the savings account
and then we get the the bigger methods
which are using these calculation
methods so I defined four calculation
methods so far calc checking withdraw
Cal saving withdraw calc checking
deposit and Cal saving deposit basically
withdrawing and deposit for both of the
classes and then we have these business
functions called get checking withdraw
input and get saving withdraw input get
checking deposit input and get saving
deposit input so these getter methods
are something which were being called
from the option menu class if you
remember if you go back to the option
menu class and if you chose the checking
account you get these options and let's
say you chose option two which was
withdraw funds or option three which was
deposit funds then the corresponding
methods which were being called were get
checking withdraw input and get checking
deposit input
and this is the exact same method get
checking withdraw input and get checking
deposit input so if you see what is
happening inside this particular method
is couple of s outs then we take the
scanner input amount and we we convert
that amount to the double after that we
check if the amount which the customer
wants to withdraw is smaller than the
checking balance or not and I'm running
this condition to check that if the
amount is smaller than the checking
balance then we call the Cal checking
withdraw method which was defined right
here remember I told you that these four
Cal methods will be used and this is how
they are used so here I'm actually
subtracting the value so whatever amount
the customer wants to withdraw subtract
that from the main balance and then
return the new main balance that's what
you do right if you have 1,000 rupees
and if you want to withdraw 500 you
subtract 500 from 1,000 and then you
send back the remaining
balance so that is what is happening
when we call this method and then we
print the new checking account balance
that is what is happening in the get
checking withdraw input method similarly
if you chose option three which was
depositing funds to the checking account
then get checking deposit input gets
called and it is defined right here get
checking deposit input and here instead
of subtraction we are doing the addition
so here I'm again doing a condition
check that the current balance plus the
new amount which has been supplied by
the customer from the command line the
total sum of it should be greater than
zero what if the customer entered an
amount minus 5,000 I should not allow
that so that's the reason I'm putting
this condition in place and if the
current balance plus the new amount
which is supposed to be deposited to the
account the sum of it is greater than
zero then call the Cal checking deposit
method and this is where the calc
checking deposit method is present and
where I'm just doing present balance
plus the new amount and returning the
New
Balance that's all which is being done
here and you will see exactly similar
logic running for the savings account as
well if you look at the get saving
withdraw input which is used to withdraw
money from the saving account so I take
the input from the command line and I
run a condition check that the amount
which the customer wants to withdraw
should be less than the current saving
accounts balance if yes then call Cal
saving withdraw method which is defined
here where I subtract the amount from
the current balance and I return the new
balance and similarly you will see the
exact same functionality in the get
saving deposit where we add the money
instead of of subtracting the money and
this is all what is defined in the
account class so we talked about the
option menu class we talked about the
account class and now we have the ATM
class which is the entry point which
basically initializes the option menu
class and calls the get login method
remember get login was the first method
which asked you to provide the customer
number and then get login called the
method to choose the account type and
the account type methods then called the
method to choose the option to withdraw
deposit or
exit so now we have built a fair
understanding of what is happening in
this application so let's run this
application so I just ran this
application and let me bring the console
here it's first asking for a customer
number so I will go to the option menu
class and I will pick up one of the
customer number which I have hardcoded
here so I will provide that customer
number and hit enter then it asks me for
the PIN number so remember you have to
provide the correct pin number
corresponding to the customer number so
I'm taking this pin number just copying
it and pasting it
here then this whole code got
executed and then it called the get
account type and the get account type
method provided you with these options
which you see here on the screen so
based on what you select the case block
will get executed and let's say I want
to go for a checking account so I press
one and I hit enter once you select the
checking account the case one get
selected and it calls the get checking
method and the get checking method again
provides you with another menu view
withdraw or deposit or exit so let's say
I want to deposit funds so I press three
and hit
enter it says the current balance is
zero and enter the amount you want to
deposit
let's say I want to deposit 500 and I
hit
enter you get the message saying the new
checking account balance is 500 and you
have successfully deposited the money
and that is what I did for the checking
account now let's try to withdraw
something from the checking account so
you again get back the same option
because inside the get checking
method we call the once we have
successfully done the business operation
we again call the account type uh method
to display the menu again to the user so
let's see again select the checking
account class and this time I want to
withdraw the funds remember I've added
500 there so let's say I want to
withdraw so I choose the option two as
the choice current balance is 500 and
it's asking me the amount you want to
withdraw from the checking account so I
enter let's say 100 and I hit enter when
I do that the new checking account
balance becomes 400 so the 100 got
subtracted from the 500 and the new
balance is shown to your screen you can
do exactly the same thing for for the
savings account as well and let's also
run a negative condition so I again
select the checking
account and I want to withdraw the funds
I choose the option two current balance
is 400 and I I would like to withdraw
1,000 what
happens if you do that we get a message
saying balance cannot be negative and
this is coming from the calc checking
method which which is defined here so
what is happening that I wanted to
withdraw the funds from the checking
account and here get checking withdraw
input. called here this condition was
checked so the checking balance was 400
and the amount I wanted to withdraw was
1,000 so 400 - th000 is not greater than
equal to Z so it jumped into the L's
block and it said balance cannot be
negative so this is how you can also
build some error conditions in your code
which are mandatory and which should be
built otherwise your application will
have lot of bugs we can also exit the
application so if you just type three
and hit
enter you will exit from the application
and it will again call the login method
where it will again ask you to enter the
customer number so this is how you can
run this application and this is this
was a simple use case for you to show
how you can use the different
objectoriented concept like classes
objects methods Setters Getters switch
case Etc to build the application with
the correct business logic and this is
all I want to cover in this particular
session and in the next session we are
going to have a look at another
interesting core Java project just to
build our understanding more better
about the core Java concept choose from
over 300 in demand skills and get access
to 1,000 plus hours of video content for
free visit scaleup by simply learn click
on the link in the description to know
more let's get started with walking
through a core Java project using all
the different oops concept we have
learned so far so in this example we are
going to have a look at a calculator
application and this calculator
application supports primarily four
different operations like addition
subtraction multiplication and division
so let's see how do we build that app so
in front of me right now is open the
main class so I have a main app class
here which has a public static void main
method and the first thing we see is a
read input class which is calling a read
method so if you go to the read input
class it has a simple static method here
which is the read method and it is using
the scanner class if you remember I
talked about the scanner class which is
used to take inputs from the command
line from the user so we we initialize
the scanner class and we start taking
the inputs and whatever the user inputs
in terms of the expression let's say the
user entered 4 + 5 or whatever that
whole expression gets sent back into
this input line as a string and that
comes back here in the input expression
once we have captured the input
expression the next thing we do is
divide the input expression in the
numbers and The Operators basically an
expression would be either something
like 4 + 5 into
3 divided by two let's say let's say the
user entered this expression so this has
either numbers or
operators so that's what we are doing
here we are using the split method of
the string API the string class
basically and this split method is going
to split the numbers and operators into
two different string arrays and here I'm
providing the split expression that
split at every time you encounter one of
these symbols so this when you execute
this particular statement it is going to
return a numbers array which will be uh
created based on this expression so you
will get an array with 4 5 3 and 2 and
similarly in the operator array you are
going to split or pick out the elements
every time you receive a number so this
operator array is going to hold this
plus sign this multiply sign and this
divide sign hope you get the
understanding that we are just splitting
the whole expression into two different
arrays where first array is holding only
the numbers and no mathematical
expressions and second array is just
holding the mathematical operators and
no numbers and we'll see why we need to
do that in the upcoming
lines once I've created the string array
I just want want to store or convert
these string arrays into a q so I
convert this array into a list by
calling the array do as list so this
expression is going to return a list and
then I'm going to convert this normal
list into a link list and then going to
store this link list into the que of
numbers and I'm going to do exactly the
same thing for the operator array as
well
converting this into a generic list
converting that generic list into a link
list and then storing this link list as
a que so I have an operator q and I have
a number que both of them have been
stored into a queue now and then I'm
using the poll method if you remember
the poll method of the queue is used
when you want to fetch the first front
element the head element of the que so
whichever element is sitting at the head
of the que will be taken out the the
moment you call the pole method so I
fetch the first number from the numbers
Q so in this case four will be fetched
here in this variable and after that I
run a loop on the numbers q and I'm
going to run this uh particular Loop
till this particular Q is not empty if
you see there's a negation here so I'm
going to pick up numbers one by one from
this number Q till the number Q becomes
empty and inside the loop I do this
exact same pole operation for the
operations queue so this operations cue
is holding all these mathematical
operations like plus star and divide so
I'm going to pick the head of it so in
this case plus will be picked up and
will be stored in this variable called
opr and then I'm going to run a switch
case on this opr basically as I told
told you in this particular calculator
application we are supporting four
operations which are addition
subtraction multiplication and division
so I Define a case for each of the
mathematical
expression so you see there are four
different cases here and for each case
I'm initializing a class if it's a plus
sign then I'm initializing the add class
if it's a minus sign then I'm
initializing the subtract class for
multiplication I have a class called
multiply and for division I have a class
called divide let's have a look at what
this classes are
containing so if I go to the add class
first of all it is implementing an
interface called
operate and this operator interface has
just a single method called get results
which is accepting a variable argument
array if you remember I told you that
you can also use a v ARG array this is
called a v ARG expression this means
that this numbers will be an array of
arbitrary length it can be a one element
array it can be a two element array it
can be a Four Element array or whatever
you supply but it is still going to be a
fixed length array but the length is
going to be dependent upon how much
argument you supply to this particular
method so that is what this interface
operate is doing it just has one method
declared which is called get result
which is accepting an array of numbers
so if the ad class is implementing the
operate interface then it has to
override the get result method and here
it is just doing a summation of all the
numbers which have been supplied so if
you supply four numbers it is just going
to add up those four numbers and return
the sum and the exact same kind of logic
or similar logic will be seen in other
operate classes so if I go to the
subtract class it runs the exact same
operation but it subtracts the values if
I go to the multiply class it is also
implementing the operate interface and
in the get result it is just multiplying
all the
values similarly in the Divide
class it is also implementing the
operator interface and it is dividing
all the numbers one by one so it's doing
pretty much the same thing in terms of
the expression and the logic the only
difference is whether you are using an
add operation or a subtract or a
multiply or a divide so we have checked
all these classes and and the operate
interface as well and let's go back to
the main app now now you also see that
I've defined a reference of operate here
and each of the uh switch case block I'm
assigning the object type to this
interface reference so I'm using the
concept of dynamic binding which we
talked about when we talked about
interfaces that we can also do Dynamic
binding where we can assign an object to
an interface type and the object type
will depend upon the
expression so once we have filled that
based on the case while filtering out
this expression and picking up plus star
and divide sequentially then we go to
the next line outside the switch case
block which is to pick the next number
from the que remember we already did one
poll here so as per this example four
was here in this rest and now when we do
this number do Pole
again five will be picked up because
that will be the next head of the que so
we pick up five here and then we call
operate. get result now this get result
will be called based on the expression
which was encountered first in the Q
again looking at the example the first
expression encountered will be plus so
the expression was plus so the operate
type object is of add type and when you
call operate. get result the get result
method of add class is going to get
invoked and it is going to sum four and
five this rest is holding four right now
based on what I described here numbers.
pole and this num is holding the the
second oper hand basically basically
five here so 4 + 5 gets evaluated here
in this case and then it again goes back
here and it checks if the number Q is is
now empty no it is still not empty
because we still have three and two left
there so again it does the operations do
pole and it picks up multiply sign here
then it again runs the switch casee
since it's a multiply sign it will go
here and it will initialize the operate
interface reference as the object of
multiply class then coming here it will
do a numbers do pole and this time the
numbers. pole is going to pick up three
so three will be picked up here and then
the current value of result which is
already 9 4 + 5 was 9 the current value
of result will be updated here so rest
will be nine here and num will be three
here and when you call operate. get
result the multiply classes get result
will get called and it will say 9 into 3
which will become
27 it will again go back here to this
particular line and it will check again
if the numbers Q is now empty no it is
still not empty because we still have
one element left then it pulls the Q of
the operations where the expression
divide is present there which is the
only element left in this particular
operations q and since we have the opr
value as divide this case block gets
called and the New Divide class gets
initialized the Divide class basically
gets initialized and we come here and we
do numbers. Pole now now the last number
which is available in this queue is two
which gets picked up here and then we
again call operate. getet result this
time since the operate object ref object
uh operate reference type was of divide
class type so when we call operate. get
result The Divide operation or the get
result method of the Divide class
basically this method will get invoked
and it will divide the current value of
result which was 4 + 5 9 into 3 which
was 27 so it is going to divide 27 by 2
which was the last value of the numbers.
pole it is going to execute 27 by2 and
whatever value it gets it is going to
store value back into the rest variable
and then it is again going to go back
here and again going to check the
condition if the numbers Q is not empty
but now the numbers Q is is empty
because two was the last element so it
is going to come out of the loop and it
is going to print the final result that
is how this whole program is working now
let's try to see this in action and
we'll try to execute the exact same
expression so if I right click and go to
run as and run this as Java
application and I Supply an expression
saying 4 + 5 Star 3 divide
2 and if I now hit enter I get the value
as 13.5 which is exactly what we ran
through because 4 + 5 will be evaluated
first which will result into 9 then 9
into 3 will be 27 and 27 / 2 will be
13.5 exactly so this is how this whole
program is running where we first take
the inputs and then we divide the input
into numbers and operation arrays or in
fact cues and once we have those cues
built up then we pick up the first
number and we keep running this Loop
till the numbers Q is not empty inside
the while loop at each step we pick up
the first expression or the operator we
check what is the operator whether it is
an addition subtraction multiplication
or division operator and whatever kind
of operator we have we initialize the
corresponding class of it and then we
fetch the next value in the numbers q
and then we call the get result based on
the expression and whatever result we
get from the get result we store it back
into the rest variable so we keep
updating the rest variable at every step
that's the reason the result of 4 + 5
gets stored in the rest and next time
you are calling the get result for a
multiply operation here the rest value
is 9 now and it says 9 into 3 again in
the next time the rest value will be
updated to 27 because we are storing the
result back into the result
variable so this is all I want to cover
in this particular session where we
looked at an example of a calculator
application purely from the console
standpoint obviously there can be lot
more stuff which we can do into this
particular application make it more
error free and cover a lot of corner
cases like validating the inputs Etc
also looking at putting some conditions
around the exception handling handling
the divide by zero scenario Etc which is
not here but this is just to show you
the basic idea of how you can build
simple to complex CLI applications using
the core Java Concepts today we will be
discussing Java interview questions we
all know that Java is one of the most
soft programming languages in the
current IT industry there are multiple
multi-million dollar companies which are
using Java till today so this video is
completely dedicated to help out the
Java developers and the beginners in
Java programming language to crack the
most frequently Asked Java interview
questions so without further Ado let's
begin with our interview
questions at first we will start with
the beginner level interview questions
so in the beginner level interview
questions the first question we have is
what is
jit so the answer for this question
is jit is an abbrevation for Java in
time compiler it increases efficiency of
The Interpreter by compiling the bite
code in the
runtime jit or justtin time compiler
compiles code to Machine level directly
for higher speed of code
execution so basically just in time
compilation is a feature added to The
Interpreter of java so this involves
conversion of the code directly to Mach
Machine level during the compilation
stage this improvises the speed of
execution of a Java program now after
the first question the second question
in the docket is what is a class loader
now let's discuss the answer for this
particular question so basically class
loader is the first file to load when
you execute any Java program so the Java
class loader is the integrated part of
java virtual machine so the
functionality of class loader is to load
the class to the Java virtual machine
while it is demanded to execute a
class Java has both strap extension and
application type of class loaders so the
third question in the docket is what are
the memory allocations available in Java
so the answer for this particular
question is Java provides multiple types
of memory allocations but the five major
types of memory allocations which are
most frequently used are class memory
Heap memory stack memory program counter
memory native method stack memory so the
next question in the list
is will the program run if I write
static public void main so basically we
write public static void main but in
case imagine if I write the program as
static public void main will the program
execute properly so the answer for this
question is yes because Java does not
follow any specific rule for the order
of specifiers you place in your program
so when you execute the program with
such pattern in your specifiers then the
program will compile successfully also
it will run successfully so the next
question we have
is what is the default value stored in
local
variables so in C programming language
when you declare a local variable or a
global variable or any type of variable
then the first value which is stored
inside that variable will be a garbage
value unless you initialize the variable
with a personalized value for example if
you declare a variable I equal to zero
then you're storing a value in that
variable I that is zero if you just
declare it as in I then the value stored
inside that I variable will be a garbage
value so similarly when you declare some
kind of local variable in Java then what
will be the default value stored inside
it so the answer for this question is
neither the local variables or the
global variables or any Primitives or
any object references do not have any
kind of default value stored in them so
followed by the fifth question we have
the sixth question so what would be the
output of the following code segment is
the sixth question so this might happen
sometimes so basically what happens is
your interviewer will throw a question
at you which has a code segment so all
you need to do is decode that code in
your mind and provide the output so this
would be the code that we will be
dealing
with so you can see our question has two
prin of statements the first one has 100
+ 100 plus a string which is simply
learn and in the second printer
statement we have a string that is
e-learning company plus 100 + 100 so
what will be the output of these two
print of
statements so the answer for this
question is really
simple so we'll be having 200 simply
learn as the first output and e-learning
Company 1 0 0 1 0 0 as the second output
why let's check out the code segment
once again so when you see the code
segment once again so the first prin of
statement has 100 + 100 plus simply
learn so jvm here understands 100 as an
integer value and the plus symbol symbol
as an addition operator here so followed
by the addition operator we have another
integer value so what jvm does is it
adds the two numbers 100 + 100 so
followed by that we have another plus
symbol here so followed by the plus
symbol we have a string value so here
the jvm considers the plus symbol as a
concatenating operator but not as an
addition operator so that's why the
first two numbers got added and the
result was 200 and the next two values
were concatenated so it became as 200
simply learn similarly in the second
printer statement the jvm encountered
with a string value so it considered the
plus symbol as a concatenating operator
similarly it happened with the second
plus symbol as well so that's the reason
we had e-learning 1
010 as the second out
output now followed by the sixth
question we have the seventh
question what is an
association so the answer for this
question is an association can be
defined as a relationship that has no
ownership over the other so to
understand this definition we can
consider a simple
example consider a person associated
with multiple Banks so consider person X
who has got accounts in Bank a bank B
and Bank C and similarly a bank is
associated with person X that is a bank
a bank B and Bank C are associated with
the person X but no one has ownership
over the other a person X who is an
account holder with all the three banks
that is a b and c does not possess any
kind of ownership over the three Banks
similarly Banks a b and c who who has
the customer which is a person X but the
banks do not possess any kind of
ownership over the customer so the
relationship between the person X and
the banks ABC can be considered as an
association now followed by the seventh
question we have the next question that
is the eighth
question Define copy Constructor in Java
so the answer for this question is as
follows a copy Constructor in Java is a
Constructor that initializes an object
through another object of the same class
a copy Constructor in Java is really
helpful because when you want to copy a
complex object that has several fields
or when we want to make a deep copy of
an existing object then the copy
Constructor is the one which will help
you out in this
situation so followed by the eighth
question we have the ninth
question what is a marker interface so
the answer for this question
is an empty interface in Java is
referred as a marker interface
serializable and clonable are some of
the popular examples of marker
interface so basically a marker
interface is just another interface but
normally in interface we provide some
signatures so these signatures belong to
particular methods so in normal
interface we just have methods
signatures but not the complete
implementation or at least we'll be
having some variables but in a marker
interface we do not have any kind of
data manipulating method signatures any
data members nothing they have special
functionality unlike a normal interface
so followed by the ninth question we
have the 10th question what is object
cloning I guess the word object cloning
is completely self-explanatory yet the
answer for this question is it is an
ability to recreate an object completely
similar to the existing object this
process is known as object cloning in
Java Java provides a built-in function
or method that is the Clone method to
clone an existing object offering the
same functionality that of the original
object so followed by the 10th question
we have our 11th question why is Java
not completely
objectoriented so this question might be
a little confusing but it's true jav is
not completely objectoriented but what's
the reason yes I'll explain you why Java
is not completely
objectoriented so the answer for this
question is Java is not considered as
100% objectoriented programming language
because of the data types it uses it
still makes use of eight or more
primitive data types which are int float
double and few others so this is the
only reason why Java is not considered
as completely one 100% objectoriented
programming language so the next
question is Define rapper classes in
Java so the answer for this question is
in Java when you declare primitive data
types that is the in float double Etc
then the wrapper classes are responsible
for converting them into objects or
reference types just as we discussed
before Java is not 100% objectoriented
programming language just because of the
primitive data types it uses so when you
include such primitive data types then
raber classes are the ones which convert
them into objects or reference types for
the ease of compilation and execution of
programs without any issues so followed
by this question we have the next
question Define single time classes in
Java so the answer for this question is
in Java when you make the Constructor of
a class as private then the particular
class can generate only one one single
object this is the reason why such type
of classes are called as Singleton
classes so followed by that we have our
next question that says Define package
in Java so if you use some of the
popular idees that is the integrated
development Enterprises such as in tal
or Eclipse then you might be familiar
with projects packages source files and
then the class file so basically you
create a project first and inside the
project you will be having your Source
folder and then you will be creating
your own package using the source folder
and inside the package you will create a
class file and inside the class file is
where you write your Java program so
here the question is Define package in
Java so the answer for this question is
as
follows package is a collective bundle
of classes and interfaces along with
necessary libraries and jav files the
use of packages helps in code
reusability so basically when you create
a specific package inside that package
you will store all the class files that
you will be using in your Java program
so not only class files in case if you
use any kind of connectors or any kind
of Jar files or any kind of dependencies
for your Java program you will include
all those inside the package so that the
requirements and the class files are
bundled together and this this helps out
in code reusability making sure that the
program files or the jav files or any
dependencies are not juggling between
one package to the other or one file to
the other so using a package is
basically a good
practice so followed by this we have our
next
question can you implement pointers in
Java program so if you remember C
programming language we had pointers
there so we use pointers to directly
access the
memory so similarly can you use pointers
in a Java program this is a little
tricky question for beginners but
basically it's really
simple now the answer for this question
is no because Java virtual machine
personally takes care of memory
management implicitly so Java's major
motto was to keep programming simple so
accessing memory directly through
pointers is not a recommended action so
the answer is a big no you cannot
Implement pointers in Java
program so followed by that we have our
next
question differentiate between instance
and local variables so the answer for
this question is really simple instance
variables are declared inside a class
and the scope is limited to only a
specific object inside which an instance
variable is created so followed by the
instance variable we have the local
variable so the local variable can be
anywhere inside a method or a specific
block of code also the scope is limited
to the block of code where the variable
that is the local variable is declared
now followed by the 16th question we
have our next question explain Java
string pool so the answer for this
question is a collection of strings in
Java's Heap memory is referred as Java's
string pool so for example you wanted to
create a new string consider your name
so your name might be some XYZ so if you
wanted to create XYZ string then you
provide that particular code to your jvm
so what does jvm do it will not directly
create that particular string first it
will search for the XYZ string in your
string Poe if that is already existing
in your string pool then it will provide
a reference to that particular string in
case if XY Z is not there then the jvm
will create a new string that is the XYZ
string so followed by this we have our
next question that is what is an
exception so the answer for this
question is an exception in Java is
considered as an unexpected event that
can disrupt the normal flow of the
program so for example just consider
that you are going to write a program
for division operator so after you
finish your program your evaluator might
want to test your code to the extreme
levels so instead of providing a proper
number imagine that your evaluator is
providing a wrong input such as special
symbols sometimes zero or any other sort
of input so if this kind of input is
provided to your program then your
program might crash so you can avoid
this kind of Crash by using exception
handling so basically you can use try
and catch blocks so you can embed your
code inside the tri block and say to
your program that if any kind of wrong
input such as special symbol or zero is
provided by the evaluator then send a
message saying wrong input or divide by
zero exception so this kind of approach
will provide an output but this kind of
approach will avoid your program from
crashing so this is how exceptions are
handled in real time so followed by this
we have our next
question what is final keyword in
Java so the answer for this question is
the term final is a predefined word in
Java that is used while declaring values
to variables when a value is declared
using the final keyword then that
particular value of that particular V
variable will remain constant throughout
the execution of program so sometimes if
you include a normal variable and
provide an operation on that particular
variable then the value of that
particular variable will change after
the execution of program but when you
declare the same variable using final
keyword then no number of operations or
any kind of manipulations Applied onto
that variable will not change the value
of that particular variable so that's a
speciality of final keyword in Java so
followed by that we'll dive into the
next question that is what happens when
the main method is not declared as
static so the answer for this question
is when the main method is not declared
a static then the program may be
compiled perfectly but ends up with a
serious ambigu and throws a runtime
error that says no such method error so
when you basically declare a main method
don't forget to specify the static
keyword so with this we finished the
beginner segment of questions followed
by the beginners segment we have the
next segment that is the intermediate
level segment so the first question in
the intermediate level is what is jdk
and mention the variance of
jdk so the answer for this question is
so jdk is basically an abbrevation for
Java development kit this is a combined
package of JRE that is the Java runtime
environment and developer tools used for
Designing Java applications and applets
Oracle has the following variants for
Java development kit so the first one is
the jdk standard edition which is
normally used by beginners and
intermediate developers next after the
jdk standard edition we have the Java
development kit for Enterprise so this
particular Enterprise Edition is used by
professional Java developers for
developing Java based applications and
Frameworks now the last one is the Java
development kit micro Edition now
followed by 21st question we will dive
into the next question that says brief
access specifiers and types of access
specifiers in Java so the answer for
this question is as follows basically
access specifiers are predefined
keywords used to help a Java virtual
machine to understand the scope of a
particular data member or data
manipulating method within a class or
outside the class so in Java we have
four types of access specifiers the
first one is Public Access specifier so
when you declare a data member or a data
manipulating method as public then that
particular data member or method can be
accessible by any class CL or object
throughout the package followed by that
we have the private access specifier so
unlike the public access specifier when
you provide the private access specifier
then the accessibility of that
particular private data member or the
data manipulating method will be
provided to specific classes and
specific objects only and finally we
have the protected access specifier so
the protected access specifier is a bit
more secure than the private access
specifier so the access for this
particular protected data member or
protected data manipulating method could
be a little more difficult to access
unless you are going to implement
everything which is present in that
particular package so basically if you
are trying to access the protected data
member or protected data manipulating
method of a different package then you
need to First import the package into
your existing package so that's how the
protected access specifier Works
practically so finally after the major
three access specifiers we have the
default access specifier so default
access specifier will be provided by the
Java virtual machine so in case if you
declare a variable or a data
manipulating method without using any
specific access specifiers that are
public private and protected then jvm
implicitly consider
the default access specifier so there is
no much of a difference between the
public access specifier and the default
access specifier both have the same
functionality and accessibility so
followed by this question we enter into
the next question that is can a
Constructor return a value so the answer
for this question is as follows yes a
Constructor can return return a value it
basically Returns the current instance
of a class implicitly you canot not make
a Constructor return return a value
explicitly but automatically it Returns
the instance of a
class so the next question is explain
this keyword in Java so in Java we do
have a keyword which is called as this
so what does the keyword this mean in
Java is the question so the answer for
this question is that term this is a
special keyword designated as a
reference variable so the term this
keyword is used to refer to the current
class properties like data manipulating
method instance data member and
Constructors so followed by the 24th
question we have our next question that
says explain super keyword in Java so
the answer for this question is as
follows the term super is a special
keyword designated as a reference
variable so similar to this keyword even
super keyword acts as a reference
variable but the difference is super
keyword is used to refer to the
immediate parent class object so
followed by the 25th question we have
our next question that is explain method
overloading in Java so basically method
overloading and Method overriding Etc
are the concepts of polymorphism so now
let's have a correct answer here so the
process of creating multiple method
signatures using one method name is
called as method overloading so for
example consider that you wanted to
include an addition operation in your
program that performs addition operation
so the first method will be having the
name add and inside the method
parameters you'll be having two integer
types of parameters similarly you wanted
to perform another addition operation
with the same name add so here you will
provide the method name
completely same to the first method but
inside the parameters there is a
difference you are adding three
parameters here so when you pass the
values to the add method then which
method to be overloaded that's the
confusion right so should I overload or
should I execute the first ad method or
the second ad method so this completely
depends on the number of parameters you
pass if you are passing two parameters
then the first method will be executed
if you stop passing three parameters
then the second method will be executed
so this is how the method overloading
happens in Java so the process of method
overloading can be achieved by using two
different ways the first way is to
change the number of arguments so that's
what exactly I've discussed before now
the second way is varying the return
type of the method so with this let's
enter into the next
question can we overload load a static
method so as discussed before the values
of the variables or data manipulating
methods will not be changed when we have
used the keyword static in front of it
so the question is can we overload a
static method now let's discuss the
answer for
this the answer is no Java does not
support overloading of static method the
process would throw an error reading
static method cannot be referenced so
followed by this we have our next
question so the next question is Define
late binding the answer for this
question is binding is a process of
unifying the method call with the
method's code segment late binding
happens when the method's code segment
is unknown till the method is called
during the runtime so followed by this
we have our next question Define dynamic
method
dispatch so the answer is the dynamic
method dispatch is a process where the
method call is executed during the
runtime the overridden method is called
through a reference variable of super
class so this process is called as
runtime
polymorphism now we have our next
question why is delete function faster
in link list than an array so basically
link list and array are the Java
Collections or in other words it's also
considered as data structure so to
answer this question you need to
understand the analogy of Link list and
array so basically an array is a
complete memory block of consecutive
memory locations so consider that your
memory location starts from 100 and your
array has 10 locations so it's a
complete reserved block of from 100 101
102 to
one9 so you have 10 memory blocks so in
case if you wanted to add a number or
delete a number then you had to make
changes to the complete memory block but
when you come into link list you have
the memory blocks used from the memory
Heap so basically what you do here is
you basically connect the notes through
addresses so in case if you wanted to
eliminate a number then what you do is
just to manipulate the addresses so the
address of the consecutive node will be
changed so that's the only change what
you make so now this is the reason why
the delete function or any kind of
manipulation function is faster in link
list compared to array so now let's have
a brief answer on this delete function
is faster in link list as the user needs
to make a minor update to the point of
value so that the note can point to the
next a successor in the list now
followed by this we have our next
question give a briefing on the life
cycle of a
thread so the life cycle of a thread
includes five stages which are as
mentioned below newly born state
runnable state that is it provides the
jvm with a feedback that I'm ready to
run now followed by that the running
stage where the thread is actually
running followed by that the block stage
so basically the thread will be blocked
for some reasons for some intermediate
output or something if the thread is
waiting for an input from another source
or something similar so that's where the
blocked State comes to existence and
finally the dead State once after
everything is processed the threat is
eliminated by gvm now followed by this
we have our next question that
says explain the differences between the
operators provided here so the operators
might look similar but they are
different now let's understand about
these operators in a much better way
through the answer so the answer for
this question is although they look
similar but there's a huge difference
between them so the first operator which
looks like two greater than symbols
perform the operation of right shifting
so when you provide a binary number or
binary value then the bits will be
shifted towards the right and the second
symbol or the second oper Ator which is
having three greater than symbols is
used to shift out the zero fill bits so
this is the functionality of these two
operators now followed by that let's
have the 33rd question brief the life
cycle of an applet so the answer for
this question is the life cycle of an
applet basically involves the following
stages the first stage is the
initialization stage next is the start
stage third is the stop stage fourth is
the destroy and finally we have
paint now the next question is why are
generics used in
Java so the answer for this question is
compile time type safety is provided by
using generics in Java so this approach
allows the users to catch unnecessary
invalid inputs at the time of
compilation generic methods and classes
help programmers to specify a single
method declaration a set of related
methods or with a single class
declaration a set of related types so
followed by this we have our next
question explain externalizable
interface so the answer for this
question is the externalizable interface
helps with the control over the process
of serialization the externalization
interface incorporates read external and
write external methods so we have
listened to a new term here which is
serialization so what exactly is
serialization serialization is a process
of sending your Java code or Java
project from one computer system to a
different computer system so basically
if you wanted to execute some kind of
java program from a different location
then you serialize this particular code
to a different location where you
actually want to execute and this
particular process of transferring your
code is called as serialization
now the next question is explain demon
thread so the answer for this question
is the demon thread can be defined as a
thread with least responsibility the
demon thread is designed to run in a
background during the process of garbage
collection in Java the set demon method
is used to create the demon thread in
Java programming
language so we have our next question
now explain the term enumeration in Java
so the answer for this question is
enumeration or enum is an interface in
Java enum allows the sequential access
of elements stored in a collection in
Java now the next question is why is
Java considered as a dynamic programming
language so the answer for this question
is Java was designed to adapt to an
evolving environment Java programs
include large amount of runtime
information that is actually used to Res
access to the objects in real time so
this is the reason why Java is
considered as dynamic programming
language now followed by this we have
our next question can you run a code
before executing the main method so the
answer for this question is yes we can
execute any code even before the main
method we will be using the static block
of code in the class when creating the
objects at load time of the class any
statements within the static block of
the code will execute it once while
loading the class even before the
creation of objects in the main
method now the last question in the
intermediate section is how many times
the finalized method is called so the
answer for this question is the
finalized method is called by the
garbage collector so for every object
the garbage collector calls the
finalized method just for
once now with this let's enter the
advanced segment of interview questions
based on
Java so the first question in the
advanced segment is can the keywords
this and super be used together so the
answer for this question
is no this and super keywords should be
used in the first statement in the class
Constructor so the following code
segment will give you a better idea so
you can see that we have used the
keyword super and this in the class
Constructor that is the first class
Constructor now this is how you can use
super keyword and this keyword together
in case if you want it to use so with
this let's continue with the next
question in the advanced level so the
next question says explain JSP page so
the answer for this question is JSP is
basically an abbrevation for Java serlet
page so the Java seret page consists of
two types of text the first is the
static data and the second one is Java
serlet page
elements now the next question
is explain
jdbc so the answer is jdbc is an
abbrevation for Java database connector
jdbc is an abstract layer used to
establish connectivity between any
existing database and to a Java
application next question is explain the
various directives of
JSP so the directives are instructions
processed by JSP engine after the JSP
page is compiled into a sovet directives
are used to set page level instructions
insert data from external files and
specify custom tag libraries directives
are defined between the following
symbols so these are the symbols that I
used to specify the directives in a JSP
page the different types of directives
are shown us below there are three types
of directives they are include directive
page directive and tag lab directive so
include directive includes a file and
merges the content of the file with the
current page the page directive is used
to define specific attributes in the JSP
page like error page and buffer the tag
lip directory is used to declare a
custom tag Library which is used in the
JSP page followed by that we have the
next
question what are Observer and
observable
classes so the answer for this question
is objects that subclass the observable
class maintain a list of observers when
an observable object is updated it
invokes the update method of each of the
observers to notify that The Observers
that it has changed its state The
Observer interface is implemented by
objects that are observe observable
objects might be a little confusing but
you need to read this answer once again
you can pause it and you can read this
answer once again so that you can get a
brief understanding of
this followed by that we have the next
question what is session Management in
Java so the answer for this question is
a session is essentially defined as the
dynamic stage of a random conversation
between the client and the server the
essential Communication channel includes
the string of responses and requests
from both sides typically the most
popular way of implementing session
management is the employment of a
session ID in the communicative desk
course of the client and the
server the next question is brief about
spring framework spring framework is
basically the framework of Frameworks
now the answer for this question is
spring is essentially defined as the
application frame workk and inversion of
control container for Java basically the
chief purpose of spring framework is to
create Enterprise applications in Java
also it is especially useful to keep in
mind that the central features of the
spring framework are essentially
conductive to any Java
application so the next question is
explain jca in Java so the answer for
this question is jca is basically an
abbrevation for Java cryptography
architecture so jca provides a platform
that gives architecture and apis for
encryption as well as decryption JC is
used by the developer to combine the
application with the security measure it
also helps in performing the third-party
security rules it uses the hash table
encryption message digest Etc to
implement the security so the next
question is explain jpa in Java so the
the answer for this question is jpa
stands as an abbrevation for Java
persistence API the jpa is enabling us
to create the persistence layer for
desktop and web
applications jpa deals with the
following Java persistence API query
language Java persistence criteria API
object mapping metadata Etc so the last
question in our list is explain the
different authentications in Java
servlets so the answer for this question
is authentication options available in
servlets are as follows the first one is
basic authentication so the basic
authentication consists of username and
password provided by the client to
authenticate as the user the second one
is form based authentication in this
particular type of authentication the
login form is made by the programmer by
using
HTML follow by that we have the third
type of authentication that is digest
authentication digest authentication is
similar to basic authentication but in
this the passwords are encrypted using
hash formula this makes the just more
secure and lastly we have the client
certificate authentication the client
certificate authentication requires that
each client accessing the resource has a
certificate that it sends to
authenticate itself this requires SSL
protocol staying ahead in your career
requires continuous learning and
upskilling whether you're a student
aiming to learn today's top skills or a
working professional looking to advance
your career we've got you covered
explore our impressive catalog of
certification programs in cuttingedge
domains including data science cloud
computing cyber security AI machine
learning or or digital marketing
designed in collaboration with leading
universities and top corporations and
delivered by industry experts choose any
of our programs and set yourself on the
path to Career Success click the link in
the description to know
more hi there if you like this video
subscribe to the simply learn YouTube
channel and click here to watch similar
videos to nerd up and get certified
click
here