foreign
s are vital in many domains including
developing technology and addressing
complicated problems algorithms play a
vital role in our daily lives in various
ways even though we aren't aware of them
such examples include online shopping
Healthcare entertainment navigation and
many others overall algorithms are
ubiquitous in our daily lives making
them more convenient efficient and
personalized they're helping in various
ways to shape how we live work and
communicate algorithms are step-by-step
instructions to solve a problem or
carrying out a specific task now they
assist programmers in various ways
including problem solving efficiency
reusability accuracy and scalability
ultimately algorithms are essential for
programmers helping them write more
efficient reusable and accurate scalable
codes on that note hey guys welcome to
the data structures full course part 2
video by simply learn in the second part
of the data structure video we will
firstly cover what are graphs and then
will have a look at graft reversal in a
data structure which will include BFS
and DFS algorithms and then we'll move
ahead with some of the essential
algorithms in data structures such as
prim's algorithm screw sculpts method
and searching and sorting algorithms we
will conclude this data structures full
course by discussing some essential
interview question and answers of data
structures to help every individual
crack and interview so without any
further Ado let's get started and if you
want to become a software developer then
take up the postgraduate program in full
stack web development by simply learn
and master those necessary skills check
out the course Link in the description
for more details over to our training
expert
so without any further Ado let's get
started with what is battery
B tree is a special ambulatory data
structure
a b tree of order M can have at most M
minus 1 keys and M children
now let's discuss some properties of B
trees
first up every node in a b tree can have
at most M elements
next every node except the root and the
leaf node must have M by two children
next a root node must have at least two
nodes
at last a leaf node must be at the same
level
now let's discuss what are the various
operations we can perform on a battery
we can perform three operations or a B
tree that is searching insertion and
deletion
let's discuss these in detail
first up searching in this we will
Traverse the complete battery until we
have found a key we will start from the
left side to go all the way up to the
right side
now let's try this in a code editor we
will first start by creating a b tree
node to do that we will use class
betray node
end
case
it is an array of keys
foreign
this will Define the range of the number
of keys
then we will create a child pointer
eat tree
node
see
it is an array of child pointer
then
then a variable uh to check the current
number of keys
and a Boolean variable
which will be true when the node is leaf
now Define some functions in public
first Constructor
foreign
function to insert a new key in a sub
tree
void
insert
non-full
argument as intake
next a utility function to split the
child y of the node
argument as int I
foreign
a function to Traverse the battery
and a function to search a key in the
sub tree
it will return null if K is not present
now we will create another class B tree
and make it a friend of this so that we
can access private members of this
battery of this class in B tree function
now we will create a pointer root
minimum degree
then public
a Constructor B tree
foreign
and T is equals to
score t
now we will write a function to Traverse
this tree
for it Traverse
if
not null
and root
Travis
now we will write a function to search a
key industry
return
if root is equals to null
foreign
now the main function that inserts the
new key in this B tree
word
insert
print okay
now we will write the Constructor for B
tree node class
now we will copy the given minimum
degree and leave property
now we will allocate the memory of the
maximum number of possible keys and the
child pointer
foreign
star bracket 2 Star t
now we will initialize the number of
keys at zero
now let's write the function to Traverse
all node in the subtree rooted with this
node
there are n keys and N plus 1 children
to Traverse through n keys and first and
children's we need to do int eyes
equals to zero
I less than none
I plus plus
if this is not Leaf node then before
printing key
Traverse the subtree rooted with child
CEI
so if
is equals to false
done
C bracket I
l equals to
Traverse
else C out
case
now we'll print the sub tree rooted with
the last node
so if
leave
is equals to false
and C I
Traverse
now we will write the function to search
key K in sub tray rooted with this node
so
B tree
node
are
B tree or
search
and K
we will first find the first key greater
than or equal to K
so
while
and I
is less than n
and
K is greater than
is
bracket I
then I plus plus
now if we found the key is equals to k
then we will return this node
if
record I
is equals to K
then we will
return
if key is not found here and this is the
leaf node then
if
Leaf is equals to
true
then we will return
now we will try to go to the appropriate
child
so we will use return
C bracket I
Arrow search
now we will write the main function that
inserts the new key in this victory
so void
B tree
insert
and K
so if
root
is equals to
null
then we will allocate the memory of our
root
foreign
keys
bracket zero
is equals to K
now we will change root
here we are updating the number of keys
in this root
now if else
as if tree is not empty
then
if root is full then tree grows in
height so if
root Arrow n
is equals to
to start t
minus 1
.
then we will allocate the memory for the
new root
B tree
code
star s
equals to new
tree
node
T comma false
foreign
of the new root
so
as Arrow
C bracket zero
is equals to
root
now we will split the old root and move
one key to the new root
so
s
ick child
0 comma root
thank you
Now new root has two childrens
we have to decide which of the two
children is going to have an EQ new key
so int I is equals to zero
if
thank you
if
as keys
zero
is less than
okay
then I plus plus
and as Arrow C bracket I
Arrow foreign
now we will change the root
equals to s
H as if root is not full we are called
the insert non-full
now we will write a function insert for
non full
we'll initialize and
is equals to
n minus 1
f
is equals to
true
then while
I is greater than equals to zero
and
if
is greater than k
then case
I plus 1
will be equals to keys I
and I minus minus
now we will insert the new key at the
found location
foreign
I is greater than equals to zero
is
high is greater than
k
then I minus minus
now we will see if the found child is
full
if
C
bracket I plus 1
well
and equals to
2 Star t
minus 1
.
done
we will use split child
I plus 1
comma
C
I plus 1
.
now if
case
bracket 5 plus 1
is less than k
then I plus plus
okay
see
I plus one
insert
known for
okay
now we will write the function split
child
foreign
then there
and equals to
T minus 1
now 4 do
and
J is equals to 0
J less than T minus 1
J plus plus
Z equals to
okay
equals to y
now we will copy the last two childrens
of Y to Z
if
y leaf
is equals to false
then four
enter J
is equal to zero
J less than t
and J plus plus
foreign
since this node is going to have a new
child we will create a space for the new
child
so for Loop
and J is equals to 9 J is equals to n
J greater than equals to
I plus 1
J minus minus
she recorded
J plus 1
equals to C bracket J
now we will link the new child to this
node
foreign
and find the location of new key and
move all greater Keys one space ahead
now we will increment the count of keys
in this node
foreign
block
we will Define a b tree with minimum
degree 3
now T dot insert
10
.
T dot insert
20
dot insert
five
dot insert
6
T dot insert
12
foreign
Ty
now let's try to Traverse this
C out
traversal
of
P3
and T Dot
also
now let's search some keys so let's take
end
K is equals to 6
so if
D dot search
k
is not
null
then C out
else
C out
not present
let's try this function one more time
foreign
let's execute this
as you can see we have successfully
traversed this B tree and we have
checked two keys if they are present or
not
if K is equals to 15 was not present and
K is equal to 6 was present
let's get back to our slides
next up insertion
we have to insert an element in such a
way so that we won't disobey any
properties of B trees
now let's try this operation in a code
editor
we will start by creating a node to do
that we will use Class B tree node
then we will create an array of keys
minimum degree
an array of child pointers
current number of keys
and a Boolean variable leaf
this variable will tell if the node is
leaf or not
then we will Define some public
functions
we will start with Constructor
now we will create a function to insert
a new key into the non-fold node
a utility function to split the child
a function to traversal
free
a front glass big tree
now we will create this class B tree
now we will Define a pointer to root
node
minimum degree
then we will create some public
functions
first Constructor
foreign
equals to
null
and T equals to
underscore t
now
void
Traverse
now if
root is not equational
then root
Arrow
Traverse
foreign
a main function that inserts a new key
in this battery
now we will write the Constructor for
the B tree dot class
and T1
comma Boolean
Leaf one
now we will copy the given minimum
degree and leave property
now we will allocate memory of maximum
number of possible keys and child
pointers
foreign
now we will initialize the number of
keys as zero
now let's write a function to Traverse
all node in the subtree
foreign
keys and N plus one children so we will
Traverse through n keys and first and
Central
so end
I
follow
I is equal to zero
L less than n
and I plus plus
now suppose if this is not leaf then
before printing key we will travel the
sub tree rooted with this child
so if
if
is equals to false
length C
I
Arrow
Traverse
now we will print these keys
now we will print the sub tree rooted
with the last child
so if
leave
is equals to
false
then
CI
Arrow
Traverse
now we will write the main function that
inserts a new key in this B tree
void
B tree
and K
now if tree is empty
then we will allocate the memory to root
so root
is equals to new
B tree
node
e comma true
now we will insert the key
the root
Arrow
keys
first okay
and we will update the number of keys in
root
root Arrow
and
equals to 1
else
if tree is not empty
and if root is full then tree will grow
in height
if
root
n
is equals to
start T minus 1
foreign
now we will make all root as child of
new root
is equals to
root
now we will split the old Route and move
one key to the new root
so to do that we'll use split challenge
function
0 comma suit
Now new root has two children now
we have to decide which of the two
children is going to have new key so to
do that we will use end high is equals
to zero
if
s case
0 is less than k
then I plus plus
and S
Arrow C I
or non full
now we will change the root
else
root
insert
non-full
okay
now we will write a utility function to
insert a new kid in this node
we will assume the node must be non-full
when this function is called
so void
B tree
node
insert non-full
and K
we will initialize index as index of
rightmost element
so end I is equals to n minus 1.
now if this is a leaf node
then the following Loop does two things
a finds a location of new key to be
inserted or move all greater keys to one
place ahead
so while
I is greater than equals to 0
and
is
I
is greater than k
now
is
I plus 1
will be equals to
keys at I
and I minus minus
now we will insert the new key at the
found location
so keys
at I plus 1
will be equals to K
and n equals to n Plus 1.
now else
if this node is not Leaf then we'll find
the child which is going to have the new
key so while
I is greater than equals to 0.
and
is
I
is greater than k
then
I plus I minus minus
now we will see if the farm child is
full
so if
c i plus 1
Arrow n
is equals to
2 Star t
minus 1.
okay
now if the child is full then we will
split it
so
split
child
at I plus 1
comma
c i Plus 1.
after split the middle key of C i goes
up and c i is splitted into two now we
will see which of the following will
have the new key
f
keys
I plus 1
less than k
then I plus plus
C
I plus 1
insert
non full
okay
child
and I comma
a tree
node
now we will create a new node which is
going to store T minus keys of Y
so B tree
node
Z
equals to
new
E3
node
by Arrow
t
comma
y Arrow
leave
now Z Arrow n
is equals to T minus 1.
now we will copy the last T minus 1 case
of Y to Z
so for Loop
and J is equals to zero
a less than T minus 1
J plus plus
so Z
Arrow
is
J
equals to
y Arrow
is
J plus t
now we will copy the last two childrens
of Y to Z
so
if
why Leaf is false
so for
and J is equals to 0
foreign
CJ
is equals to
y
C
J plus t
now we will reduce the number of keys in
y
so y
Arrow n
is equals to T minus 1
now since the node is going to have a
new child we will create the space for
the new child
so for
integer is equals to n
and J is greater than equals to I plus 1
and J minus minus
C
J plus 1
will be equals to
C J
now we will link the new child to this
node
so C bracket I plus 1
equals to Z
now a key of Y will move to this node
so we will find the location of new key
and move all greater Keys one space
ahead
so far
end
J
is equals to
n minus 1
J greater than equals to I
J minus minus
is
a plus 1
plus 2
is
J
now we will copy the middle key of Y to
this node
so the key is
tracker
I
is equals to
y
Arrow
keys at T minus 1
.
now we will increment the counts of key
in this node so n equals to n plus 1
now we will write a driver program to
test above functions
foreign
now we will insert keys in this tree
e Dot
insert
10.
T dot insert
15
.
T Dot insert
five
T dot insert
thanks
T dot insert
12
.
Dot
insert
seven
now let's print this Constructor tree So
Co
created
B tree
s
now T dot Traverse
okay
now let's execute this
as we can see we have created a b tree
of order 3. let's get back to our slides
finally deletion while deleting any
elements from B3 we have to be careful
not to break any properties of the
battery like all the leaves must be
present at the same level or elements
must be in ascending order
now let's try this operation in a code
editor
let's start by creating a node to create
a node we need a class
note
end
start keys
this is an array of keys
entity
a minimum degree
now we will define an array of child
pointers
so beat re node
there are number of keys and and
a Boolean variable leave to tell us if
the node is leaf or not
now we will Define some public functions
we will start with the Constructor to
this class V3
node
and underscore t
comma Boolean
underscore leaf
and a function to Traverse the all nodes
in the sub rooted tree
so void
drivers
now a function to search a key in the
subtree
so B tree
node
star
search
and K
this one returns null if K is not
present
now we will write a function that
Returns the index of the first key that
is greater or equal to K
so in
find key
and okay
now we will write an utility function to
insert a new key in this subtree rooted
with this node we will be assuming the
node must be non-full when this function
is called
so void
insert
non-full
as argument as k
now we will write a utility function to
split the child of Y
of this node
void
it
child
and
I comma
B tree node
star y
a wrapper function is to remove the keys
k in substituted with this node
avoid
remove
entry
another function to remove a key present
in the ith ith position in this node
which is a known Leaf node so void
remove
from non-leaf
and
idx
now we will write a function to get the
predecessor of the key where the key is
present in the idx position in the node
so and
get
red
and idx
now we will write a function to get the
successor of the key where the key is
present in the idx position in the node
so and
get successor
and idx
now we will write a function to fill up
the child node present in the idx
position
in the C array if that child has less
than T minus 1 keys sub void
fill
and idx
now we will write another function to
borrow a key from the c i t x minus 1
node and place it and place it in C idx
node
so void
borrow
from
sort of
create idx
a function to borrow a key from the idx
plus one node and place it at the I idx
node so avoid
borrow
wrong
next
and idx
void
merge
idx
now we will make B3 class as friend so
that we can access private members of
the this class in the B3 functions
so friend
class
B tree
okay
so Plus
we'll start with the pointer to the root
node
will be three
node
R root
and T
now we'll write some public functions
we will start with the Constructor so B
tree
and
underscore t
sub root
is equals to null
and T is equals to
underscore p
now a Traverse function void
Traverse
so we will check if
root is not null
then
root
Arrow
Traverse
now we will write a function to search a
key in this tree
so B tree
node
search
and K
we will return
if
root is equals to
null
then we will return null
foreign
insert
int k
now another main function that removes
the new key in this battery
so void
a move
ment and
now we will write the Constructor for
this big tray node
us
and T1 comma
bull
leaf
one
so T will be equals to T1
and
Leaf will be equals to Leaf one
now we will allocate memory for the
maximum number of possible keys and
child pointers so key is
is equals to new
int
bracket to start T
minus one
yeah
and child C is equals to new
B tree node
star bracket 2 Star t
now we will initialize the number of
keys as zero so n is equals to zero
now we will write a utility function
that Returns the index of the first T
that is greater than or equal to K
so end
B tree
node
find
key
int J
now end
idx is equals to zero
then while
idx is less than n
and
keys
idx
is less than k
plus plus
idx
return
idx
now we will write a function to remove
the key K from the sub tray rooted with
this node so void
B tree
node
remove
and K
and
idx equals to
Point Key
okay
if the key to be removed is present in
this node then
idx
is less than n
and
keys
at idx
is equals to K
now if node is leaf node
then we will remove from Leaf node is
called
otherwise remove from non-leaf function
is called
so if
leave
then remove
from
leaf
idx
foreign
from
only
idx
now as
if this node is a leaf node then the key
is not present in the Stream So if
leave
C out
okay
foreign
exist
industry
and return
the key to be removed is present in this
sub tree rooted with this node the flag
indicates whether the key is present in
this sub tree rooted with the last child
of this node
so
bull
flag
is equals to
idx
equals to n
f
it is true
as false
If the child where the key is supposed
to exist has less than T Keys then we
fill that child
so if
C at idx
and
it's less than t
then fill
idx
foreign
flag
and
idx
is greater than n
and C
DX
-1
remove
okay
else
C
idx
removed
okay
okay
return
void B3
node
remove
from leaf
and
idx
now we will move all the keys after the
ID Exposition one place backward so for
Loop
end
I is equals to idx Plus 1.
idx plus 1
I less than n
I plus plus
I
so keys
at I minus 1
should be equals to
at I
and we will reduce the count of keys so
n minus minus
and return
now we will write the function to remove
the idx key from the node which is
non-leaf node
so void
E3
node
remove
from non-leaf
and
idx
int
K is equals to
keys at idx
If the child that precedes k at C idx
has at least D Keys then we will find
the predecessor thread of K in the sub
tree rooted at cidx we will replace K by
predecessor recursively and delete
thread in C idx
so if
C idx
Arrow
and
is greater than equals to
t
then end
equals to get
red
idx
keys
idx
equals to
red
C
idx
remove
d
else
if
C at idx plus 1
Arrow
and
is greater than equals to
t
and end
suck
is equals to
get
suck
idx
of keys at idx
is equals to suck
C at idx plus 1
uses remove
suck
else
we will merge
idx
and C at idx
will call remove
okay
at idea as well call
remove
return
now we will write a function to get
predecessor of keys idx
so int
V3 node
get bread
and suck
repeat
end idx
so B tree
node
starter
is equals to C at idx
while
there is not a leaf
then
will be equals to
curve
Arrow C
equal
s n
now we will return
key
now we will write
and
Bakery
node
that
suck
and idx
are
equal goes to C idx
plus 1
while
car
Arrow
while car is not leave
or
is equals to curve
cut zero
foreign
C idx which has less than T minus 1 keys
void
big tree
node
l
and idx
f
repeat If the previous child C idx minus
1 has more than T minus on Keys then we
will borrow a key from that child
so if idx
is not equals to zero
and
see at idx
-1
calls
n
greater than equals to
t
then we will borrow from priv
ate DX
else
if
idx is not equals to n
and
C at idx plus 1
calls
and greater than equals to 1. a t
then
we will borrow
from next
at idx
else
if
idx
is not equals to n
and we will merge
idx
merge
idx minus 1
return
now we will write a function borrow from
prev
directory node
star child
is equals to C idx
catering node
star sibling
is equals to C
idx
minus 1.
now the last key from C idx minus 1 goes
up to the parent and key IDF minus 1
from parent is inserted as the first key
in C ideas thus the losses sibling one
key and child gains one key moving all
keys in cidx one step ahead
so for Loop
and
I
is equals to
child
at an
-1
I greater than equals to zero
and I minus minus
minus minus I
tried
calls keys
at I plus 1
equals to
child
calls
keys
that I
now if C idx is not a leaf then we will
move all its child pointers one step
ahead
if underscore child calls leave
or
and
I equals to child
and
I greater than
equals to zero
I
minus minus I
child
at C bracket I plus one
yeah
equals to
child
see bracket I
think
now we will set the child's first key
equal to the key at idx minus 1 from the
current node
so child
is
at zero
is equals to
keys at idx minus 1.
now we will move sibling's last child SC
ID access first set
so if
child is not leave
foreign
C
ibling
calls n
now
keys at idx minus 1
will be equals to
sibling
keys
sibling
false
n minus 1.
now child
at n
will be plus equals to
1.
and sibling
and
will be equals to minus equals to
one
return
word
B tree
node
.oro
from next
find the ID idx
now we will start by day tree
node
child
request to C at idx
and B tree
node
sibling
is equals to C at idx
Plus 1.
now key idx is inserted as the last key
in the C idx
so child
keys
and
is equals to
keys
at idx
now child
at case
X
if
child is not leave
let's see
equals to
sibling
at
C 0
now the first key from sibling is
inserted into key idx
sub key at idx
is equals to
sibling
case
zero
or Loop
and I is equals to 1.
okay
less than
sibling
at n
plus plus I
sibling
foreign
is equals to
sibling
now if
sibling is not leaf
I
equals to 1
then equals to Sibling calls n
plus plus I
false C at I minus 1.
equals to
sibling
calls C at I
now we will be increasing and decreasing
the key count of cidx and cidx plus 1
respectively
so
child
at an
is plus equals to 1.
sibling
calls
n
minus equals to
1.
return
now void
big tree
node
merge
with argument as end idx
no
B tree
node
star child
is equals to C
DX
beet tree
node
or sibling
equals to C at idx plus 1
now we will be pulling a key from the
key node and inserting it at T minus
oneth position in C idx
so child
calls keys
T minus 1.
is equals to
keys
at idx
now we will be copying keys from C idx
plus 1 to C idx at the end so for
hint
I is equals to zero
I less than sibling
equals n
plus plus I
so child
I plus t
equals to
sibling
I
if
not child
calls leave
for
foreign
I less than equals to
sibling
calls
S Plus I
child
C
Vector I plus t
equals to sibling
because
I
now four
and
is equals to idx
Plus 1.
I less than n
plus plus I
foreign
is equals to case at I
or
and
I is equals to
idx plus 2
I less than equals to and
and plus plus I
e
at I minus 1
is equals to
C
at I
Jade
and
plus equals to
sibling
and
plus one
Elite
sibling
return
now we will write the mean function that
inserts a new key in this victory
so void
battery
and K
if
root is equals to
null
all right
then we will allocate memory to root
is equals to new
tray node
T comma true
[Music]
root
is
bracket zero
is equals to K
okay
and root
at an is equals to 1
.
else
if
root
calls
n
is equals to
4 star
D minus 1.
so B3
node
Stars
is equals to
new
V3
node
e
comma false
now s
C bracket zero
equals to root
as
flipped
child
zero comma root
and
I is equals to zero
f
s
keys
bracket zero
less than k
I plus plus
s
J bracket I
all right
insert
noun Pole
okay
now we will change the root to s
root
calls
insert non-fold at k
a utility function to insert at known
full node
for INT
I
is equals to n minus 1
F Leaf equals to true the following Loop
does two things finds the location of
key to be inserted or moves all greater
key to one place ahead so while
I is greater than equals to zero
and
keys
at I
are greater than k
then
case at I plus 1
will be equals to keys at I
and I minus minus
case
at I plus 1
will be equals to
a
and N will be equals to n Plus 1.
foreign
I is greater than equals to zero
and
is
Hattie
is greater than k
I minus minus
f
C bracket I plus 1
at n
equals to
2 Star
T minus 1
. child
five plus one
comma C
y plus 1
f
is
bracket I plus 1
k
I plus plus
C okay
I plus 1
insert non-hole
okay
B3
node
and I
comma
B tree
node
star y
foreign
yeah
now that calls
n equals to
T minus 1.
now we will copy the last T minus one
case of y two Z so for Loop
and J is equals to zero
foreign
less than
T minus 1
J plus plus
so Z keys
okay
is equals to
y
at keys
J Plus
t
so if
y
if
equals to
false
four
and
J is equals to zero
J less than t
J plus plus
J
C bracket I
is equals to
y calls
C bracket J Plus
e
now y calls
n equals to T minus 1
now since this node is going to have a
new child we will create space for the
new child
so for Loop
and
J is equals to n
J greater than equals to
I plus 1
J minus minus
C vector
J plus 1
equals to C bracket
J
of C bracket
5 plus 1
is
equals to
C bracket
J
e bracket
I plus 1
is equals to Z
now for Loop
and
J is equals to n
minus 1
J greater than equals to
I
G minus minus
is record J
plus one
equals to
key is at J
foreign
equals to
y
is
bracket
T minus 1
.
n is equals to n plus one
now we will write function for Traverse
so void
B tree node
Traverse
and I
for Loop
I is equals to zero
I less than n
I plus plus
if
leave
equals to false
and C bracket I
will Traverse
if
if
is equals to false
then c i
will call
Traverse function
now we will write the function to search
key in the sub tree rooted with this
node so B tree
node
star
battery
node
search
and K
and
I is equals to zero
while
I is less than n
percent
K is greater than keys
bracket I
so I plus plus
now if
is bracket I
is equals to K
then return
this
now if
if
is equals to true
then return
null
otherwise return
C bracket I
calls
search
for k
now we will write the utility function
to remove
so void
E3
remove
end
okay
f
not root
and see out
the
is empty
return
now we will call the reboot repeat now
we will call the remove function for
root so root
cause
remove
okay
now if root has zero Keys then we will
make its first child as a new root if it
has a child otherwise such root as null
so if
foreign
is equals to
zero
then B 3
node
.r TMP
equals to root
if
root
leave
fruit
equals to
null
else
together
equals to root
C bracket
zero
now delete
okay
done
now we will write the code for the main
block
we will start with the B tree
of order three
foreign
this crater tree
see out
created
tree
foreign
now we will use T dot remove
D to remove five
now see out
modified
tea tree
after
deleting
five
foreign
as you can see we have successfully
deleted five from our B tree
so without any further Ado let's get
started with what is a B plus tree
a B plus tree is a special Amway tree
data texture a B plus tree of order M
can have at most M minus certain keys
and M children a B plus tree can be used
as B tree with only keys to each node
and with linked leaves to which an
additional level is added at the bottom
now let's discuss some properties of B
plus trees
first up every node in B plus 3 can have
at most M elements next every node
except the root and the leaf node must
have M by two children
next maximum keys for any node is M
minus 1. and at the last minimum keys
for any node is ceiling of M by 2 minus
1. now let's discuss what are the
various operations we can perform on B
plus 3. we can perform two operations on
a B plus tree
first up insertion second deletion
now let's discuss these in detail
first up insertion
we have to insert an element is in such
a way so that we won't disobey any
properties of B plus trees
now let's try this operation in a code
editor
we will start by creating a node to
create a node we need a struct
B plus
tree node
int
star data
B plus
3 node
space star
child PTR
Boolean
leaf
and int n
for the object star root will be equals
to null
star NP pointer
will be equals to null
comma
star X will be equals to null
now we will write a Constructor for it
so B
3
node
star planet
I
and P equals to
new
p plus
tray node
NP Arrow
Tata
is equals to new
space and
bracket 5.
nnp
child
PTR
is equals to new
B plus 3
node
star
record
six
and belief
is equals to true
and NP at the N is equals to zero
now we will write a whole Loop
I is equals to 0
by less than six
I plus plus
NP
child
is equals to
return
Traverse
B plus
3.
node
star B
out
and
I
again according to
from I equals to 0
to
I less than P at n
I plus plus
f
T doesn't have leaves
then we will Traverse that child
Traverse
a
child
KTR bracket High
foreign
now we will check these conditions again
for
I at T at n
we will Traverse it again
from p
child
at I
foreign
now next function will be used to sort
this
so void sort
and star p
comma
and
and I comma J comma time
for Loop
a equals to Pi
a less than equals to n
J plus plus
if
P bracket I
better than P bracket J
then
we will swap these two so temp
will store P at I
and then P will replace its value with P
at J
now we will store
the temp value in the P of J
now let's write a function to split this
side and
set
child
e plus
3
node
star X
comma
and I
and J
made
B plus 3 node
star np1
comma star
np3
comma
star y
and B3
is equals to
find it
MP3
true
f
I is equals to -1
mid is equals to
X
DotA
bracket 2
X data bracket two
will be equals to zero
foreign
X will store n minus minus
P1
is equals to init
now when P1 leave
will be equals to false
and X Leaf is equals to true
so for Loop
J is equals to 3
.
J less than 5.
J plus plus
X
foreign
will be equals to
X
data
and J
P3
child PTR
at J minus 3
is equals to
X at child PTR
bracket J
MP3
n plus plus
X data bracket J
is equals to zero
now X greater than n minus minus
another for Loop
from J is equals to zero
with J less than six
at J plus plus rate
X
child PTR
at J
will be stored at null
now np1
data
at zero position
will be equals to Mid
np1
child PTR
at
np1
on air
will be equals to X
and P1
child
at np1
on N Plus 1.
will be equals to np3
P1
all n plus plus
root is equals to
np1
now else
Y is equals to X
child
video that I
and mid is equals to Y that dot i
at 2
.
and Y
on data at 2.
is equals to zero
I will store n minus minus
now for Loop
J is equals to 3
.
J lesson five
J plus plus
MP3
data
a minus 3
is equals to y
data
a
and P3
and plus plus
y
data
bracket J
is equals zero
y
n minus minus
X
child
at I plus 1
is equals to y
X at
child PTR
I plus 1
is equals to
np3
return
now we'll write a function to insert
into the tree
void
insert
argument as hint a
so end
I comma temp
X is equals to root
if
x equals to null
then root
is equals to
finite
and X will be equals to root
otherwise
f
X is a leaf
and
X at nine repeat and exit and
is equals to 5
and temp is equals to
let
child
X
comma minus one
X is equal to root
if
a is greater than
X
I
and
a is less than
X
at data
I plus 1
I plus plus
and break
else
if
a is less than
X at data
zero
then break
else
continue
X is equals to X at
child
at I
else
slide
hex sleeve
is false
for Loop
I is equals to zero
when
I is less than x at n
I plus plus
f
a is greater than
X
at data
I
and
a is less than
X
and data
I plus 1
I plus plus
break
as
if
a is less than x
DotA
break
foreign
continue
if
X
child
and
is equals to 5.
that time is equals to split
child
at X comma I
X
data
at x n on n
is equals to temp
X
at n plus plus
continue
else
X is equals to X
child
right here
I
X
on data
at
X at n
is equals to A
sort
X at data
foreign
X at n plus plus
now let's write a code for the main
block
first we will declare some variables as
and I
and
and T
now we will request
enter
number of
element
to be inserted
um
pattern
now see out
now we will enter the element so enter
element
now we will write a for Loop
Y is equals to 0 to I less than n
at I plus plus
so c n
T and insert
t
now we will Traverse this tree So Co
foreign
of B plus 3
.
whatever's
root
let's execute this
we will enter five elements
2 comma 3 comma 5 comma seven comma 9.
as you can see we have successfully
traversed a first B plus tree let's get
back to our slides
next deletion while deleting any element
from B plus 3 we have to be careful not
to break any properties of B plus tree
like all the leaves must be present at
the same level or elements must be in
ascending order
now let's try these operations in a code
editor
start by creating a B plus tree
first we will declare a global variable
and
Max equals to 3
then we will
create a class
PP tree
and a class
node
Boolean
is leaf
and
start key
comma size
rptr
and a friend class
equity
now public
load variable
now we will write class
BP tree
so no
star root
word
insert
internal
end
node star
comma
node
star
void
remove internal
hint comma
code
star comma
node star
and a node function
find parent
s
node
.star
now public
tree
The Constructor
search function
insert function
foreign
display
get root
e is equals to new
okay
bracket Max
is equals to
new
node
star
record Max Plus One
BP tree
now void
beep
baby tree
insert
foreign
X
2 is equals to null
then root
is equals to
new node
calls key
at zero
z x x
row
checks
let's leave
place
price is equals to 1.
else
node
cursor
is equals to root
node
star parent
y
cursor
is leave
is equals to
false
better
equals to cursor
mm-hmm now for Loop
and I is equals to zero
to I less than
cursor
size
I plus plus
f
X is less than cursor
key
at I
cursor
is equals to cursor
add
PTR
at I
f
I is equals to
cursor
size
minus 1
cursor
cursor
at
PTR
I Plus 1.
break
now if
person
advice
is less than Max
then end
I is equals to 0
while
X is greater than cursor
e
at I
and
I is less than
size
for Loop
and
is equals to
cursor
at size
and J
is greater than I
a minus minus
so of course
key
at J
is equals to
cursor
false key
at J minus r
cursor
calls key
at I
is equals to X
cursor
calls size
plus plus
calls
PTR
add cursor
size
is equals to
cursor
PTR
at
cursor size
minus 1.
now cursor
at BTR
cursor
size
minus 1.
cursor
PTR
equals
else
node
equals to new
right
virtual
note
Max Plus One
for
end
I equals to zero
two
I less than Max
at the rate I plus plus
virtual node
okay
is equals to
cursor
e
at I
and
I is equals to zero
comma J
while
X is greater than
virtual
or
make it I
I is less than Max
I plus plus
4
int
J is equals to Max
plus one
comma J is greater than
I
G minus minus
virtual
node
J
is equals to
virtual
code
at J minus 1
.
so virtual
node
at I
is equals to X
so New Leaf
is leaf
is equals to true
size
is equals to
Max
plus one
by two
New Leaf
price
is equals to Max
plus one
minus
Max
plus one
divided by 2.
question
idea
cursor
eyes
is equals to
New Leaf
a new Leaf
New Leaf
is equals to
cursor
PTR
Max
now void
BP tree
insert
internal
ENT X
comma node star
cursor
comma
node
scar
child
if
person
size
is less than Max
then
end
is equals to zero
while
X is greater than
cursor
at
key
that I
and
I just less than
cursor
of size
I plus plus
for Loop
end
J is equals to
cursor size
a is greater than
I
a minus minus
cursor
at Key
h a
is equals to cursor
a minus 1
cursor
okay
is equals to X
cursor
is
plus plus
cursor
at PTR
bracket I plus one
is equals to child
else
node
star
to internal
is equals to
new node
and
virtual
key
is Max Plus One
node
star
virtual
key
that match
plus one
uh
virtual
video
at
or
and I
is equal to zero
I less than Max
I plus plus
virtual
key
right
is equals to
cursor
key
for
end
I is equals to zero
I less than Max
plus one
I plus plus
virtual
DTR
I
was to cursor
VTR
at I
node
star pp3
find
parent
node
star
answer
comma node
star child
star parent
if
cursor
is leave
or
cursor
at ATR
zero
yes I think
foreign
return
better
else
parent
is equals to find
parent
cursor
PTR
right
if
parent
not equals to
null
return
got it
now void
EP tray
remove
and X
root
personal
then
see out
empty
else
node
star cursor
first two
star parent
and
sibling
comma
right
sibling
so while
foreign
equals to
false
so for
th
I is equals to zero
I less than cursor size
and I plus plus
current is equals to cursor
left sibling
is equals to I minus 1
.
right
sibling
is equals to I Plus 1.
f
X is less than
is
at I
then cursor
will be equals to cursor
VTR
now if
I is equals to
cursor
eyes
minus one
is too high
right sibling
plus 2y plus 2
cursor
is equals to
person
bracket I plus one
right
more
round
is equals to
false
false
for
post
position zero
pause
is less than cursor
size
plus plus
f
answer
key
at pose
is equals to X
then found
equals to true
and then break
now if
not found
out
not
data
now if
cursor
size
close to zero
then
Co
right
okay
cursor
delete
video
delete
presser
root
is equals to no
return
for Loop
and
I is equals to
cursor
is
equal to zero
J less than
right node
size
I plus plus
comma J plus plus
cursor
key
is equals to
write node
cursor
add cursor
size
now see out
merging
to
remove
internal
at
right sibling
minus 1 comma
current
comma
right node
delete
right
node
k
ite node
right now
avoid
entry
display
f
cursor
is not equals to null
for
I equals to 1
I less than
cursor
size
C out
professor
C out cursor
key
at I
C out
and then
if
cursor
this leave
not equals to true
and four
and
I equals to zero
I less than cursor
price
plus one
I plus plus
okay
professor
PTR
or node
star BP tree
get root
foreign
now we will write the main block
we will start with an empty tree DP tree
node
download Dot
insert
five
node
dot insert
15
note
dot insert
25
node dot insert
35
dot insert
dot display
Dot
get through
node
dot remove
d
okay
dot display
or
Dot
truth
let's execute this
as you can see this program is working
flawlessly we have successfully deleted
the key 15.
so what exactly is a graph so a graph is
a data structure like any other data
structure example linked list arrays Etc
so graph is a little different from the
other types of data structures such as
linked lists and Aries they are linear
data structures whereas graph is a
non-linear data structure that consists
of finite sets of vertices and a bunch
of edges connecting with them
so what are these vertices and edges so
let us understand that a graph is
usually represented by a set of vertices
and edges so a vertice is the node
present in a graph imagine that you are
a group of five friends so each one of
you is considered as a vertex and the
network connecting you guys is known as
an edge
so the overall graph of you people can
be considered as G and it is represented
by vertices and edges set where vertices
is you and the network connecting you
guys is called as an edge
so here you can see it clearly each one
of the friend is called as a vertex and
the network connecting them is called as
an edge and the entire graph is
represented using a set of vertices and
edges now moving ahead we will
understand the craft terminologies
now at first we have the adjacency
vertices and adjacency edges so what are
adjacent vertices
if there is an edge between two vertices
that is one vertex or one node is
connected to another node directly using
just one single edge then those vertices
are called as adjacent vertices now what
are adjacent edges if there is one
common vertex between two edges then
those two edges are called as adjacent
edges let's imagine this way let us
imagine that we have three vertexes and
these three vertexes are connected using
two edges so here we have one vertex
which is common between these two edges
so such type of edges are called as
adjacent edges
next we have the degree in an undirected
graph number of vertices adjacent to the
vertex is called as a degree
next is the path the path is considered
as a sequence of distinct vertices such
that two consecutive vertices are
adjacent to each other
up next we have the cycle a path that
has only one repeated vertices are
called as first and last vertices
followed by that we have the work the
term work is self-explanatory a work is
the sequence of vertices and edges in
the graph which is used to Traverse
through one vertex to another vertex
now we have entered the next segment of
this particular tutorial where we will
be discussing the different types of
graphs available
so at first we have the finite graph so
what exactly is a finite graph a graph
is said to be finite when the number of
vertices and the number of edges are in
a finite number or in a countable number
now the next type of graph is the
infinite graph so what exactly is the
infinite graph so the infinite graph is
a typical opposite of the finite graph
so this particular graph will not have
countable number of edges and countable
number of vertices
the image here is an example for a
typical infinite graph
now followed by the infinite graph we
have the trivial graph so what is a
trivial graph
a graph is said to be trivial if there
is only one single vertex without any
edges so this particular type of graph
will only have vertex that is only one
single vertex not more than one and
there will be no Edge if you have just
one vertex then there is no possibility
of having an edge unless if you have one
single Loop type of edge which is
connecting to itself but in a trivial
graph we don't even have that we just
have one single vertex
so followed by trivial graph we have a
simple graph
so what exactly is a simple graph a
graph is said to be simple if there is
only one and one Edge between each
vertex
so this particular example can be
considered as a simple graph so here
each and every set of vertices have one
single edge between them
now followed by the simple graph we have
the multigraph
so if there are multiple edges between
the pair of vertices then this
particular type of graph is known as a
multi-graph so here you can see that we
have two vertices A and B and we have
two edges connecting then not one but
two but in a simple graph we were
supposed to have just one Edge
connecting the vertices so this is the
difference between simple graph and a
multi graph
so followed by multigraph we have a null
graph so what is a null graph a graph is
said to be null if there are only
vertices and no edges between them so
remember that trivial graph right we
just had one single vertex but no edges
but here we do have multiple vertices
but no edges connecting them so this
type of a graph is considered as null
graph so followed by null graph we have
the complete graph so
so what is a complete graph a graph is
called as a complete graph where each
vertex must be connected with the other
vertices using the edges so the meaning
of this particular type of graph is all
the edges are connected to all the other
edges using at least one single edge so
here you can see a is connected to b d
and c all together with at least one
Edge and similarly all other vertices
are connected to each other with at
least one single edge
now followed by the complete graph we
have the pseudo graph so what is a
pseudograph a pseudograph is a graph
where at least one vertex will have
self-looping type of edge so remember
the self Loop or self Edge we have
discussed in the trivial graph type so
this particular type of NH where it
connects to itself is called as a loop
or kind of self-connecting edge so any
graph that has this kind of a edge is
called as a pseudograph
so followed by the pseudograph we have
the directed graph
so what is a directory graph any graph
is called as a director graph where each
Edge has a direction associated with it
so so far we have just discussed the
edges which are connecting to one or the
other vertex but there was no Direction
but here you can see that this
particular Edge has a direction that is
from B to a not from A to B it is from B
to a this type of edges which are
directing the traversal of the graph are
known as the directed graphs
now followed by the directed graphs we
have the regular graph so a graph is a
regular graph where each vertex of the
graph has the same degree now here you
can see all the vertices have the same
amount of degree that is the connection
between all the other vertices so the
degree of as3 so the degree of B is also
3 and the degree of DSC and similarly
the degree of C is also 3.
so what I mean to say is all of these
vertices have the same degree that as 3.
now we have the weighted graph so what
is a weighted graph a weighted graph is
where each Edge holds some weight that
denotes the traversal cost through those
edges now here you can see that all the
edges have a different weight The Edge
from A to B has the weight 5 and the H
from a to c has the weight 9. and this
from C to B has 2 and the h a to d as 8
and finally C to d as 7. so all these
values are the weight or the cost to
Traverse from a to another vertex flow
so from A to B we have the cost 5 and a
to c we have the COS 9 and similarly C
to D we have 7 and so on
now followed by the weighted graph we
have the connected graph so what exactly
is a connected graph a graph is said to
be connected where each pair in the
graph is connected
followed by connected graph we have the
disconnected graph so it is a typical
opposite of the connected graph a graph
is said to be disconnected where each
pair in the graph is not connected to
each other
now next we have the cyclic graph so a
graph is said to be cyclic if it
contains at least one cycle in a graph
that is one complete traversal
connection so a can be traversed again
from traveling a to c c to d d to B and
B to a again so this type of a graph is
called as a cyclograph
now next we have the acyclic graph so it
is the typical opposite of the cyclic
graph so here it cannot travels to a
Again by traversing from a to c c to D
and there is no connection between D to
B so the complete cycle is not available
here this type of graphs are called as
acyclic graphs
so moving ahead we have the graph
representation
so generally there are two different
ways to represent the graph data
structure
they are using adjacency Matrix and
adjacency list
so what is adjacency Matrix
so adjacency Matrix is a sequential
representation a decency Matrix is used
to represent which nodes are connected
to which node if there is an edge
between two vertices then the value of
the corresponding element of the graph
is one otherwise zero if there is any
way to craft besides then zeros and
bonds we can store the weight of the H
as that particular number so suppose
that there is a connection between a and
b and it is represented as a weight of 5
then there is a connection so we will
use the connection as true but we will
not represent it as one instead we will
use the weight that is 5 to represent it
as 5 not as one if there is no weight
then we will represent it as 1 and if
there is no connection then we will
represent it as 0.
now undirected graph representation
so here you can see how we have
represented a graph so there is no
connection between a to a that is there
is no Loop so the value will be zero if
there was a loop and if it was
represented width of it then we could
have written a weight here since we do
not have weight then the no connection
is represented as 0 and a connection is
represented as one we have a connection
from A to B so we have represented it as
1 and similarly to a to c so and so on
now directed graph representation so the
simple difference between the directed
and undirected graph representation is
we did not have a direction in the
previous segment but here we do have
directions so B is connected to a but a
is not connected to B so we will write
it as 0 because the control is
traversing from B to a but not from A to
B so we need to take care of the
traversal of control so we are
representing as 0 and you can see from D
to B we have one connection and the
traversal is in the direction of D 2B so
we will have one there so here we have D
and B so we have one so in that way we
represent the directed graphs
next undirected waitress
so this was what we discussed before
instead of zeros and ones we will
represent the weight here so we do not
have a connection between a to a so that
is 0 as usual but we do have a
connection from A to B so we have
represented it with a number that
happens to be the weight of the edge
and remember we do not have the
direction here this is undirected
weighted graph now if it were the
directed weighted graph then we could
have seen the direction and represented
the number with the weight now after
this let us look into the adjacency list
so what is adjacency list adjacency list
is a linked representation
in this representation we maintain the
list of its neighbors for each vertex in
the graph every vertex of the graph
contains the list of adjacency vertices
array of vertices which have vertices
indexed by each vertex number for every
vertex the array element points to the
linked list of the neighbors of the
vertex so this might be a little
complicated to understand so let us
understand this using an example
so directed graph representation
implemented using linked list
so this is the directed graph we are
using
so you can see that a is not connected
to anything so we have ended the address
of next location as X but B is connected
to a and C is connected to a similarly D
is also connected to E
so that is how we represent the
directed graphs using linked lists
next we have directed graph
representation using array
so a is not connected to anything so we
have represented as 0 and B is connected
to B as well as a so we have 1 there and
C is connected to B
so C is also connected to a so we have 2
there D is connected to a c and b so we
have 3 there
now we have the graph trap version
so graph traversal refers to the process
of examining each Edge and vertex in a
graph
traversing can be performed in two ways
the first one is breadth first search or
BFS algorithm BFS starts traversing the
graph from root node and expose all the
neighboring nodes then it selects the
nearest node and explores all the new
nodes Q data structure can be used in
BFS algorithm
so the following image depicts the apfs
algorithm working
it chooses the nearest node first then
it traverses to all the other nodes
so followed by BFS algorithm we have the
DFS algorithm that is the depth first
search algorithm DFS starts traversing a
graph from the initial node of the graph
and then it goes deeper and deeper until
it finds the node has no child there the
backtrack from the dead end towards the
recently explored nodes stack is used
for BFS algorithms so this particular
gif image can be considered as the
graphed reversal which is performed
using DFS algorithms so if you don't
know much about DFS and BFS algorithms
don't worry about that those particular
tutorial videos are added in the
description box below you can go through
it and understand BFS and DFS algorithms
in a much better way now we will go
through some of the applications of
graphs
so some of the major applications of
graphs are used in the websites Google
Maps and social media websites like
Facebook and some security systems
and also software programming
at first we will discuss web first
search algorithm
so what exactly is breakfast search
algorithm so breadth first search
algorithm visits every node efficiently
and marks all the nodes which are
adjacent to that particular node the
critical nodes in the graph are in a
breadthwise manner
breadth first search starts traversing
from root node and then selects all the
unvisited adjacent nodes of the selected
node Q data structure is used to
implement BFS algorithm so here you can
see a gif which is explaining about BFS
algorithm so let us consider that we
have selected the root node as 1 then it
will check for all possible adjacent
nodes so it will Traverse to 2 then it
will Traverse to 3. after that it
doesn't have any adjacent nodes so the
control moves to either one of the child
nodes that is two or three so let us
consider that we go to 2 and from 2 it
will check for all the adjacent nodes
that is 4 and 5 and there are no other
adjacent nodes from 2 then it will go to
4. it can also go to 5 But Here let us
consider that it goes to 4. so from 4 it
does not have anything to Traverse so it
get backs to 2 then it goes to 5 and
from Phi it checks for the traversal
there is only one possibility that is 7
and no other Explorations then it goes
to 7 and there is no other possibility
for 7 as well so it comes back to 5 then
to 2 then to 1 and then it enters the
second child node that is the three from
the 3 it moves to another possibility
that is 6 and it checks for another
possibility but there is no possibility
so now the control moves from 3 to 6
from 6 it tries to visit the adjacent
nodes so 6 has only one adjacent node
that is eight and no other adjacent
nodes and now from 6 it goes to 8 and
from it it checks for any other adjacent
nodes but there is no other adjacent
node so it gets back to 6 then 3 then to
1 back so this is how the control
traverses when you are implementing
breadth versus algorithm
now here let us look into an example for
breadth first search algorithm as
discussed in the previous example here
the root node is selected first then it
goes to B then it goes to C and it
checks for any other adjacent node but
there is no other adjacent node other
than B and C so the control moves to B
and from B it starts traversing to all
its adjacent nodes first it traverses to
T then to e and it checks for any other
possibility but there is no other
possibility so the control goes backs to
B then to a and from a it traverses to C
and from C it checks for all the
adjacent nodes that is f and g so it
checks for other possibilities since
there is no other possibility it goes
through F and from f it checks for other
possibilities but there are no other
possibilities from F so the control gets
packs to C and then finally to G and in
G it checks for any adjacent nodes since
there is no adjacent node from G it
stops there and we have the queue output
here that is a b c d e f and g so this
is how the breadth first search
algorithm works now to understand this
in a practical way let us try to execute
a program in Dev C plus plus
so now we are on dev C plus plus and the
program on my screen is an example for
BFS algorithm in this program we have a
queue first as BFS is executed using Q
data structure
and there are two variables that is rear
and front and there is one array named
as size and the size is defined here as
50.
next we created some functions first
there is a queue function to create a
queue then we have NQ and DQ to insert
and delete the element from the queue
so this is the NQ function and this is
the DQ function to insert and delete the
elements from the queue
then we have a function to display and
after that we have the empty function to
check whether a queue is empty or not
so this particular code segment is to
check whether the queue is empty or not
and this particular function is the
print function which is used to print
the elements inside the queue
after that we defined node and made a
function as creating a node and in node
there is a one variable named as vertex
and one pointer next to it
so this is the structure for creating
the node
and followed by the node we have created
another structure called graph and
inside graph we have the create graph
function to create the graphs and we
have number of vertices adjacent lists
and visited
and next we have the add edge where we
will add edges in between the vertices
and finally we have the BFS algorithm
so here we will check if the queue is
empty or not first then we will call the
DQ function and we will execute the BFS
algorithm
and now finally we have the main
function where we will add all the edges
to the graph and call the PFS algorithm
now let's try to run this program and
see the output
so there you go the program got
successfully executed and the output is
displayed on the screen
so Q contains the values that is 0q
reset node is visited to 0 and then Q
contains values two and one now the node
is visited to 2 followed by that the
queue has values 1 and 4 and node has
visited one and then Q contains values 4
and 3 and node has visited the value or
Vertex 4 and finally Q contains value 3
and the queue is reset and the node is
currently visited at node number 3.
now with that let's move ahead into the
next type of algorithm that is the depth
first search algorithm so what is depth
first search algorithm
so DFS algorithm is used for traversing
trees using the depth wise Direction
the execution of this algorithm begins
with the root node and explores each
branch before backtracking next DFS uses
stack data structure to remember to get
subsequent vertex and start a search
whenever a dead node appears or the dead
end appears at any iteration
now we used to have queues in BFS
algorithm button DFS algorithm we will
be using Stacks now to understand the
working of depth first search let's go a
bit more detail
so here we have a graph so how depth
first search algorithm works now here we
can choose the root node first so once
the root node is chosen it sees the
possibilities of traversal it starts
from the left side tree first it first
visits B and now it will not stop at p
in BFS it used to stop at B and used to
check all the possibilities but here it
is not like that it will first visit P
then it will not stop at B it directly
sees the depth of the B that is it has
another child node so it will enter the
left child node and checks D and now
here it will not stop at D it will check
for possibilities ID so since there are
no possibilities from the left or right
side of D it will get back to B and now
it will check for another possibility
from B that is right side first it
finishes the left subtree on completion
of left subtree only then it will enter
the right subtree so here it checks for
the possibility it found e and from E it
will check for another depth search so
there is no depth search from E and not
on left and not on right so it comes
backs to p from B it visits the root
node again from here it checks for the
right subtrain now here we have C so it
will not stop at C it will go to the
next subtree that is f
and now it will not stop at F it will
search for other opportunities now since
there is no other opportunity or other
vertex from f it gets packs to C and
after that it checks for next right
subtree and that is g so from G it looks
for another opportunity or vertex since
there is no other vertex it gets packs
to C then to a so to keep the traversal
in order
it uses stack data structure now for a
better understanding let us go through a
practical demo on dev C plus plus and
now we are on dev C plus plus and this
particular code is an example for DFS
algorithm in this particular code we
have defined the structure that is node
and inside the node structure we have
this vertex and node reference which
points to the next node in the graph
followed by that we have the graph
structure and inside graph structure we
have the number of vertices and visited
and referenced to each node followed by
that we have the depth first search
algorithm and this particular code
segment is the Logic for depth first
search algorithm then we have the
structure of node reference and followed
by that we have the structure of graph
reference that is the number of vertices
visited and the adjacent vertex list and
then the reference of that particular
node is visited or not now we are using
dynamic memory allocation here and
followed by that we have add edge
function where we will add edges between
the vertices and followed by that we
have the print graph function so here we
will be printing the stack data
structure which has the vertex after
visiting all the vertices in the graph
and finally we have our main function
where we will assign the edges to the
graph then we will call the depth first
search algorithm now let's try to
execute this code and see the output
there you go you can see that the code
got successfully executed and we have
our list here that is we have visited
the vertex 2 3 1 and 0.
now followed by this let us look into
the differences between breadth first
search and depth first search algorithms
so some of the fundamental differences
are breadth first search finds the
shortest path to the destination whereas
depth first search goes to the bottom of
the subtree and then backtracks
the next difference is BFS algorithm
uses a queue to keep track of the
following locations to visit whereas DFS
algorithm uses stack now we have gone
through that in the examples for both
DFS and BFS
followed by that the next difference is
the BFS uses fifo that is first in first
out order of implementation because we
are using Q data structure here whereas
DFS uses lost in first out order of
implementation because we are using
stack data structure the next difference
is BFS requires more memory as compared
to DFS and depth first search requires
less memory compared to that of BFS
followed by that we have BFS algorithm
which gives the shallowest path to the
solution next compared to BFS DFS
algorithm does not guarantee for
shallowest path as the solution
the next difference is in BFS algorithm
if you do not find any goal then you may
need to expand to the other nodes before
the solution is found whereas in DFS if
you do not find any goals then the back
tracking will start from the leaf node
now we will discuss some of the major
applications of BFS algorithms
so BFS algorithm can be easily used to
create the shortest path and the minimum
spanning tree to visit the graph
vertices in the shortest time possibly
with high accuracy
BFS algorithm is implemented to locate
all the neighboring nodes in
peer-to-peer Network and this will find
the required data faster
search engine or web crawlers can
quickly build multiple levels of indexes
by employing VFS algorithm and start
implementing from the source and then it
visits all the links from the source
the BFS algorithm guides the broadcast
packet to find and reach all the node it
has for the address now we will look
into the applications of DFS
the next application of DFS is it is
primarily used for scheduling jobs for
the given dependencies among the group
of jobs in computer science it is used
for instruction scheduling data
serialization and compilation task
ordering
next the DFS algorithm can be easily
adapted to search all solutions to a
maze including nodes in an existing path
in the visited set
we will have a look at an application of
the spanning tree to understand it
better
meet Patrick Patrick works is ahead of
the network administration department in
an I.T solution company named as gray
Solutions being the head of network
administration department Patrick is
responsible for managing his team to
keep the organization's computer network
up to date and operate it as intended
Network administration department
coordinates and connects multiple
systems in the company to a single
network using multiple routers
this network is called as local area
network or Lan which is created for the
sole use of an I.T company
but in the last few days something went
wrong in the network management system
which came to Patrick's notice
he observed that the network loop is
formed in a routing system a network
loop occurs when multiple routes carry
information from the same source to
various Computing devices
and due to this formation of a network
loop the network connectivity started
slowing down initially after a few hours
the network connectivity completely went
down and all the operations of the
company stopped abruptly
now Patrick and his team needed to do
something in order to resolve this
problem permanently
so Patrick started brainstorming to find
out an optimal solution to fix this
problem
one of Patrick's teammate was good at
data structures and he came forward with
an idea to implement a spanning tree
data structure for managing the routing
connections he suggested replacing the
old naive routing strategy with a
minimal spanning tree routing
after listening to this idea the whole
network Administration team started
working on implementing a spanning tree
while doing that they treated the
network connection as a graph the
routers and end devices like computers
fax machines were treated as the nodes
of the graph where the connecting wires
carrying Network signals were treated as
the edges of a graph
but before understanding how Patrick's
team was able to solve this problem
using a minimum spanning tree let's
first understand the basics of this data
structure
this will allow us to get a clearer
insight into how spanning tree solves
Network routing problems so let's start
with graph and its different types
basically a graph is a structure made of
nodes and edges connecting them and
there are three types of these graphs
based on the types of edges
the first is the undirected graph the
second is the directed graph and the
last is the connected graph
let's understand these types completely
in the upcoming slides
the first type of graph that we are
going to discuss is the undirected graph
it is termed as a graph in which all the
edges does not point to any specific
Direction in simpler words all the edges
of this graph will be bi-directional
as you can see in this particular graph
you can move from any node to any other
node and retrieve back as well
next up is the directed graph it is a
graph in which the edges point to a
specific Direction
by this I mean in this type of graph you
can only move towards a single direction
for example you can Traverse this given
graph starting from a then B then C then
D and finally e
but here you cannot Traverse back from e
to a as this graph is unidirectional
the last type of graph depending on its
Edge is a connected graph it is defined
as a graph with a path from any vertex
to any other vertex in the graph
in this particular type of graph you can
reach any vertex from any other vertex
in a graph for example you can go to
node b or T from node a and arrive back
at a from either vertex P or D
now moving ahead we will understand what
a spanning tree is and how we can create
it
mathematically the spanning tree for any
graph G having vertices V and edges e
can be represented using superscript
notation G Dash having vertices V Dash
and edges e Dash
suppose we intend to create a spanning
tree for graph G then R spanning Tree G
Dash must follow few constraints
the first constraint suggests that the
number of vertices for created spanning
tree must be equal to the number of
vertices of a given graph G
further the edges of G Dash should also
be similar to the number of vertices in
graph G minus 1. to understand this
mathematical formulation clearly let's
have a look at an example
now for this given graph G we have to
formulate all possible spanning trees
remember a single connected graph can
have multiple spanning trees until we
fulfill the constraints mentioned
earlier
so for this particular graph G we have
five vertices and five edges
additionally each Edge has been assigned
with some cost or weight
let's say this weight represents the
distance between the connected two nodes
to create the spanning tree g Dash we
need to ensure that g Dash contains five
vertices and five minus 1 that is four
edges hence for this graph we can create
a spanning tree like this
you can observe that we have eliminated
one node in the spanning tree to remove
the loop or cycle in a graph
for this spanning tree one we have a
cost or value equal to 10 and this cost
is nothing but the summation of all Edge
weights
now that we have created the first
spanning tree for our graph G I would
like to ask all of you to give this a
try
for that I am going to provide you with
a short moment to generate all possible
spanning trees for the structure that we
are discussing right now
you can also pause this video if you
need more time in order to do that
so now let's have a look at all possible
spanning trees at a glance we have seen
that the value for the first spanning
tree was 10.
and for this new spanning tree 2 it is
13. in this spanning tree The Edge
between vertices B and C is removed
the next spanning tree looks something
like this with cost 14.
further We have spanning tree number
four with a value 12. and finally we
have the last possible spanning tree Phi
with a value 11.
out of all these spanning trees the
value or cost for spanning tree number
one is the least which is 10. thus this
spanning tree will be called as minimum
spanning tree
I hope you're clear with the creation of
spanning trees but how can we judge the
number of all the possible spanning
trees
well for that you need to check the
structure of your graph
if the graph you have been given with is
cyclic then the number of possible
spanning trees will be equal to the
number of vertices
the cyclic graph is a graph in which you
will have the same number of vertices
and edges with a cyclic structure
if the given graph is a complete graph
then the number of possible spanning
trees will be equal to V raised to V
minus 2. where V is the number of
vertices in a given graph you can say
that the given graph is a complete graph
if each pair of vertices is connected by
The Unique Edge
for this particular graph the number of
possible spanning trees will be equal to
the number of vertices that is 4 to the
power of 4 minus 2 which is further
equivalent to the square of 4. hence the
number of possible spanning trees for
this structure will be 16. moving
forward let's understand some important
properties of spanning tree
we have already gone through some
crucial properties while creating
spanning trees in the previous section
so primarily we will list all of them
here the first property of a spanning
tree conveys that a connected graph can
have more than one spanning tree
the next property states that the number
of vertices in spanning trees must be
equal to the number of vertices in the
given graph whereas the number of edges
is equivalent to the mod of V minus 1.
the third property of a spanning tree
says that the spanning tree must not
contain any cycle if the structure that
you have created as a spanning tree
includes a loop or a cycle then it's
clear that you have made a mistake
because no tree can contain a cycle
and finally the fourth property is all
about Kaylee's formula if the given
graph is a complete graph then you can
calculate the number of possible
spanning trees using the formula V
raised to B minus 2.
the next property of a spanning tree
conveys that a spanning tree can never
be disconnected for example if you
create a spanning tree for this given
graph which is accurate and you erase
one Edge when you do that the structure
will no longer be a spanning tree it can
only be referred to as a disconnected
graph the next property states that if
the graph contains more than one similar
weight there is a possibility of having
more than one minimum spanning tree for
example in this particular graph there
are more than one Edge having the same
widths thus there will be two possible
minimum spanning trees with the same
cost that is 7.
this is all about the properties of
spanning trees now that you understood
what spanning tree is you would have
also understood how it proves is an
effective solution and that is exactly
how Patrick from our story solved his
Network issue in a few days Patrick and
his team changed the knife routing into
the minimum spanning tree routing now
the routing parts are managed by a
minimum spanning tree to maintain cost
Effectiveness and to avoid any looping
activity as we have already understood
MSC removes all the loops from a given
graph and we also know that the whole
network becomes the graph for which MST
will maintain a minimal routing path
hence the network system will never
experience a network loop again
due to this amazing initiative Patrick
and his team were appreciated by the
whole organization
this example clearly illustrates the
importance of a spanning tree and why it
is one of the most important algorithms
in data structures
now we will look into the different
applications of spanning trees
the first application that we are going
to talk about is telecommunication
Network building
if we want to build a telecommunication
Network for the whole city and we are
putting different connection lines for
each customer then we will have to deal
with a huge cost this knife ordinary
approach is not the best solution to
build a connection line
but no worries this problem can be
resolved using the minimum spanning tree
data structure in this case each
customer will be treated as a Vertex
whereas the connection line will be
treated as an edge
the minimum spanning tree will give us
the possible output for generating the
telecommunication Network
no matter what type of algorithm you are
building using machine learning
techniques somewhere down the line you
will be using clustering techniques
quite liberally
clustering and data preparation go hand
in hand as many times you will be
working at least initially with data
sets that are largely unstructured and
unclassified
those data sets cannot be classified
using single neuron or classification
methods
so you use a clustering algorithm which
utilizes a minimum spanning tree to
create clusters or groups by mapping
distances between data points
the next application of a minimum
spanning tree is image segmentation
you must have observed that your face
gets detected with a square shape while
clicking images in selfie mode
this scenario is happening due to the
image detection algorithm developed on
the camera system
at the back end the picture gets
fragmented into tiles of similar pixels
with the help of a minimum spanning tree
the last application of the spanning
tree is its use in calculating the
finance factors
a correlation Matrix can be created by
calculating a coefficient of correlation
between any two stocks
this Matrix can be represented
topologically as a complex Network and
the minimum spanning tree can be
constructed to visualize the
relationships
the prims algorithm is used to find
minimum spanning tree for a given graph
but what exactly is a minimum spanning
tree or MST well a minimum spanning tree
is a subset of graph G having the same
number of vertices as of graph G and
edges equivalent to a number of vertices
-1 along with these properties it also
has a minimum cost for summation of all
age weights included in a spanning tree
algorithm starts with a single node and
explores all the adjacent nodes at every
step the edges with minimal age weights
causing no Cycles in the crop gets
selected hence we can say that primps
algorithm makes a locally optimal Choice
intending to find global optimal choice
that is why it is called as greedy
algorithm
moving ahead let's understand how we can
find out the minimum spanning tree using
prim's algorithm
now given a graph G consisting of vertex
is V and edges e we need to construct a
minimum spanning tree g Dash with
vertices V Dash equal to V and ages e
Dash equal to V minus 1. having this
summation of edge vets minimal this
particular graph G contains 9 vertices
and 12 edges that means our MST G Dash
will have 9 vertices and 9 minus 1 edges
that is 8 edges so with this in mind
let's create an MST for this graph G
using prim's algorithm
the first step in prim's algorithm is to
choose an arbitrary starting vertex here
we'll select node a as our starting
vertex
now the next step in prim's algorithm is
to add new vertices with a minimum age
weight in this case from vertex a we
have two possible edges for traversal
the age weight for h a b is 1 whereas
the age weight for age AC is 6. so
obviously we'll choose vertex B here
since we have reached vertex B we will
look into the possible edges for adding
an age with minimum weight to our MSD
hbd has the minimum age weight so we'll
add it to our MSD now from vertex D
there is only one Edge hence we'll
directly add that h d h into a spanning
tree
now from vertex Edge there are two
possible paths out of which the path h i
has minimum cost thus will add it to our
MSD from vertex I there is only one Edge
so we'll directly include it in our MST
now that I have included vertex G I am
going to check for connected edges I
have from vertex G but since there is
only one Edge from vertex G we'll just
insert it on rmsd from vertex e two
edges are going to different vertices so
we will choose the one with least age
weight and that age is h e c
now that I have included node C I am
going to examine what connected edges I
have to consider from vertex C
currently out of these two highlighted
edges I want to pick that edge which has
not yet been included in MSD and has the
minimum age weight but the question that
arises here is can I add this Edge AC
into our MSD
well we cannot if we add H AC to our MST
then it won't remain a tree structure
due to the creation of cycle or a loop
which we cannot allow to happen
according to the primps algorithm thus
in this particular case we'll choose
Edge CF for insertion in our MSD and
finally the summation of age weight for
this MST will become 30. also till the
time you must have observed that this
algorithm chooses the next vertex that
offers the most prominent or immediate
benefit it started with an empty
spanning tree for maintaining two sets
of vertices the first set was for the
vertices included in the MSD and the
other one was for the vertexes that
haven't been included in the MSD at
every step this algorithm considered all
the edges that connected the two sets
and picked the one with minimum age
weight from The adjacency Matrix a group
of Ages that connects two sets of
vertices in a graph is called cut in
graph Theory so at every step of primps
algorithm we find a cut of two sets one
contains the vertices already included
in MST and the other containing this
rest of vertices after that we pick the
minimum age weight from the cut and
include that vertex to our MSD set that
is why this algorithm is called as
greedy algorithm having said that let's
dive into the implementation strategy
for developing code for prim's algorithm
the idea behind prim's algorithm is
simple all the vertices of a spanning
tree must be connected hence the two
disjoint subsets of vertices must be
connected in order to create a spanning
tree and further this vertices should
only be associated with the minimum age
weight to make it a minimum spanning
Tree in order to store these vertices
and edges we'll create an adjacency
Matrix using 2D array in C programming
language well the indexes of this 2D
Matrix will be the vertices where the
values other than 0 will be the edge
widths for indexes 0 1 and 2 you can
clearly see that the adjacency Matrix is
having value 0 that means there is no
recurring connection or Loop for these
vertices so primarily let's add them to
our graph structure
for age 1 to 2 we have the weight value
2 so we'll add age between vertex 0 and
1.
after that
we have age between 2 and 1. the value
for this age weight is 3 so we'll add
age between 1 and 2 and assign 3 as its
age way
finally the age weight for connecting 0
to 2 is 4 so we'll insert it in our
graph as well in the next slide we'll
discuss the strategy for implementation
of a prim's algorithm
from this example I hope you are clear
with how we are going to maintain a
structure of a graph using 2D Matrix in
the next slide we'll discuss the
strategy for the implementation of
prim's algorithm
the first step of this algorithm is to
maintain a set for keeping track of
vertices included in an MSD once we
create the set we'll assign a key value
to all vertices in the input graph
initially we are going to set all key
values as infinite and at the runtime
we'll assign by 0 to the first vertex by
doing that we choose it as an arbitrary
starting vertex once done with that
we'll start adding vertices to our
minimum spanning tree for that we'll
pick up a Vertex U with minimum weight
to insert it into our set after that
we'll also update the key values for all
adjacent vertices of you on that note
let's visit a code Editor to implement
prim's algorithm using C programming
language
if getting your learning started is half
the battle what if you could do that for
free visit skillup by simply learn click
on the link in the description to know
more
now in order to begin with coding
implementation we'll need to load some
dependencies for this implementation
process we are going to need a Boolean
set in order to keep track of vertices
included in our MSD that is why we'll
include a standard Boolean library in
our program
so hash include
STD
goal dot h
once done with this addition we'll
Define a number of vertices that we are
going to use in our graph I am going to
set the number of vertices to 5. so
let's do that
hash
Define
vertices
5.
and if you want to implement MSD for a
larger graph then you must set the
number of vertices to a most significant
number now let's move to the main
function the graph that I am going to
use for generating a minimum spanning
tree is supposed to be stored inside a
2d Matrix
so first let's have a look at that graph
this is the graph for which we want to
develop a minimum spanning tree the
first step that we must take to do that
is converting this graph into 2D Matrix
as discussed earlier the diagonal values
will be null or zero and other values
will be the age weights between two
nodes so without wasting any time on
this I will directly create adjacency
Matrix for this graph inside our code
editor this part is what maintaining our
graph in form of 2D Matrix now after
this
we are calling print semestic function
which is responsible for generating a
minimum spanning tree so let's do that
here
rims underscore MST and we'll pass this
graph
to this function
but we haven't developed any code for
this premium SD function but we'll do
that now
so let's create prim's MSD function void
prims underscore MSD
and will pass graph as an argument
should be vertices
and vertices to make it a 2d Matrix
now inside this function we'll create an
array name key to store Key values of
all vertices
and key
okay
vertices
along with that we'll also initialize
the parent in which we'll store our
actual MST and Boolean set to keep track
of each and every vertex of our graph so
let's create that parent
array
vertices
thank you
and we'll create Boolean
set for maintaining track of all
vertices
now after this what we'll do is we'll
set the key values of all vertices to
infinity and will also make sure that
these vertices are not part of our
minimum spanning preset so for that
we'll create a for Loop and inside this
for Loop we'll use iterator element I
and we'll initialize this element to
zero
till
vertices
and will increase the iterator element I
for each Loop
and set this Loop
we will say key I
to the possible integer maximum value
and in order to use this value we'll
need to add one Library which is called
as limits.h so we'll add it here
hash
include
limits
dot h
okay
after this
we will also make sure that these
vertices are not part of our minimum
spanning tree set or Boolean set so for
that we'll write statement mean
underscore span underscore tree
I
should be false that means empty
and we'll add indentation
okay
now in order to choose the arbitrary
index we'll set the key value of our
first vertex to zero so that it will be
chosen first in our minimum spanning
tree for that we'll write statement key
0 should be equal to
zero
and as we have chosen vertex 0 as our
first arbitrary vertex so we'll also set
the index 0 of the parent array to -1
by doing this we are ensuring that the
index 0 is the root node of our minimum
spanning tree now to choose vertices
with the minimal key value we'll create
a new function named list key so let's
do that
end
and list
underscore key
and inside it will pass arguments in key
Boolean set
foreign
body we are going to set all key values
to Infinity
so let's do that in list
will be equal to int underscore Max
and will also initialize
minimum underscore index as new variable
Now using a for Loop will Traverse
through all vertices if the given vertex
is not present inside the minimum
spanning tree set and the key value is
also smaller than the least value then
we'll set the least variable to the key
value and minimum index to that
particular index V so let's create that
for Loop
and inside it end v as iterator element
and we'll initialize it to value 0.
and the maximum limit for this V will be
vertices
and will increase the value of this
small V variable
plus plus
now if the chosen vertex is not present
inside minimum spanning tree set
and and
the key value
for that vertex
is also smaller than list
then
we will set list
equal to
key of
green
and minimum index
to
V
and we'll get out of this for Loop and
will return
the minimum index value
on that note let's arrive back at our
Prim semestick function
here using a for Loop will fetch the
minimum index that we have generated
inside a list key function
so let's create for Loop
we'll use count variable here
and will initialize it to zero
and we'll move this count variable
till vertices
minus 1.
which is nothing but the number of
vertices in our minimum spanning tree
next will increase discount variable
now we have arrived inside this for Loop
body
now we'll store that phage minimum index
value in variable U so in u
will be equal to least
underscore key
and will pass
keep
and
Boolean set that is mean underscore span
underscore tree
and
we will include this list node that is U
to our minimum spanning key set
or Boolean set
equal to true
now here we'll use a nested Loop in
order to insert a complete Edge which is
initiating from node 0.
inside this Loop we'll further call if
log to validate some conditions so let's
create that nested for Loop first
foreign
and set this for Loop We'll add F log
and we'll check graph
U
to V
end and
mean expand tree
V
is equal to equal to false
and n
graph
U
three
it's minimum than K of V
then what we'll do is
we'll set parent
of V
to U
and key
of V
to graph
u v
yeah so now you must be thinking about
what exactly is this code is doing so
actually what we are doing is we are
inserting node U into our minimum
spanning tree and once we include node U
into our minimum spanning tree then we
check if there is any age between u and
v v is nothing but all the vertices
inside the ga if there is H with between
u and v then we check if that V is
included in our spanning tree or not if
it is not included then we check the
value key value of V
if the key value of V is greater then
what we do is we set parent of V is
equal to U and key value of V is equal
to graph u v which is nothing but the
weight between h u and v
so that's what this code is doing
after this what we'll do is we'll write
one printf statement so for that we'll
need to get out of this for Loop and
we'll write printf statement print f
created
spanning
tree
for given graph
as
backslash n
so that this next part comes inside the
next line
and
will also
make a call to
print underscore
MSD
function which is not created but will
write code for it once done with this
call and will pass parent and graph to
it
well
now let's
create a code for this print frame
semester function
and
print
underscore frames
MSD
and will pass
and
parent
will pass end graph
with vertices
and
vertices
now inside this function
what we'll do is we'll write one printf
statement
to
show the pattern of printing
Edge
all right
slash d
wait
slash and
semicolon and in next slide
will create iterator element
and will initialize it to 1
and we'll extend this till
vertices
and I plus plus
printf
printers
modulus d
Ash
modulus d
slash
d
backslash d
modulus d
and backslash n
and will pass
parent
I
comma I
comma
graph
I
and parent
of I
this statement will print a graph on our
screen
but here is one mistake that I have made
I haven't added the indentation for this
for Loop
okay
I think this should be fine now
we can say that our coding
implementation and finish now let's run
our code and check if it is working or
not
well we have received output on our
console here that means our code is bug
free and it works fine you can verify
this result by drawing the spanning tree
of output on your notebook and further
you can compare it with the graph that
we have shown previously
the crystals algorithm is used to find
the minimum spanning tree for a given
graph but what exactly is a minimum
spanning tree or MST well a minimum
spanning tree is a subset of graph G
having the same number of vertices as of
graph G and ages equivalent to number of
vertices -1 along with these properties
it also has a minimum cost for the
summation of all age weights included in
a minimum swanning tree
if you want to learn more about spanning
trades then please consider watching our
video which you can find in the I button
section right away
now coming back to the crystals
algorithm the crystals algorithm sorts
all ages in increasing order of their
age weights and keeps adding notes to
the tree only if the given age does not
form a cycle also it picks the age with
minimum cost at first and the age with
maximum cost at last hence we can say
that the couscous algorithm makes a
locally optimal Choice intending to find
global optimal solution that is why it
is also considered as greedy algorithm
the data structure that we are going to
use for implementing this couscous
algorithm is Union fine but now you must
be thinking what exactly is this Union
fine data structure and how it works
well Union fine is a data structure that
keeps tracks of element that are split
into one or more than one disjoint sets
where a disjoint said its collection of
two distinct groups or clusters that do
not have single common element the union
fine features two important operations
named as find and Union
the operation find Returns the set or
group to which provided element belongs
basically it constructs a bisection
between the object provided and its set
whereas the Union function joins two
distinct disjoint cells to create a
single subset let's understand how this
data structure works with the help of
real life example
let's say we have some singing magnets
placed on table with a higher magnetic
Affinity towards each other all these
sinking magnets present on the table are
color coded with sky blue color now due
to the high magnetic attraction the
magnets a to e will form a strong
magnetic field which will cause the
bonding or connection of all these
magnets as a result all these magnets
will be grouped together we will now
color code this set with red color along
with that we'll also call this set as
red
after that the magnet F to I are also
closer to each other thus they will also
form a connection we'll call this set as
green finally this last set of magnets
will also formulate a connection with
each element inside a group we will call
this group as set purple
all these distinct magnets got
distributed into three different
disjoint sets but as the magnetic
attraction between these groups
increases significantly hence all these
clusters of magnets will end up
connecting with each other this scenario
can be related to the Union function
Union function merges different sets
into a single subset where the find
operation helps in extracting the group
of element to which the particular
element belongs similarly in this
scenario a particular magnet can be
traced back to its group with the help
of color code that we have maintained
alongside the magnets
the use of Union find in crucial's
algorithm can be related to this example
while implementing kruskal's algorithm
we are going to maintain three distinct
disjoint sets the first set will store
age weight values for all ages in a
graph whereas the second set will store
tree hierarchy for a different notes the
last set will store the ranks for all
nodes included in an MSD by using the
union fine structure and its operation
we can justify the entry of each Edge
into the spanning tree which we will
explain in the implementation of this
algorithm but let's understand the
functioning of this algorithm primarily
the crystals algorithm begins with
sorting all edges into increasing order
of their age weights this sorting is
done to include edges with the least age
weight primarily into the tree structure
after that we'll pick the first smallest
Edge and we'll check if it generate any
cycle in the tree structure or not if it
does not form any cycle then we will
include that edge into our spanning tree
otherwise we will discard it we will
keep repeating this process until mod of
V minus 1 edges are included into our
MSD where V is number of vertices now
moving ahead let's discuss how we can
create a minimum spanning tree using
couscous algorithm
this given graph g v e contains 12 edges
and 6 vertices and we are supposed to
find out G Dash such that the number of
vertices is equal to 6 and the number of
edges is equal to V minus 1 that is 6
minus 1 which is equal to 5. the one
more condition that the formulated
structure must abide by is that the
summation of all included Edge weights
must be the minimum possibility for the
spanning tree going forward we'll
discuss how we are going to create MST
for this graph using couscous algorithm
the first step that we need to perform
is removing all the loops or parallel
edges from our graph hence primarily
we'll remove these two present Loops The
Next Step that we are going to perform
is arranging all the edges in increasing
order of their weights
the reason behind maintaining the sorted
list is to make sure that the first Edge
for insertion is of a minimum cost here
I have maintained the sorted list for
all the edges that are part of our graph
so according to this sorted list the
first age that we are going to insert in
our MST is h e f as it has minimum
weight cost that is 2. the next stage
that we have in our sorted list is hfd
it also has an edge weight equal to 2
hence we'll include it in our spanning
tree
the third Edge in our sorted list is HBC
with weight 3. the inclusion of this
Edge does not formulate any Circle in
artery structure hence We'll add it to
our MSD the next is
hcf having the age weight 3 so we'll
include it in our MSD structure
the fifth age that we are going to pick
is hcd having weight 4 but the inclusion
of this age inside a spanning tree will
create a loop and the structure that
contains a loop can never be considered
as tree hence we have to exclude this
Edge
the next age is age BF and the inclusion
of this age will also generate a cycle
in our spanning tree structure
so we will exclude this age as well
the next age
is hbd
this age has weight value 6 the
inclusion of this age can also create a
loop in our structure so we'll have to
discard this Edge as well
the next up is h a b with a weight value
7. even though this age has higher
weight value than previous ages but it
does not formulate any cycle in our MSD
so we'll include it in our tree
structure by doing that we have
generated V minus 1 edges for our
spanning tree thus we won't iterate
further in our sorted list this
generated MST has minimum possible cost
for our graph gve which is 17. I hope
that you guys have understood the MST
implementation process using crystals
algorithm because in the next slide I
have a problem for all of you guides to
assess your understanding of cuscal's
algorithm
the craft shown on your screen contains
10 vertices and 18 edges and for this
graph you are supposed to generate a
minimum spanning tree such that it
contains 10 vertices 9 edges and minimum
construction cost in order to do that
you can take out your pen and paper to
draw the spanning tree structures based
on the step that we have discussed till
the time I am aware that this graph is
quite strangely structured however if
you can solve this problem you will
undoubtedly be able to solve other
difficult problems out there and of
course if you are confused about any
step then you can reiterate through the
session but here I am going to give you
guys a little moment to figure out your
answers
well now that you guys must be ready
with your solution so let's check if it
is true the highlighted part of this
graph is possible structure for spanning
tree with minimal cost
by removing all the edges the MST will
look something like this I hope you guys
have got the right answer on that note
let's dive further and discuss the
implementation strategy for cuscal's
algorithm
while implementing the crystals
algorithm primarily will generate a c
structure for keeping track of the
source and destination node along with
its weight after that we'll sort all
that edges of a graph in increasing
order of the age weights
moving ahead we'll create three distinct
sets to maintain nodes of a graph their
hierarchy entry and corresponding ranks
for every node for each insertion of an
age in MST we'll update the rank and
parent of each node
if the two nodes have the same parent
node then we will not insert the edge
joining them as it will generate the
cycle in tree structure let's understand
all these steps with the help of an
example
this is the graph structure for which
we'll try to generate a minimum spanning
tree using C programming language
as discussed earlier primarily we'll
create a sorted list of all ages in
increasing order of the age weights the
list will contain the source node
destination node and corresponding age
weight for that particular age along
with that we are going to maintain
disjoint sets to carry out Union
operation those disjoint sets are parent
and rank and they will include rank
value and parent value for every node in
our graph initially all the nodes are in
their own different sets hence we'll set
their parent values to -1 also the ranks
for these nodes will be initialized to 0
at the beginning because we haven't
included them in our minimum spanning
tree having said that let's include the
nodes of our graph in our MSD in
upcoming slides we'll Traverse through
our list of Ages to include them in our
minimum spanning tree now the first is
that we are going to check is HDC the
which have minimum age cost that is 1.
in order to insert this Edge in our MSD
we'll need to find the absolute parent
of node D and C as well so let's check
out the parent set to determine the
absolute parent value of node DNC the
parent value of node D is -1 and parent
value of node C is also -1
both of them are having same ranks which
means either we can make no D point to c
or node C point to D here I'll assume
that node D points to node C so if node
D is pointing to node C then the parent
of node D will become node C
and as C becomes the parent of node D
the rank of node c will change
remember whenever two disjoint tree
structures are joined together then the
rank of 1 being 0.82 will increase by 1.
hence the rank of node c will become 1
now
once the disjoint sets are updated the
union operation will generate the link
between node d and c
now we'll process the second Edge in our
list that is H CB having weight 2.
primarily we'll check the parent values
of both these nodes node B and node C
have parent values minus 1 and -1
which indicates that these nodes are
absolute parent of their own sets since
they have different absolute parents we
can join both of them
however the rank of node C is higher
than node B thus the connection should
point from node B to node C
as node B is pointing towards node C
thus node c will become the parent of
node b as well
hence we'll update the corresponding
absolute parent values for them
next up is HBA with the weight value too
now the parent value for node a is -1
and the parent value for node B is C so
both of them have distinct parent value
which implies that we can establish a
connection between them for that purpose
we'll have to update the rank field and
as the parent of node B is node C the
rank of C will definitely increase by 1.
once the fields are updated the edge
will get included in our MSD
on that note we have generated our
minimum spanning tree but you must be
thinking about how our algorithm will
discard the other edges so to understand
that we'll Traverse further in our list
of Ages the next age is age AC and the
parent of node a is node C itself hence
we'll discard this node as well now the
final Edge in our list is h a d and
again both these nodes have the same
parent node thus we'll discard this node
as well
now you must be thinking about how we
can limit iteration of the whole list if
we formulate MST using the few topmost
ages only well the answer to that is
pretty straightforward we can avoid the
complete traversal of the list by using
looping condition from a is equal to 0
to e is equal to mod of V minus 1. when
we use this condition the looping will
stop when V minus ages get included in
our MSD
now the next up is the time complexity
analysis of algorithm the time
complexity of Crystal's algorithm will
be bigger of e log e plus e log V the E
log e for sorting all ages and E log V
for finding the age from maintain three
sets the average time complexity graph
for this implementation will be
something like this it will be a
parabolic nature I hope that you all
have understood the strategy for
implementing preschools algorithm so
without wasting any time further let's
visit the code Editor to develop a
program in C programming language for
Crystal's algorithm if getting your
learning started is half the battle what
if you could do that for free visit
skillup by simply learn click on the
link in the description to know more
now to begin with coding implementation
the first thing that will do is we'll
create a storing system to represent a
weighted age for that purpose we'll use
structure in the C programming language
so let's get started with that
truck
age
and and set this structure will create
int source
destination
and wait
now what we'll do is we'll utilize this
structure to store the edges of the
graph moving ahead we'll also initialize
the structure for storing the complete
graph so let's create one more structure
and will name the structure as graph
and inside this graph structure we'll
create
node
will also create variable e to represent
number of edges in our graph
we will also call the reference of
structure H to this graph by doing this
we'll be able to include all the edges
into our graph structure as well so
let's create that reference
chart
age
star
h
now we have successfully created the
structure for graph
now moving forward what we'll do is
we'll assign dynamic memory to the
reference of graph structure for that
what we'll do is we'll write code struct
graph
generate
graph
and inside this function will pass end
node
and
the number of edges that is e variable
now we'll write body for this function
and inside body first thing what we'll
do is we'll create
the space
that is dynamic memory space for this
graph structure
equal to struct
graph
star
malloc
sides off
struct
Ure next
graph
dot node
will be equal to node
and
graph
DOT number of
edges
will be equal to
e itself
next what we'll do is
will unlock it a memory to each Edge
okay I added underscore here
for that what we'll do is we'll use
struct
H star
malloc
size of
truth
h
and finally we'll return
the graph
now we have successfully allocated
memory space to our graph and individual
edges as well so moving forward what
we'll do is we'll initialize one more
structure to store the parent array and
rank array basically these are the
disjoint sets whose usage will allow us
to generate a spanning tree using Union
find algorithm so let's get started with
that we'll create another structure and
we'll name the structure as tree
underscore maintainance
underscore set
and insert this structure it will create
parent array
and
rank array
now we have created the tree maintenance
set structure so let's generate an Union
find algorithm for maintaining MSD
structure in order to do that let's
create a function name findis joint set
first
so this find this joint set function
will be of int data type
find
underscore
disjoint
set
and inside this will pass
trapped
tree underscore
containments
underscore set
and its object
subsets
and
a variable and I
insert this function we'll use if Case
to find root and make it as a parent of
argument I also if it is minus 1 then
we'll need to update it for that we'll
keep recurring through this a block by
calling the function find this joint set
and set a block so let's do that if
subsets
I
dot parent
is not equal to
I
then what we'll do is
we'll get inside this F log and will
execute
subsets
I
dot parent
is equal to
find
underscore
disjoint set
and will again pass same argument
subsets
comma
subsets
I
dot parent
and finally
will get out of this F block
and
will return
subsets
I
dot parent
foreign
operation let's name this function as
void
Union
underscore
this joint
set
and insert this will pass
dropped
tree underscore
maintenance
underscore set
and its object
subsets
and we'll pass
argument X and argument
y
now inside this function we'll create
two variables named X root and Y root
and the extrude variable will store the
return data from find disjoint set when
the X has been passed to the function
and similarly the Y root will store the
return value for fine disjoint set given
y as an argument so
let's write command for that
and
X root
will be equal to find
this joint set
and objects will be subsets
comma X
similarly in y root
will be equal to find
this joint set
and object subsets
and
variable y
now in order to build connection between
these nodes as discussed previously the
node with lowest rank value should
always be pointing to the node with
highest rank value and vice versa so
we'll have to use this if Block in order
to put this condition in the connection
building block of our program so we'll
write condition for that here now if
subsets
exude
dot rank
it's greater less than
subsets
y root
dot rank
then what we'll do is
we'll set
subsets
X root
dot parent
to Y root
that means
well okay
so what we are doing here is we are
checking the rank value of x root if the
rank value of x root is smaller than y
root then what we'll do is we'll simply
set the wire root as parent of X root I
hope you guys are clear with this now
moving forward we'll write LC part of
this condition
else if
subset
X root
dot rank
sorry
I'll have to add s here
and
F subsets X root dot rank is greater
than subsets
y root
Dot
rank
then what we'll do is
we will
set subsets
y root
dot parent
it's equal to X root
or the whites
a both above mentioned condition fail
then what we'll do is we'll add one more
condition we'll set subset
y root
dot parent
to
X root
and then we
set subset
X root
Dot
rank
to incrementation
there is one mistake over here
subsets okay
so now we have implemented the union
find algorithm for this critical
implementation next we'll create a
function to sort the list of edges in
our graph according to increasing order
of their age weights so let's create new
function for that we'll name this
function as and my
comparator
and inside it will pass
const
ant star
a
and const
void
star
p
and we'll create function body but
before we get started with coding
implementation of this my comparator
function I want to talk about arguments
of this function
so basically A and B are constant
quantifiers the significance of this
quantifier is to tell the user that you
cannot modify this pointer and the
location it is pointing to throughout
the program
so let's
get started with the coding part of this
my comparator function what we'll do is
will create
extract
age
star
A1
is equal to
struct
age
star
a
semicolon and similarly
construct
h
star
V1
will be equal to
draft
H star
B
next we'll return the output
a 1
foreign
it's greater than
B1
Dot weight
so basically what this statement will do
is if the weight value of A1 is greater
than B1 then it will return A1 as output
and if the weight value of B1 is greater
than a 1 then it will return B1
I hope you guys are clear with this my
comparator function so moving forward
will finally create a crystal MSD
function
return type of this function will be
void
and will name this as criscal MST
and inside it will pass argument
struct graph
the
graph
and will create function body
now the first thing that we'll do here
is we'll assess the value of number of
nodes in a graph and after that we'll
generate a new reference of structure
age for storing our MSD so the first
thing will
keep
the node
to
graph
Dot
node
and
draft
h
result
node
along with it we'll also initialize
variable e and variable I equal to 0 so
end e
is equal to 0
and end
I
is equal to 0. we'll need to break the
indentation here
and here as well
and semicolon so basically these
variables will store index values for
result and index variable for the sorted
list simultaneously now moving forward
we'll sort all the edges of a graph if
we are not allowed to change the given
graph then we can create a copy of the
given graph the function name Q sort
allows us to do that so let's create
that Q sort function here
Q sort
graph
h
comma
graph
a
comma size of
graph
h
0
so this Q sort is nothing but C standard
Library function that implements a
polymorphic sorting algorithm for arrays
of arbitrary objects according to a user
provided comparison function and that
comparison function is nothing but this
my comparison function
and
I guess you guys must be clear with this
Q short term
so let's add
comma here and will give call
to a
my comparator function
now moving forward we'll break the
indentation
and
will call
the object of tree maintenance set
underscore
maintenance
[Music]
set
subsets
equal to
3 underscore
maintenance
underscore
set
star
malloc
node
star
size off
dropped
tree underscore
maintenance
underscore set
foreign here
so next we'll create subsets equal to
number of nodes and after that we'll
make sure that all the elements have the
rank value equal to zero and to do that
we'll initialize new for Loop
so let's
create for Loop here
well taken it from V is equal to zero
to V
is less than node
and
we'll set this way to incrementation
after that we'll make body for this for
Loop and inside it will set
subsets V
dot parent
is equal to
V
and subsets
V
Dot rank
is equal to
zero
now moving further
will Traverse through all the edges in
the graph but we want to limit our
traversal to the number of vertices -1
and to achieve that we'll create while
loop here
file
e
it's less than node
Capital node
then
node minus 1
and and
I
it's
smaller than
graph
e
that
then
create struct
age
next underscore h
equal to
graph
Dot
h
I plus plus
and here
will create
X and Y nodes
so
let's do that int X
will be equal to
find underscore
disjoint set
and we'll pass subsets
comma
next h
dot source
and for y
will pass
find underscore District sets
subsets
comma
next underscore h
Dot destination
now if including the H between X and Y
does not create the cycle in our graph
only then we can include that edge in
our MSD for that what we can do is we'll
set if x
it's not equal to y
then
we'll set result
e
plus plus
equal to
next
underscore Edge
and we'll find unions
disjoint set
for subset
and will pass X and Y as well
with this we have successfully created
our Crystal semester function
now what we'll do is we'll also print
the structure of our minimum spanning
tree for that we'll need to create
pattern using printf function so let's
do that
the first statement that will print on
screen is edges
created
in MST
are ads below
and we'll add backslash n so that our
output gets to the next line
we'll add semicolon and
dot that
will add end
minimum
cost
variable
and will initialize it to zero
so
okay
so
what we'll do is
we'll create for Loop here and we'll
initialize it with iterator 11 beginning
from 0
till
I
I less than equal to E
and we'll
I create this I element
and what we'll do is we'll create
pattern for printing the edges the
pattern will go like modulus d
Dash Dash
modulus d
equal to equal to
modulus d
slash NS
and
the parameters that will get printed
will be result
I
dot source
comma
result
I
Dot
destination
and
result
I
Dot
weight
okay
so we haven't done it comma here
now this error will get resolved
now after this what we'll do is
will increment this minimum cost
variable by adding the values of edges
to it so we'll take this minimum cost
variable
and
will add
result
I
dot weight to it
now we'll get outside this for Loop
and
will print f one more statement
cost
for creating
MST as
modulus d
and
will print minimum cost
okay we have now successfully
implemented triscal's algorithm function
and we have created code for printing it
on Console as well so now moving forward
will work on our driver method
and for that let's
get into its function body
here first we'll Define the number of
nodes that we are going to use for our
graph
those number of nodes are 4
the graph structure that we are going to
pass to this crystals algorithm program
is the same that we have discussed
implementation strategy for it had four
edges and it also had six
HS as well
so
we'll add six edges here
now what we'll do is we'll set struct
graph
star
graph
equal to
generate
generate
crop
and will pass node
comma
e
and we'll add semicolon
now next we'll create graph structure by
implementing the edges
so the for
first stage
will call graph
Dot
h
0
dot source
will be equal to zero that means
the first age will begin from zero
and it will
end at
destination
load and that will be
one
and the weight
for this
age will be
equal to
now we'll copy this pattern
and
will paste it below
okay
and now
the h
will be 1
and for this
H1 The Source will be 0 and destination
will be 2 and the weight value will be
4.
now
let's copy this again
and paste it
and we'll set
age number to two
will change source
and destination now Source will remain
same and destination will be changed
will make it 3
and the weight value will also remain
the same that means
Edge between 0 to 2 and H between 0 to 3
have same age weight
now
for next Ctrl V
we'll remove this indentation and now
we will change the node number Edge
number
here
The Source will be 1
and destination will be
3
and the age weight value
will be 3.
after this we'll add new
h
number will be 4 now
The Source will be
two
and destination will be
3
and age weight would be one
and the last age
will be
H5
and
The Source will be
1 here
and destination will be 2
the age weight will be 2.
now after this what we'll do is we'll
give call to our physical MST function
in order to generate minimum spanning
tree and will pass this graph structure
to it
and we'll add return 0 statement
with this we have successfully completed
a programming implementation for
cuscal's algorithm so let's run it and
check if a code is working fine or not
okay so we are getting three problems
here
the first one
is expected token oh
and mode will be equal to
and this node should also be Capital
here
okay
so what next error is there
yeah
so now a code is bug free
oh
but some exception is happening here
we'll jump this exception we'll try to
jump it
okay but we are not having any errors
into our system so
I think that's the compatibility issue
with our vs code so let's copy this code
and paste it into
the virtual coding environment and we'll
check it if this code is working fine or
not
so we'll copy the code
and we'll go back to the Google Chrome
will go to the online compiler tool
and here
will paste our code
and we'll run it
okay so here we are getting our output
so there will be only three edges that
will get formed in our minimum spanning
tree and the cost for all those HS will
be 5. let's try to understand what is a
bubble sort algorithm the bubble sort
algorithm is one of the fundamental and
simplest forms of algorithm used to sort
a collection of elements the collection
of elements can be either a set of
numbers or characters the control
iterates through a sequence of numeric
or character type elements in the bubble
sort algorithm and rearranges them into
ascending or descending order
the bubble sort algorithm rearranges one
element at a time the bubble sort
algorithm is also known as the sinking
algorithm
here we have some random distributed
Elements which are 30 10 20 50 and 40
and after performing the bubble sort
algorithm all the elements are sorted as
10 20 40 and 50. so how is it done
we will see in the next segment where we
will understand the working
terminologies of bubble sort algorithm
the bubble sort algorithm will not get
implemented on the entire array in one
group instead it Compares two adjacent
pairs of elements in an array if the
elements are not in the correct order
then they are swapped so the largest of
the two moves towards the right and this
process continues until the most
significant element or bubble is moved
towards the highest position after the
first process is finished the search for
the next most significant object starts
and the swapping continues until the
whole array is in correct order this
process is employed when you want to
arrange the elements in ascending order
to understand the logic in a better way
let's go through an example
the example on my screen consists of
five elements according to the bubble
sort algorithm logic we need four
iterations to sort all the elements in
the ascending order or in descending
order the elements in the array are as
follows they are 3 8 4 2 and 12. so in
this array the index begins with zero
and ends with 4. and each time the
bubble sort algorithm goes through the
data element list and it is known as a
pass let us analyze the total number of
comparisons required to sort the array
in the correct order according to the
formula
if n is the total number of elements in
an array then the total number of
comparisons needed to sort the entire
array can be calculated by a simple
formula shown on my screen that is n is
equals to n minus 1. so in this scenario
we need 5 minus 1 that is 4 comparisons
or passes to sort the entire array in
the first pass there are four steps
let us select the first two elements
that is 3 and 8. according to the
requirement we need to sort this array
in the ascending order hence when we
compare 3 and 8 clearly we get 3 as the
least number so we do not need to swap
them next is the step two comparing the
second and third Elements which are
eight and four here we need to swap
these two elements because 8 is always
greater than 4 and it requires placing
the elements in the ascending order now
moving ahead we have step 3 moving on to
the third and fourth Elements which are
8 and 2 and here again we need to swap 8
a width 2 because 8 is greater than 2.
and in the step 4 we have we have the
last Elements which are 8 and 12. there
is no need to swap because 8 is already
less than 12 so you can see it clearly
so now we enter into Pass 2 and in past
two we need three steps so the first
step in the second pass let us select
the first two elements which are three
and four
no swapping is necessary as they are
already in order next we have step two
in Step 2 we need to select the elements
2 and 4. as you can see 2 is always less
than 4 so there is no swapping required
next we have step three in step 3 we
need to compare the elements 4 and 8 and
here we may not need any switching
because 4 is already less than 8. now
here you can see that we are not
comparing 8 and 12 because the last
element is already sorted now we have
come to the last pass
and here there is only one step the step
is to compare the first two elements two
and three and then swap them as 3 is
greater than 2. now the array is finally
sorted and we do not need to do any more
comparisons after understanding the
working process of the bubble sort
algorithm we will see its pseudo code in
the pseudo code there is a function
named as bubble sort the bubble sort
function includes an array of
collections of sortable elements let us
consider n as the length of the array
after that we have to repeat comparisons
for the first element to the last
element of the array if the first
element is greater than its next
consecutive element then we must swap
both the elements and place them
correctly we do not need to switch after
closing this repeated statement and
getting out of the loop this bubble sort
function will end after understanding
the pseudocode of the bubble sort
algorithm let's learn about the
optimized bubble sort algorithm so we
can optimize the algorithm in a loop by
programming it to avoid the comparison
at n minus 1 position after every
iteration since the nth element is
already sorted in the previous iteration
more generally more than one element may
be placed in their final position on a
single pass all the elements after the
last swap are sorted in every pass and
do not need to be rechecked optimized
bubble sort algorithm allows skipping
over many elements this results in a
worst case that is 50 Improvement in
comparison count and adds little
complexity because of the new code
substance the swapped variable
next we will learn variations of the
bubble sort algorithm so there are two
variations of the bubble sort algorithm
they are odd even sort and cocktail
shaker so odd even sort is a parallel
version of bubble sort for the message
passing system whereas cocktail shaker
is a sort of bi-directional bubble sort
that first goes from beginning to the
end and ends to the beginning after
knowing the variation of the bubble sort
algorithm now we will see the complexity
of bubble sort algorithm
so the best case of the bubble subtle
algorithm is Big O of n where n is the
number of elements being sorted and
worst and average cases of the bubble
set algorithm are Big O of n into n and
lastly the space complexity of the
bubble Circle algorithm is Big of 1.
here n is the number of data elements
being sorted let us understand when this
complexity occurs the best case of
bubble sort algorithm is O of n which
occurs at all the data elements in an
array are already sorted here we have an
example with some data elements in an
array which are already sorted that is
10 20 30 40 and 50. next talking about
the average and worst case the worst
case an average case of the bubble
Circle algorithm is O of n to the power
2 that is N squared or n into n it
occurs when all the data elements in an
array are reversely sorted again we have
an example that consists of data
elements that are reversely sorted that
are 50 14 30 20 and 10 in the narrative
lastly we have space complexity the
space complexity of bubble sort
algorithm is O of 1 because only one
additional variable is required to
implement bubbles or algorithm whereas
temporary variable we came to the last
topic where we will understand four main
applications of bubblesh or algorithm
first application of bubble sort
algorithm states that this sorting
technique is used to sort the elements
in a specific order the bubble sort
algorithm uses less storage and is the
second application of bubble sort
algorithm third the real life
application states that the bubble sort
algorithm is used to start the students
based on their height in the line
lastly bubble sort is used to create a
stack pile up the elements based on
their height after covering all the
bubble sort algorithm topics we will now
see a practical demonstration of bubble
sort algorithm now on my screen we have
an example for purple sort algorithm so
let us get started with the code in this
code at the first position we have some
header files that is standard input
output standard Library Etc after that
we will Define the main function in the
main function we will declare an array
with maximum size of 50. so here you can
see that we have the first array
variable that size is 50. size will be
defined with declaration only because we
cannot change the array size in the
runtime after that we will declare 4
variables that is a b num and temp num
variable will store the number of
elements of an array after that we will
ask the user how many elements are
required wired for the array using
printf function
so here is the printer function where we
will be asking the user to enter the
number of elements in an array and the
user will enter the elements and this
will be done using scanf function then
finally we will print all the elements
that the user wants to store in an array
using another printf function we will
have three Loops firstly there will be a
loop from the first element to the last
element of the array so this is the
first for Loop you need then second the
for Loop will use the variable a for the
rotation purpose as we know rotation
equal to number of elements minus 1 so
it will make a loop from index 0 to
number minus 1.
the last Loop is used for how many
passes will be required for the
implementation and we already pass
equally to the number of elements minus
number of rotations minus 1 so there is
the loop from index 0 to number minus a
minus 1 then there will be the if
condition stating that if the first
element of an array at index B is
greater than the element at the index B
plus 1 then we will make swap then we
will come out of the loop and we will
print all the array elements after
performing the bubble sort algorithm now
let's quickly execute this program and
see the output
so you can see the program got
successfully executed now let us enter
the number of elements let me choose
five now let us enter the elements in a
random order
so this was the array input 3 2 4 1 and
5 and here after executing the bubble
sort algorithm we have the sorted array
that is one two three four and five
let's get started with an introduction
to quick sort a quick sort is a highly
efficient sorting algorithm and it is
based on partitioning an array into
smaller sub arrays and then we will sort
these two resulting sub arrays in the
same manner
this algorithm is quite efficient for
large size data sets as its average and
worst case complexities are bigger of n
Square
now let's discuss algorithm of quick
sort
let's say we have an array first we have
to select a pivot we can select either
the first element or the last or medium
or any random element as pivots this
pivot will dissect the array into two
sub arrays then we will shift all
smaller elements then the pivot element
to the left
then we will again apply the same
operation for the left sub array and
take pivot like we did for the main
array
we'll perform the same for the right sub
array as well
we have now introduced the quick sort
and its algorithm now let's implement
this algorithm in the code editor
we will start by creating a function
swap
so void swap
end
star X
comma and
star y
and
equals to
star X
star X is equals to Star y
r y is equals to temp
now we will write a function which will
partition this array this function will
take the last element as pivot
and the pivot element at its correct
position in sorted array and places all
smaller elements to the left of the
pivot and all greater elements to the
right of the pivot
so int
partition
int ARR
comma
and
low
comma and I
so end
favorite
equals to
ARR High
now end
I is equals to
low minus 1.
so for
end
J is equals to low
J less than equals to high minus 1.
a plus plus
now if the rent element is smaller than
the pivot so if
ARR at J
is less than pivot
then we will increment the I
then we will swap
Ampersand array
I
comma
Ampersand array
at J
then we will swap
am percent
array
at I plus 1
comma
ampersand
array
at High
and then we will return
I Plus 1.
now we will write the mean function that
implements quick sort
so avoid
quick sort
and ARR bracket
comma and low
comma and I
so if
oh
is less than High
end
p i is equals to Partition
ARR comma low comma
hi
now we will separately sort elements
before partition and after partition so
quick sort
ARR comma
low
comma
Pi minus 1.
and quick sort
era
comma
p i plus 1
comma I
now we will write a function to print
this array so void
and array
and ARR
comma
and
size
and I
so for Loop
I is equals to zero
I less than size
a plus plus
C out
array at I
layout
handle
now we will write the main block so end
array
n comma 7
comma 8
now we will find the size so int n
is equals to
size of
array
is divided by
size of
array
element at zero
now we will call quick sort
for array
comma 0 comma
n minus 1.
now we will print this so C out
or third
array
up print
array
error command
now let's execute this
as you can see we have successfully
sorted our array let's get started with
introduction to binary search tree
binary search tree is a set of nodes
organized in such a manner that they all
have the same binary search tree
characteristics
key and a value is assigned to each node
the requested key is compared to the
Keys in binary search tree
so during search if the key is found
then the corresponding value will be
retrieved
next up
properties of binary search tree
first up the left subtree of a node
contains only nodes with keys lesser
than the
no parent node
next up the right sub tray of a node
contains only nodes that are greater
than the parent node
the left and the right subtree each must
also be a binary search tree
next let's discuss what are the
operations we can perform on a binary
search tree
first up insertion
last deletion
let's discuss them in detail
first up insertion
we can insert a node in a such a way so
that we obey binary search tree rules
that is the new node should be either
less than the parent node if it's a it's
on the left subtree or if it's on the
right sub tree it should be greater than
the parent node let's execute this in
the code editor
we will start by creating a class for
the binary search tree
so class
PST
length data
and BST pointers
left
comma
right
next we will Define some functions
publicly
public
first default Constructor
and a parameterized Constructor
a function to insert the value
and a function to Traverse the node
now let's write default Constructors
definition
so BST
now let's write the parameters
constructor's definition
BST
and
value
data
is equals to value
and left is equals to null
and
write
equals to null
now let's write the definition for the
insert function
so BST
start PST
star
root
comma
and value
now we will check if the tree is empty
or not so if
root
then we will insert the first node
we will return
you
EST
value
otherwise we will insert the data so if
the value
is greater than
root data
and
then we have to insert it
in the right subtree
so
root
right
is equals to
insert
root
right
comma value
else
helps with the value should be inserted
in the left side
so root
left
is equals to insert
root
left
comma value
and then we will return
now let's write the Traverse function
so void
PST
there was
EST
a root
if
root
and we will return
otherwise we will First Traverse
website
then we will print the root data
and then we will Traverse
the right side
root
right
now let's write the main block
so we will start with an empty tree so
BST
B
comma
star root
is equals to null
root
is equals to
B dot insert
root comma
50.
e dot insert
equals to
root comma 10.
B dot insert
gonna be root comma
30
e dot insert
Wanna Be fruit
comma 50.
sorry we already use 50 so we will use
60
a DOT insert
root
comma let's use 20.
let's try to Traverse this
so B Dot
hours
root
let's execute this
as you can see we have successfully
created and traversed our first binary
search tree
let's get back to slides
at last deletion
we will delete a node following the
binary search tree rules that is the
value of the left subtree should be less
than the parent node and the value of
the right subtree should be greater than
the parent node
let's try this in a coordinator
let's start by creating a node
this time we will use structure so
struct
Ure
hint
key
product
node
start left
comma
are right
now we will create a utility function to
create a new binary search tree node
substruct
node
star
new node
and
item
code
star
lamp
is equals to
product
code
star
malloc
size of
product
no
next
attempt
will be a sign the key is equals to item
left
equals to null
and
damn
right
is equals to
North
now let's write a function to Traverse
the tree
Traverse
node
star
root
so if
root
is equals to null
Traverse
root left
Co
root
e
covers
root
right
now let's write a utility function to
insert the new node with the given key
in the binary search tree
substruct
code
insert
node
star
node
comma
and key
so if
node
is equals to null
then we will return
new node
key
otherwise
we will recover down the tree so if
he
is less than
unload key
then we will insert in the left subtree
so node
left
is equals to insert
code
left
comma
key
else
node right
could be inserting
e
now let's return the node
foreign
Ty binary search tree so we have to
return the node with the minimum key
value found in that tree
so we will start
product
mode
star
man
value node
star mode
star
current
is equals to node
so we will look down to find the left
most leaf
so
while
current
and
parents left
is not equals to null
so current
should be equals to
current
return
current
node star
Elite
node
star
root comma and key
f
root
equals to null
return
root
now if the key to be related is smaller
than the roots key then it lies in the
left subtree so we will check if
e
less than
root key
then root
left
it will be equals to
delete node
root left key
comma key
now if the key is deleted
is greater than the roots key then it
lies in the right sub trees so else
he is greater than root
root
right
is equals to
delete
node
root
right
comma key
else
if
Roots dot left
equals to null
and
root
dot right
is equals to another
then return
else
if
root
left
equals to null
then struct
node
star
is equals to
root
right
and free
root
return
temp
late
roots
right
is equal to null
then struct
Ure
jump
is equals to root
3
root
return
temp
now node with the two children get the
in order successor smallest in the right
subtree
so struct
note star
temp
is equals to
Min value
node
root
right
right now we will copy the inorder
successors content to this node so root
is equals to temp
now we will delete the in order
successor so root
right
equals to
delete
node
right
comma temp
e
now we will return
root
now let's write the main block
we will start with an empty tree
product
knob star
root
is equals to
null
now root is equals to
insert
root comma
2.
root
is equals to insert
comma five
root is equals to insert
oh
comma
three
root is equals to insert
root
comma four
root
is equals to
insert
root comma
seven
and root
equals to insert
root comma
six
let's try to Traverse this so C out
traversal
of the given
hours
root
now first we will delete a value to see
out
foreign
to
a root is equals to
delete
node
root comma
to
C out
traversal
after
deleting
Traverse
root
let's execute this
as you can see we have successfully
deleted two and Traverse the tree again
let's get started with an introduction
to insertion sort insertion sort is
basically a sorting algorithm in which
each item in the final sorted array is
sorted one at a time and it is
significantly less sufficient than more
sophisticated algorithms like quick sort
heapsort or merge sort on larger data
sets
now let's discuss the algorithm of
insertion sort
let's say we have an array
we will start with traversing the array
from index 1 to n minus 1. while
traversing we will compare elements at
the current index to its predecessor if
the data at the current index is smaller
than its predecessor then we will
compare it with the element before that
after that we will shift bigger elements
to an index up to make space for swapped
elements
then we will shift the bigger elements
to an index up to make space for the
swapped element and then we will iterate
the same steps again to sort the
complete array
we have now introduced the incision sort
and its algorithm now let's implement
this algorithm in the code editor
we will start with creating a function
to sort an array using session sort so
void
insertion sort
we will give it argument as end array
ARR
comma int size
we will declare variables and I comma
key comma J
now
we will create a loop for Loop
from I is equals to
1.
2 I less than size
I plus plus
here we are traversing this array from
index 1 to the size n minus 1.
so t
is equals to ARR at I
and J is equals to I minus 1.
now we will move the elements of ARR 0
to I minus 1 that are greater than the
key to one position ahead of the current
position
so while
J
is greater than equals to
0
and
ARR at J is greater than key
then we will swap these so a i r
at J plus 1
is equals to ARR
f j
and J will be equals to J minus 1.
and then we will assign ARR J plus 1
is equals to G
now we will write a function to print
this array of size
void
print
array
we will give its argument as int array
and
size size
we will declare int I is equals to zero
or Loop
I is equals to 0
I
less than size
I plus plus
Co
ARR
ARR
bracket I
and C out
and
now we will write the main block
so end
ARR
is equals to
12 comma 11 comma 15 comma
9 comma six comma seven
and size is equals to we will find the
size using size of so size is equals to
size of
ARR
divided by size of
ARR at index 0.
now we will print this array without
sorting so see out
unsorted array
and we will print
array
ARR comma size
now we will call insertion sort
ARR comma size
C out
we will print this
array
sorted
now we will again call Print
array
argument as ARR comma size
now let's print this
as you can see our function is working
flawlessly it has sorted this array now
let us try to understand what exactly is
searching
searching in data structure refers to
the process of finding the desired
element in the set of items the selected
item is called the target element any
data structure such as an array linked
list tree or graph can be used for
searching a set of elements
in data structures searching can be
categorized into two types first type is
the sequential search in which we check
the elements in a data list or an array
one by one
in data structures searching can be
categorized into two ways the first type
is a sequential search in which we check
the elements in a data list or an array
one by one
an example for sequential search is
linear search now let us learn about the
next type of searching approach the next
type of searching approach is the
interval search approach interval search
divides the search in half by repeatedly
targeting the center of the data set the
binary search algorithm can be an
example for Interval search we will go
over the binary search algorithm in
detail in our upcoming video
after understanding the logic of search
and the types of search we will get into
understanding what is linear search
algorithm the linear search method is a
simple search technique in this type of
searching approach we perform a
sequential search across all objects one
after the other every element is
examined and if there is a match found
then the specific element is returned
otherwise the search will continue until
the data Gathering is complete let us go
through an example for Better Learning
Experience on my screen we have the
following elements 50 10 20 30 70 40 90
60 as randomly distributed elements let
us imagine that our Target element is
70.
we found that our Target element was 70
using linear search strategy so how does
it work in the next segment we will look
into the working terms of linear search
algorithm the simplest method of
searching the data collection is the
linear search starting from the
beginning of the data set each element
is examined until no match is found the
linear search is completed after the
item has located
in the first stage We compare the first
element that is 50 to the search element
that is 70. we will go on to the next
element because 50 and 70 are not
matched
we will compare the second element which
is 10 to the search element that is 70
in the next step
and once more there is no match found
then we have the element 30 as the next
comparison and 70 and 30 are not matched
we have the next element that is 20 in
the fourth phase and there is no match
when we compare 20 with 70. moving on to
the following stage we have the data
element 70 and after comparing 70 with
the search element there is a match
we will now have the searching and
display index as for and this index
contains the searched element
we now comprehend the pseudocode of the
linear search algorithm after learning
the working terminology of linear search
algorithm
first we have a function called linear
search which has two variables in its
parameters the arrays name which is an
array and the search variable which is
the value then using a follow we must
search for our Target variable by
analyzing all the data elements in the
data set with the condition that is the
search item is identical to any such
value we must return its index value
now we must stop searching once the
searched value has been discovered then
we will close our if and for loop as
well as the linear search function
we will now look into the complexity of
linear search algorithm after
comprehending the pseudo code
the complexity of linear search
algorithm is divided into three
categories the best case which is the
Big O of 1 the average case which is the
Big O of capital n and the worst case
scenario which is same as the average
case which is the Big O of n
here n is the number of data items to be
sorted let us look into how all these
complexities of linear search algorithm
play out in detail
first we have the best case which is Big
O of n as a result the best case
scenario happens when the search element
is found in the data sets first block
as a result the search takes a constant
amount of time
here is an example of an array with 50
10 40 20 30 as the elements
now our search element is 50 which is
located in the first location of the
array then there's the typical case of
linear search algorithm which has Big O
often and occurs when the search element
is in the middle of the data set or any
point of the data set with the array
containing the same search Element 50 we
can easily see that The Element 50 is
present in the center of the array at
the location number 2. finally we have
the worst case which is weight o of n
which is same as that of the average
case of the linear such algorithm and
happens when the search element is in
the last block of the data set as a
result of the number of searches
required as proportional to the number
of elements as demonstrated in this
example the search Element 50 is found
in the last block of the array index
which is 4.
in the next segment we will look into
some real world instances of linear
social algorithms according to the first
application of the linear search
algorithm linear search is particularly
efficient when it comes to discovering a
particular string next we will look into
the second application of linear search
algorithm
when a data set has only few elements
linear search is the simplest to
implement the final real world
application of the linear search
algorithm is with the help of telephone
directory you may find out the name of a
person with the phone number one two
three
this can be implemented easily using
linear search algorithm now let us have
a look at the linear search algorithm
working in Practical demonstration
so on my screen we have an example for
linear search algorithm we have included
three libraries standard input output
standard library and console input
output Library
then we have entered the main function
where we have declared an array with
maximum size of 50 elements a counter
variable I a variable named Target where
we would store our searched element and
finally num variable where the number of
elements in the array is recorded then
we have a printf function to ask the
user how many items are there in the
array and then we use a scanf function
to allow input from the keyboard so we
have added percentage D format specifier
to this kind of function which is used
for numeric values and num variable then
using a follow we will try to print all
the items in the array starting with 0
and ending with num variable which is
the last element then we will enter our
search element which we want to find
among all the elements of the array and
as previously said we'll store the found
element in the Target variable following
that we will use the for Loop to examine
all the elements in the array then we
use the if statement to check for the
element is identical to our searched
element or not
if the element is found we exit the
follow and we will break the keyword
and if the target values location is
less than the number of elements in the
array then we will return the location
otherwise if the value location is
greater than the number of elements in
the array then the search will be
unsuccessful and we won't be able to
find the search element
now we will compile this code and see
the output
so there you go the code got
successfully compiled now it is asking
for the number of elements in the array
let me give us five elements now let us
enter the elements into the array let us
enter some random elements
now we have entered the five elements
let me provide the searched element as
2.
now we have found the target element to
be found in the location 2. that is 0 1
and 2 yeah 2 is located in the second
index location first we'll build a
breadth first search algorithm which
Begins by traversing the root node and
then moves on to all the other nearby
nodes the breadth first search approach
repeats the procedure for all the nodes
until the desired node is found
the queue data structure is the data
structure that is used for breadth first
search algorithm
for a better understanding we look at an
example of breadth first search
algorithm the blue color indicates that
the node has been already explored while
the pink color indicates that the node
has not been explored yet or visited yet
next we'll have our output
we will use a q data structure to keep
track of all the nodes visited and all
the nodes that are unvisited
so to begin let's look at the algorithm
as a result we'll have node a which is
added to the output and marked as
visited we must verify all the unvisited
adjacent nodes of a that is node B and
node C and add B and C nodes to the
output and NQ to the queue according to
the breadth first search algorithm
then we'll look at any node between V
and C we'll start with node B node D is
unvisited adjacent to node B so we'll
add node D to the output and queue and
since node B is now being visited we'll
decode it
when it goes to node D the next
unvisited node is node e at node e to
the output and NQ to the DQ once node D
has completed its traversal DQ from the
queue
now in the case of node e the adjacent
node is node C which is already visited
first we will dequeue node C from the
queue now that the pointer is pointing
to node C and node f is the next
unvisited node after the node C we will
set node F to output and queue here the
pointer leads to node F which has no
unvisited adjacent nodes so we will dqf
from the queue and queue is empty so
we'll come to the hold here here's what
we got that is a b c d e and f after
understanding all the theoretical
aspects of BFS algorithm let's look at
the code of BFS algorithm and C
programming language
now we are on the Practical mode on my
screen you can see an example for BFS
algorithm we have declared a two
dimensional array with maximum row and
column size of 10 and 2 arrays the first
one is a square of a maximum size of 10
and second one which is a visited that
stores the maximum size of 10 as well
some variables nij and finally we
declared front which is initialized with
zero and rare variables which is
initialized with minus 1. we perform a
loop from index 1 to the size of an
array visited in this function with the
condition that if two dimensional array
of column 1 and visited array of index
is not one we initialize variable I to
the front of the queue then one is set
as the front of the queue index of the
visited array and we use the breadth
first search function with the vertex as
the front of the queue until front is
less than or equal to rare then we enter
the main function where we Define the
variable X that stores the graph's
vertex and then we use the printf
function to enter the number of vertex
that will be stored in variable n then
we perform a loop from index 1 to Q size
and visited array in which we initialize
0 to the queue and index 1 to the
visited array then after that we'll
enter the graph value in the form of
Matrix of two dimensional array by
performing a loop with two variables I
for the graph rho and J for the graph
column then we print the source node
which is saved in the variable X then we
print the source node which is saved in
the variable X and we call the breadth
first search function or method which
takes a Vertex X as parameter and V
print which nodes are reachable by
looping from index 1 to the size of the
visited array if index 1 of the array is
visited otherwise breadth first search
is not possible so this was the
explanation of the program now let's try
to execute and see the output
there you go the program got
successfully compiled and now it's
asking for the input now it is asking
for the number of vertices let's enter
the number of vertices as 3
now it is asking for us to enter the
input in the form of Matrix so the first
row will be 1
2
and 3. so these are the first rows the
next rows will be 2 3 and 4. so the last
row elements are 3 4 and 5. so we have
successfully given all the three rows of
elements now let us select the source
node so the source node would be 2. now
all the nodes that are reachable from
the source node 2 are 1 2 and 3. so
there you go that's how you implement
the breadth first search algorithm now
let's get started with the introduction
to depth first search
so what is a depth first search
so basically a depth first search is an
algorithm for traversing or searching
the tree or graph data structures the
algorithm starts at the root node
selecting some arbitrary node as the
root node in case of graph and X Plus as
far as possible along each branch before
backtracking
so DFS starts with the initial node of
the graph then goes deeper until it
finds the goal nodes over the leaf nodes
or the nodes that have no children that
is the end part here you can see 4 and 7
are the leaf nodes so the depth first
search algorithm runs till the end of
all the nodes that is a 10 all these are
the leaf nodes are the last goal nodes
in DFS the backtracking starts once all
the nodes are explored and the DFS
algorithm uses stack data structure for
its traversal now that was a brief
introduction to the DFS algorithm now
for a better understanding let's go
through a practical example
so here we have a graph data structure
with elements A B C D E and F so we will
be running the DFS algorithm and we will
be traversing through all the nodes of
this particular graph and the traversal
will be recorded using a stack data
structure and we have two different
colors which will be used to indicate
the elements color
so the black color is for the nodes
which are not visited yet and the blue
color will indicate the nodes which are
being traversed already
now this is the stack data structure
that we will be using for the traversal
and we have another part which declares
or which gives out the output of the
traversal of the nodes of this
particular graph
now we will begin with the first one
that is a now followed by that we will
move ahead to B then after B we will go
through d
then after T we have e next we have C
and last we have f
so that's how we Traverse through the
graph using the DFS algorithm
now for a little more understanding
let's go through a practical example
where we will be executing a program for
implementing the DFS algorithm
so this particular program on my screen
is an example for DFS algorithm so here
we have the structure node so followed
by that we have also the methods which
will create the edge
and which will also print the graph
elements and finally we have the main
class now don't worry about the code
this particular code segment or the
complete code document will be added in
the description box below and you can
have access to it and try to run it on
your local system and have a better
learning experience now without further
Ado let's try to run this program and
get the output and see how the DFS
algorithm gets implemented and traverses
through the graph
there you go the program got
successfully executed and we had the
graph elements that is 0 1 and 2 and 3
so it has visited all the elements that
is 2 3 1 and 0 according to the Stacked
data structure and we have found the
output over here what exactly is a
bucket sort algorithm
so the buckets are algorithm divides the
unsorted array into several groups known
as buckets so each bucket is sorted
using any suitable sorting algorithm or
recursively applying the same pocket
sort algorithm I know it it's a little
complicated to understand so let's go
through an example
so on my screen we have an example of an
array consisting of numerical elements
that is 12 6 37 29 11 35 21 and 22.
now we will create some buckets with
different ranges
so here we have different buckets
ranging from 0 to 7 8 to 15 16 to 23 24
to 31 and finally the last packet path
Range 32 to 39 so 6 will be stored in
the first packet followed by that 11 and
12 will be stored in the second bucket
followed by that we have 21 and 22
stored in the third bucket followed by
that we have 29 in the fourth bucket and
finally the last two elements which are
37 and 35 stored in the last bucket
in the next stage all the elements are
sorted according to an order that might
be ascending or descending in our case
we have the ascending order so the final
result will be 6 11 12 21 22 29 35 and
37.
so this is how the bucket sort algorithm
Works in real time now the next topic
that is working off a bucket sort
algorithm in a detailed way
so now we know the briefing of a bucket
sword algorithm now let's learn the
working of pocket sort algorithm in
depth
suppose we have an array consisting of
decimal values or floating values as the
input so the first element is 0.47 next
we have 0.39
0.23
0.55
0.29 0.41 0.59 and finally 0.31
then we will create an array of size 10
and store 0 in each block and each block
of an array is used as a bucket for
sorting the elements next we have step
2. insert the elements into buckets from
the array and all elements are inserted
as per the range of the bucket
buckets ranging from 0 to 1 to 2 2 to 3
up to n minus 1 to n here n is the
number of elements in an array so for
our example 0.23 will be multiplied by
10 which is the size of an array and
that gives us 2.3 approximately equal to
2 so finally we will insert 0.23 into
the bucket number 2.
inexact we will insert other elements
into other respective buckets
followed by that we have step 3.
elements of each bucket are sorted using
the stable sorting algorithms
and finally the step four in Step 4 all
the sorted elements of each bucket will
be gathered and represented in the form
of an array as pseudocode is an informal
programming description that does not
require any strict programming language
syntax similarly we will understand it
effortlessly so in the pseudo code first
we will create n empty packets
next we will insert all the array
elements into buckets by multiplying the
size of an array we have to keep doing
this for every array element as we
understood this in working of the bucket
Circle algorithm after that we have to
sort individual packets using insertion
sort and finally we will concatenate all
these sorted packets next we will learn
about the complexities of bucket sort
algorithm first we will see about time
complexity
talking about the time complexity we
usually have three cases to summarize
the time complexity so first we have the
best case
so that the best case is O of n plus K
next we have the average case that is O
of n into n and finally we have the
worst case that is O of n
here n is the total number of elements
to be sorted and K is the number of
buckets
so let us understand all the three cases
one by one so first we have the best
case
so the best case occurs when all the
elements are uniformly distributed in
the packet with an equal number of
elements in each bucket as insertion
sort is used to sort the bucket sort
algorithm then overall time complexity
is O of n plus k
o of n complexity is for making the
buckets and O of K complexity is for
sorting all the elements after
understanding the best case now we will
see how the worst case occurs in the
bucket sort algorithm
the worst case occurs when there are
elements of close range in the array
they are likely to be placed in the same
bucket it makes the complexity depend on
the Sorting algorithm used to sort the
elements of the packets complexity
becomes worse when all the elements are
in reverse order and if insertion sort
is used for sorting then time complexity
becomes o of n into n and lastly we will
learn how the average case occurs in a
bucket sort algorithm the average case
occurs when the elements are randomly
distributed in the array it occurs even
when the elements are distributed in
uniform way bucket sorts run at the
linear time the average case holds true
until the sum of bucket sort sizes is
linear and in the total number of
elements
next we will see about the space
complexity so the space complexity of
all the buckets or algorithms is O of n
plus k
lastly we have stability so talking
about stability so yes the buckets or
algorithm is stable
after understanding the complexity of
packet sort algorithm now we will
compare the bucket sort algorithm with
other algorithms
so first we will compare the counting
sort algorithm buckets out can be worked
as a generalization of counting sort
algorithm and if each bucket has size 1
then the buckets are degenerates to
Counting zero the variable size of
buckets or algorithm allows it to use o
of n memory instead of O of M memory
where m stands for the distinct value
that keeps counting sort o of n plus 1
worst case Behavior
next we will compare the buckets of
algorithm with quick sort
bucket sort with two buckets is a
practical version of the quick sort
where the pivot value always selects the
median value of the value range another
meaning of choosing the previous in
quick sort such as a randomly selected
period makes it more resistant to
clustering it in the input distribution
after that we have the merge sort
algorithm starts by Distributing the
list into N Sub list and sorting each
one then the sub list created by merge
sort have overlapping ranges and cannot
be recombined by a simple concatenation
bucket sort lastly we have one more
sorting algorithm that is Radix sort for
comparison top down Radix sort can be a
particular case of bucket sort where
both range of values and the number of
packets has contained the power of 2.
this approach can accelerate these cater
phase since we only need to examine each
element's prefix of bit representation
to determine a bucket at last we have
one more topic to learn that is the
applications of packets or algorithm
the bucket sword algorithm consists of
two main applications first by using
buckets or algorithm input is uniformly
distributed on the Range and second by
using packets or algorithm there are
floating Point values
now let us go through a practical
demonstration of bucket sort algorithm
now on my screen we have an example for
pocket sword algorithm so we will begin
with the header files followed by that
we will Define a function namely
buckets.alco
this particular function is to implement
a bucket sort algorithm in the functions
argument there will be an array namely
ARR and a variable num which will store
the number of elements in an array after
that we will Define two counter
variables which are I and J and declare
one more array namely array 1 with the
same size of an ARR array
so this particular second array will be
used for displaying all the elements in
the array 1 we will have a for Loop
which will run from index 0 to the
entire size of an array and for this
array we will use the variable I as the
counter variable
we will have another for Loop to print
all the repeated numbers with frequency
in an array we will run another for loop
from index 0 to the last element of both
the arrays and elements of array and
array 1 will assign to ARR array now we
will accept from both the loops and now
we will enter into the main function
where we will declare an array namely
array with the size of 100 and two
variables which are num and I next we
will ask the user to enter several
elements of an array using printf
function and now the user will enter
number of elements and we will scan that
using this kind of function now we will
ask the user to enter the elements of an
array using printf function and the
entered elements will be scanned using
the scanf function and next we will
print a before sorting and an array
after sorting using for Loops by calling
the packets of alcohol function and in
this function we will pass the name of
an array that is an array and the size
of an array that is num
now
let's try to execute this program and
see the output
so there you go the program got
successfully executed now let us try to
enter the number of elements that is 5.
now let us enter all the five elements
two three
one four and five
so the array before sorting was two
three one and four five then the array
got sort using packet sort algorithm and
the resultant array is one two three
four and five in ascending order let's
get started with an introduction to
Counting sort
counting sort is a sorting algorithm
that sorts the elements of an array by
counting the number of occurrence of
each unique element in the array the
count is stored in an auxiliary array
and the Sorting is done by mapping the
count as an index of that auxiliary
array
now let's discuss the counting sort
algorithm
let's say we have an array first we will
find the largest element in this array
to evaluate the range of the elements
then we will create a count array to
store the count of element from the
array
then we will update the count arrays
element with a cumulative count
at last we will output each element from
the array followed by decreasing its
count by one
we have now introduced the counting sort
and its algorithm now let's try to
implement this algorithm in the code
editor
let's start by creating account sort
function void
count sort
its argument as int ARR
comma int n
we will declare an array output
it's size 10
and an array count
again with the size 10.
and an integer variable Max
is equals to ARR at zero
now we will write a for Loop to find the
largest element of this array
so for
hint I is equals to 1.
I less than n
I plus plus
if
ARR at I
is greater than Max
then Max
will be equals to ARR at I
now we will initialize the count array
with all zeros so four
and I is equals to 0
to I less than equals to Max
plus I
count
at I
is equals to 0.
now we will store the count of each
element in this array so for Loop
and
I is equals to 0
I less than n
I plus plus
count
at ARR bracket I
is plus plus
now we will write a for Loop to store
the cumulative count of each array so
for
and I is equals to 1
where I is less than equals to Max
at I plus plus
count
at I
is equals to
plus equals to
count
I minus 1.
now we will find the index of each
element of the original array in count
array and place the elements in the
output array
so for
end
I is equals to n
minus 1
I greater than equals to 0
I minus minus
so output
account
at ARR I
minus
1.
is equals to
ARR at I
and then we will decrease count
ARR I
by one
now let's write a function to print this
array so avoid
print array
so end ARR bracket
comma and and
so for Loop
and I is equals to 0
I less than n
I plus plus
C out
error at I
doubt
handle
now let's write the main block
and
ARR
is equals to
we will write the element
now let's find out the size of this
array so end n is equals to
size of
array divided by
size of
that is first element
now we will call the count sort function
ARR comma and
now we will print this array so print
array
ARR comma n
now let's try and execute this
as you can see we have successfully
sorted this array using counting sort
let's get started with an introduction
to Radix sort
Redix sort is a non-comparative sorting
algorithm it avoids comparison by
creating and distributing elements into
buckets according to their Radix
and for elements with more than one
significant digit this bucketing process
is repeated for each digit while
preserving The Ordering of the prior
step until all digits have been
considered
now let's discuss Redix sort algorithm
let's say we have an array first we will
find the largest element in the array to
decide maximum number of significant
digits we will need to compare to sort
this array
we will go through each significant
place and sort the array one by one
first we will solve the array according
to the units please
then we will sort according to the tens
place
and then we will sort according to
hundreds place and so on till the array
is sorted
we have now introduced the Radix sort
and its algorithm now let's implement
this algorithm in the code editor we
will start with the utility function to
get maximum value in this array
so hint
get Max
with an argument as array ARR
comma size n
we will declare variable int MX is
equals to ARR at 0
and we will write a for Loop
where
and I is equals to 1.
2 I less than n
at I plus plus
if
ARR at I
is greater than m x
then
MX will be equals to ARR
at I
and then we will return
the value of MX
now we will write a function to do
counting sort of array ARR according to
the digits represented by exponent
so void
down sort
at int ARR
comma
and N comma
hint EXP
we will declare an integer array output
and I comma account array
of size 10
where all elements are 0.
now we will store the count of all the
elements of the array ARR
so for Loop
I is equals to zero
I less than n
to I plus plus
count
error
at I
divided by
EXP
modulus of
done
plus plus
now we will change count I so that count
I now contain actual position of this
digit in output
so for
I is equals to 1
I less than 10.
I plus plus
count
I
plus equals to
count
I minus 1.
now we will build the output array
so for Loop
at I is equals to n minus 1.
2 I greater than equals to 0
and I minus minus
output
account
ARR at I
divided by EXP
modulus
10.
minus 1.
is equals to
ARR at I
and now
count
ARR
I
divided by EXP
modular
10.
minus minus
now we will copy the output array of ARR
so that ARR now contains sorted numbers
according to the current digit
so for
I is equals to 0
I less than n
I plus plus
ARR
at I
is equals to
output
at all
now let's write the main function that
will sort the ARR using Radix sort
so void
Red X sort
and error
comma
and
m is equals to
at Max
ARR comma n
now we will do the counting sort for
every digit note that instead of passing
digit number exp is passed exp is
basically 10 raised to the power I where
I is current digit number so
or
important
EXP
is equals to 1.
and M divided by
EXP
is greater than zero
while EXP
multiplied equals to
10.
we will do count sort
on ARR of size n
with the XP
now let's write a function to print this
array so void
and array
and ARR
comma
and and
for
and I is equals to 0
I less than n
I plus plus
layout
array
that I
now let's write the main function
we will declare and ARR
bracket
with values
170 comma 45 comma 75
comma 90
comma
802 comma 24
comma 2 comma 66
now we will find out the size of this
array ARR
and is equals to size of
ARR divided by
size of
ARR first element
now we will call the Red X sort function
and we will print this array
now let's try and execute this
as you can see we have successfully
sorted this array using Redix sort
hey everyone I'm Baba khandelwal and I
welcome you all to Simply launch YouTube
channel
in this session we will discuss heapsort
we shall begin our session by
introducing what is a binary Heap
then we will discuss the implementation
of the heapsort
that we will check out various
applications of Heap soap finally we
will sum up what we have learned from
this session
but before we begin make sure you have
subscribed to our YouTube channel and
clicked on the Bell icon below so you
never miss an update from Simply learn
let's get started with what is a binary
Heap
it's a complete binary tree with all
levels completely filled except the last
level where all leaves are to the left
as far as possible
binary Heap can be either Min Heap or
Max Heat
in a Min binary Heap the elements at
root must be minimum among all elements
present in the binary Heap
Max binary Heap is like minhi where root
must be maximum among all elements
now let's discuss implementation of Heap
Sort
first we will start with creating a Max
heap of elements present
next up we will remove the elements at
the root and put it at the end of the
array and put the smallest element at
the root
after that we will reduce the height by
1.
finally we will happify the root element
again and repeat the process from step
2. now let's try to implement this
algorithm in the code editor we will
start by creating a function to helpify
a sub tree rooted with node I which is
an index in Array ARR and and is the
size of the Heap so void
ep5
and ARR
comma
and n
comma end
I
now we will initialize largest as root
so end
largest
is equals to I
now we will Define the left and the
right subtree so end
L is equals to
2 into I plus 1
and and R is equals to
multiply with I
plus 2
now if the left child is larger than
root then if
L is less than n
and
ARR at l
error at L is greater than ARR at
largest
so
the largest
will be equals to l
now if
right child is larger than the largest
so far
so if
R is less than n
and
AR at r
is greater than ARR at largest
so largest
is equals to R
now if largest is not true so if
largest
is not equals to I
so we will swap
ARR
at I
width with a ARR
at largest
and then we will recursively call ep5
for the affected subtree
krr comma and
common largest
foreign
bracket comma
and
now we will start by building Heap so
for
and
I is equals to
n by 2
minus 1
where I is greater than equals to zero
at I minus minus
we will call ep5
for ARR comma n comma I
now we will one by one extract an
element from the Heap so for
and I
is equals to n minus 1.
where I is greater than zero
at I minus minus
now we will move current root to end so
swap
error at zero
at I
and we will call Max cpify on the
reduced Heap so he P5
error
comma I
comma
zero
now we will write a function to print
this array so void
and array
and
ARR
comma and n
so forth
and I is equals to zero
I less than n
plus plus I
we will do c out
ARR
bracket I
is
and a c out
and L
now let's write the code for the main
block
so
and
ARR
is equals to
e comma
18 comma 12. comma
14 comma 5 comma 6.
comma 2
now we will write a statement to find
the size of this array so end
and it's equals to
size of
ARR
divided by
size of
the first element of the array arr0
now we will call Heap Sort function so
heat sort
or ARR comma n
now let's print this
array so C out
sorted
array is
print
array
at ARR comma n
now let's try and execute this program
as you can see our sorting function is
working flawlessly
let's get started with what exactly is
divide and conquer algorithm
a divide and conquer algorithm
iteratively divides a problem into two
or more sub problems of the same or
relative type until they are simple
enough to be solved directly the sub
problem Solutions are then integrated to
solve the original problem
there are three steps involved in the
divide and conquer principle that is
divide conquer and combine the first
step is to divide the significant
problem into smaller sub problems
the second phase is to conquer the
solutions to all divided sub problems
then the final step is to combine and
merge all of the solutions to create a
definite solution
we will understand this by an example
right here on my screen
suppose we have a large problem we can
use divide and conquer technique to
divide it into n number of sub problems
such as problem 1 problem 2 problem 3
problem 4 and so on until we reach the
problem n
then we conquer all the solutions to the
specified sub problems as solution 1 2 3
4 and so on and finally we merge all the
solutions to get one definitive solution
now that was divide and conquer
algorithm followed by that let us get
into much sort algorithm so merge sort
is one of the most efficient sorting
algorithms it is based on divide and
conquer strategy merge sort continuously
devise a list into numerous sublists
until each sub list contains only one
entry then merges all those sublists
into a sorted list
there are four elements on my screen we
have seven and three in the left half
and five and two in the right half after
dividing the four elements in half we
combined all the items in ascending
order that is 2 3 5 and 7.
in the next segment we are going to
understand how it happened and we are
going to learn the working procedure of
merge sort algorithm
there are two approaches to implement
the merge sort algorithm the first
method is top down approach and the
second method is bottoms up approach the
first method that is the top down
approach implies that it begins with the
large picture from then it's broken into
smaller chunks now the second method
that is the bottom up technique which
starts with a specific number of jobs
and works its way up to the general
let's have a look at how to implement
the merchword algorithm using top-down
approach the top down merge sort
approach is the methodology that uses a
recursion mechanism it starts at the top
and proceeds downwards splitting the
array into two halves making a recursive
call and merging the results until one
gets to the bottom of the array for a
better understanding of the top down
approach method
consider the following scenario right
here on my screen we have an example of
an array of size 6 consisting of
elements
73956 and 4. starting with 0 and ending
with 5. using the following formula
we'll divide the array by its middle
that is Middle is equals to left plus
right divided by 2.
we have three elements on the left and
three elements on the right near the
middle so according to the drop down
strategy we divide the given array in
half resulting in three elements that is
7 3 and 9 on the left and 5 6 1 4 on the
right next we sort all these elements in
ascending order by doing so the first
half will be 3 7 and 9 and the right
half will be four five and six and after
merging all of them we will have the
sorted array that is three four five six
and nine
next we will understand the bottoms up
approach
an iterative process is used in Bottoms
Up merge sort approach it starts with a
single element array and then joins two
neighboring items while also sorting
them the combined sorted arrays are
combined and sorted again only until one
single unit of the sorted array elements
remains
now let us look at an example right here
on my screen in the first iteration we
will merge pairs of array sizes by one
sorting each of the two elements when
you iterate the array by size 1 the
elements 7 and 3 become 3 and 7.
similarly 9 and 5 become 5 and 9 and
finally 6 and 4 become 4 and 6.
we will merge the pairs of array size by
2 in the next iteration with the bottoms
up method as a result the elements 3 7
and 5 will become 3 5 and 7 and the same
way 9 4 and 6 will become 4 6 and 9. in
the last iteration merge pairs of array
size by 3 so that after sorting three
five seven four six and nine becomes 3 4
5 6 and 7 as sorted arrays after
understanding the working procedure of
merge sort algorithm we will now see the
pseudo code of Mercer algorithm
we have a function called merge sort in
this pseudo code and parameter of the
function contains an array named as
array and two variables named as left
and right
if the number of elements in the left is
greater than the number of elements on
the right we will get a middle using
formula left plus right divided by 2.
the merge sort is called and this
function now has an array a left
variable and right variable by calling
merge sort we have array left as middle
plus 1 and right variable and finally by
calling merge sort we have left middle
and right variables in our upcoming
segment we will implement the merge sort
method in a practical demonstration
in the next section we will discuss the
complexity of merge sort algorithm
first we will look into the time
complexity of merge sort algorithm as we
all know time complexity in data
structures is divided into best case
average case and worst case the best
case of merchant algorithm is Big O of n
into log n average case of monster
algorithm is Big O of n into log n and
the worst case of Merced algorithm is
Big O of n into log n
the number of elements being sorted is
given by n merge Source Time complexity
is Big O of n star lot n in all three
situations that has worst average and
best because it always divides the area
into two halves and merges the two
halves in linear time it takes up the
same amount of space as the unsorted
array as a result it is not a good idea
to use it to search big unsorted arrays
moving on to the space complexity of the
immersed algorithm this phase complexity
of the merge sort algorithm is large o
of n
in the master algorithm we store the
left and right parts of the must array
in the temporary arrays and then utilize
the original array to keep the entire
merged array in the worst case scenario
the left and the right sub arrays will
each be n by 2 in size and then the
total auxiliary space will be Big O of n
resulting in a space complexity of Big O
of n following that we will look into
several applications of the merge sort
algorithm
so the first application is merge sort
is an efficient way to sort linked list
in Big O of n log n time
subsequent application of the merge sort
algorithm is for Linked lists merge sort
implemented without taking up more space
followed by that the Mozart method is
used to count the number of inversions
in a list last application states that
an internal sorting the merge sort is
employed
now let us look into some of the
drawbacks of Mozart algorithm
so some of the drawbacks of Mozart
algorithm are for smaller assignments
Mozart algorithm is slower than the
other sorting algorithms for temporary
array the mods or technique requires an
additional memory space that is space of
Big O of n now let's look into a
practical demonstration of Merz sort
algorithm on my screen we have an
example for merge sort algorithm
to Define constants or micro
substitution we use the hash defined as
preprocessor directive with a constant
variable Max of 10. following that 2
IRAs array 1 and array 2 are declared we
declare array 1 and initialize it with
elements like 8 4 7 6 2 3 5 9 10 4 and
1.
array 2 is used for temporary array then
to implement the merge sort concept we
declare a merge sort function we specify
three variables in this function
parameter that is left right and middle
the left variable is used to display the
left part of the array 1 the right
variable is used to display the right
part of the array 1 and middle variable
is used to indicate the middle or center
of the array in this function we utilize
the for Loop in this function setting
the left to level 1 the middle plus 1 to
level 2 and the left to variable I with
the condition that level 2 is less than
or equal to the middle and level 2
should be less than or equal to the
right of the array we have a condition
in this for Loop that if level 1 of
array 1 is less than or equal to level 2
of array 1 we will initialize all the
consecutive elements of level 1 of array
1 to array 2 else we will initialize all
the successive elements of level 2 of
array 1 to array 2.
out of for Loop all subsequent elements
of level 1 of array 1 will be
initialized to array 2 until Level 1 is
less than or equal to the middle all
successive elements of level 2 of array
1 will be initialized to array 2 until
Level 2 is less than or equal to the
right of the array using the loop which
will run from I equal to the left of I
is less than or equal to right we
initialize all the items of array 2 to
array 1. we have declared one more
function in this code namely sorting out
of the merging sort function in which
only the left and right variables are
defined May specify the middle function
in the Sorting function with the
condition that if the left is less than
the right the middle will be calculated
as left plus right divided by 2 then we
call the Sorting function passing left
as middle as right and then another
sorting function passing left as middle
plus 1 and right
finally we use the merge sort function
passing left middle and right to the
Sorting array 1 otherwise we would
return nothing
we entered the main function out of the
Sorting function where we declared the
counter variable I and printed the array
before sorting using the printf function
in for Loop where I will run from index
0 to the arrays maximum size after that
we invoke sorting method
passing left as 0 index number and right
as the IRS maximum value finally after
doing the merge or process we will print
the array using the printf function and
for Loop we will run from 0 to the RS
maximum value then we compile the
program and run it
now let's try to quickly execute this
program and say the output
so there you go the program got
successfully executed and the list
before sorting is eight seven six two
three five nine ten four and one and the
list after sorting is one two three four
four five six seven eight nine and ten
let's get started with an introduction
to selection sort
the selection sort algorithm is an
In-Place comparison based method that
divides the list into two halves with
the sorted portion on the left and the
unsorted half on the right
then the smallest element from the
unsorted array is chosen and swapped
with the leftmost element and that
element is added to the sorted array now
let's discuss the selection sort
algorithm let's say we have an array
first we will divide this array into sub
arrays unsorted array and sorted array
then we will divide the minimum element
from the unsorted array and swap it with
the leftmost element of this unsorted
array after that we will add it to the
unsorted array
we will keep repeating this process
until there are no elements left on the
unsorted array
we have now introduced selection sort
and its algorithm now let's implement
this algorithm in the code editor
we will start by creating a function
swap
argument will be integer pointer X comma
integer pointer
y
we will declare an element temp
to store the value of pointer X
then we will store pointer wise value in
x
and we will store times value in y
and that's how we can swap them
next we will write the definition of
selection sort function
void
selection sort
argument will be int array ARR
comma
and and
we will declare variables and i j and a
Min underscore idx variable to store the
minimum index
now we will one by one move boundaries
of unsorted sub arrays so for Loop
I is equals to 0
where I is less than n minus 1
I plus plus
we will find the minimum element in this
unsorted array so min
underscore idx
is equals to I
a 4
is equals to
I plus 1
J less than n
J plus plus
if
error element at check location
is less than
array at the Min index
then
idx will be updated with j
now we will swap the for minimum element
with the first element
so
we will call swap function
with argument as
10 percent
ARR
admin idx
comma
10 percent
ARR at ith location
now we will write a function to print
this array
so void
and
array
argument as int ARR
and its size
and n
or Loop
and I is equals to 0
I less than
n
I plus plus
B out
ARR at I
author
and Earth
now we will write the code for the main
block
so end
ARR
is equals to
4 comma 2 comma 1 comma 8 comma 3
we will find the size of this array so
end n is equals to
size of
array ARR
divided by
size of
this arrays first element
now we will call selection sort function
argument as ARR comma n
then we will try to print this so C out
sorted
array
and we will call the function print
array to print this array
ARR comma n
now let's try and execute this program
as you can see we have successfully
sorted this array using selection sort
algorithm let's get started with an
introduction to cell sort
shell sort is a sorting algorithm that
is based on insertion sort algorithm and
it is very efficient when the smaller
value is on the far right and must be
shifted to the far left then this method
avoids significant shifts as in
insertion sort
now let's discuss the algorithm of shell
salt
let's say we have an array we will
initialize a variable H this H will
represent intervals
then we will divide this array into H
intervals it will create some sub arrays
then we will apply insertion sort on
these sub arrays
after that we will reduce the interval
Latch by 1. then we will repeat this
process recursively until H counts down
to 1.
we have now introduced shell sort and
its algorithm now let's try to implement
this algorithm in the code editor
first we will start within function to
sort an array using shell sort
so and
cell sort
we will write argument as int ARR
bracket
comma
and and
we'll start with a big interval then we
will reduce this interval by 1.
so
for Loop
and interval
equals to n by 2
.
interval
greater than 0
and interval
divide equals to 2.
foreign
insertion sort for this interval
so for
and I is equals to interval
I is less than n
I plus equals to 1.
and
is equals to
ARR bracket I
now we will shift earlier Gap sorted
element up until the correct location
for arri I is for
so and
a
so for
a is equals to I
and J greater than equals to interval
and then
ARR bracket
J minus interval
greater than temp
and J minus equals to
interval
now ARR
at J
is equals to ARR
J minus
interval
now we will put this temp in its correct
location so ARR
bracket J
is equals to temp
now I will return 0.
now let's write a function to print this
array
so avoid
print
array
hint error
comma and n
so for Loop
and J is equals to 0
a less than
and
J plus plus
C out
ARR
foreign
now we will write the function for the
main block
so end
ARR
is equals to
12 comma 34 comma 56 comma
85 comma
2 comma
9.
comma 11.
comma
5.
now let's find the size for this array
so end n
is equals to
size of
array
divided by
size of
first element of this array
now
see out
array
array
before
print
array
ARR comma
and
shall sort
ARR
comma n
now C out
arrays
after
sorting
we will again print array
AI comma m
now let's try and execute this
as you can see we have successfully
sorted this array here we will look into
the real life example of greedy
algorithm in order to understand it
better this is Alex he's quite wealthy
and intelligent as he works for one of
the most reputed I.T firms and this is
Alex's best friend Rachel Rachel is in
dire need of 85 dollars right now
however she needs money in such a
quantity that the number of coins is
kept to a minimum so Rachel shared this
issue with Alex and asked him for help
now Alex is thinking about Rachel's
issue which he can easily fix because he
has a limitless supply of 50 dollars
twenty dollars ten dollars and five
dollar coins stashed in various bikes
although this being said Alex needed to
think about the constrained Rachel told
him about he needed to give her money
such that the number of coins utilized
must be minimal to do so Alex began
making a list of the various coin
combinations in which he could present
money to Rachel however after a while he
became confused due to the vast number
of conceivable combinations
so he decided to use his programming
ability to solve real life problems
Alex developed a program that will
provide him with the optimal number of
coins that he can present to Rachel
this generated program was iterating
through the different possibilities to
choose the best solution
at each iteration the program added the
coin of the largest value that was not
taking Alex passed the amount to be paid
which is 85 dollars in this case
for 85 dollars the largest denomination
ID can start giving is 50 now ID is
still short of 35 dollars to reach the
amount so that the next largest coin
program can take in as 20 dollars
but since the program still requires 15
dollars to meet the threshold the next
highest denomination it can accept is
ten dollars followed by five dollars
the best part about this program is that
it allowed Alex to present 85 dollars in
just four coins which is fairly
incredible
the vital thing to note here is that
after each loot the program makes a
greedy Choice providing the coin with
the highest potential value what I mean
here by greedy is that locally optimal
choice is picked at every step to reach
the global Optimum solution now moving
ahead we will formulate the idea of
greedy algorithms
basically a greedy algorithm is based on
a problem-solving method that involves
making locally optimal decisions at each
stage in the hopes of achieving a global
Optimum that means at each stage we
choose a locally optimal value in the
hopes of arriving at the optimum
possible end result
furthermore this algorithm is an
optimization technique that can find
either minimum Optimum result or maximum
Optimum result
the best part about this algorithm is
that it is simple to understand and
Implement as well Additionally the
runtime complexity for this algorithm is
pretty reasonable
however the fundamental disadvantage of
this strategy is that we only receive
the globally Optimum value in a small
percentage of cases
having said that you must be thinking
about when to implement this algorithm
for solving particular problems as it
does not always produce globally Optimum
results
well let me tell you guys that we have
two conditions to judge our problem for
implementing greedy algorithms
the first condition is the greedy Choice
property this notion states that making
locally optimal judgments can lead to
the global Optimum solution for a given
problem
the second condition is about optimal
substructure
the problem has an optimal substructure
only if an optimal solution to the
entire problem comprises the Optimal
Solutions to the sub problems
in simpler words that means the problem
can be split down into multiple sub
problems and the solutions to these sub
problems can collectively lead to a
solution for the entire problem
if both the above mentioned properties
are satisfied by the problem then we can
create a greedy solution for that
particular problem
moving forward we will look into the
steps for constructing a greedy solution
finding the substructure or subproblem
that can lead us to the final answer is
the first step in building a greedy
algorithm
because in this algorithm we are just
trying to operate with local Optima to
reach the global Optimum solution
the second step is about determining the
type of solution the given problem can
result in two that can be either the
largest sum or minimum path
the final step for creating the greedy
solution is about creating an iterated
process for traversing through local
stages and making decisions to reach a
globally Optimum solution now you might
be confused about how we can do that
well let's go through an example to
understand the approach to implement a
greedy solution
the example that we are going to deal
with is called the traveling salesman
problem in which a Salesman is supposed
to reach the destination from a given
current location
the representation of cities and parts
connecting them is done using graph
structure that each node is considered
as a city and edges connecting them as
paths having Edge weight as the distance
between the two cities
now in this case we are supposed to find
the minimum path between two cities so
to do that we will begin from the
current arbitrary position from this
node called as starting location there
are three possible paths but the path
towards City B has less distance hence
we will Traverse this Edge primarily as
it is an optimal local route
we have reached City B now and from this
note we have two possible paths out of
which one part directly leads us towards
the destination city having distance 20
but the other path leading towards the
city F has Edge weight value or distance
value as 2.
hence according to the local optimal
decision we will choose the edge
connecting cities B and F for traversal
we have reached the city F now from this
Nora City there is only one path leading
us to our destination
hence we will Traverse it now we have
reached the destination city the path
highlighted in the green shade is the
global Optimum for this DSP problem you
can verify that by calculating the edge
weights for all other possible parts
since the solution allows us to reach
the global Optimum by making optimal
decisions at the local stage this
strategy to solve the problem will be
considered a greedy approach
now moving ahead we will look into the
demerits of using greedy algorithm
we have learned that the greedy
algorithm makes decisions based on local
Optimum instead of analyzing the broader
picture of the whole data hence there is
a possibility that the greedy solution
might not be the best optimal solution
for some problems
for example consider this traveling
salesman problem in this problem the
highlighted part is a created solution
to reach the destination city from the
current location using a greedy
algorithm
But If You observe this graph the
selected solution is not the global
optimal solution for this problem in
contrast it is the worst generated
solution to reach the destination
that is why the greedy algorithm is
considered to be prone to correctness
issues even if the algorithm is correct
proving why it is correct is difficult
thus it is deemed to be trickier to
solve specific issues
now we will discuss about applications
of 3D algorithms to understand their
importance
the first application of a greedy
algorithm is its use for constructing
minimum spanning trees the coding
approaches that we use to generate MSDS
is based on the greedy algorithm both
prim's algorithm and Crystal's algorithm
are known as greedy algorithms as they
make decisions based on locally optimal
decisions
the next application of the greedy
algorithm is its use to implement
Huffman encoding and decoding algorithms
the Huffman coding technique is a
lossless data compression method
the concept is to give variable length
codes to input characters the lengths of
which are determined by the frequency of
the related characters
the smallest code is assigned to the
most frequently occurring character
whereas the largest chord is assigned to
the least frequently occurring character
this process is carried out by making
local Optimum decisions hence it is also
considered to be a greedy algorithm
final application of the greedy
algorithm is its use for developing
solutions to well-known coding problems
those problems are the activity
selection problem job selection problem
and fractional knapsack problem all
these problems generate solutions by
making decisions at each local stage so
the solutions for these problems can be
developed quite easily using the greedy
approach
foreign
between three types of a linked list the
three types of linked lists are single
linked list doubly linked list and
circular linked list in single linked
list the traversal is possible All in
One Direction whereas in W linked list
the chamacill happens in two ways
forward and backward Direction and each
node consists of data and the address of
the previous Annex node whereas in
circular linked list the traversal of a
circular single linked list is until we
raise the same node with Saturn in index
and in single linked list and W linked
list the last node is pointing to null
meaning no node after it in a list
whereas in circular in English the last
node in an index points to the address
of the first node no null is found in
the list
in single linked list every node in a
linked list connects with the other
through a pointer variable that holds
the address of the next node
a duplicating list we uses two pointer
variables then points to the address of
the previous and next node a circular
linked list uses two pointer variables
that points to the address of the
previous and next node and the last node
next will point to the address of the
first node in a list
top ninth question is
write a program to add a note at the
beginning end and specified position in
any linked list
so as you can see the screen this is the
program to add a note at the beginning
and and specified position in a linked
list
so as you can see the screen here we
have a structure of a node
coming to the insertion and beginning
function
now we're creating a new node and
allocating memory to it using mlog
function and then we are assigning a new
data to a new nodes data path
and initially
the new notes next is holding head that
means head is assigned to the address of
new nodes next
Now new is head
then coming to insertion at the end so
we are going to insert the node at the
end of the linked list so here we are
creating a new node allocating membrane
to it using analog function and
assigning a value using new data so new
data part is holding new data and last
note is equal to head
essentially it's assigned to head but if
we are checking the condition if head is
equal equal to null that means head is
equal to Nu return else check the
condition while last node next is not
equal to null then last node next is
assigned to last node and now last note
next is equal to Nu then return
then coming to insertion of the note
that means of the specified node so if
previous node is equal equal to null
then print the given previous node
cannot be none
written that means we are inserting a
node
at this specified position so if the
previous node is equal equal to null
then the given previous node cannot be
none so for that we are creating a new
node allocating memory and assigning a
data using new news data is equal to new
data and new data new nodes next is
holding previous previous known next and
now previous node next is equal to new
and this display function will print all
the elements in a linked list so well
now node is not equal to none then it
will display the node data part
and then assign nodes next to node
coming to the main function here we are
assigning values to the node so we are
calling the function insertion at n and
passing the value that is 25 insertion
at the beginning
passing value 15 insertion at the
beginning again 10 in session at the end
we are passing 30 and insertion of this
specified node that is 20 and then print
the linked list element so for that we
are calling the display function so
let's run the program
so as you can see the output here the
linked list elements are 10 15 20 25 and
30. it has print in an order
the top eighth question is
find the sum of the notes in a linked
list
so in this program we are going to find
the sum of the nodes in a linked list so
here we have a structure of a node where
we have data variable and a pointer
variable next
so we have a function called insertion
to insert an element into the list so we
are creating a new node and we are
allocating memory for it using envelope
function and assigning data
so new node data part is holding the
data and new node next is assigned to
head that means now head is holding the
address of the first node so head is
equal to new node and coming to the main
function
we have a head which is initialized to
none and initially the sum is equal to
zero so now calling the insertion
function and passing the value so we are
going to insert the value 1 16 26 and
30. that means we are assigning a value
to the nodes and then we are creating a
pointer which is assigned to the head
while pointer not equal to null then we
are performing certain operation that is
sum is equal to sum plus pointers data
so calculating
uh that means we are adding the data
over all nodes and then
point is next is assigned to PTR
so that will calculate all this um
data that means all this uh elements 1
16 26 and 30 and then it will display as
a sum of all nodes
so let's execute it
so as you can see the sum of nodes is
equal to 73.
the top seventh question is
Implement a c program to reverse the
elements of a singly linked list
so in this program we are going to
reverse the elements in a single linked
list
so as you can see the screen here we
have a structure of a node where we have
a data and a pointer pointing to the
next
we have a reverse function so we have
reverse function to reverse the data
so coming here
we are creating a previous which is
initially in slides to null and then we
have a temporary
variable that is assigned to head and
the next is equal to num so
while let's make the stamp
so well temp is not equal to null
then it will execute this statement that
is this statements are used to reverse
the elements that means the list of
elements that we are given here will be
reversed
so for that we are performing this
operation that is uh the temp whatever
is there in the temp notes next is given
to the next variable
and whatever is there in the previous is
given to temps next and what's there in
the temp is given to previous and
finally
the temp is equal to next that means
whatever is there in the next is
assigned to temp
and now head is equal to previous coming
to the insert node we are going to
create a new node uh then assigning a
value using data
so new null new nodes data is holding
the data and the next is assign to head
then that means um the first the head is
holding the address of the first node
that is new nodes address
and then the head is equal to new node
and then coming to the display function
this will display all the list of
elements that is we are using temp
variable that is equal to head that
means assigned to head while temp is not
equal to null
print the data
so it will print the data
so what data it's like temporary next
whatever is there in the temp data which
will print all the data all the news
data and then temp next is assigned to
temp
then coming to the main function here
the head is initially assigned to null
and we are calling the insert node to
insert the values that that is 10 20 30
and 40. so it will print the given
linked list is and calling the display
function so it will display all these
elements and then calling the reverse
function to reverse this element and
then again calling the display function
to display it back
so let's try to execute
now as you can see here we have
the list of data that is 40 30 2010
and then and the reverse data is 10 20
30 and 40.
the code that I'm executing in this
session and the question and answers we
are discussing will be attached in the
description box below so you can have a
look at it and execute the code for a
better understanding and if you face any
issues while executing the programs then
please let us know in the comment
section below and our team of experts
will be happy to resolve all your
queries at the earliest
top sixth question is
write a program to count the number of
nodes in a linked list
so in this program we are going to count
the number of nodes in a linked list so
here we have a structure of a node where
we have again same data and the
variable or a pointer to the next
then coming to the insertion function
this is to insert an element for that we
are creating a new node and allocating
memory then assigning a data
and the new next is holding head that
means head is equal to new node head is
holding the address of the new node and
coming to the display function here we
are going to display the
for what uh the count the node count so
here we have a new node which is
assigned to head and initially the node
count is equal to 0. while new node is
not equal to none that means new node
next is assigned to new node and every
time it is printed it will increment
node count by one so we are using
nodecon plus plus that means it will
increment uh node by 1.
so then it will display the total number
of nodes in a linked list
so coming to the main function here we
have head which is assigned to null and
calling the insertion function for
passing the value 10 20 and 13. so now
we have
uh the values 10 20 and 13 and calling
the display function to display the
number of counts sorry number of nodes
in in a linked list so let's execute it
so as you can see the total number of
nodes in a link list are three because
here
over here we have given three values to
three nodes so let's try to add one more
so let's run it
so as you can see now the total number
of nodes in the linked list are four
while we are already discussing some
Adobe questions let us know the
trickiest ones you faced in your
interviews in the comments below let's
see if anyone responds with the right
answers to your questions could be
helpful for all the viewers with some
extra questions to learn
top fifth question is
Implement a program to merge two sorted
linked lists from their end
so now let's understand the program to
merge two sorted linked lists from their
end
so as you can see here again same we
have a structure of a node
and we are creating a pointer variable
that is next
and then we have a display function so
this will display the elements
so here we are creating a pointer
variable PTR which is assigned to head
while PTR it will print the data
and then point is next is assigned to
PTR
then coming to insert we are going to
insert the element into the list so for
that we are creating a new node and
allocating memory for it after
allocating memory we are assigning a
data for new nodes data part and in unit
next is holding head that means now the
head is equal to new node head is
holding the address of the new node then
coming to the move function
so here we have PTR and head well if
head is equal equal to none then return
is what we are going to do here is
creating a new node which is assigned to
head and then head is equal assigned to
hits next
and pointer is assigned to new notes
next and PTR is assigned to new node
so this function here we are going to
move the linked list
so
this function or these are the
statements that we are going to perform
and then coming to the reverse we are
going to reverse to
or two set of linked lists so the first
link a set of Link list is first and the
second is second
so while first and second initially
result is equal to none if First Data is
lesser than second data then call move
else move function and pass the first
set of data
and pass the second set of data
why second then again we are calling the
move function
and
result uh that is we are passing the
reference result and second while first
then we are calling the move and passing
the first set of linked lists
then it will print the result so this is
basically to reverse the linked list so
we are reversing the first set of as
well as second
and then coming to the main function
here we have a first set of
Link list that is first set assigned to
null and whereas second set is also
assigned to null so for I is equal to 6
to I greater than 0 that means from i 0
to 6
I is equal to I minus 2 that means it's
going to it's going to print the even
numbers from 0 to 6 calling the insert
to insert the elements then
so passing the first this that means
this is the first set of linked list and
this is the second set of linked lists
where I is equal to 9 I greater or equal
to 1 then I is equal to I minus 2 that
means from 1 to 9 equaling it going to
print the odd numbers so we are calling
the insert function and passing the
second set of that means this is the
second set of elements
then print first list of elements so
display first so this will display the
first set of linked lists and then again
print the second list of elements
calling the display function to display
the second set of linked list
then calling the reverse function to
reverse first as well as second
so after merging the linked list so now
um this is going to merge two linked
list so then after merging again we are
calling the display function to display
so let's try to execute it
so as you can see the first list of
elements were 2 4 6. and the second set
of list is one three five seven and nine
so it's going to merge this two linked
list from their end so this is the
sorted uh linked list
so here we have nine seven six five four
three two one so this is going to sort
the elements and then merge from there
in
the top fourth question is
write a program to delete a note at the
beginning end and specified node in any
linked list
so as we have previously discussed on
how to insert the nodes now let's
understand on how to delete the node
from a list
so as you can see here we have a delete
function that means to delete a node so
we have last and keynote as an argument
that we have passed and if last is equal
equal to null that means written that
means there are no nodes in a list
so and this functions to delete a node
at the end so if last data is equal
equal to Keynote and the last next is
equal to last then free the last
we are assigning the last equal to none
until it will return
then we are creating a temporary
variable which is assigned to last and
then we have a delete note
a pointer to delete node
so if last data is equal to the keynote
y temp next is not equal to last then
whatever is there the temp notes next is
assigned to temp
and the last node next is assigned to
Temp next and free the last
so once you fill the membrane of a last
node then assign the last next that
means the temp next is assigned to the
last
wealth temp next is not equal to last
and temp next data is not equal to the
keynote then whatever is there in the
templates is assigned to temp
so if temp next data is equal to the
keynote and the temp next is um
is assigned with it delete node
now the delete note next is assigned to
Temp next and then we are going to
free the memory for the node to be
deleted now calling the display function
to display the list so if
creating a pointer variable and if the
head is equal to 9.
if head is equal to none that means the
list is empty
then we are assigning a pointer is equal
to Heads next so do that means this will
print
that is it will print the notes data so
once it prints the First Data again it
will uh the pointers next is assigned to
the PTR then we'll print all the nodes
data and then check the condition by PTL
not equal to H next coming to the main
function as we have already seen how to
insert so the elements that we are
inserting is 30 40 10 20 and 10.
so it is like 10 20 13 14. and print the
linked list element so if we are calling
the display function to print the
elements and
after deletion the linked list elements
are so which element we are deleting
that is 10 so delete node we are calling
the delete node to delete the element
10. then again we are displaying calling
the display function to display the
elements so let's execute it
so as you can see the linked list
elements were 10 20 30 and 40. so after
division the linked list elements are 20
30 and 40 that means we have deleted 10
successfully
top third question is
write a program to remove duplicate
elements from the sorted linked list
so here basically we have the elements
these are the sorted elements that is uh
10 20 30 40 and 50 and also we have a
duplicate elements that means a
duplicate nodes
so basically we are going to delete this
so we are going to delete this then then
30 and extra 40. so for that
uh we have a structure of a node
and then we have a display function
so in display function we are going to
display the data
so for that we have a pointer which is
assigned to head while pointer it will
print the date of all the nodes
and we are assign pointers next to PDF
then coming to insert function this is
to insert the elements or the node so
creating a new node and allocating
memory for it
and then assigning a data and new nodes
next will be head that means
um
the new node address head is holding the
address of the new new node and then we
have a remove duplicate function so this
function is basically going to remove
this extra or the duplicate 10 30 and
40.
so in this function
it checks if head is equal equal to null
written that means there are no nodes
then creating a pointer which is
initialized to head so while pointer
next is not equal to none then we are
going to perform this so if checks the
condition if pointed data is equal to
0.2 pointer nodes next data that means
if this and this is equal to
if this and this element is same suppose
this is the pointer
and is the pointer next
so this is what your pointer next data
so if those both are same
then we are assigning Point as next next
to next next
and then free this space or the memory
for the pointers next and next next is
assigned to pointers next else we are
assigning pointer next to the PTR
and coming to the main function here we
have I and the elements that um list of
elements that is 10 20 30 40 and 50 and
we have X star or the duplicate elements
as well and we have n which is assigned
to size of elements divided by size of
elements starting from the index 0.
and initially had assigned to null and
for I is equal to n minus 1 I greater
than equal to 0
we are inserting the elements and then
decrementing I back minus 1.
we are calling the remove duplicate
function to remove the duplicates and
then again display the list so let's
execute it
so as you can see here they have we have
removed all the duplicates that is we
had extra 10 30 and 40. so now
um the duplicates are removed so now the
list is 10 20 30 40 50 and the last is
none
top second question is
Implement a program to rotate a linked
list
so in this program we are going to
rotate the list so for that we have a
rotate list function
so here we have a variable called P if p
is equal equal to 0 then return
so p is nothing but the list if the
linked list is empty then it will return
so let's consider the below example that
is we have a list called one two three
four and five so if suppose p is equal
to 4. so that means PTR is assigned to
head first so current will either point
to the P payth or none so if initially
the count is equal to 1 while count is
lesser to p and the pointer is not equal
to null then we are assigning pointers
next to PTR and we are implementing the
count by 1.
so that means the current will point to
the node 4 in the above example that
means um this now the current that is
PTR is pointing to the fourth
and if PTR is equal to none then it will
return
else now again
the current points to kth node that
means here we have the period so
the current points to create node store
it in a variable so whatever is that the
uh four here in this example it is 4
so this 4 will be stored in
here it will store in the variable this
one eighth note
now the period points to the node 14
above examples so now here while
pointers next is not equal to null then
assign pointers next to PTR
and now pointers next is equal to a head
that means head is holding the address
of the point as next and now a pH node
next is holding head
and again the pth node next is assigned
to none that means we are keeping the 4
as it is and rotating that means
rotating in the sense now these three
elements will come this side and this so
it's kind of uh it's not a reverse but
it's just a rotating
so coming to the insert function here we
are going to create a new node uh and
then assigning a value
and first notes uh address will be uh
for holding head will be holding the
address of the First new nodes next
and now
head is assigned to new node and now
this function is to print the elements
so while node is not equal to none then
only it will print the all the data of a
node uh nodes or nodes data and now
nodes next is assigned to node and
coming to the main function here head is
assigned to null so for I is equal to 6
I greater equal to 0 that means from 0
to 6. we are inserting values that means
uh inserting the node so print given
linked list
so whatever is given first it will
display then after rotating
oh now PTR is pointing to four so after
rotating the list again we are going to
display the list of elements so let's
execute it
so as you can see here the given linked
list is one two three four five and six
so after rotating it is 5 6 1 2 3 and 4.
our first question is
Implement a stack using any linked list
so in this program here we have a
structure of a node and actually the top
is assigned to none and push item that
this function is used to push the items
into the stack so using linked list we
are
implementing a stack so here creating a
new node and allocating memory for it
and then assigning a value to a new
nodes data part so if the top is equal
to null the new note next equal to none
else the new nodes next is equal to top
so now the new node is top so if it is
uh the top is equal to new naught then
item is pushed successfully that means
inserted and pop item this function is
to delete the item from a stack
so if top is equal equal to none that
means stack is empty else
we have a temporary variable which is
assigned to top so it will delete the
top item
from a stack so temp next is assigned to
talk and we are going to free the memory
for a temporary variable
and then printing the element
that means printing the items in a stack
so if top is equal equal to null that
means the stack is empty else
uh here we have a stuck node temp that
means we are creating a temporary
variable which is assigned to top and
while temp next is not equal to null
uh then it will print the data of a
temps data that means it will print or
the items in a stack
so a temp next is assigned to temp
and then again it will print all the
data
so coming to the main function here we
are having a choice and then item while
one using while Condition
it's asking options that is push pop
display and exit
so first asking enter your choice so if
you enter the choice the in case one we
are going to insert the item into the
stack
uh so we are calling the push function
that is push item function and then in
the case too if you uh select the option
two then we are going to call the
function pop item
if it is third then print item if it's 4
then it is exit by default if you if you
enter
anything apart from one two three and
four then it's going to print wrong
choice so please try again with
different choice
so let's try to execute it
so first let's enter the choice one
and enter the value to be inserted that
is 10. again let's enter one
and value 20. now let's uh display
so now the inserted are 20 and 10.
so to delete let's enter Choice 2 so
that means whatever was at the top is
deleted successfully so top was 20. so
now 20 is deleted successfully so now
let's display three
so as you can see
now only 10 is in the list or in the
stack
so here I have one question for you guys
and the question is Implement a program
to check whether the list is palindrome
please try to find out the answer and
let us know the solution for this
question in the comment section below
and the top 10 question is what is data
structure
a data structure is a collection of data
used to store or organize in an
efficient manner to access it
effectively in short it deals with how
the data is organized in the memory
next the top ninth question is what is
the classification of data structure
structure is classified into linear and
non-linear whereas linear data structure
is further classified into a static and
dynamic data structure so now let's look
at a complete classification of a data
structure
the data structures are classified into
linear and non-linear in which
non-linear data structure consists of
tree and graph
a linear data structure is divided into
Aries queues stack and linked list
so what do you mean by static and
dynamic data structure the memory of a
static data structure is fixed in size
which means the memory is allocated
during the compile time RS are the
example of a static data structure and
in the case of dynamic data structure
the memory is allocated during the
runtime queues stack and Link list are
the example of a dynamic data structure
the top eighth question is what are the
applications of data structure
the first application is Graphics that
helps to represent the data virtually
then
data structures are used in artificial
intelligence which is a manual machine
to perform a certain task next
data structures are used in creating
operating systems such as Microsoft
Windows Unix operating system Etc
then
compiler design which is used to compile
the computer programs or translates the
source code into machine code
next image processing it is used to
perform operations on the image or to
get any kind of information from a
particular image
later
numerical and statistical analysis
numerical analysis is used to refer to
the numerical facts whereas statistical
analysis refers to analyzing and
presenting the data
and finally database management it is
used to store and retrieve the data from
a computer
seventh question is what is a stack and
explain the operations performed on a
stack
diet is a linear data structure the
items in a stack are stored in the order
of first in last term or last in first
dot so here let's consider an example
where we have stack of books so suppose
students were asked to keep books for
the corrections one after the other then
each one of them would keep the books on
top of the other book therefore in the
same way items are inserted into this
stack another example could be a stack
of clothes
operations like insertion and deletion
of an item are possible only from the
one end of the stack that is on top of
the stack now let's have a look at the
operations performed on a stack
push operation is to insert the item
into this stack whereas pop is used to
delete or remove the item from this
stack
and top will return the top item of a
stack is MJ Returns the true if the
stack is empty else it will return false
size operation is used to return the
size of a stack
next top six question is
what is sorting and mention the types of
sorting algorithms in C
ertain is the process of arranging the
data in some particular order to access
the data efficiently and the Sorting
algorithms are
insertion sort selection sort bubble
sort
counting sort Radix sort quicksort and
merge sort a programmer can use any of
the following sorting algorithms to
arrange the data either in ascending or
descending order therefore sorting
reduces the complexity of the problem
the next top fifth question is what is a
linked list and what are the different
types of a linked list
a linked list is a linear data structure
consisting of nodes where each node is
divided into two parts data and address
every node in a linked list is linked
together the different types of linked
lists are single linked list doubly
linked list and circular linked list
a single linked list is a collection of
data called nodes where each node is
divided into two parts to store data and
address every node in a linked list is
connected with the other through a
pointer that points to the address of
the next node a special note called the
head node holds the address of the first
note and the last note points to the
none
and a w linked list is a complex
compared to a single linked list each
node is divided into three parts to
store data and the addresses of the
previous and next node in a doubly
linked list the first note previous and
last note next pointer points to null
indicating no notes before or after it
it is easy to access elements in the
doubling list since it consists of two
pointers to travel from forward and
backward Direction
circular linked list in C programming
performs a reverse table cell with less
memory uses than a w link is a circular
linked list is a collection of data
called nodes where the last node links
to the first node
the top fourth question is write a
program to convert an infix expression
to a post fixed expression
so as you can see this program is to
convert an infix expression to a post
fixed expression so we have a pop
priority and push function which are
declared and then we are declaring stack
of size 50 and top injury is equal to -1
then going back to function
push is used to insert an item into the
stack so
n is assigned to stack of plus plus top
and pop is to remove or delete an item
so if top is equal equal to minus 1 then
return minus 1 that means top is empty
else returns stack of top minus minus
that means decrementing the top by -1
then coming to Priority function checks
the condition if x is equal to open
parenthesis then written 0 if x is equal
to plus or minus then written 1 if x is
equal to into or divided by then written
2 that means the priority of plus and
minus the same and into n divided by
odds same
then going to main function
here we have the expression of size 100
and then the pointer variable exp then
asking to enter the expression to
perform in fixed to post fix once you
enter
the expression is assigned to exp so why
ax will not equal to null then checks
the condition
so if is Al num X of expression that
means if the expression is Alpha
numerical
then print the expression
as if
prints the character and else if
expression is equal to open parenthesis
then push to X calling the push function
then else if expression is equal to
closing parenthesis while n is equal to
pop not equal to
closing parenthesis print character is y
priority of stack of top is greater than
equal to priority of expression then
pops the character and pushed to the
expression and incrementing the
expression by 1 while top not equal to
-1
then pop that means if stack is not
empty then pop out the character return
0. so let's try to execute it
enter the expression
so let's enter a plus
K of C into d
and we got the output
the code that I'm executing in this
session and the question and answers
that we will be discussing will be
attached in the description box below so
you can have a look at it and execute
the code for a better understanding and
if you face any issues while executing
the programs then please let us know in
the comment section below and our team
of experts will be happier to resolve
all your queries at the earliest
top third question is what is a binary
search tree and explain its properties
a binary tray is a complete tray in
which every node is spelled except the
last level nodes in a binary tree are
added from left to right
topmost node is a root node of a tree
and the sub tree consists of a parent
note and a child node
the properties of a binary search tree
are the left substrate of a node contain
only nodes with a K element less than
the root load scheme whereas the right
subtree of a node contains the note with
key elements greater than the root node
scale
the top second question is what is a
graph data structure in same
a graph is a non-linear data structure
it is a collection of a finite set of
nodes called points connected through
edges called lines as shown in the below
diagram
is to represent networks such as
telephone networks circuit networks and
social networks Etc
now first question is how to implement a
program to find the height of a binary
tray
so as you can see this is a program to
find the height of a binary tree which
means finding the levels of a binary
tree
so first we have a data variable and we
have a pointer to less child and right
child
and then coming to height function if
node is equal equal to none then written
0 else
the height of nodes left child is
assigned to left height and the height
of nodes right child is assigned to
right height so if left height is
greater than right height then return
left height plus 1 else written right at
Plus 1.
and then creating the new node and
allocating memory for it using m-log
function
and then assigning data so assigning
data for a nodes data and initially
denotes left child and right child is
assigned to null and written node
and coming to main function we are
assigning values to every node so root
node is having the value 10
and Roots left child is equal to 15
Roots right child is equal to 20 and
Roots left child's left child is equal
to 25 and Roots left child's right child
is equal to 30 and print the height of a
binary trick
so let's execute it
so as you can see we got the output the
height of a binary tree is 3.
and the top 10 question is
consider a text file interrupted by a
park and all the text has been reversed
due to this bug so which data structure
would you chose to implement a program
to reverse the text file to its original
the solution is stack data structure
let's look at the problem we must read
an existing element by element in
reverse order sounds something like last
to first as we all know stack follows
first in last order principle in order
to reverse a string we must create an
empty stack to push all the string
characters one by one
and then what about the character one
after the another
so once performing the pop operations on
a string all the string characters would
be reversed and form into the original
string
now let's try to implement the program
using stack data structure
so as you can see here we have a reverse
function which is declared and
going to the function here we have a
structure of Stack where we have top
size and array variables
and we have a function called structure
creation sorry stack creation
so first we are allocating memory to a
stack using analog function and this
size is assigned to stack of size and
initially stack of top is equal to -1
and then allocating memory to the stack
of array
then coming to is full function where it
checks whether the stack is full so if
we'll return stack of top is equal to
stack of size -1 and checking if the
stack is empty that is is empty written
stack of top is equal to -1
and then coming to the push function
which is used to insert the item into
the stack so it checks if is full if the
stack is full written where the item is
assigned to stack of top
and pop to delete the item from a stack
so it checks it is empty then written
intimate as written stack of array that
is of stack of top minus minus that
means stack is empty
is decrementing a doubt by -1 and then
coming to the reverse function here we
have string length of string which is
assigned to n
and then calling the stack creation
function to create an empty stack and
from I is equal to 0 to n
push all the stack or whatever is there
in the string of I is pushed to the
stack and for I is equal to 0 to I less
than n Pop All the
items to back to this string of I and
then coming to the main function here we
have a reverse string
and here
we are reversing a string so we are
calling the reverse function which is
this and it tries to reverse this string
and get back to its original form
hmm so if prints the reverse string
so let's try to execute it
so as you can see here reverse string is
simply long
the top ninth question is
today you have been assigned a task a
task in which you are given an array of
numbers to be arranged in ascending
order so with sorting algorithm would
you choose to place the numbers most
efficiently
and the solution is quick sort algorithm
quick set algorithm helps research the
information faster than any other
sorting algorithm it is widely used to
sort the elements faster also memory
storage is utilized efficiently since no
additional storage is required if the
array size is small then the quicksort
algorithm Works faster to sort the
elements
so now let's consider array of elements
3 5 2 4 and 1 and let the pivot element
be 3.
so
while are we taking private as a 3
because the left hand side element is
greater than the right hand side element
so if the right cell element is lesser
than the pivot element
let's swap out the elements
next comparing the next left element
with a pivot element and it checks
whether 5 is lesser than the element 3.
so if it's lesser than it will swipe
with each other
similarly comparing the next element to
and since 2 is less than 5 it will
remain in the same position next
comparing the element 4 width 5. again 4
is lesser than 5 so it will remain in
the same position
so now as you can see the left hand side
elements are not at the proper position
so considering the left hand side
elements
we will swap the elements
so here it Compares 1 and 2. since 1 is
less than 2 it will remain in the same
position
next compare 3 and 2. here 3 is greater
than 2 so it will swap out the elements
now let's have a look at the program
implementation
so here as you can see we have a quick
sort algorithm function declaration and
then going to quick sort algorithm
function here we have array of size 24
end of left and into right so
initializing the variables i j p and
temp so if left is lesser than right
then assign the left element to P that
is Pivot element and
assign all the left element to I and
right element with J so while I less
than J while array of I lesser or equal
to array of p and I less than right then
increment I by 1. while array of J is
greater than array of P then decrement J
by 1. so if I is lesser than J then we
are doing swap so we are swapping the
elements that means array of I is given
to the temp variable and whatever is
there in Array of J is assigned to array
of I and the temp variable is assigned
to array of J and then changing the p
that means the array of p is assigned
are stored in temp variable and whatever
is there in Array of J is given to RFP
and whatever is the n term is given to
array of J and then calling the quick
sort algorithm
so coming to the main function here we
have I count and array of size 25.
so it's first asking to enter the number
of elements
so suppose you want to enter 5 elements
to arrange in the ascending order then
enter 5. so once you enter 5 it will ask
to enter one element by element
so from 0 to count it will last one by
one
so then we are calling the quicksort
algorithm to sort the elements and then
it will printed elements from I is equal
to 0 to I less than count and with sort
the elements one by one so let's execute
the program
so here enter the number of elements so
let's enter 5
and enter the elements one by one five
so we have 2 5 6 3 and 1.
so the elements are sorted 1 2 5 6 and
31.
of eighth question is
you are given a list of numbers to find
the minimum and maximum numbers
Implement a c program using the
appropriate type of data structure
and the solution is array data structure
the array data structure is used to
store multiple data of the same time
easily allowing random access to an
element using the index number it also
improves performance remarkably as it
stores the element consecutively next
the array use less memory space as there
is no usage of pointer variables
so now let's Implement a program to find
the smallest and largest element
so here we have array of size 50 then
variable i n and
variable to find the largest element and
a variable to find the smallest element
so first enter the number of elements
input the array elements so one after
the other from I is equal to 0 to n it
will take the array element
and initially the largest element and
smallest element is assigned to array of
0.
and then coming to for Loop wherefore I
is equal to 1 till I less than n if
array of I is greater than array of L M
sorry large element
then assign array of I to the largest
element
if array of I is lesser than smallest
element then assign array of I to the
smallest element and then print the
smallest element and largest element
so let's execute it
so enter the number of elements let's
enter 5 and input the elements let's
enter two
5 10
6.
1
so as you can see the smallest element
is 1 and the largest element of an
arraylist is 10. so with this we have
come to the end of the session on the
part 2 data structure full course I hope
the session was informative and
interesting if you have any further
queries regarding any of the topics
covered in this session or if you
require the resources like PPT code
documents or anything else then please
feel free to let us know in the comments
below and a team of experts will be more
than happy to resolve all the queries at
the earliest until next time thank you
stay safe and keep learning
video subscribe to the simply learned
YouTube channel and click here to watch
similar videos turn it up and get
certified click here
foreign