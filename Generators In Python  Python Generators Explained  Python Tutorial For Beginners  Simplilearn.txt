hello and welcome to this session of
generators in python
today we are going to talk about a very
unique concept in python about
generators and when we will see why they
are useful
so what's in it for us today
we will talk about what is a generator
in python we will talk about the
advantages of using generators
and the utility of the next function
which
allows us to
operate with generators and
print the
values within the generator so we will
see these
all these concepts with an example
now what is a generator in python
python generators lets you create your
own iterator functions that return the
traversal object with a sequence of
values
so basically even with iterators you can
only work on list tuples or sets but
with generators you can convert your
functions into iterator functions itself
and we will see that when we will be
working on a jupiter notebook
now another important feature in a
generator function is that a yield
statement is used rather than a return
statement
so
basically the return statement
terminates a function entirely if you
use it within the function and you know
basically return from the statement
while the yield statement pauses the
function there it is
and holding all its states all its
variables the values in the variables
and then continue
thereafter on the successive calls
so basically in a generator function you
use yield functions and i will talk
about the utility of this yield
statement within the generator function
how it helps in generating pipeline
but just to hold a thought over here and
understand the concept the yield
statement basically holds
the processing of the function at that
point and if you make an invocation of
that generator function again it starts
from there itself where you left it
as compared to return statement return
is a general exit
if you make an invocation of the return
statement from a function it will
restart again from the beginning
if you invoke it the next time and
that's the basic difference
so what are the advantages of using
generators it's very easy to implement
the code syntactically it's very simple
within the few line of codes you are
able to achieve uh the
you know functions and able to implement
the logic
you can generate infinite sequence you
don't need to provide the range values
the starting and ending you can generate
an infinite value and i'll show you that
with an example
and
generators are very memory efficient
they are the most memory efficient ways
of processing huge data sets
they process the data incrementally and
do not allocate memory to all the
results at the same time they do that
incrementally
they really come in handy when
implementing data science pipelines for
huge data sets in a resource constraint
environment where you have
uh you know constraint on the ram and
the other resources of the hardware
now another biggest advantage is
pipelining with generators
generator pipelines are a great way to
break apart complex processing into
smaller pieces when processing list of
items so basically you can
break your complex code into smaller
pieces and then
invoke them as a generator
recursively and we will see that how
but basically you are making the complex
code look simple and making it invoke
in a pipeline fashion
now the another most important function
in order to deal and operate with the
generator is the next function
the next function is used to retrieve
elements from a generator object and
then print it so that's how you
basically
interact with your generate function
you cannot do that until unless you
don't use next function
so now let's quickly
jump to our examples
which we are going to support for each
of these concepts now let's start by
basically
creating our first
generator function
i'm going to
create a variable n initialize it with
1
and i'm going to do a print
this is just for my
logging
and showing on the console that where we
have reached
and then
i'm gonna say yield n
okay
so now here we are not exiting the a
function we are just
saying
that just you know this is the point
if you invoke the function again the
function will start from this point on
now here
you will
increment
and again if this is the second
checkpoint in the code
and similarly
this is the we're gonna have a last
checkpoint in the code
now in order to
create my generator now this is the
my generator initialization my gen
now if i
use the next function and invoke my
generator
now
my
generator has
been executed till this point right
n equal to 1
now if i
make a second invocation
now it has moved ahead and printed the
second so it is behaving like a loop it
is now behaving like a loop it is
behaving like a nitrater
but i have not created any list i have
not created any double but i am
basically traversing
through the variables through the
sequence of the variables within my
generator
and if i again
print it
this is my last this is printed at the
last so all the
checkpoints within my generator have
been executed
now
the same example which i have over here
let me
call it in a loop
okay
so what i'm gonna do is i'm gonna
remove these invocations and just
replace it
with a loop call right so this generator
functions remain as is
now instead of writing my next
function
three times
i am going to just invoke my generator
in the for loop and this will get
invoked the number of times i have yield
in my generator
and my output should be
the you know the these logs which i have
created
and of course uh the variables
yeah so see now what has happened is
now the output is all these three print
commands have been executed plus the
variable values of n has been imprinted
at each at point one
two and three
so when i initialize my item variable
during the for loop this item consists
of the variable values which are there
in my generator
now i'm going to show you example of if
i use a return statement in my generator
so i'm gonna create another generator
and
provide a value
now in during this in middle of the
generator i'm just invoking the return
and then i am
printing my second checkpoint
and then the
last checkpoint
now
i'm going to initialize my generator
now if i invoke
my
first element of the generator i'll get
it there's no problem because i printed
the first item i called the value of my
yield and then i returned
but now if i invoke my second element in
the generator
but before invoking second i have
already given the return statement
my
generator will exit
and i'll get the stop iteration error
now this is a python generated
exception which is denoting that you
have you cannot move beyond the first
item because you have returned from the
generator over here
so that's the difference if you just
remove this comment this out
and then run it
you will get your second item so it's
not x the code exits if you write return
over here
so i hope you are able to understand the
difference
now let's take another example now here
we are going to create a list and how
a implicit list like the way legacy way
we have been creating in python
differentiates
like the way we are creating a generator
so what i'm doing is i'm creating a list
with random numbers
and then another list in which i'm just
square rooting the numbers in that list
and similarly i'm also creating a
generator
which
i'm expecting the same output in the new
list as the generator but i'm going to
show you different ways
of traversing the generator as compared
to a list
now if you see this list underscore if i
just make a print call to this list
it's gonna straightforwardly
uh square root
uh the numbers and give me the output 4
9 64 100
but if i print the generator
i will not get the expected output what
i'm expecting i will just get the
generator object which is not what i
desire so basically you can't just print
the generator like the list
you have to
either use the next or you have to
use the for loop which i had shown
earlier and print each and every item
within the generator
now this is the output which i was
expecting i was expecting the
line by line
output of each and every element in my
generator
4 9 64 100
okay
now this for loop is taking care that it
is not exceeding
the number of items the length of the
items in the generator so this is
automatically taken care by this syntax
but if you don't take care of it then
you will get an exception let me show
you another example
if i create a list
and now i'm creating a generator
which is square
of square of all my elements
so now one by one
instead of the loop i'm one by one
printing the output
second output
third element output
fourth element output
okay i have four now if i try to again
print
i'm exceeding the uh
length of
the
uh
list i'm gonna get an exception stop
iteration exception because i'm
exceeding the length right either i use
the 4
or if i'm using individual print and
next function then i have to take care
that okay how many elements are there in
the list and i cannot exceed beyond that
else the python will
raise an exception
okay
now i'll show another example of
highlighting the difference between next
and
the for loop printing i'm gonna create a
uh generator for 2 to the power n
so i'm initializing n with 0
and then just
raising it
2 to the power n
now here i am initializing my generator
and printing it
and i am getting the expected output as
2 raised to the power 0 1 okay
now another way of doing this job is
i
loop over this
and i get the same output so if you see
it's only
i do not have only one element
so either you use for loop or you print
using next the output is going to be
same
now another important concept which i
talked about if you want to print in
finite
infinite numbers
so
or you want to do some infinite
calculations
i'm gonna use print in
all
even numbers
so i'm gonna
write an
generator
which is gonna print
infinite number of even numbers
so i have created a generator
and now i'm going to invoke this
and mind you i have to kill this job
because it's going to keep running
it's going to keep running keep running
because it's constantly generating the
numbers even numbers so i would have to
stop this
but if you see otherwise this is not
possible in any for loop the basic for
loop you have to give a range start and
end of the length but using a generator
you can do infinite
looping
right because here i have to kill this
job i have to do a keyboard interrupt
now i'm going to show you an example of
how you can use generators for creating
a pipeline
so i'm going to take example of
fibonacci series
create an example of fibonacci two
variables initialized with zero and one
and now
i'm going to
write the logic of fibonacci adding the
two numbers
to itself
subsequently
and i'm gonna add yield
now this is my generator this is my one
generator
and i'm gonna create second generator of
square
so i'm gonna
show you in excel
what logic i'm gonna apply and what will
be my expected output
so i am now squaring the numbers which
i'll get out as an output of
fibonacci
okay
now
i'm gonna
i'm creating a pipeline
like this
first i'm gonna
generate fibonacci series for the first
10 numbers
then
i'm to find the square of each of the
fibonacci numbers and add it
so if you see this
representation in excel
i'm going to generate
these are the two variables which i've
already initialized x and y and from
here on these
10
are my first 10 fibonacci numbers
i'm gonna find
calculate the square of these numbers 1
4 9 25
and till 55 the square of 3025 and then
add these numbers and i should get the
output of 4895 so if you see
one
function generator second generator and
the third calculation now this hole
has been done in one single line of code
you have generated created two
generators
and just invoked them in a single line
pipeline
so entire looping
and you know
you don't have to write the looping
operators the for loop and you don't
have to worry about writing all that
complex logic it is all encapsulated
within this
now let me run and i'm going to expect
this output 4895
and here is my output right so in the
hindsight what python has done is it has
generated these fibonacci numbers found
the square of these numbers and then
added it in single line
and now this is the convenience
simplicity which i was talking about
earlier
now let's take another example of
fibonacci
i'm going to create a generator again
initializing a and b with zero one
and this time i'm taking an example of
printing the fibonacci in two different
ways
okay
i'm gonna print
the first
five fibonacci series number
the first way i'm gonna do is i'm gonna
print
the next function five times because i'm
generating five
so let me run this
these are the first five fibonacci
number zero one one two and three
and i'm also gonna use a
loop
in order to print
so now in the loop i am invoking the
five fibonacci numbers
and run it
so either you can
you make individual five individual
calls or you can use the for loop but
the output is the
same
and you're using a generator so that's
all i had today for this session i hope
you had a great learning experience and
i look forward to connecting with you in
my next session thank you
hi there if you like this video
subscribe to the simply learn youtube
channel and click here to watch similar
videos turn it up and get certified
click here