ever heard of java it's an
object-oriented language with right ones
Run Anywhere convenience ensuring smooth
operations on diverse platforms from web
development to mobile apps and
enterprise software Java's reach is vast
fueling the hunt for adapt Java
specialists in the U.S the average
yearly income for Java developers is
about ninety four thousand dollars
ascending to 114 000 for senior roles
and with a potential upper limit of
hundred and eighty thousand per year
eager to uncover the world of java then
have a look at Caltech coding bootcamp
by simply learn with this amazing
program you will be benefited with the
skills like agile Java JavaScript HTML
and CSS angular mongodb Maven JSP and
spring this course not only offers you
the best skills but also the hands-on
experience with Capstone projects so so
hurry up and enroll Now find the
complete course details from the link in
the description box hello guys this is
vikesh and let's get started with the
first topic of this series which is
about introduction to Java so when we
talk about Java it is one of the most
popular programming language out there
and it was created way back in 1991 but
it was publicly released only in 1995.
it was developed by one of the famous
developers of Our Generation who is
James Gosling at Sun Microsystems and
then later Java was acquired by Oracle
and today Oracle owns Java Java is very
simple and easy to use and we will look
at different aspects of how it is easy
and simple to use it's a write once Run
Anywhere type of programming language
again we will look at details into into
into this particular concept as well and
when we talk about the usage of java you
can and use it to build web applications
mobile applications desktop applications
even command line applications and at
the same time you can also use it to
build complex applications like gaming
applications building microservices or
building distributed computing Etc let's
talk about the features of java so one
of the most prominent features of java
is that it's an object-oriented
programming language which means that
everything which happens in Java happens
around objects objects enable the
execution of the program objects talk to
each other to exchange data and messages
we will okay about a look at the concept
of objects in details in the upcoming
lectures it's a platform independent
language which means that again going
back to the previous point of write once
Run Anywhere it basically enables the
program to be run on any platform once
compiled so once you have prepared your
program and you have compiled your
program then you your compile program
can be run on any platform it is a
strong type checking language which
means that it will force you to respect
the contracts of the variables to the
data types for example if you have
created a collection which should accept
strings then you can only insert strings
in that collection and it will not allow
you to add an a number or an integer
into that collection so it's a strongly
typed checking language so when you run
your program it's a two-step process in
Java you compile the program and then
you it then you execute the program
which we also call as interpretation so
you have a Java compiler and you have a
Java interpreter you first compile your
program and then you run the program
using the help of java interpreter Java
also provides automatic garbage
collection it's a really important
feature and if you talk about the
languages prior to Java like C or C plus
plus they did not offer this capability
and and this capability made Java really
popular because it could automatically
find the unused objects and variables
and remove them from the memory to free
up memory space for the program
execution it also provides
multi-threading support which means that
you can build multi-threading
applications like a gaming application
if you take the example of a racing game
for example so there's they can be one
thread which is monitoring your
leaderboard score there can be another
thread which is displaying the speed of
the car there can be another thread
which is displaying the graphic there
can be another thread which is
displaying the sound so you see all of
these threads are working parallelly and
Java provides the support to create such
applications using the multi-threading
capability it has Java is secure by
default because there are no pointers in
Java so there are no possibilities of
having any memory leaks or any reference
leaks from the application again if you
take the example of programming
languages like C or C plus you had the
concept of pointers and we we witnessed
lot of a lot of scenarios and a lot of
incidents where there was a memory
leakage happening in the in the
production application which was which
was really a bad experience for the
organizations so Java removed the
concept of pointers totally from its
programming language it's also a very
robust language because it provides a
really great exception handling
framework out of the box which
developers can use and Implement to
build really resilient applications so
now let us understand how a Java program
is run so at first you basically write
your Java program and you store your
Java program into a DOT Java file then
you compile your Java file with the help
of the Java compiler once the program is
compiled the compiler is going to
generate another file which is a DOT
class file and this dot class file is
basically the compiled file or also
known as the byte code file so this byte
code or the dot class file code can be
run on any platform be it a Linux
platform or a Windows platform or a Mac
OS platform or any other platform to
give you some more context the first two
steps where you write your Java program
and you compile your Java program can be
run on any machine let's take the
example that you ran these two steps on
a Windows machine so you add your you
write your program and you compile your
program on a Windows machine which
generated a DOT class file then you
transported this dot class file to a
Linux machine and it also worked there
you transported your dot class file to a
Mac OS machine and it worked there as
well and that's what brings the platform
Independence concept of java that you
can write the program once on any
platform and once you have the byte code
available then you can run this program
on any other platform of your choice
okay so that was about how the Java
program execution works and how the
platform Independence is actually
achieved now let us spend some time to
understand the anatomy of java so once
you download Java and install Java on
your local machine you will hear the
term jdk actually if you will see that
in the next lecture that when you try to
download the Java it will say jdk
download jdk stands for Java development
kit so the Java development kit is the
installation of the Java this is what
you're going to install on your machine
once the jdk or Java development kit has
been installed the jdk will provide lot
of other components as well like Java
runtime environment or JRE Java virtual
machine or jvm some class libraries and
some other supporting libraries so let
us understand what happens when your
program is run and how these components
work together to make sure that your
program runs as expected it let's start
from here so you install jdk or the Java
development kit you write your program
and then you compile your program with
the help of java compiler which is
provided by jdk once the program is
compiled your dot class file will be
generated and then you can run
that.class file using GRE in fact if you
just run your program on your local
machine JRE will automatically kick in
and run your dot class file so the Java
runtime environment or GRE runs your dot
class file with the help of these three
components let's talk about first
component which is Java virtual machine
or jvm so the Java virtual machine is
actually the virtual environment inside
which your program runs this is the real
main environment inside your dot class
file is running so when when this
program is running how does it achieve
this environment for achieving this
virtual a virtual machine environment it
would need some runtime libraries and
that is provided by these class
libraries for example there would be a
runtime jar or rt.jar as a shorthand
which will be supplied to the program at
the runtime to make sure that the
program runs smoothly then there are
other supporting libraries as well which
your program may be using for example if
this program this dot class file is
let's say a calculator program then it
might be using a square root function
from java.math package so how do how
does the java.net package gets supplied
at runtime it would be supplied by the
other supporting libraries which are
present inside GRE so GRE will make sure
that your program runs inside the Java
virtual machine it gets the required
runtime libraries and it also gets the
libraries which are referred in your
program at runtime and this all together
will make sure that your program is
running so you can see JD okay basically
provides GRE automatically and jvm
automatically but you can also install
GRE separately if you talk about that
use case where you compile your program
on a Windows machine using jdk and then
you exported your dot class file to
another machine and there you just
install the GRE you don't install jdk
there you just install the runtime
environment and you can run the dot
class file just using the runtime
environment and that brings us to the
end of this lecture let's get started
with installing Java we will basically
look at how we can install Java on a
Windows machine so the first step to
install Java is to download it from the
official Oracle website so for that
let's open a web browser and let's type
jdk Java download and hit enter then you
need to find the link which says
oracle.com because like we discussed in
the previous lecture uh Java is owned by
Oracle so we need to download it from
the official website only so we can
click on this link which says Java SE
downloads it will bring us to the
downloads page and we will see different
versions of java you can see the Java
se15 you can see Java se14 you can also
see Java se11 and all the previous
versions another thing which you will
notice that it says LTS here which means
long term support basically long term
support are the releases for which
Oracle is going to provide long-term
security patches and updates for the
non-lts releases Java will not provide
long-term support and long-term patch
fixes and long-term security fixes so
it's a good idea to analyze and evaluate
on which version you want to develop
your applications on for this demo I
think it is fine we can go with the
non-lts version and even for your for
your customer facing applications you
can start with the non-lts version and
then upgrade to the latest PS version
whenever that is available so for this
demo we can download Java se15 and you
can also do the same on your machine it
will work exactly the same way as an LTS
works so you can click on the jdk
download option here let's click on that
it is going to bring up the downloads
detail page and you can see there are
multiple options given here in terms of
what platform you want to install Java
on whether it is a Linux platform or it
is a Mac OS machine or it is a Windows
platform so like I said in the beginning
of the demo that today we are going to
see how we can install this on a Windows
machine so I'm going to download the
windows x64 installer here if you are
working on a Linux machine or a Mac OS
machine you can download those
respective installers as well so you can
see the exe here so let's click on this
once we click on this we'll get this
pop-up which will ask us to accept the
oracle technology Network license
agreement so we can hit this checkbox
and click on download jdk 15 and this
shall start the download and you will
see some some exe getting downloaded in
in your download box here but as the
download is going to take some time and
I'm not going to wait for that and
that's the reason I have already
downloaded the jdk 15 for this
particular demo and that jdk is is
sitting here on my desktop which I have
downloaded prior to this demo so we'll
just run this particular exe which is
exactly the same exe as the one which is
being downloaded so let us double click
on this it will ask you for this pop-up
in some cases so you can just hit yes
basically it is asking whether you trust
this exe or not but as we downloaded
this from official Oracle website then
we can trust this particular exe so I
will hit yes and now the installer is
going to unpack and you might get a
screen like this which will be an
installation wizard for the Java SC
development kit 15. another thing which
before I proceed I just wanted to
highlight that as well that you might
have noticed about jdk here it's exactly
the same term which we covered in the
last lecture that when you install Java
you basically install the jdk which is
the Java development kit and this is
also visible here when it says Java SC
development kit 15. so let's hit next
then on this particular page you have
the option to change the installation
location of java if you want to by
default it is going to install in C
program files slash Java jdk15 but if
you want to change the location and you
want to install Java to a particular
custom location of your choice that is
also possible you just hit change here
and then you can choose whatever
directory or folder or place you want to
install this Java on and you can
basically select the appropriate
location for this particular case I
don't want to change that I'm happy with
the default location which is available
here so I'm just going to proceed with
this particular location here so I will
just hit next and then Java is going to
install and it's it's very fast
installation It generally takes few
seconds as you will see in this demo
basically it is going to unpack all the
all the libraries and all the runtime
libraries and all the class path
libraries which we discussed in the
previous lecture and put all that into
the location which we specified to
install Java it will also set up the
rest of the prerequisites which are
required to run Java successfully so
looks like the Java has been
successfully installed as is visible in
this message and there's also a next
step if you want to access the tutorials
or the API documentations the developer
guides the release notes Etc I don't
want to do that so I will just hit close
here and now if we want to just verify
if Java is is installed or not then we
can verify that from the command and
prompt let me just exit this and let's
go to the command prompt to verify to
see if Java has been successfully
installed so to do that uh we'll we'll
just open the search bar and we'll type
CMD it is going to show us this command
prompt here we'll click on this and it
will open the command prompt for you
like it has opened for me and there you
just need to type Java hyphen version
and you hit enter if you get a message
like this it means Java has been
successfully installed if you get a
message saying that Java is not
recognized as a command it means that
Java is still not successfully installed
and something has gone wrong in your
installation and in that case you might
want to restart you might want to go
back and reinstall this Java exe again
so in this case it looks like it has
been successfully installed and we can
also get some interesting information
from here we can see which version of
java has been installed it says Java
version 15. we we can also see that the
JRE is also installed the Java SC
runtime environment what JRE is also
installed and we can also see that the
jvm is also installed which is Java
hotspot server VM VM means the virtual
machine so if I connect this back to the
previous lecture we can see that the
Java jdk basically installed the JRE as
well as the jvm as well and the complete
Java package has been successfully
installed now we are ready to use Java a
Java program and run Java programs on
this machine and at this step I would
like to conclude this lecture in the
next session we will be discussing how
we can install Eclipse because that
would be the natural next step for any
Java developer that they want to install
Java and then they want to install
eclipse and start working let's get
started with installing eclipse on a
Windows machine so the first thing which
we need to do is to download Eclipse so
for that I'm just going to open my web
browser and type Eclipse download press
enter and then you need to find the link
which says eclipse.org downloads which
is the first link in my search results
you can also see it says Eclipse
downloads the eclipse Foundation an
eclipse Foundation is the is the
organization which maintains the eclipse
installers so we can click on this once
we click on this we will be redirected
onto the eclipse downloads page and
there again you will see bunch of
options you will see the default option
highlighted which would be the eclipse
installer for uh for GRE for Mac OS
windows and Linux and then you have some
other tool platforms option as well like
Eclipse G or Orion which you might want
to use for advanced cases but for
running Java applications all you need
is an eclipse installer which is coming
from here so based on your machine
Eclipse will automatically detect
whether you want a 64-bit installer or a
32-bit installer and you can just click
on this particular link which says
download 64-bit here so I'm just going
to hit download 64-bit it is going to
open this particular screen where based
on your current location Eclipse will
suggest the nearest possible
distribution mirror distribution mirror
is basically a server which is present
somewhere in this world which contains
this Eclipse installer exe and Eclipse
has created these servers all across the
Globes these servers are basically
called the mirrors and based on your
current location which will be deducted
taken taken from your ISP from the
internet IP address from which you are
accessing this particular website so
based on your ISP location it is going
to suggest you the nearest possible
mirror location so that your download is
the fastest so in my case the nearest
location is Netherlands here as you can
see and I I get a download option this
is the file name which says Eclipse
installer GRE windows 64.exe and if you
think that this mirror doesn't make
sense just click on this option select
another mirror and then you can choose
another mirror but generally it works
really well it works based on it works
based on your IP location and it's
generally the download speed is pretty
good based on the suggested mirror so
I'm not going to change the mirror
location because I think this works fine
for me so and I'm just going to click on
this particular button which is going to
start the download of the eclipse
installer so now I have I have hit the
download button and you can see right
now an exe has been download has begun
to download uh it is going to again take
some time and I have already downloaded
this particular exe just to save us some
time and I'm going to use that exe to
Showcase how we can install it another
thing just wanted to highlight is that
eclipse is an open source organization
it works on donations so if you feel
generous about it and if you feel that
eclipse is doing really great work you
can also donate to it which will show
here so we can move to the next step
which is about installing so you can see
here I have an installer here an exe
file basically which I have
pre-downloaded to Showcase this demo I'm
just going to double click on this and
it is going to unpack the installer you
can see this this icon will be presented
to you which says Eclipse installer by
oomph oomph is basically the provider
for this particular installer who
manages the installer and based on your
computer's capacity and speed it is
going to take few seconds and in the
background what it is doing is basically
it is unpacking this installer and
creating all the installation files
which it needs to successfully install
it on your computer once that is done
you will be presented with this kind of
screen and you will see that Eclipse
provides multiple different kind of Ides
for different set of developer
communities you will see an option which
says again Clips IDE for Java developers
you will also see Eclipse IDE for
Enterprise Java developers you will see
the IDE for C plus plus and C developers
web and JavaScript PHP Eclipse
committers who basically contribute to
the eclipse organization or RCP rap
tester scientific Computing there are
tons of Ides which Eclipse maintains for
our use case throughout this series I
think we will be focusing on this
particular IDE which says Eclipse IDE
for Enterprise Java developers you can
also use this particular IDE but this is
a very bare bone IDE with very limited
set of Integrations like it says it
includes a Java IDE a git client an XML
editor a maven plugin and a Gradle
plugin but if you look at the Enterprise
you will get more Integrations you can
use this particular IDE to work on
whatever you work here so these all will
work here but in addition you can also
use this IDE to build a web application
build a web service build a jpa
application data tools Java server Pages
faces Etc so this is more a more
advanced I would say and we will go with
this particular IDE and you can also
choose this ID if you want to but for
this demo we are going to choose this
one I will click on this then it is
going to show me which virtual machine
it is going to use so if you remember in
the previous lecture we installed Java
15 it has automatically detected that
location by reading by C program files
folder and it has automatically taken
that if you have multiple jdk
installations on your machine you can
click on this icon and change a
different Java virtual machine I'm going
to leave it as is again the installation
folder is also by default taken to your
C users username slash Eclipse slash the
Jee version number and again if you want
to change this you can also change a
different installation folder I'm going
to leave everything as default it will
automatically create a start menu entry
and a desktop shortcut and now I hit
install it might come ask you for a user
agreement so you can hit accept now and
now it has begun the installation the
installation generally takes a bit of
time to complete in some cases so again
it depends upon your in your in your
computer's capacity and speed basically
if it's a good robust machine with the
with good capacity the installation
might be very fast as you can see in my
computer and if you have a computer
which is not very strong on
configurations you can just be patient
and wait for some time and the
installation will be finished once the
installation is finished you will see
this launch option here you will also
have an option to keep an installer if
you want to show the readme file but I
think the the main option here which we
are going to use is the launch option so
if you hit the launch option now the
actual IDE is going to start up it's
again going to set up some configuration
files and some bootstrap configuration
files which it needs to and then it will
ask you to choose a workspace again a
workspace space is up to you where do
you where you want to create your
workspace the workspace is basically the
location where you you will create your
projects it will store those project
files and the source code of those
projects so it is up to you where you
want to create it again I'm going to
leave it as default here but if you want
to change it just hit browse here and
choose whatever location you want to you
can see you can choose you can go to PC
and you can choose whatever location you
want to I'm going to leave it as is and
you also have a choice that you don't
want Eclipse to ask this every time so
you can check this box and next time
eclipse is not going to ask you to
choose a directory as workspace and
every time you start Eclipse it will
automatically go to this particular
directory so you can either check it or
uncheck it based on your convenience and
hit launch once you hit launch it is
going to start the actual IDE as a
desktop application and you will get a
nice interface and a welcome screen from
Eclipse which will which will basically
show the basic overview of the screen
something like this so now you can see
that the eclipse ID has started it has a
welcome page which has multiple options
you can check out a project from Git You
Can import an existing project you can
go to the marketplace create a Java web
project or whatever or you can just
close this you have a nice navigation
project uh project Explorer bar here so
all the projects which you're going to
create will be listed here there are
also some quick shortcuts here for
creating different kind of projects and
if you don't want to use that just go to
file new and choose a kind of project
you want to create whether it is a maven
project or Enterprise application
project or dynamic web project or just a
project if you just hit just a project
you can choose a basic Java project to
start with click next give a project
name let's call it test demo you can
choose an execution environment here the
GRE and currently this particular IDE
has support up to 14 but I think this is
going to work fine we don't need to
worry about it we can also use our
Project Specific GRE like in this case
Java 15 which is the current
installation so I can use this option
because I want to use Java 15
environment because I have Java 15
installed so you can basically choose
whatever option you want to choose it
gives you flexibility in terms of
choosing the GRE whether you want to
choose an external GRE whether you want
to choose a Project Specific GRE or you
want to use the default GRE jdk
installation so you can use this option
as well if you want to project layout is
create either you want to create
separate folders for source and classes
or you want to create the use the
project folder again this is these are
just basic configurations which you can
play around with if you want to I'm just
going to leave it as is and hit next and
then it is going to just give me a
review screen here if I want to change
anything I can otherwise I can just hit
finish I can create a module name here
if I want to but I don't want to create
it so just hit on don't create and open
the Java perspective and that's it you
have a Java project here where you can
create your Java our files under this
SRC and you can start executing those
files we will look out on those details
in the upcoming lectures but for this
lecture I think this is what we wanted
to achieve we wanted to show how we can
install eclipse and how we can create a
very sample uh Java CLI project so this
is it for this this session in the next
session we will look at some of the data
types in Java let's get started with
primitive data types in Java we are
going to learn about the primitive data
types in Java and we'll also see a short
demonstration of it so let's get started
let's first just learn about those data
types I've just opened the official
Oracle documentation and don't worry if
you see how this link appears here you
can just open a browser window and just
type Java primitive data types and if
you hit enter the first link which will
be given is this particular link and
this is the same link which I have
opened so let's learn about the data
types now so Java has these primitive
data types which you can see here some
of them store numbers some of them store
Boolean values and some of them store
characters so the data types which store
numbers are byte short int long float
and double these six data types
basically are used to store any kind of
numeric value let's understand these a
bit more byte is the shortest possible
data type value which you can use in
Java to store numbers you can only store
numbers within the range of -128 to plus
127 so you can see the range is very
small and Java has created this variable
for use cases where you want to store
numbers which are very small value in
this range why do we provide these kind
of options just to save memory because
the smaller data type will require less
memory to be used in the Java program
similarly the next big data is short
which is a bit bigger than byte and the
range of this particular data type where
variables will range from
-3 to 678 to plus three two seven six
seven so that is the range for this
particular variable and you can see that
it has a it has a very big range as
compared to the byte data type so if you
want to store very values which lie in
this range you can use short the next
one is int data type you can use this
one to store even larger values which
range from minus 2 raised to power 31 to
plus 2 raised to power 31 minus 1 the
next one is long which is even bigger
than int and it can be used to store the
values within the range of minus 2
raised to power 63 to plus 2 raised to
power 63 minus 1. so as you can see as
we go from top to bottom from byte to
Long the size of the value which can be
stored using this data type increases
and that's how you will basically take a
decision of whether you want to use byte
or you want to use short or int or long
based on what size of the value that
variable is going to contain then the
next ones are float and double these two
have been created for the use cases
whether where you want to store the
values numeric values which have
decibels which are Precision values I
should also mention that byte short int
and long are only used for storing
absolute numbers which do not have any
decimal representation even if you try
to store a decimal value in these
variables they will automatically be
trimmed the decimal values will
automatically be removed and you will
only be shown the absolute values and in
case of float and double they can
maintain those precision and decimal
values so we use float for the use cases
where you want to store decimal
representations of the values and you
can see that the float value can store a
smaller Precision value but double can
store even a bigger Precision value so
if you have really big Precision values
to be maintained very big decimal values
to be maintained we should use double
and the float is used for storing a bit
smaller size of the Precision values I
mean its range of values basically
beyond the scope of this discussion if
you want to read more about this you can
go to this particular links which will
explain this in detail but the basic
idea is that float is good for storing
two Precision values and if you want to
go beyond that you want to use double in
some cases some people also use float to
store even Beyond two values as well so
it completely depends the main the
decision factor is how long the value
you are going to store in the decimal
and that will take the decide whether
you want to use float or double the next
one is Boolean which is used for storing
the Boolean values Boolean values can be
either true or false so there are only
two possible values and then we have
care which is used for storing
characters it is using 16 bit to store
the value and this is a very popular
Java question for beginner level
programmers that why does it store uh
needs 16 bit to store the character it's
because it stores a Unicode
representation Unicode representation is
the representation which can be accepted
across platforms across the world in
different character encodings so let's
move on to Eclipse now where I have
prepared a very short and simple demo I
am just creating a variable for each
data type and I'm printing them you also
see some things here like the these
keywords and don't worry about these
keywords I will cover these keywords in
detail in the upcoming lectures you also
see this and you can just for now you
can remember that system dot out dot
println is used for printing anything in
Java anything you want to print on the
console you would be using system dot
out dot println what is system what is
out and what is println again we will
cover these in the uh upcoming lectures
for now I'm just creating a bunch of
data types here variables here basically
I'm creating a cat type variable a byte
type variable a short type variable an N
type variable a float type variable a
double and a Boolean the way you create
variables is basically you put the data
type name you put the variable name
which can be anything you put an equal
sign and you put the value actual value
which this variable is going to store
and I've done the similar thing for all
of these variables Java wants semicolons
to be there when you write your
statements so please remember that your
statements always end with semicolons so
I've declared all of these variables
here a byte a short and int float double
and Boolean and then I'm printing all of
them basically here I'm printing the cad
variable here I'm printing the byte
variable here I'm printing the short and
so on so forth so how do we actually run
this application or this program we just
double click on this or right click on
this you go to this run as option you
see this run as Java application option
so you can hit this option it will run
the application and it will present all
the output here in the console tab let
me just bring this up so you can see all
the variables have been printed here and
this is coming from these print
statements like I said this is used
system.out.printellin is used to
basically print anything and I've used
that to print all the variables here
first I'm printing the carry variable
whose value is a then I'm using the byte
variable which is denoted by B and whose
value is 2 so you can see the value is 2
here then I am printing the third
variable which is C which is a short
type variable which has a value 22 you
can see short and this is coming here
the next print statement is int so you
can see int here with the value 45 and
this value is coming from here then we
have float we can see the float value
being printed here and you can see the
float value declared here you also see
an F here and this is the standard
naming convention which Java proposes
that whenever you declare float and
double you end them with f or D based on
whether it is float or it is double then
you see the double value which is having
which is having a bigger position than
float so I have printed the double value
using this particular print statement
which is printed here and then we have
the Boolean value which is stored as G
and the value of G is true and the same
value is printed here so whatever I
write here basically is printed here
this is just a placeholder and this is
the actual value so you can see that we
are able to use all the variables here
all the Primitive variables basically
which range from byte character byte
short int float double and Boolean and
that's it for this session in the next
session we will be discussing about the
non-primitive data types in Java eager
to uncover the world of java then have a
look at Caltech coding bootcamp by
simply learn so hurry up and enroll Now
find the complete course details from
the link in the description box let's
get started with non-primitive data
types in Java in the previous lecture we
talked about the primitive data types
and now we'll discuss about some of the
data types which are not primitive first
of all let's understand what is the
difference between primitive and
non-primitive so the primitive data
types are the ones which are by default
supported by Java and non-primitives are
the one which are a bit custom in nature
where you as developer have the Liberty
to define the nature of that data type
we'll look at some examples of that as
well but when we talk about which all
are the non-primitive data types we
broadly talk about arrays we talk about
classes we talk about strings as well
and we will cover some of them in
today's lecture and we have the a
detailed lecture upcoming about the
classes as well in fact in the in the
after after a few lectures we will cover
how we'll create classes as well but for
today's lecture we are going to focus on
string data type and array data type and
like I said for classes we have a
dedicated lecture upcoming so don't
worry about that and again for this
particular case as well I have already
prepared a demo for this and we'll
basically do some look at some Hands-On
examples to see how do we create these
variables what is what does these
variables mean and the first
non-primitive data type we are going to
talk about is string and before I go on
further I should also mention that it's
very debatable in the Java Community to
call string as a non-primitive data type
and actually technically speaking string
is a special data type it neither fully
lies in the Primitive category nor it
fully lies in the non-primitive
categories I am covering this as a
non-primitive data type because it's a
bit inclined towards the non-primitive
category degree why do we do this is
because Java does provide native support
for string handling in the jdk and
that's the reason some of the developers
feel that string is a primitive data
type which is primitively supported by
Java but at the same time string is so
customizable and it's so special in
nature it's the way it stores the value
the way it provides the operations and
handlings it's so different than
primitive data types that it cannot
fully be put in the same bucket as the
primitive data types so that's why I
said it's it's a special data type a bit
inclined towards the non-primitive
category so what is string basically we
covered about the cad data type in the
previous lecture and in care data type
you can only store A Single Character
right but if you want to store a
complete name of somebody then it's a
list of character it's basically lot of
characters together then in that case
you would need a data type to store the
that continuous sequence of characters
and that's what string does string can
store a continuous sequence of
characters technically string is
basically a character array you can call
string as a character array and don't
worry if you don't understand about the
word array I will explain that in the
same lecture so basically it stores The
Continuous sequence of characters that's
how that's how we Define string and you
see this string this is a basically the
keyword the data type basically in Java
so whenever you want to create a string
you need to write string with S capital
you need to give a name to the string
this can be anything and then you can
provide the value which is which this
particular string is going to contain so
you can see this is a continuous
sequence of characters
t-e-s-t are the four characters which
this string is going to contain and
after that again I am printing this
particular value and like I said don't
worry about this we'll cover this when
will when we'll write our first program
in Java so this is just to print the
string value I'm just putting a string
placeholder here and then I'm actually
putting the printing the values of the
string variable now string can be
created in multiple ways in Java this is
one way of creating it there's another
way of creating a string variable which
is this one which says again the string
data type some variable name a keyword
called new again don't worry about what
is this new keyword we'll cover this
when we'll talk about running our first
program in Java and writing the first
program from scratch then we again the
string and then we provide the value so
if I compare this line number four to
line number seven you can see the
difference is that I am still storing
the same value test but the difference
is that here there is no new string
keyword but here we have this new string
keyword so what is the difference the
difference is this that in this case in
this particular case string is going to
reuse the same object multiple times but
in this case every time you call this is
it is going to create a new object again
what is object it's just you can think
of it as for now you can think of it as
a memory block we'll Again cover objects
in details but these are two different
ways in which you can create string this
is generally the most popular way of
doing it because this is memory
efficient because you can reuse the same
variable again and again so I'm creating
the string variable here and creating
another string variable str1 here and
printing both of them then I've created
this strange looking thing here which is
basically an array array like I said is
also an a non primitive data type in
Java and array can store a continuous
sequence of anything that anything can
be a number that anything can be
characters that anything can be or a
floating number as well so basic idea is
that if you want to store a collection
or sequence of multiple multiple values
how do you do that you do that with the
help of arrays array is a data structure
a non-primited data structure in Java
which can store lot of values of similar
type we also call it as homogeneous data
structure which because it can only
store same data type values a
homogeneous data type values so the the
biggest way to identify array is this
square bracket whenever you see the
square bracket in Java it means it's an
it's an array variable so here I am
creating an integer array variable with
the name ARR this is the name of this
particular array it is only going to
store integer values because of
specified int and the moment I provide
the square brackets its mean it means
that it is an array so you can declare
an array like this and then you need to
assign a size to the array size is
basically denoting how many values this
data structure is going to store so I am
saying new again it's a keyword and I'm
saying that okay create a memory block
for storing two integers so this
particular array ARR can store at Max
two values two values at continuous
locations the next thing about array is
that it stores the value in a zero index
based location so like I said it can
store two values so the first location
will always be array of 0 and this is
how you specify the location for index
of the element which is going to be
stored so at the zeroth location of this
array I'm storing 0 the first location
of the array I'm storing one and this is
just to show an error scenario but I
will just comment this for now you can
just put double slashes and comment any
line so I'm just storing filling up this
array for two values and the two values
location would be zero index and first
index these are just continuous memory
locations and we denote those memory
locations as 0 and 1 array indexes
always start with zero and I'm just
putting some values here you can put any
values and then I'm printing the whole
array and I'm also printing the first
value of the array and we'll see how
this pans out and we'll also see how we
can change this so now we are going to
run this application so I'll just go to
run as and click on run as Java
application and once I hit that I get
this output here so let's understand
this output the first one is I'm just
printing the string which has the value
test and you can see it has printed here
it is coming from this line then the
next line which is printed is line
number eight where I'm saying another
string str1 and str1 also had the same
value so you can see another string has
the same value and then I have printed
the array here the complete array and
you see this changed value here it also
tells us that if you want to print the
array then you cannot just put the
variable name and print it the reason is
because this is a non primitive data
type and once you do this it is
basically printing the memory footprint
end of this array the whole memory
location where this array is stored
that's why you see this strange looking
number which is the memory hash code and
if you want to print any particular
value or any particular element inside
this array then you can do that by
providing the index location of that
element so here I have said that print
the 0th location element of the array
the zeroth location array element of the
array was 0 so you can see the value 0
here let me put some other value just to
just for fun and show you how this works
so just change the values and now let's
see what do we get for array 0 we can
see now I get value 3 because now that
at the zeroth location the three value
is being stored and that is what is
being printed here we can also print the
first value I'll just go run as Java
application you can see now the array of
first index is being stored which is
basically technically the second element
of the array but because array always
works on a 0 index based value format
that's why when we say array 1 the
second element is printed when I say
array 0 the first element is printed so
always remember that array is a zero
index based collection or data structure
basically what happens if I do this now
there is no third element in this array
because the array has the size only of
two elements and when I say ARR of 2
which means I'm trying to print the
third element in this array which does
not exist so let's see what happens in
that case I get an exception exception
is basically an error I get an error
saying that index 2 is out of bounds for
length 2 it means that the array length
was actually 2 and index 2 does not
exist remember it's saying index 2 not
the element 2. index 2 doesn't exist
because only index 0 and index 1 exist
this makes two elements and the actual
size is also two it does not have
capacity to store third element it does
not have the third element location
anywhere that's why it complains that
you are trying to print a non-existing
value so this is where I would like to
conclude my lecture about the
non-primitive data types so we covered
about string we covered arrays and like
I said we'll cover classes in the
upcoming lecture as well in the next
session we are going to talk about
tokens in Java let's get started with
tokens in Java when we talk about tokens
in Java these tokens are basically some
reserved expressions or words or symbols
which have a predefined meaning in Java
and you cannot override this meaning
because this meaning is already defined
by Java and you can use those
expressions those symbols and those
words in only the way Java wants you to
there is no way you can change the
meaning of those terms or those symbols
so we will be covering those tokens in
today's lecture these tokens are broadly
divided into five different category
series these categories are keywords
identifiers constants special symbols
and operators so let's talk about each
of them one by one so when we talk about
keywords these are the words which are
reserved by Java and they have a
predefined meaning you might have
already seen some of these reserved
keywords for example we have used int
when we were working on the primitive
data type lecture we have seen this as
well though we haven't actually found
out the meaning of this but we will find
out the meaning of this in the coming
lectures so don't worry about that we
have seen Boolean as a as a data type
again we have seen by it so these
Boolean byte end class care catch super
switch synchronized all the all the
keywords which you see here these
keywords have a predefined meaning in
Java and you use these keywords so that
you want to take an action and expect
action by Java for example if you call
something as int then you want Java to
treat it as int int will only have a
single meaning in Java and there is no
other meaning of int in a Java program
so that's the intent with the keywords
these are reserved Words which have a
predefined meaning and we will cover
these keywords at length during this
whole course the next token is
identifier and identifier is is nothing
but just a variable name technically and
we have already covered this this kind
of identifier when we were showing the
demonstrations for primitive data types
and non-primitive data types Etc it's
basically anything which you declare as
a variable is an identifier and when you
declare the variable name again Java
puts some sort of restrictions as to
what you can or cannot do when you work
with Java and you declare the variable
names for example these variable names
cannot start with numbers so you you
cannot have a variable name which starts
with any number you cannot have a
variable name which contains spaces in
between them you either have to fill
those uh if there's a if there's a
variable name which you think has two
parts for example student name then you
need to write it as student underscore
name so that you can create the variable
name with the same impact and still does
not contain space so spaces will not be
allowed when you create the variable
names similarly you cannot have plus
hyphen and Ampersand in the variable
names as well these are the restrictions
which Java puts on the identifier tokens
when whenever you create identifiers the
next one is constants and we will cover
these constants in detail in the coming
lectures as well but to give you an idea
of what constants are so constants are
basically exactly what they sound like
they are the identifiers which you have
declared in your program whose value
cannot be changed once defined so if you
write something as final int I equal to
5 then this value is fixed you cannot
change the value of I again in the
program Java will not allow you to
change the value of I again because I
has now become a constant because you
have put a final keyword in front of it
and again final is a keyword you see
final is a keyword basically so you so
these constants are treated specially by
Java that Java will make sure that their
values will never change during the
course of the execution of the program
this can come really handy when you have
situations where you do not want the
certain variables values to be to be
modified for example if you have an
application where you are counting the
number of applicants and if you have
declared the number of applicants as
final then every time you call the
application you can do a plus one to the
previous value the value will not be
re-initiated so it is very useful
concept and and it can be very handy in
in programs where you don't want to
change the values the next is special
symbols these special symbols are the
symbols which again have a predefined
meaning in Java we have already seen
this square bracket symbol in our
previous lecture when we were creating
arrays so whenever you use these square
brackets then Java would understand that
you are trying to either access or
create an array or you are trying to
access or create a list
Etc so this is predefined you cannot use
this anywhere else or with any other
meaning similarly when we talk about
these braces these standard brackets or
standard braces these again have a
predefined meaning in Java generally
whenever you will write functions and
methods in Java you will use these
brackets to define the parameters of the
function now you cannot use these
brackets in any other meaning in Java
Java will not allow you to use this
anywhere else apart from using it in
method parameters similarly the next one
is the curly braces and the curly braces
are used to define a code Block in Java
you might have already noticed that when
we were looking at the previous demos
you could see some curly braces then
some code and then the and then the
curly brushes would end for example if I
show you here it just it's just a sample
example and let me open the example
which we covered in the last lecture so
you can see this curly brush here and
this curly brush ends here right so this
defines a code Block in Java any code
block which you want Java to understand
will always be starting with a curly
braces and ending with a curly brace
remember I talked about the standard
braces you can see these are the
standard braces opening and ending and
this is where we are defining this
particular methods arguments now what is
Method what is argument don't worry
about that we will cover in detail but
just an introductory concept whenever
you are trying to define a method and
you want to pass any argument to the
method we use this brackets to do that
okay uh similarly this is semicolon is
used to close any Java statement so you
will see this semicolon here every Java
statement has to have a semicolon as
ending otherwise Java will complain that
it is a syntactical error so it is part
of the syntax you need to put the
semicolon and semicolon has only one
meaning in Java which is that your
statement is actually ending uh then we
have star and star is used for
multiplication and then we have equality
which is used for assigning any values
and again assigning any values is
everywhere you are seeing this equality
sign everywhere so these are all tokens
basically the last type of token we have
is operators and we will cover these
operators in the upcoming lectures in
detail with the examples but these
operators are basically some special
symbols like for arithmetic it would be
plus minus multiplication divide for
comparison it will be greater than less
than for logical it would be Ampersand
and and pipe operators bitwise again
will have some bit wise operation
operators so they so these are basically
different categories of operators and
under each category of operators there
are certain symbols like for arithmetic
we have plus minus we have come for
comparison we have greater than less
than etcetera so these again symbols are
also reserved by Java Under The
Operators tokens category you cannot use
these in any other meaning or in any
other way and like like I said we will
look at a detailed example of this as
well in the coming lectures so this was
a quick overview of what are different
types of tokens in Java so we have
keywords we have identifiers constants
special symbols and operators so this is
it this is all what I wanted to cover in
today's lecture and in the next session
we will be looking at data type
conversions let's get started with data
type conversions so when we talk about
data type conversion the whole idea is
to basically answer the question that
whether I can convert into data type
variable into a long data type variable
or a long data type variable to a float
data type variable and also vice versa
can I go back can I convert a float
variable into a long variable or an INT
variable and vice versa so this lecture
is about answering all of those
questions and we will basically look at
some examples to understand how the
conversion works but let me just explain
the basic principle the basic principle
is that smaller box can fit into larger
box but if we have to fit a larger box
into a smaller box you need to do
something else so what do you mean by
smaller box and larger box here the
smaller box is a variable or a data type
which has a smaller range if you
remember we talked about the range of
short byte end Etc and we could see that
as we go from short to byte to int to
long to float to double the ranges were
increasing right so we will follow the
same kind of analogy that if we have to
store our smaller range variable into a
larger range variable Java will
automatically do that but if I have to
store a larger range variable into a
smaller range variable then I have to
sacrifice some quality of the value and
we will look at the examples of that as
well so let's first take a look at the
example where we can store a smaller
range variable into a larger range
variable we call this as implicit data
type conversion so here you can see I
have declared an INT variable with the
value 100 and I am printing the int
variable then I have declared a long
variable and what I am doing that I am
assigning the value of int a to the long
variable B so I am not assigning a new
value to this long variable but rather
I'm just passing on the existing integer
value into a variable of type long
similarly after that I am taking the
value of this variable of long type and
storing this value into a float type so
you can see int is basically smaller
than long and long has a smaller range
than float so I'm just storing a smaller
range variable into a larger range and
then a larger range variable into the
largest range and then I am printing all
the variables values to see if this
actually is working can long
automatically store the value of a and
can float automatically store the value
of B here I am just printing the
variables and again using the concept of
the previous lecture this is just to
print the values and I will cover this
in detail in the next lectures of how
this works but here you can understand
that we can use
system.out.println to basically print
the values and here I'm just printing a
string and then the the value then again
the string and the value and here also
the string and the value so this is what
is happening in this program and again
don't worry about these details I will
cover about what these concepts are in
the upcoming lectures so let's run this
and see if the data type conversion
actually works so I will just right
click and do run as and go to Java
application and if I click on this I get
this output so the first output is
pretty straightforward I'm just printing
the int variable as is so this works
then I am storing the int into a log and
printing the long representation of a
which is B basically and this also works
without any errors or any warnings by
Java similarly when I talk about storing
the long variable into a float variable
C this also works but here you see an
additional decimal Precision here
because as we remember from the previous
sessions float is used to store values
which have decibels or which have
precisions so it it will automatically
convert your absolute number into a
number which has decimals whenever you
try to cast this into float casting is
also a word which is used some people
call it as implicit data type conversion
some people call it as implicit data
type casting so if you hear the word
data type casting or implicit data type
casting you can think that it is exactly
the same concept as data type conversion
so this is about implicit data type
conversion now let's look at an example
of explicit data type conversion how
does that work so using the same analogy
of the boxes now I will try to store a
larger ranging value variable into a
smaller range variable and see how that
looks like so I will start with the
largest which is which is double
variable so I have created a double
variable and as we know that double is a
is a variable which is used to store
decimal values so I'm storing this value
here and then I'm just printing the
double representation as is without any
changes then I'm trying trying to store
this variables value into a float
variable so I'm trying to go to a
smaller box now I'm trying to grow from
double to float and if you remember I
told you that if you have to do that it
will not work out of the box but you
have to do a bit uh something special as
well and this is the special part this
is called type casting type casting is
basically a way to tell Java to
explicitly cast this variable's value
into this data types variables value and
you always need to do this Whenever
there is no implicit casting happening
if you are trying to store a larger
value variable into a smaller value
variable you have to do this otherwise
Java will complain you will get a
compilation error so that's what I'm
doing I'm I'm telling Java to store the
value of a as a float and store the
value in F and this is where I'm telling
to store the value as float so you just
put brackets and you define float and
then I'm going entering the float
representation similarly in the next one
I am trying to store the value of this
double variable into a long so you can
see now I'm trying to go even from our
Precision data type to a non-precision
data type because long does not
understand decimal values so I'm trying
to store a variable which has decimal
values into a variable data type which
does not understand decimal values and
we will see how the output looks like
but here also you need to do the
explicit casting explicitly you need to
tell which data type this a needs to be
converted into that's what I do here and
then I print the long variable here and
then next I will again go down further
and I will try to store a larger long
variable type into a smaller int
variable type so again I'm trying to
store the value of B into a smaller data
type which is integer and I'm naming the
variable as C here again I have to do
this explicit casting I'm telling that
telling Java to explicitly cast the
value of B which is a long data type
variable into an integer C which is an
INT data type variable and then I'm just
printing the value so this is what is
happening in this program that from
double to float to long to end now let's
run this program and see what happens so
I will right click and go to run as and
choose the Java application option and
this is the output I get first of all
for the double representation the value
gets printed 0 is ignored then in the
float it works fine as well without any
Precision loss because float can also
print values up to one to two decimal
points without any problems even beyond
that actually so it works fine then when
we talk about the long representation we
are trying to convert a double variable
into a long variable and we see that the
Precision the decimal values are lost
this is expected because long does not
understand decimal values that's why
anything after the decimal but in fact
the whole decimal portion is gone when
you're trying to store double or float
into some Absolute Data type variables
like tint or long and then in in
representation since you already have
this long this long can easily be casted
to int by just providing this explicit
casting and the end representation also
prints 50. so we started from this value
and we ended up with these values when
we try to store them as long or int so
this is all I wanted to cover in in
today's lecture so we covered basically
about the data type conversion or data
type casting Concepts how does implicit
data type casting works and how does
explicit data type casting works and as
we know the concept the basic concept is
that the the value can easily be casted
from a smaller range to a larger range
without any changes or without any extra
code but when you have to go from a
larger value to a smaller value you have
to provide these casting instructions to
Java to successfully cast those
variables in the next session we will be
looking at how we can write the first
hello world program in Java and there we
will actually cover all the all these
things which which I have been saying
that we will cover so we will cover all
these ways of how we can write the first
hello world program in Java let's get
started with how to write your first
program in Java so I have been talking
about this lecture and the details of
this lecture in the previous lectures as
well and today we are going to focus
exactly on how do we actually write a
Java program so as we have already
covered how you can install eclipse and
how you can create a sample Java project
in Eclipse if you haven't seen that
please go back to my previous videos
where you can actually see that and once
you have created your Java project so
your Java project might look like
something like this you will have an SRC
folder here and under the ice SRC folder
you see some some namespaces sort of
things created here right we call these
as packages and in Java you can think of
package as something which can group
multiple related artifacts together this
is simply a grouping mechanism I can say
it's a way to put all the related
artifacts to a particular business
problem into a certain place for example
if you are working in an e-commerce
application so you have you might have
created multiple Java files for let's
say for checkout and then some more Java
files for the uh filters flow I would
say then some other Java files for
Designing the advertisements so you have
multiple Java files and these Java files
now below belong to these three
different domains so you want to group
them together for easy accessibility for
referencing each other files with the
within the code so if you want to
achieve that kind of flexibility you
would group the checkout code files into
a single package you can name it as
checkout package then you can similarly
do the same thing for the advertisement
package and for the filters package so
similarly I have created some packages
here which you can see you see a package
here which says IO GitHub vikesh Pandey
hello world and how do you create a
package you just right click on this so
you go to the SRC and you right click to
go to new and here you will see this
option which says package so you can
just click on this and write anything
which you want as the package name let's
call it as test package it says invalid
because the package is a keyword so it
is not allowing me to put package here
but let's call it test package one and
you can just click finish and you will
see a test package popping up here then
you can right click on this again go to
new and then you can create a Java class
now what is a Java class a class is
basically a blueprint for an object it
it's basically the specifications of an
object like I covered in the very first
lecture everything in Java is an object
or most of the things in Java are object
I would say so object is basically an
instance of the class so let's say you
create a class for if I take the same
example of e-commerce you create a class
for writing the business logic of
checkout and then you create instance of
this particular class to work for a
particular customer order so class is
basically a blueprint it's the
specification it's the skeleton of the
object so once you click on this you can
create a class now eclipse is a pretty
smart IDE it will provide you with bunch
of options on how you actually can
create a class what and it will also
provide use with some sensible defaults
for example it will automatically select
a source folder in your project which
you have created it will automatically
select a package in fact the currently
selected package and if you want to
change the package just hit browse and
choose any other package which you want
to choose so your your class file will
be created in that package then you can
provide a name to the class so let's
call it as test hello world and you can
see I have followed a sort of a naming
convention here the first character I've
kept it as capital and then any other
new word which is coming in my class
file name is also capitalized so Java
would expect you or and it would
encourage you to follow this naming
convention that whenever you are
creating a class always start with a
capital letter then small letters and
every new word you are writing can start
with a capital letter again Java will
not throw an error if you don't do this
h capital or W Capital but it's a good
practice the next thing is the modifier
we are going to cover the modifiers in
details in the in the upcoming lectures
but for now you can understand and that
anything which is marked as public is
accessible to every other Java class in
this whole project that's the basic
meaning of making a class as Public
public has the names suggests itself it
means it's visible to everyone so you
can select the super class and again
we'll talk about the superclass later
but this is the Java line object is the
super class of all the classes which are
created in Java again interfaces again
an advanced concept and there are some
other interesting uh defaults it
provides for the for example if you want
to create a main method now what is the
main method we'll just cover it in a
while so I will not do that I will leave
everything as default and I will click
on finish so I have this new file coming
up here and you can see it has
automatically picked up the package
which I selected and it has also written
public class test hello world with a
starting and ending curly braces in the
previous lecture we covered about this
curly braces that all the code block
have to be in the curly brushes whenever
you write a Java class the very first
statement Java would expect to have in
the class is package name so make sure
that you have package as a keyword and
then the actual package name as the
package name for that particular class
you can see the package follows a DOT
convention and it always ends with a
semicolon like all the Java statements
and with semicolon so that would be the
first thing which you will write in your
class second thing is the access
modifier of the class like I said you
want this class to be accessible to
every other file in this project then
you can mark this class as public the
next thing is the class keyword you need
to write this particular keyword as is
otherwise your class will not be
detected so you write this as class then
you write test hello world or whatever
name you want to write but make sure
that whatever public class name you
provide here that name should match with
the file name these two things should
match the file name and the class name
if they don't match you would experience
weird Behavior says the class will not
be compiled the class might not be able
to run Etc so always make sure that
whatever file name you provide you
always have a class with that name in
your file so my class structure is is
ready but there's nothing here in this
class in fact you cannot you cannot even
execute this class because for executing
the class for executing any class in
Java any class at all in Java you would
need a main method in Java main method
is the entry point method of the Java
whenever you are trying to run any
application be it a very small or very
large Java application you would always
and always need a main method in the in
the class in the project somewhere and
you need to tell the Java runtime to
execute that class and then the class
will have a main method and the your
program will start executing so always
have a main method otherwise your
program will not execute and how do you
write the main method so you first write
public then you write static then you
write void and then you write mean and
then you provide a parameter to this
method as this now let's understand what
did I actually write here first keyword
is public because this method has to be
public because like I said Java runtime
needs to be able to access this method
so the similar concept which applied on
the class is applied on this method as
well that the entry point method has to
be public otherwise Java will not be
able to find this method so you need to
make this method exactly as public the
next keyword is static you again need to
write this keyword as is and the reason
we write static here is because we we
want to run this particular class
without creating an object of the class
static is again a keyword which we'll
cover in the upcoming lectures but for
now you can understand that whenever you
want to access something within the
class without creating an object then
you need to create it as static then
next is void void is basically the
return type of this method the method
name is Main and it has to be main it
cannot be main one or main two otherwise
if you do that Java will not be able to
run your program because it will expect
you to write this particular method
exactly as what I have written here no
changes at all should be there if you
make any changes Java program will not
run because it will not be able to find
the entry point method which is the main
method so public static void main
remember that you need to have this in
your program so white is the return type
which means that this particular program
will not return anything back to the
runtime because a method can have this
capability to either return something or
not return something for example a
method which can add two numbers will
return the result of addition right so
we return the result return is the word
here in this case this method is not
expected to return anything because
there is nobody consuming it right Java
runtime will not do anything with the
with the return value of this particular
method that's why Java will force you to
write void here and Main is the exact
method name which you need to use Java
will expect you to supply a string array
argument if we covered arrays in bit
detail in the in the in the previous
lectures and we will cover arrays in
actually in the next lecture in very
detail but you can as we discussed that
array is basically a sequence of
characters or words or integers or
anything right so in this case this is
basically the mandatory parameter which
you need to write as is this parameter
name can be anything obviously it can be
ARG args or whatever you want to write
it as but the basic fundamental is that
Java will basically supply all the
command line arguments using this
particular string array that's why you
need to provide this then let's write
something in the program because this is
a Hello World program so I will just
write system Dot out dot print Ln and
I'll type A String here which says hello
world and a semicolon so again I have
been saying that I will explain this and
now I will explain this why do we need
this and what does this mean so as I
have told earlier that whenever you want
to print something on the console in a
Java program you need to write
system.out.print Ln now system here if
you just go if you just hover over it
Eclipse will show what it is so system
is basically a class which contains
several useful class fields and methods
it cannot be instantiated means you
cannot create an object of it and it
provides many facilities like standard
input standard output and error output
exactly what we want to focus here
because we want to use system class to
print something on the standard output
the standard output in this case is the
console so if you want to input
something or you want to output
something or you want to Output an error
then you need to use system class and
all of these standard input standard
output and error are streams and that's
what comes to the next word what is this
out out is a stream to print standard
output similarly we have system.err
which is for printing the error output
streams similarly we have system.in for
taking its standard input streams so
system.in system.out system.err these
all are these in out and err are streams
and then print Ln is the actual method
let's hover over that let's first see
out here so you can see this is a stream
object which is used to print anything
which is ready to accept output data
basically and then we go to the println
method and it says prints a string and
then terminate the line so like I
mentioned earlier as well this whole
syntax is used to print and actually
this is the code method this is the real
method which prints something on the
console so system class uses the output
stream to print something on the console
using the help of print Ln method there
is also a print method so there are two
methods one is printer one is print Ln
the difference is that in case of print
method the print method will not provide
you or terminate on a next line but in
system.out.println the Ln means line
here it will print something and it will
bring the cursor to the next line if you
do not use this and if you again use
another print statement then both of the
statements will be printed on the same
line I will show that as well but and
then we provide any random string here
which we want to print so you right
click on this particular program you go
to run as and you run as Java
application and you want to save this so
you can say always save resources before
launching and you see the output here so
this is how you can run your first Java
program now let's also see the
print so I will just copy this here and
I'll say hello world 1 let's say and
this time I will not use system.play out
dot println but I will use
system.out.print
just put a space here so that it's
visible so if I use print how does that
look like I go to run and I go to run as
Java application so now you see both of
the outputs are printed on the same line
there is no this output hasn't gone to
the next line and now if I run the same
program with system.out.print Ln methods
now both of these outputs will be
divided on two lines the first output
then a line break the hello world one
goes to the next line in the previous
run the hello world one was printing
right next to it on the same line so
that is the difference so this is how
you can build your very first program
the hello world program in Java in the
next session we will be discussing about
arrays in Java let's get started with
arrays in Java we discussed about arrays
in a bit detail when we talked about the
non primitive data types but this is a
concept and a topic which needs to be
understood well so that's why we'll go
we'll do a deep dive on arrays in this
particular lecture so as I described
earlier that array is basically a
container which can store values or a
sequence of values or sequence of
numbers or sequence of characters into
itself you can think of it as a box
which can store all the values in a
continuous fashion as you can see here
this is just a pictorial representation
and this is coming from the official
Java docs and you can see that we if we
create an array of size 10 then we have
these 10 blocks created here you can see
1 to 10 so the whole length of boxes the
number of boxes here are 10 but the way
arrays are designed is that the index
index is basically used to access the
element in this particular box the index
of the boxes start from 0 so it goes
from 0 to 9 so remember the array length
is 10 it array in the array can contain
10 elements events but the index of the
array starts with 0 and will always end
at length minus 1 which is 10 minus 1 in
this case which comes as 9 so it will
always be length minus 1 it will always
the index will always start from 0 and
go till length minus 1 length can be
anything in this case the length is 10
so the index ends at 9 if the length was
20 the last index will be 19 but in
total you have these 10 memory locations
we also call them as continuous memory
locations because they are continuously
placed and array basically blocks 10
memory locations and creates a container
over it so this is how an array
basically looks like inside the memory
and whenever you want to access the
elements of the array you will say array
of 0 or array of 1 or array of 2 you
basically need to specify the index to
access the element at index for example
if you want to access the element which
is sitting in this box you need to to
say array of index 8 and we'll see how
we can do that but this is the basic
understanding and idea of the concept of
arrays so let's try to understand this
with the help of an example I will
switch back to Eclipse IDE and I've
created a very simple program here to
demonstrate the functionality of arrays
here so we already covered in the
previous lecture of what is package and
what is public and what is class how do
we give the class name and what is the
meaning of this particular method so I'm
not going to cover that again we'll
start directly from here so here the
first thing which I'm doing is I'm
declaring an array of integer this is a
variable name the identifier basically
it can be anything and this is the data
type it's an integer array and as we as
we covered this as well that whenever
you put square bracket in front of a
data type it becomes an array data type
so this is an integer array
representation now we just declared an
array but we still haven't allocated a
size to it so you can do that with this
particular syntax so you can put the
variable name of the array and say new
int and put the right size here this
size can be anything and once you do
this now array will actually allocate
those memory boxes which we covered here
but the moment you do new into 10 this
box these boxes continuous boxes will be
placed in the memory and the memory is
allocated to this array we call this
memory allocation this is how you
allocate memory to the array so we
allocated memory to this array for
storing 10 integers the next thing is
now we can start storing elements in
those boxes so like I said that the
array index always starts with 0 so if
you have to store the first element you
actually have to store it at index 0
location so you give the array name you
provide these square brackets and you
put the index value within the square
brackets that is how you basically point
to a particular element inside the array
so we say an array of 0 and we put the
value 100 then we initialize the second
element which will be index 1 then will
be the third element which will be index
two fourth element index three Fifth
Element index four Sixth Element index 5
and so on until we store till the last
element so this is the tenth element
which is accessible as index 9 and the
value is a thousand basically so from
100 to thousand we stored 10 values in
this array and we stored them by
accessing the index and this is actually
the only way you can store values in the
array by pointing to the indexes so we
go from 0 to 9 and we stored all the
values 0 being the first element and
array of 9 being the last and the tenth
element remember the length minus one
concept okay so now we will try to print
all the elements one by one that's
pretty much what we are doing now so as
we covered in the previous lecture that
we use
system.out.print Ln to print anything
and we understood the whole meaning of
this so I'm not going to repeat that now
we want to print the first element the
first element is sitting at index 0 and
we can access that element with this
syntax by providing the variable name
and the actual index value so I'm just
writing a random string here which says
a limited index 0 and then I'm putting
this plus here and putting the variable
name this plus is basically used to
concatenate the output of a static
string with a random variable or
basically you can print anything with
using plus plus is used for
concatenation so I'm just trying to
print this whole value but here this is
a string value which is a static string
and then I have a value coming from the
array so whenever you have to print some
value from a particular data type or
variable or collection then you can use
this plus syntax to concatenate a string
static string with your actual value so
that's what I've done here by saying
plus and array 0 and similarly for index
1 I'm printing the the first index then
for 2 3 so far and so on so forth till
the index 9. so basically I'm just
printing the all the values of the array
starting from index 0 to index 9. so
that's all which which is written in
this program now let's try to run this
program so I will right click go to run
as and go to Java application and hit on
this and now if I just expand this
console you can see all the
system.out.printellent statements have
been executed and they printed this so
this is the static screen string part in
fact including the colon this is the
static string part element and index 0
printing exactly as is and then
dynamically the zeroth index element of
an array is printed here similarly we
have printed the index 1 location
element index 2 location element index 3
location element and so on so forth till
the index 9 location element so in total
these are the 10 elements but the index
always works from 0 to length minus 1.
in this case it will be going from 0 to
9. so this is basically all which I
wanted to cover in this lecture the
whole idea was to give you more
understanding of arrays and remember
this is just an integer array you can
similarly create a character array you
can also create a string array for uh
for you as well so it it's completely
it's completely related to the data type
you are using if you create a care array
then you can only store characters into
it if you create a string array then you
can only store strings into it and now
you can probably relate back to this
particular thing which I explained in
the previous lecture that we create the
string array for the reason that when
you run this particular program and if
you want to provide any command line
values command line arguments to the
program those arguments will
automatically be stored in this args and
then you can access this as args of 0
args of one Etc in your program that's
the whole concept so these are this is
the basically the Deep dive on array
which I wanted to cover and in the next
session we are going to cover about
operators in Java let's get started with
operators in Java when we talk about
operators in Java there are multiple
types of operators like assignment
operators arithmetic operators unary
operators then we have conditional
operators and logical operators and we
also have bitwise operators and we will
cover all of these operators one by one
we will understand what what these
operators are and how they work and we
will also look at a demonstration of it
so let's get started the first operators
we are going to discuss is about
arithmetic operators assignment
operators and we will also see if we can
cover engineering operators so when we
talk about assignment operators I have
again opened the official Java docs here
if we understand assignment operators we
have been using this operators all the
while in all of the demos so far and the
basic idea is very simple whenever you
assign a value to a variable you use the
assignment operator which is nothing but
the equal sign we have already covered
this in multiple demos so I will not
cover this as part of the demo but what
I'm going to cover in detail is about
these arithmetic operators so arithmetic
operators are basically used to perform
any kind of arithmetic operation on a
Java program it can be an addition
operation it can be a subtraction
operation it can be a multiplication
operation a division operation or in
operation by which you can find the
remainder of the division so we will
look look at each of these with an
example and as you can see the symbols
are expectedly what you generally use in
mathematics so you see the the plus sign
here which is for addition you see the
minus sign which is for subtraction you
see the star sign which is for
multiplication you see the slash sign
which is for division and you see the
percentage sign which is for finding the
remainder of a division so let's see an
example of each of these and how we can
use them in a Java program so for the
arithmetic operations I have prepared a
demonstration of it in the Eclipse IDE
again I'm using the same Java project
which I have shown you we created in our
previous lectures so I will for all the
demonstrations I will just continue on
the same project so again the way to
create a class Remains the Same exactly
the same as how I covered in the
previous lecture in the hello world
program where we created a class so here
also I created a class I named the class
as arithmetic demo and I have a public
static void main method inside this
particular class and I have basically
tried to demonstrate each of the
operation so let's start with the
additional operation first so I create
an integer variable here named as result
and then I try to use the addition
operator to make this variable store the
result of this Edition so it's a simple
one plus two you can also create two
different variables for one and two
let's say X equal to 1 and y equal to 2
and you can also do int result equal to
X Plus y it will have the same effect
but just for Simplicity I have put the
literal numbers here so result is
storing the the expression value of 1
plus 2 and then I am printing this value
here you can see I am printing the
result variable here with using
system.out.printellin then I'm storing
this result into a variable into a new
variable original result with using the
assignment operator and then I'm trying
to subtract something from it so now I'm
saying result equal to result minus 1 it
means whatever the current value of
result is subtract minus 1 from that
value so the value was 3 here and here 3
minus 1 becomes 2 so the new value of
result becomes 2. the original result
still holds 3 because it is storing the
old value the new value of result has
now become 2 so I'm printing the
original result and then what I'm doing
that I'm again assigning the new result
which is 2 to the original result so now
original result and result both are at 2
then I move ahead and I try to
demonstrate the multiplication operation
so I take the same variable result and I
say multiply it by 2 so whatever the
value of result was which at this place
should be 2 multiply that value by 2 so
2 into 2 the new value of result should
become 4 after this multiplication
operation and again I'm assigning the
value of original result to this
particular variable and then I'm
showcasing the fourth mathematical
arithmetic operation which is division
so you can see result by 2 here so
basically whatever the current value of
result is I am dividing that value by 2
so 4 divided by 2 should become 2 so
again the new value of the result
variable should become 2 then I am
printing the value and again storing the
value back into the original result then
the next operation is again an addition
operation where I whatever the value of
result is at this particular point which
is 2 add 8 to that particular value so
the new result value becomes 10 and then
I'm printing that particular value again
assigning the original result to the
result and then to showcase the
remainder operation on doing result we
call this particular operator as mod or
modulus so result modulus 7 so the
current value here is in this case would
be 10 so I'm saying 10 mod 7 so 10 mod 7
would become 3 because if we divide 10
by 7 the remainder should be 3 and this
modulus operator is used to calculate
the remainder of a division operation so
that 3 will be stored in this result
variable and then we print that
particular variable so that is what I'm
doing if I take you back up there I will
just minimize this window and this
window as well so if I take you by back
to the starting I am doing an addition
first here at line seven then I am doing
a subtraction at line 12 then I'm doing
a multiplication at line 17 and a
division at line 22 and then again an
addition at line 27 and then our modulus
at line 32 and I'm printing the
respective values so let us run this
program and see what results do we get
so I right click I go to run as I go to
Java application there is also a
shortcut for it if you want to use the
shortcut you can use that so I click on
this and the output is is displayed here
so you can see let me bring this output
back to its original position yeah I
just dragged it here to the top to the
bottom so if we start from the top and
see what all results did we get printed
so line 9 says 1 plus 2 equal to the
value of result so 1 plus 2 equal to at
this particular point the result will
value was 3 because 1 plus 2 equal to 3
moving on the next variable here is
minus so the current value was 3 we said
3 minus 1 which becomes 2 and we store
the value of result or 3 into this
result variable and we print that value
at line 14. so original result plus
original result is 3 then a string here
minus 1 equal to so this is just a
string and then the actual current
result value which is 2 so far so good
we move ahead and then at line 19 we are
multiplying the current value of result
by 2 and again displaying the original
result and the current value so 2 is the
original result here because here 3
minus 1 had become 2 so original result
value was to multiply that by 2 becomes
4 then moving on to the line 24 2 by 4
by 2 should become 2 so 4 by 2 equals 2
the current value of result then again
and moving on to the next variable at
line 29 now the result value should
become 10 because 2 plus 8 is 10 and
again we are printing the original
result and then the current result value
so the original result was 2 then we
added 8 to it and the new result value
had become 10 which is coming from this
particular variable moving on to line 34
we are again printing the original
result which was 10 here and then we are
saying this particular string which is
modulus 7 and the current value of
result is coming from this expression
which is 10 modulus 7 and like I said
modulus or mod operation is basically
used to calculate the remainder of a
division operation which so 10 divided
by 7 remainder is 3 so that becomes 3
and that's why you see the value 3. so
this is a demonstration to show you how
we can use the addition multiplication
subtraction Division and modulus
operators which are all the editor
automatic operators so in the next
session we will be discussing about the
other operator types which are generally
operators and we will also discuss some
other interesting operators which are
popularly used in Java let's get started
with jewelry operators so when we talk
about unary operators technically they
are also arithmetic operators but they
provide us a shorthand or they have a
more advanced meaning so if you see on
the screen these are the unary operators
we call them as junary plus unary minus
increment Operator decrement Operator
and logical complement operator so when
we talk about the engineering plus
operator basically it is used to
indicate a positive value so whatever
value you are having it will just make
that number as positive number you might
be wondering that this plus has an
addition meaning as well right which we
saw in the previous example yes that's
correct but when we use that addition
symbol we use that between two variables
but when we talk about unary operators
they are used with a single variable
that is why the name generally because
they are used with a single variable
they require only one operand so
generally plus basically makes any
number positive usually minus negates an
expression and makes that number
negative increment operator increments
the value by plus one decrement operator
decreases the value by minus 1 and
logical complement operator inverts the
value of the expression from True to
false or false to True let's understand
this with the help of an example so I
have created a class here called unary
demo and I have a static void main
method here and I have created a
variable called result and the first
example is about using unity plus so I'm
creating a variable called as result
assigning the value as 1 and just
putting 1 plus in front of it which
makes this as positive value though we
can argue that this also has the same
effect as this and yes that is true but
in case if this value was written as
something like -1 instead of plus then
we could basically make that number
positive by just putting Plus in front
of it so that's basically the power of
unity operators and that's how you
generally use unary operators so I'll
just put it back to plus one the next
example is about decrement operators so
the current value of result was 1
because we did this now we are saying
result minus minus which means whatever
the value of result is just decrement it
by 1. so the current value was 1 so now
the new value of result after this
evaluation becomes 0. so at line 14 we
print the current value of result which
is 0. moving on at line 16 we are using
the increment plus plus operator here
which means whatever the current value
of result is just increment it by 1. so
the current value of result was 0 till
this line so it becomes 1 because this
means increment by 1 so line 18 will
basically print that value 1 and then at
line 20 I'm using the unary minus
operator which means whatever the value
of result is just negate it just put a
negative in front of it just make that
number negative so if I just say minus
result the current value of result was 1
so it became minus 1 and then to
showcase the negation operation I
created a Boolean variable named it as
success assign the value of this
variable as false and printed the value
of success variable as is first and then
print the value of success with a
negation in front of it with an
exclamation mark which will basically
flip the value or invert the value of a
Boolean variable so if this was false
line 28 should print true if this was
true line 28 should print false in this
case this is false so the line 28 should
print true so let's right click on this
and run this program and see if we get
the expected output and yes we see the
output here so let's try to interpret
the output now the line 10 should print
1 yes then line 14 should print 0 we see
0 here line 18 should print 1 because we
use the increment plus plus so 0 plus 1
became 1 then we use the unary minus
operator so the value should become -1
yes VC minus 1 here and then for Boolean
variable we should see first of all
because the value is printed as is and
then we are printing a negated value so
we should flip the value from false to
true and yes it is printing the value as
true so this was about unary operators
now when we talk about this increment
and decrement operators what if I put
this particular value in front of result
what effect is that going to happen
let's analyze that part as well so for
that I have prepared a separate demo
again I've created a class called
pre-post demo and it has a public static
void main method I'm declaring an
integer variable I with the value as 3
so the I becomes 3 here and then I'm
saying I plus plus as we have already
seen in the unary demo example this
should increment the value of 3 to 4 so
it will print 4 expected right then at
line number nine I am putting this plus
plus in front of I now what will happen
now it is going to increment the value
of I and then and basically assigning
the value of I so the whole difference
between I plus plus and plus plus I is
that in this case the value of I is
assigned first and increment later in
this case the value of I is incremented
first and assigned later so here the
value from 4 becomes 5 so at line 11 if
you see if we print I it will print 5
because we have we are saying that first
increment the value and then update the
value of I so increment happens on I
equal to 4 and I becomes 5. at line
number 13 it becomes more interesting
because here inside the system.out.print
Ln statement itself I am saying plus
plus I now what will happen like I
explained first the value will be
incremented and then the value will be
assigned so before printing the value is
getting incremented so the value from 5
becomes 6 here at line 13 but if I try
to do this now I am saying first assign
the value of I and then increment it so
I at this line is still 6 because I has
already been assigned 6 and as the post
increment says if we put this plus plus
after the variable it means that you are
first assigning the value and then
incrementing the value so anything which
happens after line 15 the value of I
will become 7 but at line 15 the value
of I is still 6 because we are using a
post increment operator so the value is
still assigned to I as is and then
incremented and when we do
system.out.println the assigned value is
printed not the incremented value so
like I said after line 15 the value of I
will become incremented by 1 and it will
become 7. so hope you understood this
example or and the difference between
the pre-increment and post increment
remember the thumb rule that if we put
plus plus before a variable like at line
number nine the value will be
incremented first and then assigned so
at line 13 the updated value will be
printed because the first we are doing
the increment and then we are printing
the value for assigning the value
similarly at line 15 we are first
printing the value and then incrementing
the value so when the value is printed
at line 15 the old value 5 will be
printed but after line 15 the new value
of I will be accessible to the program
so let's right click on this and run
this program and now if we see the
values we assigned I to 3 we did a post
increment here so I becomes 4 we print
the value of I so here the value of I is
4 you see 4 here then at line line nine
we are saying plus plus I so four plus
one becomes 5 though this is is a
pre-increment but since we are not
printing this plus I as is it does not
have any any change so the value of 4
becomes 5 at line 11 we print 5 then at
line 13 we are saying plus plus I which
means increment the value of I first and
then assign it so the value of 5 becomes
6 and then I gets updated and printed
similarly at line 15 first the value of
I is assigned and printed and then
incremented so at line 15 the value is
still 6 you see this 6 here and then the
value is incremented so after line 15
the value becomes 7 so that's how we are
basically using the unary operators and
this is where I would like to end this
particular session in the next session
we will be discussing about other type
of operators which are comparison
operators and logical operators
Etc let's get started with equality and
relational operators when we talk about
relational operators they are sometimes
also called comparison operators and the
basic idea behind using these operators
is to compare things or compare the
values of variables or compare the
objects in Java so in Java if you need
to compare anything for example if you
want to compare if something is less
than the other thing or something is
greater than the other thing or
something is equal to the other thing
then you need to use the comparison
operators which are provided by Java
here you can see I have opened the
official Java docs and you can see a
bunch of comparison or relational
operators both of the terms are used
interchangeably some people call them
comparison operators and some people
call them relational operators so you
can see if I want to compare if an
object or a value is equal to another
value then I use the double equal sign
if I want to compare for non-equality I
will use exclamation with an equal to
which means not equal to if I want to do
a greater than comparison then I will
use the mathematics greater than symbol
if I want to do the greater than equal
to or less than or less than equal to
they again follow the same kind of uh
terminology as we see in mathematics so
this is all we have in terms of the
relational operators so let's understand
the usage of these operators with the
help of some examples so as you can see
I have created a class here which is
called comparison operator there is a
public static wide main method inside
this class and this method has two
variables of integer type called value 1
and value 2 value 1 has the value 1 and
value 2 has the value 2 and then I am
trying to compare the value 1 and value
2 variables using the different
relational operators we just covered for
doing that I need to use a a conditional
operator as well we will be covering
conditional operators in much much
detail in the upcoming lectures but for
now you can understand that when we talk
about conditional operators we talk
about if and else statement so if is
again a keyword in Java which can be
used to compare things and the syntax is
very straightforward you write the if
keyword and then you write the actual
comparison syntax or the actual
comparison expression so in the first
example we can see that I am writing a
condition which says evaluate if value 1
is equal to Value 2 I should put a curly
braces around here you can see there are
no curly braces here but that is for a
case when you have only one statement
under it but again I will cover this in
detail and I don't want to confuse the
audience here so I will just put curly
braces around all of these if statements
so that it becomes easy to interpret
what is actually going on in these code
blocks as we know that these curly
brushes are used to define a code block
so the first if block says compare if
the value 1 is equal to the value 2 if
yes then this condition will become 2
and the control of the program will go
at line number 10. if this condition is
not true then the control will not go
inside 10 because this condition is
false so it will never go to line 10 and
it will move to line 11 or 12 instead
similarly the next condition is we are
comparing the value 1 is not equal to
Value 2. so this condition will only be
true if these two values are not equal
or unequal and if that is the case then
line 14 will execute it otherwise line
14 will not be executed similarly in
this condition I am saying compare if
value 1 is greater than value 2 or not
so if the actual value hold it by value
1 variable is greater than the value 2
variable then this condition will become
true and the line 18 will be executed
otherwise it will be skipped then
similarly at line 20 I am doing the
reverse from pairing if value 1 is less
than equal less than value 2 if that is
the case then line 22 will be executed
otherwise it will be skipped and At Last
I am also showcasing an example of less
than equal to operator that you put less
than and equal to together and again you
compare the two variables similarly you
can also use greater than equal to
variable comparison operator as well in
this example so we have an example of
equality not equal to greater than less
than and less than equal to let's run
this example to understand so for
running the example I will just right
click here go to run as and click on
Java application and we can see the
output here so as the value 1 holds the
value 1 and value 2 variable holds the
value 2 obviously 1 is not equal to 2 so
the first condition is not going to be
evaluated to true so line 10 will never
be executed because 1 is not equal to 2.
similarly if I talk about the next
condition which was if value 1 is not
equal to Value 2 then execute statement
40 and yes 1 is not equal to 2 that's
why we see this particular system dot
out dot println here we see this printed
moving on is value 1 greater than value
2 so is 1 greater than 2 no it's not so
line 18 will never be executed then the
next one is is value 1 less than value 2
so yes 1 is less than 2 so line 22 will
be executed and we see the line 22
output here
system.out.printel and output moving on
is 1 less than equal to 2 yes 1 is less
than equal to 2 so this particular
condition is also true and line 26 will
be executed and that's why we see this
here and that's all so we can see that
we are able to use these comparison or
relational operators to evaluate
different conditions and we write those
conditions using the if block and again
if you do not understand the if block
fully don't worry we will be covering
the if blocks in in detail but the focus
here is in using the operators they are
not equal to operators the greater than
equal to operators less than equal to
operators Etc so I hope these operators
give you better understanding of how to
use them now moving on to the next
section of this comparison operators
sometimes we also use some logical terms
to do the comparison for example if I
just move down here and I show you these
conditions here we call them conditional
operators conditional operators are used
to evaluate the conditions like and or
or and we use them in two two ways
either we can use it as Ampersand or
double Ampersand or we can use them as
pipe or double pipes so the idea is
basically to evaluate if one condition
is true and other condition is also true
or one condition is true or other
condition is true so whenever you want
to combine two conditions together
that's where you are going to use this
is logical operators or conditional
operators you can also use the simple
English keywords like and or or you can
use the logical representation of these
keywords for example Ampersand Ampersand
or double Ampersand is equivalent to add
similarly double pipe is equivalent to
or so we can use these as well
interchangeably you can use either of
these operator representations to run a
conditional check in composition meaning
you can compare two conditions saying
okay if one is true and second is true
or one is true or second is true so the
whole focus is here in and and or
comparisons so let's switch back to the
IDE and let's look at an example of this
to understand this in detail so I will
again take the similar kind of example
again I have created two variables here
value one and value 2 value 1 has value
as 1 and second variable value 2 has
value as 2 and then I am writing two
conditions this time in the same if
block you can see I am writing first
condition saying is value 1 equal to
equal to 1 and is value 2 also equal to
equal to 2 so this whole if condition is
only going to be true only if both of
the conditions are true that's the
property of and and will force that both
the conditions on the left hand side of
it and the right hand side of it hold
true and then only the whole expression
is going to hold true even if one of the
conditions evaluate to false the whole
if expression will evaluate to false
similarly for or conditions we again
write our left hand condition and a
right hand condition and in between we
write this double pipe we can also write
o r or in English that will also have
the same effect and this will evaluate
in a way that this whole expression this
whole expression will evaluate to true
if even a single or condition either on
left side the right side of it becomes
true so or we'll just need one
expression to be true to make the whole
if condition true whereas and will force
both of the conditions to be true to
make the whole expression as true so and
will require two truths to actually
become true but or condition will
require only one true to become true so
if we try to do understand this logic
here I am saying that if value 1 is
equal to equal to 1 which is correct and
value 2 is equal to equal to 2 then make
this condition as true so yes in this
case this condition will evaluate to
true because value 1 has value 1 1 and
value 2 has value as 2 so it will print
the line 10 whereas in the next
condition I am saying evaluate if value
1 is equal to equal to 1 or value 2 is
equal to equal to 1 so either of the
expression if becomes true either the
left side this expression or the right
side this expression either of the
expression becomes true this whole
condition will become true and line 14
will be executed line 14 will not be
executed only in a case when both of the
conditions here become false for example
if I write it like this then we know
that value 1 is not equal to 4 because
it's 1 and value 2 is not equal to 5
because it's true in that case both of
the expression will become false and
then line 14 will not be executed if I
write it like this then the left hand
expression is evaluated to true because
value 1 is 1 but the right hand
expression is false but it's fine the
line 14 will still be executed because
either of these side is true so the
whole expression becomes true similarly
here and will require both of the
Expressions to be true and if either of
them becomes false then the whole
expression becomes false so in the
current state line 10 will be executed
but if I change this to this then the
left hand side of this Ampersand will
evaluate to false and the whole
expression will evaluate to false that
case and line 10 will never be executed
let's try to run all of these scenarios
to make a better understanding of this
so in this case both of the conditions
should work fine so I will just right
click and run as Java application and
yes we see this line 10 being printed
and we also see this line 13 being
printed so both of the lines are printed
correctly both of the conditions are
evaluating to true now let's try to play
around with it let me change this value
to 4 so now value 1 this left hand side
expression is false which should make
the whole expression as false and it
should not print the line 10 which is
the statement so let's run this program
and see if that works yes we see that
this particular line is not printed now
because this whole expression became
false because the left hand side of this
expression became false similarly in the
OR case either of them has to have to be
true you can see currently value 2 equal
to equal to 5 condition will actually
result in a false condition because this
is not a true value 2 is actually 2 not
5 5 and still we see this particular
expression because either of them have
to be true if I make both of them as not
true now both of the conditions on the
left hand side of pipe and right hand
side of pipe are false conditions what
will happen now nothing will be printed
the reason for that is that value 1 is
also that this condition is also false
and value 2 condition is also false so
the whole expression become false and
this was already false so this is all I
wanted to cover in this lecture we
covered our about the comparison
operators and how to use them and in the
next lecture we are going to talk about
the bitwise operators let's get started
with bitwise operators now bitwise
operators are very less commonly used in
the Java programming World generally we
don't use them and generally we don't
need to use them you would generally use
them when you are doing really complex
bitwise calculation where you need to
manipulate the bits now what are
actually bits so if you remember when we
talked about the integer type variables
we talked about how much memory each of
the variable type or data type was going
to consume we said that this will take
one byte and this will take two bytes
Etc one byte is basically made up of
eight bits and bits are nothing but
positions where either a 0 is stored or
one is stored actually the whole machine
will convert your whole program
ultimately in zeros and ones which are
nothing but bits so if you want to do
the manipulation at that level so now
you can understand you are you are
actually working at right at the Machine
level understanding so if you want to
manipulate the bits which are going to
be understood by the machine at that
level then you can use bitwise operators
but like I said generally we don't need
to use them now when we talk about
bitwise operators there are multiple
ways in which we can use them we can use
them with the standard and or or
operations if you remember we covered
this and or operations in the previous
lecture you see a difference here that
in case of and we are using a single
Ampersand or and not double Ampersand
this is one of the concept which we did
not cover in the previous lecture and I
would just like to brief you about this
concept that if you use double Ampersand
that is also called a short circuit
operator and if you use a single
Ampersand that is called a standard
operator to build an understanding about
this I will just quickly recap of what
we covered in the last lecture and we'll
try to explain these Concepts as well so
let's go to The Logical operator demo
and here if you remember there were two
ampersands and two pipes this is also a
valid expression a single Ampersand is
also a valid expression the only change
is in this case even if the left hand
condition evaluates to false still the
right hand condition will be evaluated
although we know that in case of and
either of the expression needs to be
false and the whole expression become
comes false so Java provides an
advantage or with that if you use double
Ampersand and if the left hand operation
becomes false then it will not cover the
right hand operation it will not even
evaluate the right hand operation
because it doesn't matter if the left
hand operation has already returned to
false or evaluated to false then no
matter whether right side is true or
false the whole expression is still
going to be false right that's the
property of and
one of the side has to be false and the
whole expression becomes false so why
why evaluate two sides why waste the
memory in evaluating the right side when
the left side has already turned as
false Java takes advantage of that and
that's why if you use double Ampersand
you save a bit of processing power of
your computer by just evaluating the
left hand condition and if the left hand
condition is false it will skip
evaluating the right hand condition and
just make the whole expression false but
if you use this a single n percent then
both side of the expression will be
evaluated irrespective of their output
so in this case even if the left hand
expression is false it is still going to
evaluate the right side expression and
similarly it works for the or case as
well in this case in our case as we know
if one of the condition is true the
whole condition becomes true the whole
expression becomes true so if the left
hand side becomes true and if you use a
single pipe then it will still evaluate
the right hand side but if you use
double pipe like this then if the left
hand side becomes true then it knows
that it does not matter if the right
hand side becomes true or false because
ultimately the whole expression is going
to be true if either of the side is true
so if the left hand side is already true
it will not evaluate the right hand side
and it will say the whole expression is
true that's why you see the single
Ampersand being used for bitwise just to
explain why it why it is used and how it
is used for for our operations in
bitwise you use this cap or whatever you
want to call it as and for the inclusive
bitwise or opera or operation you're
going to use a single pipe you also use
some shift operations where you shift
the value of bit of a particular
variable to either left or right again
these are again very complex
calculations if you want to use that
please read about this and use that but
in the in today's demo what we are going
to cover is the and and or examples of
bitwise operations
so here I have again created a class
called bitwise operator I have a public
static void main method I have two
variables here which are int a equal to
5 and int b equal to 7. now these five
and seven are actually stored as bits as
zeros and ones in the computer's memory
so how they are actually stored they are
stored in a standard bit representation
which you may have uh studied in your
mathematics if to give your recap this 5
will basically be written in a memory as
this 0 1 0 1 and it starts from here 2
raised to power 0 into 1 becomes 1 2
raised to power 1 into 0 becomes 0 2
raised to power 2 into 1 becomes 4 and 2
raised to power 3 into 0 becomes 0 so 4
0 plus 4 plus 0 plus 1 becomes 5 and
that's how 5 is displayed to you
similarly for 7 2 raised to power 0 into
1 is 1 the plus 2 raised to power 1 into
1 is 2 so 1 plus 2 3 plus 2 raised to
power 2 into 1 which is 4 so 1 plus 2
plus 4 7 and 2 raised to power 3 into 0
is 0 so 0 plus 4 plus 2 plus 1 which is
7 and that's how this 7 is built and
stored and now if you try to do this if
you try to write this condition you can
also write the condition into a system
dot out dot println block and it will
basically evaluate this condition so now
if you say A and B in this case this is
going to do a bit wise operation because
this is bitwise operand it is going to
do a bit wise operation and the what
would be the result if you do an and on
this so again use the same logic as if
in case of and if one is false then the
whole expression is false so 0 and 0
becomes 0 1 and 1 becomes 1 0 and 1
becomes 0 because 0 means false and 1
means true so if either of them is false
the whole evaluation becomes false so
that's why 0 or and 1 becomes 0 and 1
and 1 is always one the value of this is
again 5 as we already have evaluated
similarly if you do a bit wise or and if
you do this again we are doing an R
operation so 0 or 0 or basically false
or false becomes false true or true
becomes true false or true should be
true because one of them needs to be
true so this is false but this is true
so the whole value becomes true and the
finally true or true is also true so
this is the final bitwise or result and
if we convert this into an integer
representation that becomes 7 because 2
raised to power 0 into 1 is 1 2 raised
to power 1 into 1 is 2 so 2 plus 1 3
plus 2 raised to power 2 into 1 which is
4 so 4 plus 2 plus 1 which is 7 and plus
2 raised to power 3 into 0 which is 0 so
0 plus 4 plus 2 plus 1 becomes 7 and
that's how you get actually seven so
let's see if we get 5 or 7 in this bit
wise operation yes we can see the values
as five and seven so this is a bitwise
operation happening similarly you can
also use the shift operations where in
case if you're using the this particular
kind of representation or this
particular kind of representation they
are called bits they are called left
shift and right shift operations so if
you use this in front of a variable then
for example this one will be shifted
here and this 0 will be shifted here and
this one will be shifted here so that's
how the whole value is going to shift
all bits are going to shift one by one
towards left similarly if you are using
the right shift then all the bits are
going to be shifted towards right by one
bit that's the whole concept of left
shift and right shift bitwise operations
and if you want to know more about this
please read some official examples from
the Java Doc and some other examples
available on the internet to build an
understanding on this so this is all I
wanted to cover in this lecture so in
the next session we are going to talk
about the control flow statements like
if else Etc let's get started with
control flow statements so what are
control flow statements and why do we
need them control flow statements are
the ones which can help you control and
Define the flow of execution in your
program now why do we need them is
because if we want to evaluate some
conditions or we want to create some
branches of execution saying that if
this condition becomes true do this and
if this condition becomes false do that
so you can see there are two different
branches of execution of a program in
this kind of approach and that's where
control flow statements can help us
there are lot of different types of
control flow statements like if then
else and switch and for and while and do
while and we are going to cover all of
them in detail in this series so let's
get started with the first one which is
the if statement we covered briefly
about this when we talked about
operators and I promised you guys that I
will be covering this in detail and this
is the session where we'll be we will go
deeper into this concept as we have
already understood that if condition is
basically used to evaluate a condition
if it is true or false the result of an
if statement will always have only two
values it can either have a true value
or it can have a false value there is no
other possibility or there is no other
value of an if statement or as an if
expression now like I explained if you
want want to do a simple programming
execution where you say if a particular
condition becomes true do this and if
this becomes false then do that it means
you need to write this else condition as
well that if this doesn't hold true what
do I do and how do I write that so let's
understand that with the help of an
example for this particular example I've
created a class and there is a public
static void main method which is the
entry point of this program's execution
I have a variable which is called test
score this is an integer variable with
the value 76 and I have a care variable
which is grade basically what I am doing
that based on the test score marks I am
trying to define the grades which a
student will get so for that I have
built a condition here so you can see it
starts with if which is a keyword then
you put these standard braces for
brackets and you write your condition
inside it in this case I'm writing the
condition saying that that if test score
is greater than equal to 90 then the
student should get and grade A so here
I've defined this grid variable and here
I am just assigning the value to the
grade variable at line 11 if the test
score is greater than 90 the grade
should be a but what if the score is not
90. what if this condition becomes false
and you want to do something in that
case you can write this else block here
we call this else block so you write
else as the keyword you start the curly
braces and then you define the grade if
the score is not greater than 90 what
should be the grade of the student so in
this case we are saying the grade is f
so if we try to run this example in our
in our mind we see that the value is of
the test score is 76 so 76 is not
greater than equal to 90. so this
particular condition will not be true so
line 11 will not be executed but in
instead else block will be executed
because if the condition goes false then
else block should be executed as for
Java so this block will be executed and
grade will get a value of F and then we
are printing this grid value by just
writing a system dot out dot println a
string plus the value so let's run this
particular program and see what happens
we get a grade equal to F here in this
CS out or system.out.print element
because this condition was false so the
control the flow of the control of the
program went to line 12 and then to line
30 because this was the else block so
this is one understanding where we can
write an if and else logic you in some
cases you might not need an else block
so else block is not mandatory it's an
optional block if you want to remove
this and if you just want to do a sys
out here that is also fine this out
means system dot out dot println for
shorthand we sometimes call it as this
out so you can do something here as well
if you don't need Dell's block if you
need Dallas block feel free to write it
but this is an optional block but in
some cases your conditions will be more
complicated than just a single condition
if you try to understand it from a real
world example in real world you will not
have only two grades as a and F you will
have more grades right A B C D so so on
so forth so what are you going to do in
that case for that kind of case Java
provides us with an keyword which is
called else if else if is just a
continuation of if saying that okay if
this condition doesn't hold true
evaluate the next one with an else if so
I've commented out this code let me put
this code back into its place and then
we will walk through this code to
understand it okay so I have put the
code back to where it should be and this
is how it looks like so let's just walk
through this the line 10 and 11 doesn't
change it's still the same but then I
have added some additional conditions
saying that okay if the score is greater
than equal to 90 the grid should be a
but if the score is not greater than 90
but greater than equal to 80 then the
grade should be B similarly if the score
is not even greater than 80 but greater
than equal to 70 then the grade should
be C similarly if the score is not even
greater than equal to 70 but greater
than equal to 60 which means basically
between 60 to 70 then the grade should
be D and if the score is even below 60
then the grade should be F so you can
see I have basically defined the whole
Logic for defining the grades here and
it always works in a top-down approach
one by one the way in the sequence in
which you will Define the else if block
will be the sequence in which they will
be executed so after the condition at
line 10 and if this condition fails line
12 will be naturally executed if this
condition also fails line 14 will be
executed and so on so forth it will
never be the case that if this condition
fails then suddenly line 16 is and then
again line 12 is executed it will always
work in a line by line fashion so make
sure whenever you are using the l-shift
statements write it in a sequence in
which you want the natural program to be
executed so this is all we have here and
now let's try to run this example let me
just bring the system.out.printel in a
lineup save this file right click run as
Java application so we see the value is
grade equal to C which means this
particular code block was actually
executed only this condition held true
now now let's try to understand how this
happened the value was 76 so 76 greater
than 90 no this condition becomes false
so line 11 is never executed it
naturally goes to line 12 because that's
where we have defined the next else if
block is 76 greater than equal to 80 no
it's not so line 12 conditional also
becomes false line 13 never gets
executed and the control shifts to line
14 and there we have the condition
saying that is 76 greater than equal to
70 yes this condition is true so the
line 15 gets executed and once this
condition gets true none of the further
conditions will be executed because you
only need one true statement one true
execution in the whole if else if block
if that one code block gets true that
code block is executed and then the
execution jumps out of the ills if else
if blocks and it will directly go to
line 22 and it will execute that had it
been the case that this particular block
was also evaluated to false it would go
to line 16 and if this was also false it
would go to the block which is else
block let's see that let's make this
value as 56. so now 56 is not greater
than 70 so line 15 will ever be executed
because this condition will evaluate to
false 56 is greater than 60 no so this
will also be false and ultimately the
grade should fall to else block where we
are assigning the grid as F let's see
yes we get the grid F because ultimately
this block was executed because all of
the above conditions evaluated to false
so this is all I wanted to cover in this
if else if demo there is another edition
of another way of writing if statements
which we call as nested if where we have
an if block inside an if block inside an
if block and so on so forth how do we
write that and how does the control
flows in that kind of an execution we
will cover that in the next session
let's get started with using nested if
statements in Java now in the previous
lecture we saw how we can use an if else
block and also an if else if else block
but there is another case where we can
use these if statements and that is when
you have nested if blocks when when
would you use it let's take an example
let's say you have multiple conditions
to check on a particular program and
where the output of the first condition
is the input of the second condition and
the output of the second condition is
the input to the third condition and so
on so forth if you have that kind of
situation you can write it in a nested
if statement kind of block so let's
understand this with the help of an
example as you can see I have opened an
example here which is about nested if
statements I have created a class which
which is named as nested if demo and I
have created a public static void main
method inside this particular class and
now I have declared an integer variable
with the value 50 then I am checking the
first condition saying if I equal to
equal to 50 if that condition is true
then I will check the next condition
which is if I is less than 75 and then I
am adding one more hypothetical
condition saying if this is true then
also check if I is less than 55 so you
can see if I equal to 50 holds true then
only this condition will be executed
similarly if I is less than 75 then only
this condition will be executed so they
are dependent upon each other this
condition block is dependent upon the
previous block to be true and this if
condition block is dependent upon this
if block to be true if either of these
if blocks don't go through the next
subsequent nested if block will not be
executed so in this case I am checking
it for first equality condition saying
if the value is equal to 50 then execute
this statement at line number 10 then
check if I is less than 75 if that is
also true execute the statement at light
number 12 and then if I is also less
than 55 then also execute line number
14. I can also add an else block as well
anywhere in this nested hierarchy if I
want to if I add an else block here that
else block will be corresponding to this
block if I add an else block here and
that else block will be corresponding to
this if block and if I add an else block
here then that else block will be
corresponding to this particular if
block so you can also use those else if
and else blocks as well with nested if
blocks and make it as complicated as you
want it to be so that's about this
program and let's see if we run this
program what output do we get and let's
interpret that output so I'll just right
click run as Java program and I see some
output in the console first I get I is
50 so line number 10 gets printed
because I is 50 then I also see the next
line output as I is smaller than 75 it
means this condition was also true
because 50 is less than 75 so line 12
also got executed and then I'm checking
if I is less than 55 so yes 50 is less
than 55 so line 14 also gets executed
and we get this statement on the console
so this was a simple way to see how we
can implement the nested if conditions
now we are also going to talk about
another concept which is used in writing
the if conditional blocks which is
called ternary operators so ternary
operators are used as a shorthand of
writing if else block as you can see
that these if blocks are quite verbose
we have to write a lot of code to
actually write some conditions in this
case I'm executing three conditions but
the code is almost seven lines or eight
lines so we will see how we can simplify
this if we use a ternary operator and
for that I have created another class
which is called ternary operator demo
and this particular class again has a
public static void main which is the
entry point of this particular program
and then I have declared couple of
variables first is int a equal to 1 and
second one is int b equal to two I have
also delayed cleared a result variable
and we will see how we can use this
result variable and at line 10 I have
written my if else expression so you can
see this if else expression doesn't look
like the one which we have seen before
so let's understand how do we write it
if you're trying to write an if else
expression with ternary expressions or
ternary statements then the first thing
which you need to understand is the
structure of it so here at first you
will specify the actual condition which
you want to test in your if block so
this is my condition then after that
condition you are going to put a
question mark and after the question
mark you are going to put the actual
result which you want to be executed if
this condition becomes true so if the if
condition becomes true what do you want
to do whatever is that you will write it
here and then if the condition becomes
false then the logic should go into the
else block and the else logic should
come after this colon so all you need to
remember is this question mark and the
this colon before the question mark you
are going to write the condition after
the question mark you are going to write
the statement which is going to be
executed if this if condition becomes
true and after the colon you are going
to write the else block condition which
is going to be executed if this
condition becomes false another thing to
notice is that ternary operators can be
used only in cases when you have only
one statement to execute in if block and
one statement to execute in else block
it cannot be more than one statements so
instead of this you can also write
system.out.printl in here which will
also be fine if I just write this system
dot out dot print not print F but I want
to write print Ln so I'll just write
println you can also do this this is
also fine you don't need to store the
result obviously but but you can also
write this condition in a way but this
all this only has to be a single
statement it cannot be more than one
statement because this expression can
only hold one statement at a time so use
it in situations where you have to check
a condition and do something in the if
block which is only one statement and
again one statement in the else block
the same expression can also be written
in a verbose if else way in which we
have been seeing it before and we'll
also I will also show that to you and
here where this A and B is going this is
getting stored in this variable called
result so if this if condition holds
true then the result is a and this is
going to be stored here and if it is
going into the else block then B is
going to be stored in the result block
let's run this program so we can see we
get the value 1 because we have set the
condition as a less than b so yes 1 is
less than 2 so this particular statement
gets executed and this value gets stored
here in the result variable so that's
how you can use the ternary operators to
write shorthand if else statements the
same expression can also be written in a
verbose way for example you can write it
in this way saying if a is less than b
then result equal to a else result equal
to B this code has exactly the same
effect as this one line of code so you
can see this is this is pretty simple to
write pretty short to write the code
which I'm writing here in four lines can
be written here in one line and that's
the power of ternary operators so this
is all I wanted to cover in today's
session so we talked about nested if
statements and The ternary Operators
here how to use them in the next session
we are going to discuss about switch
case statements let's get started with
using switch statements in Java so let
us first understand why do we need
switch statements generally whenever you
want to check a condition you can use an
if else block but what if you have
multiple conditions to check what if you
have so many possible execution paths
that it becomes two verbose to write it
into an if else kind of block what if
you have to check on constant values of
certain Expressions how do you do that
it becomes even more challenging and the
code becomes even more verbose so in
such cases switch statement can be used
in which you can write switch statement
to have as many possible execution paths
as you want and it will work with
constant values as well so let's
understand this with the help of an
example as how and why will we use the
switch statements so for that I have
created this class which is called
switch demo and it also has a public
static void main method which is the
entry point and in this program what I'm
doing is I'm trying to accept a number
as the month number in the program and
then with that particular number I'm
trying to print the corresponding
month's name so that's the logic pick a
month number and you should get the
month's actual name so now in this case
you can you can imagine there will be at
least 12 if else if blocks which is a
long line of if else statements at the
same time if we try to do this for other
conditions where the value is constant
please understand that the value of
month is going to be constant it's going
to be the same number so it's not
similar to you evaluating a condition
it's similar to you evaluating a
condition to a particular constant value
imagine if you have to do some sort of a
classification of employees in higher
salaries and lower salaries and there
are hundreds of salary bans in the
company so are you going to write 100 if
else Logics that is going to take a long
time and then what if new bands get new
bands get introduced then it gets even
more complex so we will use switch case
statements in cases where there are lots
of if else conditions and the expression
evaluates to a constant value remember
in the if else cases the expression
evaluates to a Boolean value so here I'm
supplying the month value as 6 then I'm
also creating a string month month
string variable just to print or store
the name of the month and then the way
you write the switch statement is to
write the switch keyword and then in the
brackets you supply the month integer
value and then you start writing your
conditions so you can see you write the
case as keyword and then you write the
number or the possible values this
particular variable or this particular
expression can hold so all the possible
values this particular expression can
hold will be written individually as
cases so case equal to 1 here 1 means
the value of month is 1 in that case the
month string which we created here shell
store January and then we see a
statement called break so break is again
a keyword in Java and this keyword has a
special meaning it has a special usage
you will use the keyword break to
abruptly break the control of execution
from the current code block and the code
block is identified with curly braces so
here you can see the curly brace starts
from here and it ends down to line
number 51 at here so the moment your
Java program is going to encounter this
particular statement it is going to jump
out of the current code block execution
and continue thereafter that's the basic
logic and usage of break statement so
use it whenever you want to skip the
rest of the code after the break
statement if you don't want to execute
the rest of the code you will right
break and the moment the Java program
sees this particular statement it will
jump out of the current code block
specified by the curly braces and will
resume execution after the code block so
in this case it will resume the
execution after the line 51 that's the
usage and the meaning of this expression
called break so in this case we are
saying that if the month value is 1
which we denoted as here case 1 then
store the value of the month string as
January and break out of this particular
code block because we don't need to
execute any further we have found a
match then another case would be if the
month value is 2 so you write case which
is a keyword and then the exact
expression value the constant value
which is 2 and if that's the case then
month string becomes February and again
you break because in this particular
case there will only be one condition
true at a time there will never be a
case that month with the value 2 will
have two meanings we'll have two month
names a month with the value 2 will
always have a meaning called February it
will never have two meanings or two
month names attached to the same integer
value and that's why you do not want to
execute any further and and that's why
you write this break statement if you do
not write this break statement it is
going to evaluate all of the cases one
by one even if the cases are not going
to be true but it is going to waste lot
of processing time evaluating all the
case conditions which you have written
here which does not make sense because
we know that only one condition at a
time can be true here because we are
evaluating and checking for a constant
value which is an integer value so
that's the reason we put a break in each
case if intentionally if you want to
check multiple cases do not put a break
statement but the program can become
really confusing in that case so take
your wise call so here we put a break in
each case similarly case 3 the month
string becomes March case 4 the month
string becomes April case 5 becomes May
case 6 becomes June case 7 we have one
string as July case 8 month string is
August case 9 we store the month string
as September case 10 as October case 11
is November and case 12 as December
after that you will also see an
interesting block called default this is
the another capability of switch
statement that what if none of the above
conditions hold true what if we specify
a value which is not between 1 and 12
and it will not match any of the cases
which we saw just above and if you want
to execute subcode in that case if none
of the conditions matches you may want
to execute some default execution also
in such cases you are going to use
default default is the code block which
will be executed if none of the case
matches so here you can see that if none
of the cases match then we are going to
store the value of month string variable
as invalid month and then we'll
eventually break out and once we break
out of this program we just want to
print the month string that's all we are
doing in this program that we take an
integer value as the month number and
then we print the corresponding month
name here by looking at the case blocks
and we also Define a default case block
if none of the conditions hold true so
let's run this program we have specified
the value as 6 which should result in
the month name as June and yes we can
see we get June let's change the value
and let's put the value as 10 and see
what do we get so right click run as
Java application and we got October yes
exactly correct let's put an invalid
value as 13 and let's see what happens
now now we get invalid month so our
default code block just got executed
because we entered a value which is not
matching any of the case conditions
which we have specified so this is how
you are going to use the switch and case
statements while writing your conditions
whenever your condition evaluates to
multiple constant values remember the
the key here is to understand if you
your expression is evaluating to
multiple constant values which do not
change and in those cases using a switch
case block is a better idea than writing
if else statements so that is all what
we are going to cover in today's session
and in the next session we are going to
understand something about two
dimensional arrays and multi-dimensional
arrays as well let's get started with
understanding arrays in detail we have
been talking about arrays throughout
this course of java in the previous
sessions as well and we have covered
some basic understanding of how to
create arrays how to declare them how to
fill values in the array and how do we
print the array with positions as well
as the array as whole but whatever
examples which we took previously were
one dimensional arrays because arrays
can have more than one Dimensions as
well you can create a one-dimensional
array you can create a two dimensional
array you can create even a
three-dimensional array and you can go
up to as many dimensions as you can
handle in your Java program so it
depends upon the kind of complexity you
want to have in your program and the
kind of values the kind of structure you
are going to store in your arrays and
based on that need you can choose
whether you want to use a 1D array or
one dimensional array or a 2d array or a
3D array and so on in these sessions we
are going to talk about 1D arrays 2D
arrays and 3D arrays and after that
we'll leave up to you to try out more
dimensionals if you want to we have
already covered the basic array
structures which were one dimensional
arrays so I will just give you a quick
walkthrough of how we actually handled
one-dimensional arrays so this is a
sample program to demonstrate one
dimensional arrays if you remember this
is how we use to create arrays we write
the data type of the array and then we
write the square boxes which denote that
this is an integer array data type we
assign a variable to this and then we
initialize the array a with a size 4 so
new is the keyword which is used to
initialize anything in Java and we are
going to use this heavily when we talk
about classes and objects and even
collections literally any object which
you want to create in Java requires a
new keyword so here I'm writing new and
then int 4 which means create an array
of size 4 and then I'm filling the value
of the four positions which I have
created as part of this array and if you
remember when we create these kind of
arrays we store them in a zero index
based position the first value gets
stored at 0th index position and then so
on so forth so it will always start from
0 and never start from one remember that
and after that we just print all the
values of individual positions of the
elements in the array and if I just run
this program all of the elements of this
particular array should be printed one
by one so if I just show the full
console of the output we can see that
element and index 0 was 10 element and
index 1 was 20 element at index 2 was 30
and element at index 3 was 40. so this
was just a quick refresher of how one
dimensional arrays can be written and
whenever you declare a very simplistic
array it will generally be a one
dimensional array now let's look at the
two dimensional arrays and how do we
write them when do we need them for that
I have created another example which is
says two dimensional array I just
created a class and it has a public
static void main method and I've created
a two dimensional array this time so
let's understand this two dimensional
array in a bit detail and when do we
need that generally you would need to
use two dimensional arrays whenever you
are trying to do any Matrix calculations
if you if you understand what do you
mean by matrix it's basically a two by
two structure which stores the values in
the form of rows and columns so imagine
a table of two rows and two columns then
it will be a two by two Matrix so if you
want to store that particular table in a
Java program you would need to store
that as a matrix as a two dimensional
Matrix rows being the one dimensional
and column being the other dimension and
that's what we are doing here and if you
want to store that 2D metrics in a Java
program the approach and the procedure
for it is pretty similar to how you
create a one-dimensional array with
slight changes the first change is
instead of a single square bracket you
are going to write two square brackets
because it is a two dimensional array so
remember the number of square brackets
you are going to put while initializing
and declaring the array is the number of
Dimensions which your array is going to
have since this is a two dimensional
array example that's why you see two
brackets here if this was a three
dimensional array example you will see
three array three square brackets here
and so on so forth so that's the first
part of it second part to understand is
to how to store the data remember I told
you always imagine the structure of rows
and columns whenever you are trying to
store a two-dimensional array in Java so
what are rows and what are values and
how do you represent them while you
declare and initialize a two-dimensional
array so you start with the curly braces
as the normal 1D array but inside the
curly braces you create nested curly
braces blocks you can see three blocks
here they start with their own curly
brace and end with their own then this
curly brace starts here and ends here
and then this curly brace starts here
and ends here idea is that you provide
this outer curly braces to define the
overall structure and then inside each
of the curly brushes is going to
represent a row in your two dimensional
array so each of these values these
blocks is going to represent a row so I
can say that the this is the first row
this is the second row and this is the
third row and if I try to visualize it
in terms of columns then this is the
first row First Column first row second
column First Row Third column similarly
second row First Column second row
second column second row third column
and third row First Column third row
second column and third row third column
so individual values are going to be
represented as columns and the whole
curly braces is going to be represented
as arrays that's the basic mental idea
or mental image you should have while
declaring a two dimensional arrays
remember to declare the rows inside the
nested curly braces and whatever
elements you have will automatically be
indexed as columns one other thing to
remember that since this is an array
data structure everything starts from 0
and nothing starts from one so this will
be row 0 this this will be Row 1 and
this will be Row 2 I'm talking about the
position we can still call it as first
row second row and third row but the
position of this particular row element
is 0 the position of this particular row
element is 1 and this particular row
element is 2. similarly for column as
well this is column 0 column 1 and
column two similarly column 0 column one
and column two and so on so forth once
you understand this data structure well
and you have defined it correctly then
everything should fall in place if you
want to do a matrix addition or if you
want to do a matrix multiplication or a
DOT product all of the kind of
calculations can be performed using the
2D array concept here in this program
what I am doing is I am printing the
values of this particular 2D array into
a matrix style and you see some strange
code here which is for ETC don't worry
about this I'm going to cover in detail
what this four means and how do you
write this for now what we can
understand that we just want to print
this you might not need to print this in
your Java programs when you write a
production grid application but you
might want to do manipulations on these
arrays as metrics maybe you want to
create a transpose of a matrix or you
want to do a DOT product or addition or
subtraction or whatever be your use case
in this case just for demonstration
purpose I am printing the values as rows
and columns nothing else so this all of
this code from line 8 to line 14 or in
fact line 13 is just showing how to
print the values you can see some system
dot out and you can see some construct
here and like I said don't worry about
this I will cover this in detail let's
run this program and see if my Java
array is stored correctly and how can I
represent this so you can see I have
represented it in a style of a 2d Matrix
where this is the first row this is the
second row and this is the third row
similarly this is the First Column
containing the value value 237 so column
0 will have value 2 and column 1 will
have this value 3 and column 2 will have
this value 7 for row 0. let me also do
something here which can help you
understand this concept better let me do
a
system.out.println and let's print an
individual value because like I said the
for Loop can be confusing here to
understand so let's say I want to print
ARR of 0th row First Column and see what
kind of values do we get let me comment
this code comment is control backslash
and this code will be commented and this
code will not be executed and now only
line 15 will be executed instead of the
four block so if I run this I get the
value 7 so row 0 and First Column row 0
First Column is seven let's try with one
one I want to print the row at zero one
position remember not the first row but
the one position row which is basically
technically the second row so second row
second column and see what kind of
values value do I get in this case I get
6 so second row second column similarly
if you change this value to 2 then third
row second column which should point to
four yes we get four similarly you can
write a value here as 0 and you can
write a value here as let's say 2 this
will print the 0th row and the second
column so similarly whatever kind of
value you want to write you or you want
to access you can access it in this
fashion and remember the column and row
indexes will always start from zero so
this is a simple demonstration of how
you can use two dimensional arrays and
in this session we also did a refresher
of one dimensional arrays so that's all
for this session and in the next session
we are going to be discussing how we can
Define three dimensional arrays and
we'll also see an example of it let's
get started with how to create and use a
three dimensional array or how to go
about using multi-dimensional arrays in
Java so as you can see from this image
we talked about 1D array which is having
just one axis then we talked about 2D
arrays in the last session where we had
rows and columns basically an X axis and
a y axis and then we can also have a 3D
array which will have three axises which
will have an x-axis a y-axis and also a
z-axis think of a simple box which every
box in this world will always have at
least three dimensions and from from
here you can go even build more complex
arrays which can have four dimensions or
five Dimensions or as many dimensions as
you want it to have and today we are
going to look at an example of how can
we build a 3D array and how do we access
those elements but this picture is just
to show you the mental model of when you
will be creating a 3D array so for
example generally an image data is
stored in in three dimensions so you can
you might want to store the image data
into a 3D array and there can be many
other use cases in the mathematical and
research computational use cases where
you might want to use a 3D array so but
remember there's an x-axis there's a y
axis and then there is a third axis
which is called the z-axis so let us
look at a Java program to understand how
we can build a three-dimensional array
and for that I have created this class
which is called multi-dimensional array
it has a entry point method which is the
public static white main method and then
I have created an integer array and this
time instead of one or two square
brackets I have three square brackets
and if you remember I mentioned this in
the previous session as well the number
of square brackets which you're going to
put while initializing the array is the
number of dimensions of the array and
since in this particular program I am
going to demonstrate a three-dimensional
array that's why you see three square
blocks boxes let me just minimize this
yeah so we have three square boxes here
and we have created the variable name as
ARR or short form as array then we start
with the outer post curly braces as is
then we put another curly braces which
starts from here and it ends here then
another set of curly brace which starts
from here and and here so this is the
this is the First Dimension this is the
second dimensions and these are the
third dimensions that's how you are
going to define the different dimensions
remember this is the First Dimension
when the first curly brace starts then
you have the second dimension which
covers this hole and this hole and then
you have third dimension which are these
so that's how you are going to visualize
and and put the three dimensions in use
by while declaring a three-dimensional
array and the values work in the same
fashion it's it's a zero index based
position so since we do not have an
official name for the third dimension so
I'm just gonna use x axis y axis and Z
axis to refer to the three axises so
this would be X of 0 this would be y of
0 and this would be Z of zero similarly
X of 1 y of 1 and Z of 1 and so on so
forth so now if I try to access the
value which is at 0th X position first y
position and second Z position what's
the value do we get here let's run this
program and understand and interpret the
output okay so when we ran this program
we got the output as 11. so let's
understand this output so when we say
the zeroth position on X the first
position on Y and the second position on
Z so this is the zeroth position on X
and this is the first position on Y and
then this element is 0 1 2 is the second
position on the Z axis so to to describe
it in a nutshell this defines the x axis
so we have two elements on the x axis
here this one and this one then we have
two elements on the y axis on each x
axis so this is one this is two on the
first x axis and this is one and this is
2 on the second y second x axis so 2X
and 2y and then on the Z axis I have
three elements each so hope this helps
you understand and visualize this so x
axis and this one is other x axis and
then Y axis y axis and then in elements
inside this are Z axis so I'm saying 0
with x axis in this block first on the y
axis which is this block and then second
element or the Z or second position
element on this particular ax in this
particular block which is 11 and that's
why we get 11. if I print 0 let's say I
change this particular value as 1. so
now the output should be coming from
this side so second X position because
it's one second y position so this will
go here and then the two position which
is the third element of the Z axis which
is 13. so let's see if we get 13. yes we
get 13 here so this is just to show you
how you can interpret this this
particular array and always be mindful
of how you are structuring this array if
your structure is gone wrong then your
program will become useless and it will
give you lot of unpredictable outputs
which might not make sense and which may
introduce errors in your program so be
very careful how you define the
structure of the elements here that's
the key and after that you just need to
understand the x-axis the y-axis and the
z-axis always remember all the accesses
start from 0 so when I say 2 I'm
basically referring to the third element
and not the second element so this is
all I wanted to cover in this particular
session where we describe how we can use
a three-dimensional array and from here
you can go to any lens like I said you
can add more square brackets here and go
to four dimension or five dimension or
six Dimension but remember the more
Dimensions you add the more complexity
of the program will be having the
program will become more and more
difficult to debug and understand so
always try to take a wise call as to how
many dimensions you want to use in your
array and that's it for this particular
session in the next session we are going
to talk about the different Loop
statements in Java let's get started
with today's topic which is about how to
use do while Loops now in the previous
session we covered the usage of while
Loops but we have another type of while
loop which is called a do while loop so
let's understand when do we need that
and how do you actually use that let me
switch to the Java documentation and if
I can find some syntax of it as well yep
so as you can see here if I just
highlight this portion this is how you
actually write a do while statement
block so you write do you start a code
block you write some executable
statements and then after the code block
ends you write a while expression and
end it with semicolon this is the syntax
basically it starts with do to our curly
braces some executable statements are
while block or a while statement
basically with an expression ending with
a semicolon let's understand this with
the help of a program to understand the
structure better so for this I have
created a sample program here which is
called do while demo again having a
public static void main method and it
has a variable which is count and it is
initialized as one then I write do I
write this code block or the curly
braces and then I am just printing the
value of count then I am incrementing
the value of count and then I am writing
a condition which says while count is
less than 10 and semicolon if you
compare this with the previous demo we
ran if I just put them side by side we
had while condition statement and and
the state change condition here we have
do statement condition change statement
and then we check the condition at the
end so the idea is that if you have a
use case where before you even evaluate
the condition you want to print
something even before you evaluate the
condition if you want to do something in
that case you will use the do while loop
even before the while actual while loop
starts if you want to execute a
statement you will use do while loop for
example if you want to print the initial
value of the count even before the
condition checks then you can use do
while loop if that is not your use case
you can use a simple while loop which is
described here in this program so coming
back to the do while so I say do and
then I'm saying print this particular
statement without checking anything this
condition will be executed for the first
time without any condition check at all
this will just work as is like a normal
Java statement after that I am
incrementing the value of the count and
then I am checking the condition so
remember when this particular the
condition is being checked the first
increment has already happened but in
the while case we did the comparison
before even the first increment the
first comparison happened with the
original value of count but here the
first comparison is happening with the
incremented value of the count hope you
get the difference in a better context
now that you will use this when you want
to do some write some initialization
code before you actually hit the
condition so this condition will be
evaluated with 2 less than 10 and then
the value will be printed let's print
this example and we'll also try to play
around with this example a bit more to
bring to build our understanding better
if I run this program there is no
difference in output if you compare this
with the previous program we ran for the
while so it prints the count value so
this is coming here then it increments
the value then it checks the condition
saying is 2 less than 10 yes that holds
true if that holds true it it will go
back to statement number nine again
print this again do an increment on the
count and again check the condition with
the updated value of the count which
will say 3 less than 10 now similarly
print the value increment check this
will continue to happen till this
particular condition becomes false and
once this condition is false it will
exit out of this whole do while loop and
it will go to the line number 12 and if
you have any statement written there you
can that statement will be executed in
this case so let's try to change some
values here and let's see if if we can
make sense of this program if we change
the value let's see if I put 11 here
what will happen now let's run this
program you will say the now you will
see that this particular output is
displayed which says count is 11. so
what happened here that count was 11 it
entered the do while block it went to
this particular statement which said
count is 11 then it incremented the
value so the value became 12 and
obviously 12 is not less than 10 so it
did not print it again it only printed
once even if the first time the
condition was checked the first
condition execution itself resulted in
false so still line number nine got
successfully printed and that's the
whole that's the whole idea behind using
the do while what if I change this value
to 10 let's see what happens and after
that we'll run one more combination to
just make it more interesting This Time
Again count is 10 line number 10 will be
printed as count is 10 then at line
number 10 the count is incremented to 11
and 11 is not less than 10 so in this
case the loop ends and it will move out
now what happens if I do this if I say
less than equal to here let's run this
program and interpret the output now
again only one statement is printed
because in this case the count is 10 10
is printed here and we are saying 10
plus 1 11 11 is still not less than
equal to 10 and that's why the loop just
exits let's make it 9 and see what
happens now you see two values so count
is nine it enters the do while loop goes
to statement number line prints the
current value of count which is 9 then
increments the value to 10 then at line
number 11 this while statement is
executed and the condition is checked is
10 less than equal to 10 yes 10 is not
less than but 10 is equal to 10 so this
condition will hold true it will go back
here print count is 10 May count 11
again check the condition is 11 less
than equal to 10 no it's not and then
the condition will return to false and
loop will be exited so hope this will
give you a better understanding now
since we ran different permutations and
combinations of the values and we saw
when this will be executed and when this
will not be executed but the bottom line
is very straightforward that whenever
you want to write some pre-processing
logic even before checking the very
first condition of your Loop then in
that case you will be using a do while
loop otherwise a normal while loop or a
for Loop will have absolutely about fine
so that's the takeaway I would like you
to take away from this particular
session and that's all for this
particular session we talked about do
while and we also try to give you some
sort of a comparison between while loops
and do while Loops in the next session
we are going to be discussing about for
Loops in detail let's get started with
understanding the loop statements in
Java so first of all understand why do
we need Loop statements so generally
whenever you are dealing with some data
structures in Java which can store
multiple elements for example we saw
array which can store multiple elements
string is also basically technically a
character array which is storing
multiple characters so whenever you have
these kind of data structures where you
have multiple elements being stored in
the same then in that case you would
like to have a way to iterate or access
all of the elements in a seamless
fashion one of the ways is to access
them individually one by one but that's
too much of work that's too much of code
there has to be a simpler way of
accessing all the elements one by one if
I want to and that's where the majority
of the use cases for using Loops coming
to picture now Java provides multiple
constructs to write Loops in Java there
is a while loop there is a do while loop
there is a for Loop there is also an
enhanced for Loop and in the previous
versions of java a use case of iterator
was also very popular so there are
multiple ways in which you can actually
iterate over a collection and access all
the elements of the collection one by
one and you can use it to multiple
useful cases for example if you have a
huge eye of employee salary and you want
to give bonus to each of the employees
and add the bonus to the salary then you
need to do this Edition for all the
employees it would be nice to have to
return a while loop and the while loop
can automatically access all the
employee salary one by one and keep
adding the bonus to the salary this
would be an easier way to do this rather
than individually updating each
employee's salary and the first Loop
statement we are going to understand is
a while loop so the syntax of while loop
is very straightforward you write the Y
keyword you enter the actual condition
which will be evaluating to a Boolean
true or false so you write the
expression which will be a Boolean
expression exactly similar to the
conditions which you use to write in
your if statements so you write your
condition which will evaluate to either
true or false and then you write your
statement and these statements will keep
executing till the time this particular
expression evaluates to true so
generally the way it works is that it
will enter the while block it will
evaluate the expression if the
expression becomes true then the
statements inside this particular while
block will be executed and after the
execute tuition of the statement it will
again go back again evaluate the
expression we call the steps basically
so it will go to the next step again
evaluate the expression if this again if
this still holds true it will again go
inside execute the statement move on to
the next step it will again go to the
evaluation so this this Loop will
continue to go till the time this
condition will hold true if it still
doesn't make sense for you don't worry
we will have a demo of it to make you
understand how to use the while loops
and maybe it's a good idea to switch to
the IDE and look at an example of it so
I have already created while demo for it
here it is it looks very small and
simple but it will get to the point
where we can understand how and why will
we will be using the while Loops so I've
created a while demo class I have added
a public static void main method here
which is the entry point I have declared
a variable which is int count equal to
one so the count value is one right now
and then I'm writing a condition here
I'm saying saying while count is less
than 10 do this so it will print the
current value of count and after that
I'm using the post increment unary
operator if you remember we covered this
in the previous sessions what is the
meaning of this it basically will
increment the value of count by one this
expression is e is equivalent to if I
write it in this way if I write count
equal to count plus one this is exactly
the same as this no difference so this
will have the same impact I will just
remove this line because we already have
the count plus plus here so if we try to
understand this we are basically
incrementing the count and then checking
the condition again so at first time it
will be 1 less than 10 yes that is true
it will go inside and print the count
value the current count value which will
be 1 and then it does count plus plus so
now the count value becomes 2 it will
again go back here again check the
condition saying is 2 less than 10 yes
that is true so the while condition
again becomes true it will again go
inside this print the current value of
count which is 2 then do count plus plus
so it will again increment the value of
count so the now the count value becomes
three again go back here at condition
and saying is 3 less than 10 yes that is
still true again come here print the
three again go here make count as four
four less than 10 prints four again
count plus plus count becomes 5 and so
on so forth it will keep doing that till
the value becomes 10. so at a step when
count plus plus results in the account
value being updated to 10 it will go
here and say is 10 less than 10 now that
is not true because 10 is equal to 10
but 10 is not less than 10 so this
condition will become false and it will
exit of this while loop and it will come
here and it will execute if there's if
there was anything written after the
while loop that will be executed so
that's the idea that you want to do
something till a particular condition
holds true then you can use the while
loop Define your condition and execute
the statements and try to do something
which changes the state of this
condition here I'm changing the count so
that every time a new evaluation happens
if I comment this this will result in an
infinite Loop because one will always be
less than 10 I will not be incrementing
the count here and it will keep running
forever it will never stop it will just
keep printing one one every time till
your computer program runs out of the
memory so always remember not to end up
into an infinite Loop that's probably
one of the biggest mistakes any beginner
programmer does so please try to be
aware of that particular loophole not
try to run an infinite Loop always try
to write something in the code block
which can change the state of the
condition and also make sure that that
state condition sometimes sometimes
should become false you should also make
sure that that all that always becomes
false because if I do this if I do this
then this condition will always remain
true because it is already 1 then it
will become 0 then it will become minus
1 minus 2 minus 3 so and so forth but
that value of count will forever be less
than 10 and again you will never be able
to exit this Loop your program will be
stuck in this Loop till your program
runs out of the memory so always
remember to write a statement or a
statement of execution in your in your
code block which can change the state of
the condition which results in some
eventual time when this condition
becomes false this condition has to
become false eventually otherwise you
will never come out of the loop always
remember that so if we run this program
now let's observe the output so we can
see here this particular statement is
printed for one two three four five six
seven eight nine and that's it after 9
the moment the count plus plus resulted
into the count value becoming 10 it
checked that condition and then it just
came out of the loop because 10 is not
less than 10 and the condition became
false so always do something inside your
code block which results at least of one
scenario where this condition becomes
false and that is how you can use the
while loop now you can see this is a
pretty generic code and you can write
any kind of condition here write any a
code you want to execute here and then
do something to change the state of the
condition as well in a positive way in a
way which results this particular
condition to be false at some point of
time and then your while loop will run
fine so this is all I wanted to cover in
terms of the while loop we have lot of
more exciting stuff coming in in terms
of different loops and in the next
session we are going to understand how a
do while loop Works let's get started
with for Loops in Java so so far we've
covered about while loops and do while
loops and we also saw different examples
of using different types of data
structures like arrays but one of the
core requirements whenever you are
working with any kind of collection is
to iterate over it exactly similar to
what I explained in the do while and why
lectures that you would often require to
iterate over a collection or a data
structure and for that one of the most
sophisticated and easiest way to do that
is using for loops so let's understand
the syntax of for Loop first and then we
will also look at an example of it in
the in the Eclipse IDE so I have just
opened the official Java docs here so if
you see this is basically the syntax of
a for Loop statement so let's understand
it and let's also try to compare it with
a while loop so that we can understand
how it Compares with the while loop so
if we see the syntax we first see the
term initialization then we see the term
termination and then we see the term
called increment now if I try to compare
it with a while loop there also you
basically did these three things you
first initialized a variable outside the
while loop which is called
initialization and then you wrote a
condition which is your termination
condition you wrote a condition saying
let's say while I is greater than 10 or
while I is less than 10 so that is the
condition which is also the termination
statement the loop will continue to
execute till that condition evaluates to
false and that's when the loop
terminates that's why we call it as
termination and then the third piece of
it is the increment the I plus plus
which we used to do in the while Loops
so these three portions together make or
constitute any kind of loop in any kind
of programming language and for Loop if
you see the the kind of code which you
use to write in a while loop in multiple
lines where you first initialize a
variable then you write a condition in
the while block and then inside the
while block you used to increment the
variable all of that can be done in a
single line in the for Loop and that's
why I said it is the most sophisticated
and easiest way to write Loops in Java
so you write all of these three things
the initialization the condition and the
increment or decrement values in the
single line and then use start with the
curly braces and you write the code
which you want to keep executing till
the condition evaluates to false that's
the basic syntax of it so let us try to
understand this with the help of an
example so here I have opened a class
which is called for demo and this is a
class which will demonstrate the usage
of a for Loop so again we have a public
static void main method which you can
see here which is the entry point and
then I use the keyword for I put
standard braces for the brackets and
then I do the initialization so this
part is the initialization part you
initialize the variable so I just say in
time equal to 1 initialization done you
end it with a semicolon so that it is a
single statement understood by Java and
then you write this condition which is
your evaluation slash termination
condition so this condition is basically
the the deciding factor of how long your
Loop should run it's exactly similar to
what you used to write in the while blog
if I just show you the example this is
what we used to do so we did the
initialization at line number seven then
we wrote this termination condition
inside the while syntax or the construct
and then we did the increment here so we
are doing all of these three steps but
we are doing it in a single line so this
is the condition and then we write our
increment or decrement values which are
going to change the evaluation condition
every time at every step so we are
saying I plus plus so technically what I
am saying here is that start with i
equal to 1 and then check the condition
I less than 10 so the in the in the
first step it will be checking if 1 is
less than 10 if the condition holds true
go inside the for Loop execute the
statement at line number seven and then
go back to this particular statement so
we do y plus plus so I becomes 2 and
then you again go back to the condition
and again you check if 2 is is less than
10 yes it is so again you go inside
inside the for Loop and do whatever is
written there there can be multiple
statements here for now I have just
written one system dot out dot println
so that happens and once all the
execution is finished inside the block
it will again go back to the increment
that's the increment so 2 plus 1 becomes
3 again does the evaluation exec and if
the if the condition holds true it will
again go inside so this will continue
this condition checking execution and
increment will continue till the time
this condition holds true the moment
this condition becomes false the control
will come out at line number nine so
that's the basic anatomy and control
flow it's very important to understand
the control flow of a for Loop otherwise
you might end up into a program which is
forever running and which will just heat
up all the memory available in your jvm
so be very sure of what you write in
your for Loop be very sure of especially
these two parts the condition and the
increment or decrement so this is very
important piece the initialization
happens only once and then this
condition evaluates if the condition
holds to True some code executes goes
back to the changing statement which can
be an increment decrement whatever and
again compares the updated value with
the condition so this will keep
happening let's run this code to
interpret the output
so I will right click go to run as Java
application and if I interpret the
output here I can see that it started
with count is 1 2 3 4 5 6 7 8 and 9. it
stopped at nine so what happened there
let's try to evaluate the termination
condition so let's say I has become 9
and 9 is less than 10 so it goes inside
and it prints count as 9 which is I then
it goes here and it says 9 plus 1 I plus
plus means nine plus one the current
value of I plus 1 it becomes ten and
then it again compares the condition so
now 10 is not less than 10 10 is equal
to 10 but it is not less than 10 so the
condition becomes false and count is 10
is never printed because this condition
has become false it will jump out so
let's say if I do this if I put an equal
to here and if I now execute the same
program
this time I will see 10 here and because
I have said that okay check the
condition if 10 is less than equal to 10
that will become true it will print
count is 10 then it will increment and
the count will become 11 the I will
become 11 and then it will check 11 is
less than equal to 10 no it is not so
condition becomes false and the control
comes out of the loop so that's how you
should always try to interpret the loops
you can also run some infinite Loops for
example if I say I equal to 1 I leave it
that and I say I minus minus so what
happens I equal to 1 1 is less than 10
yes it goes here prints the value and
then I decrement the value I don't
increment the value I decrement the
value so whatever value comes out will
always be less than 10 and this Loop
will run forever for fun let's try to
run this and I will I will have to kill
this program manually but just to show
you what happens and what you should not
do in your in your Java program so you
see it will continuously keep printing
the values till the program runs out of
memory till it eats up all the available
memory it is cut it is forever running
it will never stop because the condition
will never remain never never evaluate
to false this condition will forever be
true so the loop will run forever so I'm
just gonna kill the program but this is
something which you should avoid
whenever you are writing Java code and
this happens quite often with beginner
programmers so this is all I wanted to
cover in today's session we talked in
detail about the for Loop and in the
next session we are going to talk about
another interesting way of writing for
Loops which is also called enhanced for
Loops let's get started with enhanced
for Loops in Java so we covered about
the for loops and the structure of it
and the control flow of it in the
previous session and today we are just
going to talk about another way of
writing for Loops which is a bit even
more smarter than the traditional for
Loops which we call as enhanced for
Loops we generally use the enhanced form
Loops for scenarios whenever we have to
iterate over a collection of items or an
array of items those are the most
popular and common use cases of using
enhanced for Loop and this for Loop is
even simpler like I said it's even
simpler than writing a classic for Loop
and the syntax is simply like this you
again start with for put the standard
brackets and then let's start from the
right most because then I will be able
to explain it better you specify the
collection in the right most side of the
bracket The Collection can be an array
it can be a list it can be a map so
whatever different kind of collections
which are available in Java and we are
going to cover collections in detail so
don't worry if you don't understand what
are lists and what are maps and what are
sets we will go into detail of each of
these one by one in the upcoming
sessions but the idea is that you put
the collection to the right most then
you put a colon and then you put a
repair presentation of the member of
this collection so for example here this
numbers is basically an INT array so
this int array means that this array Can
Only Hold integer numbers and that's why
we write int here because this array is
only having integers then we put any
placeholder variable name this can be
anything you can even write it as I if
you want to you can write it as anything
any variable name which you want to
write this is a temporary variable so
now this code is going to execute in a
manner that it is going to iterate over
this array one by one starting from the
first element going till the last
element you don't need to write any
initialization code you don't need to
write any termination condition code and
you don't need to write any increment or
decrement code also and how these threes
how these three values are actually
taken here of let's understand that as
well so when we talk about the
initialization as I have put an array
here a data structure here the automatic
initialization index is going to be the
first index so when we do the iteration
when this for Loop is going to execute
it is automatically going to initialize
a temporary variable with the value at
the first index which is the index 0 as
you know that array is a zero index
based structure then comes the condition
part so the condition evaluation is
going to be again based on the size of
the array or the size of the data
structure which you are using it is
going to start from the first index
which is the index 0 and it is going to
iterate till the arrays last element is
reached so technically start from the
index 0 and go till the last element
that's your evaluation condition and
then comes the increment part so at each
step after it has successfully accessed
the first element automatically the
index is going to be updated to pointing
to the next element so if it starts from
here once the first step iteration is
complete I is automatically going to be
incremented to index 1 and then it will
basically this I will be holding 2 then
in the next iteration the same I is
going to be holding 3. similarly I will
keep holding the new value of the
collection item one by one till the
collection items last element is reached
so this is the basic premise that you
can write a collection variable here and
keep iterating over it and this whatever
variable you write here will hold the
current items value one by one so in the
first step this I is going to hold 1 in
the Second Step this I is going to hold
2 in the third step this eye is going to
hold 3 and so on so forth that's the
basic idea so now let's run this program
to see what kind of output do we get so
you can see we basically are able to
print all the elements of the array and
that's probably one of the most popular
usage as well that if you want to just
print all the elements or access all the
elements of array or a collection one by
one then just use enhance for Loop so
you can see at each step it is printing
the value of I and the value of I is
basically the subsequent elements of the
array that's the whole idea with
enhanced for Loop under the hoods if you
talk about how does it work under the
hood it is actually using the classic
for Loop construct itself but for
developers it is making it easier
because it knows that if you are
iterating over a collection you will
start with the first element and you
will go till the last element so it
knows the initialization value the
termination condition and it also knows
the increment condition and that's the
reason you will use enhanced for Loops
in Java for iterating over Collections
and in the next session we will be
talking about the nested for Loops
concept and we will be looking at an
example of how to implement nested for
loops and when do we use nested for
Loops let's get started with nested for
Loops in Java so we talked about the
while Loops the do while Loops the
classic for Loop also the enhanced for
Loop so now we are going to look at a
variation of the classic for Loops in a
in a condition where we have to use more
than one Loop in a nested fashion and
how do we do that what are the use cases
when we use that so in front of you you
can see an example which I have prepared
for nested for loops and in this
particular example I have created a
two-dimensional array as you can see on
the line number six I have created an
integer array and I have put two square
brackets here which are basically really
symbolizing that this is a two
dimensional array so this two
dimensional array is going to hold
technically a 2d Matrix and we are going
to use the concept of nested for Loops
to print this 2D array in a 2d Matrix
style where you will be able to see the
rows and columns clearly let's first try
to interpret this particular 2D array so
we have a curly braces outside and then
we have these three Inner Elements which
symbolizes three rows basically so this
is the first row this is the second row
and this is the third row and then each
of the rows have three elements each
which symbolizes the column values or
the item values so it's basically a 3
into 3 2D array which has three rows and
three columns so so we can say that this
is basically a 3 into 3 array which has
three dimensions on the row side and
three dimensions on the column side or
just a three by three Matrix or three by
three 2D array so as we know that in
case of arrays everything starts from 0
so technically if we talk about the
indexes it would be the index 0 index 1
and index 2 on the row side and
similarly index 0 index 1 and index 2 on
the column side so that's that's
something which you should remember
because we are going to use this
particular concept when we write the for
Loop so let's try to write the for Loop
now if you look at line number eight we
put this keyword called for and then we
write the initialization so we say int I
equal to 0 then we are writing the
termination condition and we are saying
run this particular Loop run this whole
Loop which ends at line 13 till I is
less than 3 and keep incrementing I at
every step that's what I'm doing in the
line number eight then inside the for
loop I am writing another for Loop which
has another different variable called J
it can be anything you can name it
anything you want and this also starts
with 0 and this also has a similar
condition which is which says run this
particular Loop the line 10 basically or
this Loop which is signified by this
curly brushes run this particular Loop
till the time the value of J is less
than 3 and keep incrementing J at every
step and at line number 10 print the
element of array which has the current
value of I and the current value of J
these are basically the positions these
are not the elements the element would
be represented by this whole but print
the element which is at current I and
J's position values that's what this
code means so let's try to do a dry run
on this particular code to understand
how this is going to work so at first we
have I equal to 0 0 is less than 3 and
it goes in inside it initializes J as
well with 0 and J is 0 is also Less Than
3 so this condition went true that's why
we went to line number nine and line
number nine condition also went to true
so we went to line number 10. remember
that in this particular case at line
number 10 the values of I and J are 0
and 0 respectively and we are saying
print the array of 0 and 0 so 0th rows
0th column element should be printed so
this is the 0th row because this is the
first first sub log and this is the
first element so in this case in line
number 10 2 should get printed then it
goes here and it increments the J to 1
so 0 plus 1 becomes 1 it again checks
the condition is 1 Less Than 3 so yes 1
is less than 3 it goes here remember it
did not go up at line number eight it
just came back from line number nine so
when it comes here I is still 0 0 but J
has moved from 0 to 1 so now we are
trying to access the element which is at
zeroth row First Column which is going
to be 7 so 7 is going to get printed
similarly on the next iteration J is
going to get incremented from 1 to 2 and
again the condition will be evaluated so
2 is less than 3 all good it will again
come back to line number 10 and now it
will say print the value of 0 Row third
or the second column or the third
element so zeroth Row Third element
which is the 9 so 9 will get printed
then again J will be incremented and J
will become 3 2 plus 1 3 and now the
condition will be evaluated is 3 Less
Than 3 no it is not less than 3 the
condition becomes false so it breaks out
of the loop goes to line number 12
prints an empty line because we are not
writing anything here so it will just
print a blank line and now it will go
back to line number AIDS condition and
it will do an increment of I and now I
will move from 0 to 1 and now the
evaluation will happen is 1 Less Than 3
yes 1 is less than 3 so it will again go
to line number nine again initialize J
with a fresh zero the previous J got
destroyed the moment you came out of the
loop so this is a new J so this J again
gets initialized to 0 0 is less than 3
it goes here remember I was 1 in this
time so now it will print the value of
this 2D array which is sitting at 1
comma 0 basically second row first
element so second row first element
which is three again J is going going to
get incremented and it will become from
0 to 1 so 1 is less than 3 yes it will
again come here and it will print the
value of the array which is sitting at
array of 1 comma 1. for a row equal to 1
and column equal to 1 which will be 6
Sim similarly J will get incremented
again again 2 is less than 3 come back
here we'll print 1 then again we'll
increment J J will become 3 3 is less
than 3 no it's false the condition is
false so it jumps out of the loop goes
to line number 12 prints a blank line
again goes back to 8 line number eight
increments I and I now becomes 2 2 is
less than 3 yes it will again go here
initialize J again with 0 and again does
the same thing for the Row 2 and column
0 1 2 and again it will come out of the
loop this time again when it will go
here the value will become from 2 to 3
and 3 is not less than 3 so then it will
break out of the outer loop so the idea
is execute the inner loop for every
value of the outer loop remember this
line because that is how you will be
applying your knowledge of nested for
Loops to be used in certain condition so
whenever you have a scenario where you
have to iterate over a collection based
on a certain value of another collection
then you can use nested for Loops or you
have a scenario where you have to
iterate over 2D or 3D arrays for example
if we were dealing with 3D arrays then
you would have seen three nested for
Loops here and where it will apply the
same logic that iterate over all the
collections all the values of the inner
loop on a particular value of the outer
loop then increment the value of the
outer loop and do the same thing again I
trade over all the values of the inner
loop based on a fixed value of the outer
loop so let's run this program and let's
see what kind of output do we get so
like I said our our motive our Target
was to print this in in a matrix style
and you can see that it is printing in
it in a sort of a matrix representation
so the first row gets printed here then
the second row gets printed here and
then the third row gets printed here if
you try to decipher it it will work
exactly the same way as I explained so I
equal to 0 0 Less Than 3 condition
becomes true comes here J equal to 0 J
Less Than 3 condition becomes true comes
here prints the array of 0 comma 0 which
is 2 then prints the array of 0 comma 1
which is 7 0 comma 2 which is 9 then J
becomes 3 it breaks out of the loop goes
up here I becomes from 0 to 1 1 is less
than 3 Yes again comes here re
initializes a fresh for loop with a new
J setting to zero and it will it will
print the array of 1 0 1 1 1 2 then
similarly array of two zero two one two
two so that's basically what we are
doing we are iterating we are picking
the first row and iterating all elements
of it picking the second row iterating
all all elements over it and so on so
forth you can do this for any n
dimensional kind of array or a
collection so this is all I wanted to
cover in today's session where we
discussed about the nested for Loops
concept and how and where we will use it
and in the next session we will be
discussing about the Java Collections
framework let's get started with
collections in Java or the collections
framework in Java I must say that this
is probably the most important concept
of the Java programming language which
you will be using heavily whenever you
are working in any production grade
application so let's understand the
collections framework and the different
classes and the utilities available
inside the collections framework this is
going to be a theoretical lecture
because there is a lot of ground to
cover in this lecture so we will only
focus on understanding the relationship
between the classes why those classes
are created because each class has a
different purpose in this framework and
we will obviously talk about the
hierarchy as well in the upcoming
sessions we will go into the Hands-On
exercise of some of the most popular
collections we will not be able to
provide Hands-On of all the collections
classes which you which you can see on
the screen because then it is going to
take a very very long time to complete
this concept but we will cover the most
popular ones or the most used ones out
of this particular framework so let's
get started as you can see there let's
first understand some of the symbols
here and let me just zoom this in a bit
so that it's visible yep now though I
have just increased the resolution a bit
so you can see there are three different
symbols or Legends here you see this
oval shape which is called interface so
you can see some interfaces here then
you see this uh rectangular blue box
which is called abstract class and you
can see some these blue boxes and then
you see the purple box which is called
the class and you see some classes here
these ones so for now we are currently
we haven't covered the concept of
interfaces and Abstract classes but we
will cover that in the coming lectures
and for understanding The Collection
hierarchy right now the at least the
concepts of it you don't need to be
fully aware of the concept of interfaces
or abstract classes so let's dive deeper
into the framework I table is basically
an interface uh to to give you a very
simple definition of an interface
interface basically is sort of a
declaration which will tell you what
kind of classes will be present under
the interface for example if you have
two let's just store all the cars and
all the bikes and all the bicycles and
all the trucks from all around the world
then you can create an interface called
vehicle and create all of these classes
under the interface and these classes
will be about cars about trucks and
about other kind of vehicles so an
interface is a generic blueprint of
specific class implementation that's a
very simple definition of an interface
and like I said we will go deeper into
this concept in the upcoming lectures so
that was about interfaces similarly when
we talk about abstract classes the next
Legend here abstract classes are also
similar to interfaces where they provide
you a generalization but at the same
time abstract classes provide you a way
to also write some concrete
implementation for example if we take
the example of a bank account so there
in a bank you have different kinds of
accounts you have savings account you
have recurring accounts you have current
accounts and there are many other
different types of accounts so there
would be some common implementation and
logic which will be applicable to all
the account types for example an account
must have an account holder that account
holder must have a valid kyc done for
example well so there would be some sort
of common logic which will be applicable
to all of these right so that common
logic so you have two options either you
can write that common logic again and
again in the savings account class in
the current account class in the loan
account class etc etc or you can write
it at a central place and just refer it
from there so that's where you will you
will use abstract classes so you will
create an abstract class of an account
and then you will create these child
classes under this account class which
will be the savings account class The
Loan account class the current account
class Etc so this is a very lightening
introduction to you about interfaces and
Abstract classes and class as we know is
basically a concrete blueprint which
holds data and logic together so here I
table is an interface which will just
specify that all the kinds of data
structure which can be iterated which
can be looped over should be present
under this particular interface that's
why we created this interface so under
eye table we have this collections
interface and this will govern that
everything which will present under the
collection interface will be holding
some sort of a collection of items now
we look at the next set of interfaces we
see a set interface we see a list
interface and we see a queue interface
when we talk about the set interface
these three different types of
interfaces represent three different
properties of collection and these
properties are exclusive of each other
for example if we talk about set so set
has a property that everything which you
put into set will be unique it will
never ever tolerate or contain any
duplicate elements that's the property
offset so now you can see whenever you
have a scenario where there is a strict
constraint that your collection should
never have duplicates you will use sets
when we talk about lists list is
probably the most lenient representation
of a collection it can store anything it
can store duplicates as well it will not
raise an error or a warning if you store
same element multiple times it will
happily store it but at the same time
the list is basically an index based
collection you can access the elements
starting from the index 0 till the last
element that's the basic value
proposition so whenever you have a
requirement where you want to access the
elements into a predefined sequence and
one by one then you should use list also
the order is fixed here the first
element will always come after the
zeroth element the second element will
always come after the first element so
whenever you iterate over this
particular list you will never have a
scenario where you do not know the order
of the elements being accessed they will
always be accessed in a predefined order
so it's basically we can call it as an
indexed ordered collection which can
hold duplicate applicates then the third
one is Q here so Q is basically as you
can this is basically inspired from Real
World so think of any queue if you if
you go to buy something at a grocery
store or if you go to buy a ticket at a
railway station or you go to the
check-in counter at the airports so you
stand in a queue and the concept of
queue is that it works on a concept of
first in first out the person who first
went into the queue will be the person
first being served and coming out of the
queue and if the second person come that
has to be standing behind the first
person and once the first person is
served and and goes out of the queue the
second person comes at the front of the
queue and that that particular person is
served so you can see it's if you have
to store that kind of behavior or if we
have to implement that kind of behavior
in a Java program then you would use
queues so so this was about the top
level interfaces which are set list and
queue and out of these list and set are
very very popularly used very heavily
used in any kind of java Enterprise
grade application now there are more
interfaces like sorted set navigable set
and DQ sorted set is basically forcing
additional constraint on the set that
the elements will be unique at the same
time you can also have the elements into
a sorted order that sorting can be an
incremental sorting or decremental
sorting that depends but the whole idea
is that it will be sorted similarly
navigable set brings another navigation
kind of properties DQ is basically a
double ended queue where the elements
can be inserted and removed both from
the front and from the back so there are
the different properties of these
interfaces but like I said the most
popular ones are these three ones now
let's talk about the abstract classes so
the abstract classes you see here or
abstract collection abstract set
abstract list abstract Q abstract
sequential list generally you will not
be using these directly you don't need
to use them directly but you should be
aware that they exist if you have a very
specific case where you want to use
these abstract classes you can use them
in Java program but most of the time you
don't need to use them and most of the
times you will be dealing with either
the interfaces or you will be dealing
with the concrete classes now this
lecture is is getting a bit long so I
will like to stop this lecture here so
we covered about the interfaces part of
the collection and we also understood a
bit about the abstract classes though we
are not going to use abstract classes in
much detail in the programs in the next
session we will cover the second part of
this collection framework or the
remaining part of this collections
framework which is around the classes
let's get started with discussing the
concrete classes in the collection
framework in the previous session we
talked about the interfaces part of it
where we discussed about sets the lists
and the queues and we also touched a bit
upon the abstract classes and like I
mentioned earlier you don't need to
generally use these abstract classes
directly in your Java program but you
must be aware that they exist you see
some arrows here right if you see if I
just scroll up you see multiple kind of
arrows here these arrows mean that if
the arrow goes from bottom to top it
means this particular element is a type
of the parent it's basically a denoting
a parent child kind of relationship so
for example here you see preset is
basically a navigable set and also
extend extends abstract set which
extends set so similarly you can see all
kind of complex relationships here and
generally you don't need to remember all
of of those you only need to remember
the few and those few are basically
easily can be spotted for example
whenever you see a tree set it means
it's basically a type of set whenever
you see a word called list that means
that it is a type of list and you all
whenever you see a word called Q then it
means that it is a type of queue so
let's understand these classes let's
first go to the list interface so you
can see list interface has the
relationship with abstract list and from
there it goes down to error list
abstract list has another child which is
called abstract sequential list which is
another abstract class and which has a
concrete class which is called linked
list so let's understand these two
collections or these two uh types of
list right now so when we talk about
arraylist let's understand this we
already have covered arrays so what are
arraylists they are very similar to
arrays in in a way that they are also
indexed based collections so you can
store elements and access them based on
the index position starting from 0 going
till the length minus 1 index and this
is an ordered collection you can access
the elements only in a predefined
sequence it can obviously accept
duplicates as well and these all are
properties are also applicable to arrays
the differentiating factor here is that
arraylist is a dynamic array it's not a
static array if you remember when we
talked about arrays we had to initialize
it or we had to specify a fixed size of
it while we initialize it once you have
initialized the array size you cannot
change the array size it is static it is
fixed so if you have created an array of
elements 10 and if you are trying to
store the 11th element you are going to
get an array of array index bound of
exception but in case of array List It
dynamically updates its size based on
the number of elements stored you can
still initialize it with some some
initial size let's say you initialize an
error list and you say that you want to
initialize it with the size of 10
elements absolutely fine but the moment
you Str you try to store the 11th
element arraylist is going to
dynamically update its size from 10 to
something else so it will keep updating
its size based on the number of number
of elements which are coming to the
collection that's the whole property of
arraylist so remember it's it's used in
the cases when you have an ordered
collection to store and you want to
access them based on the index and you
want a dynamic update of the size the
second sibling of it which is linked
list is also a type of list but it has
slightly different properties than
arraylist in case of arraylist it was an
index based collection you access the
element based on the indexes but in
linked list you access the elements
based on the previous this and the next
element that's pretty much what it knows
so an item can only be accessed in a
particular sequence starting from head
to the tail and when we talk about
linked list the idea is that you have an
element which will have a data and it
will also have a pointer or a basically
a reference that reference will be
pointing to the next element in the
linked list similarly the next element
will store the value the actual data and
it will also store a reference to the
next element so you can see if you have
to go to The Fifth Element you cannot
directly say link list of five the way
you can say this in arraylist because
arraylist is an index based position
list right so you can access the zeroth
element or the fifth element or the
tenth element directly just in one line
or one go but in case of linked list you
cannot access the fifth element or the
last element of the linked list directly
you have to start from the first element
and keep jumping the reference is till
you reach the last element that's the
property of linked list so these are the
two types of list now let's talk about
the type of set a type of set which is
not mentioned here is Hash set which is
a very popular type so a set generally
has two popular types hash set and
preset so let's talk about both of those
if I talk about hash set the property is
that it will inherit the existing
properties of set which is that element
should be unique that's good but along
with that hash set will not remember or
honor the order in which the elements
are inserted into it it will if let's
say if you insert 15 or 20 different
elements inside hash set and then if you
try to iterate over the hash set every
time the order in which the elements are
accessed and printed will be different
every time the order of accession will
be different every time the at the way
in which the elements are accessed their
order will be different you cannot
predict that and that's the property of
hash set whereas when we talk about
reset in case of preset you can have a
sort of fixed order and a tree hierarchy
so a tree hierarchy if you know about
the tree data structure from the data
structure and algorithm section you
already would know what a tree looks
like basically it has a root and it has
child this is basically you can call
this artery as well right so whenever
you have to store the values in a in a
tree fashion where you can navigate
through the parent and Childs then you
would use the preset and remember since
it is a set it will still inherit the
uniqueness property of set so that's
about hash set and preset so we covered
about list we covered about sets now
let's talk about these ones which are
vector stack and priority queue so let's
first understand about priority queue so
you would use a priority queue when you
need a fee for arrangement but at the
same time if there are few elements in
the queue which cannot wait to be
executed or processed when their turn
comes they want it to be executed on
priority so whenever you have such use
case where you want to to maintain a
fifo fashion collection but at the same
time you also want to allow few elements
of it to override this fee for
arrangement and get processed ahead of
their queue number so you can use
priority queue in those cases talking
about stack let's understand stack first
and stack is a lifo Arrangement last in
first out so remember in your house when
you when you put plates or the the
normal dinner plates over one one over
each other you are basically creating a
stack so the property is that the plate
which is put first on the table will be
picked up at the very last and the plate
which is put the last on the stack let's
say you put five plates on top of one uh
one on top of other then the fifth plate
will be consumed first anybody would
pick the plate from the very top they
will not pick the bottom plate because
it's it's almost impossible if you have
a big stack you cannot pull out the
bottom most plate the stack will fall
down so you will always pick out the
elements from the top so it has a leaf
arrangement so whenever you have to
create a last in first out kind of
arrangement in your program for storing
collections you will use stack talking
about vectors vectors are very similar
to lists they are exactly similar there
is basically one major difference is
that vectors are thread safe and lists
are not thread safe Now list has
provided a way to be thread safe we will
cover that later but for now you can
understand that whenever you have a
program in which you want to access a
collection in a thread safe manner where
two threads cannot modify the same
element at the same time then then you
will use vectors so we covered about the
complete collections framework classes
the interfaces and the abstract classes
and always remember the the reason why
you will use arraylist or linked list or
a hash set or a preset or a vector or a
priority queue or a stack that is the
most important concept I want you to
take away from this session let's get
started with arraylists in Java so when
we talk about error list we are
technically talking about a list in the
previous session I covered in detail
about the various implementation of list
interface which were analyst and linked
list and in today's session we'll be
focusing only on the arraylist I have
opened the API documentation of the
arraylist class so if we just scroll
down we will see a nice description
which is provided by Java and it broadly
covers all the points which I described
in the previous session which were that
an error list is basically an array
based implementation of a list it's an
indexed based implementation so you can
access the elements based on their index
position you can directly access any
element if you know its index it accepts
any kind of duplicates as well and by
default it is not thread safe if two
threads are trying to access the same
collection at the same time or maybe
trying to modify the collection then you
will get inconsistent Behavior so that
was about the basic description of
arraylist there are it provides lot of
interesting utility methods as well for
adding elements for adding multiple
elements for removing elements for
fetching an element from the error list
and we will cover those methods in
detail in the demo and with that maybe
let's switch to the demo so for this I
have created a class which is called
arraylist demo it has a public static
void main method and it has an arraylist
example written inside it so at line
number 10 you see that there is an
initialization happening for the error
list and this is how you basically
initialize the arraylist to start with
you write the interface name you can
obviously write arraylist as well here
instead of list you can write arraylist
that is absolutely acceptable but the
reason I have written list here is
because it is a better practice or I
would say it is a best practice to
always initialize the concrete
implementations with the interface type
I'm making a very generic statement
which is applicable to collections and
at any other type of classes and objects
you might be creating in your program
always try to declare it with the type
of interface and then Define the
concrete implementation on the right
hand side so the LHS or the left hand
side will contain the interface
declaration and the right hand side will
contain the concrete implementation the
reason for this is that if tomorrow if
you have to change the representation of
this arraylist to let's say a linked
list then you don't need to do a lot of
work because the linked list is also a
child of the list interface so since
list understands and knows about both of
the classes you can interchangeably use
this reference to point to any of those
implementations that's why it is
considered a best practice to basically
write the left hand side as the
interface and the right hand side as the
concrete implementation that's the first
bit of it second interesting thing you
notice is this so you see these
Expressions here and this basically
encloses any kind of generics or Class
Type what are generics we will cover
this in detail in the upcoming sessions
for now what you can understand and what
you should know that these are denoting
a class type of which the objects will
be stored inside this particular list so
once I say list of integer it means that
this particular list is only going to
hold integer objects if you try to
insert a string object or if you try to
insert a character object or if you try
to insert a float object or any other
kind of object it will create an error
because it remember in the very first
lecture we said that Java is strongly
typed language it has very strong checks
for these kind of data type mismatch so
if that's why it will expect you to
specify the object type here and
whatever type you have specified here
that's the kind of objects which are
going to be stored inside this list I
have been using these terms called
classes and objects into interchangeably
but for now what you can understand that
this is a type how how we write classes
and how we write objects and how we
create objects again I will cover this
in detail in the upcoming sessions so we
have specified the list interface and
I'm saying that this particular variable
should hold any list of integer type
then on the right hand side I am
specifying what type of list this error
list is and this error list will be an
arraylist Class Type and again I have to
specify the Class Type
specifications and then I'm specifying a
size here this is the size of the error
list the initial size of the error list
you can obviously write it without this
as well this is also a perfectly fine
statement in Java and in this case the
array list is going to be initialized
with its default size if you specify a
value then the error list will be
initialized with only that size it is
also considered a best practice to
always initialize the error list with
some known initial value let's say if
this error list is going to store only
two elements and the default size is
definitely way way bigger than two
elements then you are going to waste lot
of memories so that's why it is a best
practice to specify explicitly specify
some sort of an initial size this is
also acceptable because it is
automatically inferring the type from
the Declaration you don't need to
specify it again here in fact some of
this modern Ides will also show you a
warning if you write it here so the next
thing I'm going to do is basically going
to add some elements to this error list
so I've created an error list which
should hold only integer values and it
should hold to start with five values
but it will not complain if you try to
add the sixth value so for that I have
just written a small Loop here let me
just put curly braces around it for
readability so I am saying in time equal
to 1 I should be less than equal to 5 I
plus plus and I keep doing arraylist Dot
add so this add method is the method
which is used to add elements to the
array list so whenever you have to add
an element to the error list remember
you need to use the method add and then
specify the actual element which is
supposed to be added so I'm adding one
two three four five in this error list
one by one using this Loop and then I am
just printing the whole arraylist that's
what I'm doing here after that to
showcase is another operation of this
arraylist I am removing an element and
if we have to remove an element from
error list just simply called errorlist
dot remove and specify the index from
which you want to remove the element
remember you need to specify the index
and as I said in the beginning this is
an array based implementation so this is
going to start from 0. so when I say
remove the element at index 3
technically it's the fourth element of
the error list after that once we have
removed the element I am again
displaying the modified error list and
then printing all the elements of the
error list one by one and for for
fetching the element if you see here if
you if you observe this particular for
loop I am using couple of more
interesting methods of the arraylist
let's understand those methods as well
and then I will run the program so here
you see that I'm saying int I equal to 0
and then I'm saying I less than error
list dot size so in if this error list
has a capacity initial capacity of
storing five elements and I've just
added five elements to it then the error
list dot size will be 5 but it says less
than so it will start from 0 and run
till I equal to 4 because the moment I
becomes 5 5 is not less than 5 and it
will come out of the loop so basically
I'm trying to start this Loop where I
eyes value starts from 0 and goes till 4
and here I am calling another error list
method which is used to fetch an element
from the error list so whenever you have
to get an element from the error list
just call Dot get on the error list so
arraylist dot get and I'm specifying the
I value so errorless dot get of 0 get of
1 get of 2 get of 3 and get a 4 and
that's technically the five elements
which are stored in this arraylist so
let's run this program so and now let's
observe the outputs here let me just
bring the outputs down yeah so at first
I'm just printing the error list so
nothing nothing I'm just adding the
elements and printing the complete error
list so if you want to just print the
whole error list just put that inside
system.out.printellid and the whole
error list will be printed that's line
17 then I remove the element at index 3.
so if I Traverse through this particular
list this is index 0 index 1 index 2 and
index 3. so index 3 has an element which
has a value 4 and I'm saying arraylist
dot remove the element at index 3. so
this particular element should be
removed from this particular list when I
call the line 20 and then if I print the
modified error list at line 24 I can see
that 4 is gone now it's only one two
three five that's the remaining list you
also need to notice that whenever I call
system.out.println with error list I get
this square brackets which is the
representation of an arraylist if you
don't want that you might not want that
always right if you want to print this
nicely without the square brackets then
you have to iterate over the arraylist
and that's what I'm doing here I'm going
from 0 to errorless dot size and I'm
doing get of 0 get of 1 get of 2 and get
of three and that's how I get these
values without 4. we can also write the
same Loop using for enhanced Loop so
let's say if I write for INT I colon
array list and then inside it I can just
say system dot out dot print Ln I and if
I comment this particular Loop for for a
moment and run this program
I see the values one by one because it's
Ln so every output comes on on a new
line but you can pretty much see the
same output if I remove this and if I
write it like this just adding an extra
space it will look a bit more nice a bit
more formatted like this so as you can
see that we can get the pretty much the
same output either using a classic for
Loop style which is a bit verbose or you
can use an enhanced for Loop which is a
much simpler and shorter and less
verbose way of doing exactly the same
thing you don't even need to call the
errorless dot get I but I the reason I
put this example because I wanted to
show you the get functionality as well
so that's all we are going to talk about
in this session in the next session we
will be discussing about linked list
which is the another implementation of
the list interface let's get started
with linked lists in Java in the
previous session we talked about
arraylists and today we are going to
talk about the another type of
implementation of the list interface
which is called linked list if you
remember from the previous sessions we
discussed about the properties of the
linked list and all those properties are
listed here as well so basic idea is
that whenever you want to have a kind of
implementation where the order of the
elements is strictly maintained where
the first element can refer to the
second element the second element can
refer to the third element and so on in
those kind of cases you are going to use
linked list another property of linked
list is that you cannot randomly access
an element directly as you as you could
do in case of error list in case of
error list you just you just write
errorless dot get and you provide the
index location and you get the element
right away that's not possible in linked
list in linked list if you have to
access the let's say the second last
element or the fifth element in a 10
size element list in in that case you
have to start from the head which is the
first element and keep traversing Till
The Fifth Element that's the only way
possible to access the fifth element or
any random element so that's the
property of linked list it is also not
synchronized so if multiple threads are
trying to access a linked list
concurrently at least one of the threads
and and one of the threads tries to
modify the list then it must be
synchronized externally by some other
ways otherwise you will get
unpredictable results
and again this also provides a bunch of
utility methods and we will cover some
of those methods as you can see add
method for adding an element add all add
first contains get first get lost we
will cover some of these methods in the
demonstration which follows this
particular documentation and with that
let's jump to the implementation
so I have prepared an example here for
the linked list which is called linked
list demo I've just created a class for
it and we have created a public static
void main method here and here you can
see at line number 10 I have declared a
linked list so this looks very similar
to the way we declared an error list you
see if you have noticed on the LHS I
have root I have written the concrete
class and I have not written the
interface reason being I'm using some
concrete methods and actual methods
which are only available in the linked
list class so I am not looking at the
reusability aspect in this particular
example if you are then you have to add
extra code for it but here I'm just
writing linked list and again in this
particular linked list I'm saying that I
would only store string objects so
that's why inside these braces I write
string and then I say new linked list
string again I have not specified the
size so it will take the default size as
per the VM implementation now I have
declared my linked list and it's time to
add some elements to the link list for
that I have the method add which is
available in this linked list class
which will provide me with the
capability to add elements so at line
number 12 and line number 13 I'm adding
two elements and if you remember I told
you that it works in a reference based
implementation so at first an element a
will be added and when you try to add
element B element is reference will be
updated to point to B that's what will
happen in this linked list and then at
line 14 I am using another interesting
utility method of this linked list class
which says add last what this method
does that specifically it will add the
element at the very end of the linked
list so that was about add last and if I
talk about line 15 I'm using another
interesting method of linked list class
which is called add first so what this
will do that this is going to insert
this element D at the very beginning of
this linked list like even before a d
will be inserted so whatever your linked
list looks like whenever you called add
first that element is going to be
inserted at the very head of the linked
list or the very beginning of the linked
list linked list also provides another
variant of the add method so there's one
way to just add the string element
directly because this is a string a
linked list you can also add it based on
the position so you can say add e at the
second position inside the linked list
so let's observe this output let me
comment all the code below line 18
because we will be using some more
methods here so we'll cover that in a
while but let's first understand the
output at line 18 if we run this program
so right click run as Java application
and this is the output we get so let's
understand the output or maybe let me do
this let me put this here one by one so
that we can interpret the output so I'm
adding two elements and printing the
list then calling add last and printing
the new list then calling add first
printing the new list and then calling
list dot add 2 comma e and printing the
list again so let's observe this outputs
one by one I'll comment this and let's
run this now so if I run this particular
program the program till line 14 is
executed because rest of the code is all
commented let me comment this as well
and if I run it again yes this is the
output I get so at line 12 and 13 I've
added two elements and I print the list
there are only two elements and they are
printed in the fashion a comma B
everything is good here now let's
uncomment this code and now I'm calling
add last method and adding an element
with string C which should be added at
the very last of this particular list so
let's see now what happens let me
comment this one so that we only see one
list at the output
okay we see a comma B comma C so C has
been successfully added to the end of
the list now let's interpret this
particular method which is called add
first so I'm going to uncomment this and
comment the previous this out so now
there's only once it's out here so I'm
adding two elements adding C at the last
and now adding D at the very beginning
and printing out the list let's see what
happens okay so the D has been added at
the very beginning of the list even
before a so now it looks like d comma a
comma B comma C so far so good now let's
move to this particular code and now I'm
saying add an element called called e at
the second position inside this list
remember second position so let's run
this list now this program now so now I
see D comma a if you remember the
previous output was d a b c if I just
uncomment this for a while just to make
it more clearer and if I run this
program the previous list was D comma a
comma B comma C and the new one says d a
e e has been inserted at the position 2
so 0 1 2 position 2 has been added with
this new string e and my list is
modified now it's time to find some
interesting operations about the removal
so what happens if I try to remove
elements from this list and then we will
observe the output again so let's say if
I say list dot remove B and so I'm
saying just drop this particular element
so you can directly specify that
particular elements value and that
element will be removed from the list
and let's see what output do I get if I
just call list dot remove B and I
comment the rest of the code so we
should see a new output here which
should not have B so running the program
again yes so this was the old collection
and this is the new collection from
which B is gone because I've called list
dot remove B now you can also remove
elements based on the index position
instead of specifying the element
explicitly you can specify the index
position and what happens if I call list
dot remove three let's observe the
output here as well so I'm just going to
copy paste this is out and we'll see
what output do we get if we remove the
element at third location
okay so this was the previous output
after removing B and if I call list dot
remove 3 so 0 1 2 3 C is the element
which is at third location and it is
gone when I call list dot remove three C
is gone and D comma a comma e is only
remaining now let's try to understand
this particular line which says list dot
remove first expectedly this is going to
remove the element from the very
beginning so whatever element is present
at the beginning it is going to remove
the element and then we are going to
print the list the modified list so we
were here till d a e and D was the
element which was at the beginning and
if I called remove first D is removed
and now only a comma e is available and
now I use another interesting method
which is called list dot remove last and
then I print the list the modified list
so this is the list remaining and I am
calling remove first so e should be
dropped and only a should be left in
this particular list
yes we only see a here so this is
basically what I wanted to show you in
this program that we can perform
different kind of operations using
different methods like add add first add
last remove remove first remove last
obviously there are more interesting
methods available in this particular
class do check out the API documentation
for it and there you can see all the
different interesting methods which you
can use while implementing linked list
so this is all I wanted to cover in this
particular session and in the next
session we are going to cover an
interesting framework class which is
called set we are going to learn about
sets in Java in the next session uncover
the world of java then have a look at
Caltech coding bootcamp by simply learn
so hurry up and enroll Now find the
complete course details from the link in
the description box let's get started
with hash set in Java if you remember I
covered in the collections framework
session that hash set is part of the set
interface hierarchy and sets have a
property that they keep the collections
element unique if you try to add
duplicate elements to the a set it will
not accept that and it will still
maintain the uniqueness property of the
collection hashtag provides some
additional features to the set which is
that in this case the elements would be
accessed in a random fashion they will
not be accessed in a fixed sequence
rather they will be accessed in a random
fashion hence the name has set so if you
read about this particular class in the
documentation it will basically cover
all the things which I just described it
also accepts null elements if you want
to insert null but why would you try to
insert null that's the first question
which you should ask it again provides
similar kind of utility methods to the
list interface collection hierarchy we
covered like some utility methods to add
the elements to remove the elements to
check the size of the collection and to
check if an element exists in the
collection or not etc etc and we will
cover some of these methods in the demo
this is again not synchronized so this
is not a thread safe collection which
you should know so let's look at a
demonstration of hash set and how do we
actually create a headset how do we
operate upon a headset using different
utility methods so as you can see I have
created a class here which is called
hash set demo there's a public static
void main method and then at line number
10 you will see that I have created the
hash set and again it starts with the
concrete class here which says hash set
and you can obviously write it as set as
well which will also work fine so we
write the set type as string so this
particular set is going to hold only and
only string objects and nothing else and
this set is basically a type of hash set
again this is not mandatory so you can
remove that it will still not complain
and the program will run fine if you
want to specify a size please do that if
you do not want to specify the size
nothing goes wrong and it will be
initialized with the default memory
footprint but remember doing this wastes
a bit of memory so if you are running
this program on a machine which is
really tight on memory always put some
kind of initialization size based on
your knowledge of how many elements are
going to be stored in this collection so
after that at line number 12 we start
adding elements to this collection and
for adding the elements the method which
is provided by the hash set class is ADD
so you use the add method to add new
elements so at line number 12 line
number 13 14 and 15 I use the method
again and again to add some elements If
You observe the line number 14 and the
line number 15 these two lines are
adding the same element so I am trying
to add C twice to this particular
headset and we will reserve the output
to see what happens if we try to add
duplicate elements in the hash set
because if you remember the sets are
supposed to be unique they should not be
storing duplicate elements that's the
property of sets so that's what I
demonstrate by by adding duplicate
elements to see how it behaves and let's
do that let me comment the rest of the
code for a while and let's run just this
part of the code where I add C twice and
I print the hash set and let's see what
happens so I go to run as and I click on
Java application and I only see three
elements even though I added four I only
see three and C has been added only once
not twice now you might be wondering
whether this C is the C added at line 14
or the C added at line 15. so to
understand that we need to understand
how hash sets add method works so this
add method is based basically returning
a Boolean value if the element is added
successfully this ad is going to return
true and if the element could not be
added successfully this add method is
going to return false so let's do that
let's store the result of these ad
methods let's call this R1 and let's
call this one as R2
okay and now we will try to print R1 and
R2 and see what happens so if we write
system dot out Dot println and I say R1
and then I just copy this after line 16
and write R2 and now we will observe the
output of these to see which when we did
the add at 14 and when we did the ad at
16 which actually resulted in C getting
added did C get overwritten or did C did
not add twice what happens
so we see that when we do the ad at line
14 we get true so it means that this ad
was successful and C was added here and
when I did the ad again at line 16 this
returned a false it means the hash set
rejected this add operation so this C
was not added so the actual C was never
overwritten the original C was
maintained and when you try to add a
duplicate value with the same value a
duplicate element with the same value
hashtag is going to reject that so that
actually proves that the set will
maintain the uh the uniqueness property
and it will reject all the duplicates
subsequently that was about the add
property now let's understand another
interesting property of the contains
method contains method of this set class
is used to find if an element exists in
the set or not so you can just use the
hash set variable name dot contains and
just type the actual element and this is
going to return true or false based on
whether this element is present in the
hash set or not present in the hash set
if it is present then this contains
method is going to return true otherwise
it is going to return false so let's run
this method and observe the output at
line 21.
so it says list we are writing this
particular string which says does list
contain C or not and it returns true
because yes my half set does contain C
now coming to line 23 I use another
method of the hash set which is the
remove operation which you can use to
remove an element from the set and then
I'm again doing a sound and I'm asking
the to print the set this should be set
and not list
so then I'm checking if what happens to
my hash set if I call the remove method
and I'm just printing the modified hash
set at line 24. so let's see what
happens with the effect of remove
operation okay so after removing a this
is what remains in my hash set and a has
been successfully dropped if I call the
remove method and then I try to just
iterate over the hash set to show you
how does this iteration work it again
works on exactly the same way it has
been working for the list
implementations that on the rhs of this
colon you write the collection name so
hash set and on the LHS of this colon
you write the representation of the
element so this hash set is going to
contain string and this is just a
placeholder it can be anything this is
just a temporary variable to store the
current value at the current step of the
hash set iteration and I'm printing all
the items one by one
so if I run this I am able to print B
and C because that's all which is
remaining in this hash set so this was a
very quick demo to show you the
functionalities of the hash set how does
hash set maintains uniqueness how do you
remove elements how do you add elements
how do you check for an element's
existence using contains there's also a
method to get the element of the hash
set if you want to so these are all the
different properties and methods
available in the asset and do check it
check out the API documentation of the
hash set to learn about more methods so
that's all I wanted to cover in this
particular session where we focused only
on hash set and in the next session we
will be discussing about three sets and
we will also see an example of how do we
Implement three sets in Java let's get
started with three sets in Java so in
the previous session we talked about
about hash set which is one of the
implementation of the set hierarchy and
today we'll be focusing on preset and if
you remember when we talked about this
collection framework I discussed briefly
about preset that the main reason you
will use tree set is basically when you
want to maintain natural ordering of the
elements if you are adding your custom
elements then you need to tell Java how
to compare and sort and order the
elements but that's for another day when
we'll cover about the detailed
comparable and comparator interfaces for
now what you can understand that
whenever you have to maintain the
natural order of the elements
automatically then you should use preset
along with that the set property still
holds true that this tree set cannot
have duplicate elements we should also
know that reset is not synchronized so
it is not a thread safe collection so be
be remember be aware that whenever you
are trying to use preset in a
multi-threaded environment you need to
write more wiring code around it so that
preset works as expect affected okay
that was about a brief theory about the
preset you can read about about it in
detail in this tree set documentation
class and with that let's switch to a
demonstration of the preset class so
I've prepared a class here which is
called reset demo as you can see it has
a public static void main method and at
line number eight I am initializing that
reset again it's again the standard
representation of initializing a
collection which we have been using
throughout the different examples of the
collections so preset of string so this
particular preset is going to hold only
on only string elements if you try to
add another element it is going to
through a compilation error and the on
the rhs I'm just saying new preset and
again this is not mandatory so I can
remove that and it will still work you
can specify the size whenever you know
about the scope of the collection you
should always specify the size for this
demonstration it's a lightweight program
so it's fine after that from line number
but 10 till line number 13 I'm again
going to add some elements and again if
you see I'm adding elements in random
order I'm adding B and then I'm adding
adding a then I am adding C twice just
to show you the uniqueness property of
the tree set does it still hold true or
not we will be able to figure that out
from this particular example and we will
also see if I am adding B before a will
it be printed in a fashion called BAC or
will it be printed in a fashion called
ABC we should also know that so let's
try to run this program and understand
the output
so if we look at the output we see a
before B but here when we added the
elements we saw B before a we added B
first and then we added a and then we
added C twice and as per the uniqueness
property of this set the second uh
addition statement at line number 13
returned false and set rejected this
addition because it could see that c was
already present in this particular
collection so C is added only once but
what's interesting is that b is added
first but B is added B is printed after
a so the natural order of the elements
in this collection is automatically
maintained by preset so what under the
hood reset does here that it looks at
the type which is a predefined type in
Java string is a predefined class in
Java so it will use its own sorting
algorithm to sort the strings based on
their natural order of sequence and in
the natural order of sequence a will
always come before B and B will always
come before c so it will automatically
apply that sorting and will present the
result to you if you are using a custom
class here let's say your own student
class or your own customer class or your
own account class in that case that
account class or student class or
customer class needs to tell Java how to
sort elements and for that you need to
write comparable and comparator
implementations which we will cover in
detail in the future sessions but for
now you you must understand that
whatever the type of class you are
specifying here should tell Java how to
sort the elements either Java should
know it automatically if it's a
predefined class like string or integer
or float or double then Java would
automatically know by default how to
sort the elements but if you are
creating a custom class of yours in the
three set and specifying that as the
preset type then you should also tell
Java how to sort the customers whether
you want to sort them based on your
first name whether you want to sort them
based on their age their salary Java
doesn't know that so you need you need
to tell Java about that if you're trying
to use a custom class as the type entry
set in this particular example I'm using
string here and it will apply the
natural ordering let's put C here in the
very beginning to see what happens and I
can comment this as we have already
maintained and verified that c is only
printed once and added once so I'm
adding C B A and let's run this program
I still get ABC because again the
natural order is implemented contrary to
this when we talked about hash set
remember I told that hash set is a
random access
element collection list so if you run
the hash set if you try to print the
headset again and again and again you
might see a different order sometimes if
I use a hash set here sometimes it will
print ABC sometimes it will print BAC
sometimes it might print cab any kind of
sequence any kind of random sequence it
will pick automatically that's the
property of hash set but in case of
preset no matter how many times you run
it you will always get the same order
based on the Sorting implementation
available in the class type so that's
all I wanted to cover about preset
please read about read about its Java
documentation in the API docs to
understand what all other methods and
utilities reset provides but it's pretty
much similar to what we saw in the
headset example like remove or get etc
etc and contains Etc so all the all
similar methods are available in the
preset class as well and that's all
we'll focus on on this particular
session and in the next session we are
going to talk about an interesting
framework called Maps let's get started
with maps in Java so first of all before
we understand this particular diagram
and the classes in this map framework
let's understand why do we need map so
there would be instances when you would
write a Java program or any kind of
program there would be always be
instances where you would need to store
a key value kind of arrangement a very
simple example can be that you want to
maintain a company database and you want
to just bring the whole mapping of the
employee ID to the employee name into
the Java program how do you do that you
need a key value sort of arrangement
where you can store the employee ID as
the keys and each of the employee ID key
would correspond to an employee name
which will be called the value so you
need a key and value arrangement in a
Java program to store that kind of
information and use that kind of
information in your program and that's
where map comes into to picture whenever
you have to store a key value
Arrangement remember you would always
think about maps maps should be the
right collection or the right data
structure to be used if you want to
store any key value arrangement in your
program so that's about map and here you
can see a nice framework representation
of map and this is going to be a
theoretical lecture where we will
understand how this map framework Works
what is the property and what are the
different implementation classes and
then in the future sessions we will
again look at some examples of the most
popular map implementation classes which
are used in the Java world so again uh
the orange oval R interfaces the blue
boxes or the light blue boxes are the
abstract classes and the purple boxes
are the concrete classes so map is an
interface which will provide this kind
of a blueprint that every class
underneath it would be working on a key
value Arrangement when we talk about
this key value Arrangement so we have
this keys and we have the values so the
keys here are supposed to be unique the
values can contain duplicates remember
this is a very important concept that in
map the keys will be unique and the
values can have duplicate and because we
want to maintain the uniqueness in the
keys part that's why the keys are
technically stored as a set because we
know that set cannot contain duplicate
sets are by designed made to be storing
only unique elements so map uses the set
class to store its keys and to store the
values it generally uses a list class so
you can see map is basically reusing the
classes from the collections framework
sets for storing the keys and lists for
storing the values that's the basic
anatomy and basic idea of how map is
working now you see some classes here
called abstract map and sorted map and
again similar to the set hierarchy
whenever you see the sorted word and if
you look at the concrete class which is
called tree map this is going to provide
you some sort of an order sorting order
automatically and then you have the hash
map class and this class is going to be
providing a random access this will not
maintain the insertion order this will
not provide you a natural sorting order
this is just to store elements in random
order and the element here a single
element here is basically consisting of
two parts which is key and value always
remember that you also have hash table
here hash table is basically a
synchronized representation this is a
thread safe hash map and tree map are
non-thread safe so multiple threads if
you try to work in a multi-threading
program with these hash map and tree map
you are going to get very unpredictable
results but if you use hash table then
it is inherently thread safe so it will
only allow one thread to be to access
the hash table at a particular time you
will also you will also be thinking then
then it's always better to use hash
table right because you will never get
into those weird errors and you don't
have to migrate your program uh to a
multi-threaded environment whenever you
are trying to use hash tables yes that
is true but hash tables are slower for
the same reason because only one thread
can can access it at a time and that's
why hash tables are slower and hashmap
and tree map are way way faster because
they allowed multiple access at the same
time so you have to always be mindful of
what kind of collection type you're
using there are some external ways as
well to make these hash maps and dream
apps and headset and preset and
arraylist and linked list as
synchronized as well and we will talk
about that in a future session but for
now you can understand that hash map
entry map are non-thread safe and hash
table are thread safe there is another
class which is which is coming out from
the hash map class which is called
linked hashmap and linked hashmap as the
name shows it will basically carry two
properties it will carry the property of
hash map where the elements are stored
or displayed or accessed in random order
and at the same time it is also
providing the linked property of the
linked list where the sequence is
maintained so you can see you can
actually get the insertion order if you
use a linked hash map the way in which
you insert the elements would always be
the way in which the elements will be
accessed so you are getting sort of a
ordering property but the order is the
insertion order it's not the natural
sort order it's the insertion order
that's why the name linked hash map
because it brings the linked list part
of the link property inside the hash map
where the elements would be presented to
you in the order they are inserted when
you call the add method so that's what
we covered here we covered about map
interface we covered about hash snap
class which is going to store the values
and the access will be random the value
means the element means a key and value
which sometimes also call this as an
element you will see that representation
Sometimes some some people also call it
as iterable element it's all the same
thing but it's a key and value
Arrangement pre-map also stores the key
value Arrangement but it will provide
you a sorted representation and here the
Sorting will happen on the keys not on
the values the Sorting will be happening
the natural order of salt which will be
maintained by the tree map is only
applicable to the Keys here
similarly linked hashmap it will insert
the elements but when you try to access
it it will maintain the insertion order
no matter how many times you access it
it will only be presented to you in the
order the elements were inserted and
hash table is very similar to hashmap
with the difference that hash table is
thread safe multiple threads cannot
manipulate the hash table at a time it
will only let a single thread access
itself at a time so that's the property
of hash table the most popular classes
are generally these ones hashmap Cream
app and linked hashmap very rarely you
will also see hash table but since we
have some ways to get these synchronized
so generally you would not see much of
the hash table implementation and that's
all I wanted to cover in this particular
lecture where we walk you through the
concepts and the theory of the map
framework and in the upcoming sessions
we'll go deeper into the concrete
classes and in the next session we'll
specifically discussing about hashmap so
we will understand how hashmap works we
will create a hash map and we will again
look at some utility methods which are
provided by the hashmap class through
the demonstration let's get started with
hash maps in Java in the previous
session I covered about their
theoretical concepts of map and the key
value Arrangement and the keys being
basically are set and the values
basically being a list and now we are
looking at the API documentation of the
hash map class you can see the K comma V
here these are the types of the key and
the value which the hash map will accept
you can see K is basically the type of
keys and V is basically the type of
mapped values uh like I explained it's
basically keys are stored in a set
fashion and values are stored in a list
collection fashion this is not by
default synchronized so if you want a
third safe collection then you would
have to do something else which I will
cover in the future sessions this is a
very brief overview of what hashmap is
but let's look at the example to
understand better and then I will be
able to explain it in bit more detail so
now we are looking at an example which
is basically a class which is called
hash map demo I have a main method here
and then at line number 10 I am
initializing the map and as you can see
that on the LHS we see the concrete
class hash map and I can do this and
this will still work provided you have
the import here I had the import here so
it will work fine and I'm saying that
this map is going to contain a key value
Arrangement where the keys are the
string type and the values are of the
type integer and it's ultimately a hash
map here I I don't need to again provide
the generics because I have already
provided the generics here
the name of the map is just simply a map
and again you can specify your size or
you can skip the size based on the
memory requirements and the program
requirements now coming to the point
where you want to add elements to the
map now since this is a key value
Arrangement here the name of the method
through which you are going to add
elements is put so you call map dot put
and then you provide the key
comma you provide the value that's the
Syntax for adding an element or we
technically call that element an entry
this key value together is called entry
so if you have to add an entry to the
map you have to write it in this way
where key comma value is the convention
so I'm adding three elements or three
entries here which is a comma 10 B comma
20 and C comma 30 ABC are basically the
keys and 10 20 and 30 are the
corresponding values of these Keys
respectively
after that I'm I'm showcasing another
utility method of this particular class
which you can use to find the size of
the map so you can just call map dot
size and it will print the size of the
map
after that I am printing the actual map
the whole map and then I'm using some
more methods but again let's comment
this code and let's understand this code
one by one so that there is no confusion
so to start with I'm going to add some
elements some entries and I'm going to
print the size of the map and the map
itself let's run this program
so here you can see the size of the map
is printed as three because I've added
three entries and then when I call map
inside the system.out.print Ln method I
get the whole map printed here and this
is how the map will look like when it is
printed we can see key equal to Value
syntax here where a equal to 10
b equal to 20 and c equal to 30 are the
key value representations or the entries
here separated by comma enclosed by the
curly braces that's how our map looks
like so far so good the next thing which
I am going to Showcase to you is the
contains method and since the map has
this set which is the keys basically
that's why map provides a method called
contains key basically you can check if
a particular key is present in the map
or not and if you know the key is
present then it's very easy to get the
value from the key math will provide a
method also where you can supply the key
and get the value so knowing the key is
the most important part and that's why
map provides a method called contains
key so you can call this method specify
the key which you want to check for the
presence in the map it is going to check
whether a is present in this Maps key
set or not if the a is available in this
Keys we can see a is available then this
condition is going to hold true and then
like I said if you want to fetch the
value then you can call the get method
providing the key you can fetch the
value from the key that's the that's the
core idea which you should remember so I
call map dot get specify the key and
this is going to spit out the value
which is being pointed by this
particular key in this case a is
pointing to 10 when I say pointing it's
not pointer remember it's just a
reference so map dot get of a is going
to get the actual value which this key
is pointing to which is 10 and then I am
printing this integer a which is the
actual value pointed by this particular
key so let's run this program and see if
this works so we get these two outputs
from the above and then this is the
output which is coming from the if block
so it checked whether the map is
containing a key with the name a yes it
was able to find that and then we asked
the Java program to fetch the value
corresponding to this particular key so
we just called map dot get of a and it
fetched 10 and it printed 10 here that's
why you see 10 here okay so that's how
you can basically use the contain scheme
method and the get method now what if
you want to iterate over all the keys
what if you what if you have to use the
all the keys and you have to make some
pattern or make some observation about
all the keys in your map you can do that
by iterating over the key set and for
that map provides a method called key
set so you just called map.keyset and
this is going to fetch all the keys in a
set representation and will be provided
to you so here when I call map.keyset
this is basically giving me a set which
is containing all the keys and then I'm
iterating over the keys one by one you
would be familiar with this syntax by
now which is the enhanced for Loop
syntax and inside this I am printing the
key which is the current temporary
variable holding the current key and the
value pointed by that particular key at
that particular step and I'm again using
the same method get which I which I
showed you here
same method so you provide the key and
you will get the value so I'm going to
get all the keys hydrate over the keys
and then print the key and the value
let's see how this looks like so till
this we were good and here you will see
the output which is coming out from this
particular for loop from this particular
for Loop line 25 to line 27 where I am
iterating over the key set printing the
key and value one by one so this is how
to show you if you just have access to
the key set you can still iterate over
the whole map but what if you know
everything you have access to the key
set you have access to the values and if
you was if you just want to iterate over
it then you can use this particular way
and instead of map.keyset you're going
to use map dot entry set if you remember
map treats each key value Arrangement as
a single entry entry is the keyword here
so map dot entry set is going to give me
all the entries in the map and then each
entry is basically of type entry class
this is the representation of each entry
and we know how this representation
formed entry is the class basically
which is coming out of this map
collection hierarchy and then let me
just save this and then string is the
key and integer is the value held by
each entry inside the map so that's what
we are going to do we are going to pick
up all the entries in the map and going
to iterate over the entries one by one
by writing this enhanced for Loop and
entry is the temporary variable which is
going to hold each entry one by one at
each step and then it's very simple we
call entry dot getkey you will get the
key and you call entry dot get value and
you will get the value so it's much much
simpler than this one where you had to
do map.get to understand here it's very
implicit get key is going to get you the
key and get value is going to get you
the value so you just need to call map
dot entry set iterate over the entry set
and get each entries key and value and
print them or do whatever your program
requires to be done that's how you will
use it so let's run this one as well to
verify if this works okay so this is the
output which is coming from the last
Loop this Loop basically you can see key
I did not put any space that's why you
see key a key B and Key C together let
me put a space here and put a hyphen so
that the output looks better and let me
rerun this yeah this is much better so
you can see the key a value 10 KB value
20 and Key C value 30. this is coming
from this particular for Loop which I
just showed you so this is all I wanted
to cover in this particular session we
went deeper into the hash math
representation and we saw bunch of
methods contains key key set entry set
get put Etc and we showed how we can use
the hashmap for different purposes in
the program in the next session we'll go
deeper into the tree map concept and
we'll also look at a demo of tree map
and we'll understand and how it works
let's get started with three maps in
Java now if you remember in the last
lecture we talked about hash maps in
Java and we also had a look at an
example where we saw how a hash Map
works and how we can use a hash map we
also had a look at different utility
methods of the hashmap as well now in
today's lecture we are going to focus on
tree Maps which is an another type of
map as we discussed when we were
discussing about the map framework and
the main property of a tree map is that
when you enter elements into a map they
will naturally be sorted or naturally be
ordered now when I say naturally ordered
what it means that if you put the keys
as let's say integer then the tree map
will automatically sort all the map
entries in an integer sorted fashion
where you'll see the natural number
sorting uh Behavior like one two three
and so on similarly if you store Alpha
bits or strings then they then those
will be sorted in a natural sorting
alphabetical order starting from A to Z
so these are the uh these are the data
types which the Java is already aware of
on how to sort them like integers
doubles floats strings Etc but there can
be a case where you have your custom key
this particular key is your own custom
class if that is the behavior or if that
is the scenario then in that case you
will have to provide an implementation
to Java to know how to sort those
elements because Java doesn't know for
example a student class or an account
class Java doesn't know how to sort that
so if you have that kind of scenario
then in those cases you will have to
provide your own sorting implementation
and we will cover about what kind of
sorting implementation you can provide
in those kind of scenarios in the
upcoming lectures for now we will look
at have a look at an example of tree map
where you can see that I've created a
class which is called tree map demo and
I have initialized a tree map with the
keys as integer and the values as string
so this means that each entry of the map
will have key as the integer value and
the value of that particular entry will
be of string type so basically an
integer to string mapping is what each
entry of this tree map is going to store
so nothing different here you would have
already seen this kind of this kind of
initialization for any kind of map and
after that at line 11 I use the standard
put method of the map and I started
storing the values so at line 11 I'm
saying store 3 and a so 3 is the key and
string a remember this is not a
character this is a string we because I
have specified string here if you
specify a character here and if you try
to store a string this is going to throw
an error and you need to fix that so I
store 3 as the key and a as string as
the value similarly at line 12 I store 2
as the key and B as the value and at
line c i store 1 as the key and C as the
value so these integers are the keys and
the string are the values and if I just
put them and if I just try to print them
what happens what kind of order can we
expect let's try to analyze that so I
right click on this I go to run as and I
go to run as Java application it will
run the program because I have a static
void main method and now you see that
the map is printed in a different
fashion than the way it was added we
added the map elements in this sequence
that we added 3A first 2B second and one
c as the third element but when we
started printing them we saw one C
printed first to be printed second and
3C 3A printed third so what this denotes
that this tree map because the key was
integer here it automatically sorted
these Keys into a natural order sorting
and it provided when I try to access the
map it provided the access in that
salted sequence only no matter how many
times you run this particular program it
is always going to return the map in the
same format in the same sequence the
sequence of representation of the
elements is not going to change and you
can basically do the similar behavior
for example if I just change this to
string and integer let's do it like this
and if I again swap the elements here as
well I say a comma 3 and I say B comma 2
and here I can say C comma 1. if I do
this I just switch the keys and values
position now the string is the key and
the integer is the value and let me just
put these two before a so that we can
demonstrate the behavior of the tree map
properly so I am inserting B2 first and
C one second and A3 third and I just
save this file and now let's run this
file and let's see how the output comes
so now you can see that since the key is
now string it has applied it has
automatically applied the natural
sorting ordering of strings which is
starting from a going till z and that's
why you see a entry as the first entry B
entry as a second entry and the C entry
as the third entry again no matter how
many times you run it or you iterate
over it you try to access it you will
always get the sequence in the same
fashion so this is a basic overview of
how tree Maps work now you can and I
would strongly recommend you to go and
read about all the other methods which
are available in the tree map which you
can use for example how can you remove
elements how can you uh how can you
iterate the elements of the tree map Etc
in fact the iteration is is going to be
exactly the same way as we have seen in
the case of hash Maps because iteration
Behavior doesn't change but to uh if you
want to see what all different kinds of
methods pre-map support it supports a
lot of different methods we can't cover
all of them in this short tutorial but I
would strongly recommend you to go and
read the javadocs API of the tree map to
get familiar with those methods so that
you know what kind of functionalities
Stream app can provide in the next
session we are going to have a look at
how we can use stacks and we will look
in a Hands-On example of how we can
build stack and how we can use them in a
real life scenario let's get started
with Stacks in Java now if you remember
when we were covering about the
collections framework I walked through a
complete hierarchy of
interfaces abstract classes and concrete
classes and I briefly talked about what
are stacks and what kind of
functionality they provide in which
scenarios you would use them so let's do
a quick refresher of what Stacks are and
why do you need them so stack is
basically a kind of list we can say
technically a list but it's not exactly
a list so never say that stack is a list
it's it's just uh because it is
extending the list interface that is why
you can say it is a type of list but
actually it's not a type of list it has
its own representation you will use
stack in the cases where you will have
to maintain a lifo representation of the
objects now what is a le4 representation
it means last in first out that's the
basically the full form of the lifo
acronym and what it means that the
element which goes at the last in the
inside the collection will be the first
to come out
think of it as a stack of plates at your
dining table where you you put plates
over one another and the last plate
which you put on that plate start will
be the first one to be picked up by
somebody who wants to eat something
because people will not take out the
bottom most plate otherwise the whole
stack will fall that's why they will
take the top most plate and that's why
we call that plate representation as
stack of plates and this representation
in Java is exactly inspired from that
and we call this stack
you see a bracket here you see a
generics representation here which says
e which means that stack you need to
Define what kind of Stack it will be
whether it will be a stack holding
integer values or string values or any
of your custom class values so that is
the basic property that the the last
element to be going inside the
collection will be the first element to
be coming out so let's have a look at an
example of how you can use stack and
what are the different properties which
we can leverage while working with
Stacks so for that let me switch back to
eclipse and you can see I have a class
created here which is called stack demo
and it has a public static void main
method which is making this particular
class executable and here you can see I
have created the I have initialized the
stack so stack of the Class Type so you
provide the class type as string which
means that this particular stack is
going to store string objects and then
you just say new stack and you provide
the same generics here actually you can
skip that if you do this as well this is
going to work fine so that is how you
can basically initialize a stack you can
see the import here which you need to
import to make this work it's basically
part of the java.util package
what are packages again we will we will
cover that in detail when we'll cover
classes and Constructors and Etc
so now uh at line 11 I'm using a method
called push now the push method is used
to insert elements inside the stack but
we call it push because like I said
stack is a special type of collection
that's why it doesn't use the add method
rather it has a method which is called
push which is used for inserting
elements or pushing elements on the top
of the stack so at line 11 you say stack
dot push basically this stack is is
holding the list of all the countries or
the entries of all the countries so you
say America at line 11
then at line 12 I'm again doing stack
dot push and entering Germany at line
13. I'm again doing another stack dot
push and entering India so basically I
have added three countries names inside
this stack now if you if you can think
about the mental representation or if
you try to build a mental representation
of this then stack.push America is
basically the first entry then when you
added Germany this entry went on top of
America because that's how the the stack
of plates work right and then India
entry will come on top of Germany so the
America is the bottom most entry then we
have the Germany which is sitting in the
middle and then at the top we will have
the entry for the India string
and after that at line 15 I'm just
printing the stack
so
if if you want to just observe the
output till 15 let's comment this
particular section
for now and we will just focus till line
15 and once we have figured that out
then we will move to the rest of the
code here so let's run this particular
program and observe the output
so you can see this is the system dot
out dot println which is getting printed
so I'm printing a stack string and then
I'm printing the stack as is and you can
see it's printed in the sequence in
which the elements were inserted so when
you print the stack you will not be able
to figure out which is the bottom and
which is the top because you don't need
to know that while you are just printing
the whole stack when you actually want
to understand and observe that behavior
is when you will start taking elements
out of the stack at that time it would
be critical to know which element is at
the top and which element is at the
bottom but for now we can see that we
are able to successfully add elements or
push elements to a stack and we are able
to successfully print the stack now
let's uncomment this particular code and
understand what is happening here
so at line 17 I'm using another method
of the stack which is called pop so the
push method was used to push elements or
insert elements into the stack and the
pop method is used to take elements out
of the stack and remember the lifo
property of the stack which means that
if I call the pop method which is
basically I'm telling stack to remove an
element it is going to remove the top
most element from the stack and it is
also going to return the element
remember that part if you want to remove
the element and if you want to see which
was the topmost element which got
removed then you can actually store the
output of this particular execution into
a variable and you can see which element
was popped or removed
and and that's the basic property of a
lifo right that when you have a lifo
collection when you pop the element when
you call the pop method on the stack you
would expect the topmost element to be
coming out and that's why we store that
into this particular string and then we
print that popped element to verify and
see which element was actually popped
and after that because I have removed
one element here then I print the
modified stack to just see what all is
remained in the stack so let's run this
particular program now we'll let's
comment the first part maybe this
particular CS out is not needed because
we have already observed the output of
this so let's observe the these two
output after pop which was the element
which was popped and how the stack looks
like after the removal or popping of one
element from the stack
so I right click run as Java application
and now if you remember when we inserted
the elements we inserted the elements in
this fashion America Germany and India
and when I called pop the topmost
element of the stack should get removed
so it it does so the basically the Java
looked at this particular stack and it
could see that the element India was
added at the very last which means this
element was sitting on the top of the
stack and when you called stack dot pop
this method or this string basically got
popped out this element got removed from
the stack and we stored that element
into this particular variable we printed
that element and here you can see that
output that the popped element is
actually India because India string was
at the top of the stack in this
particular case at line 20 now I am
printing the modified stack basically
printing what is remaining inside the
stack after we called this pop and we
can see that the string India is gone
from the stack and now Germany is the
new top if I call this again let's call
this again
to verify if Germany is at the top
actually
so I'm calling the stop stack dot pop
again let's just call it popped element
1 for Simplicity don't do that the
production code always give nice
variable names but for the sake of demo
we can do this
so let's see what happens if after we
have these two elements left in the
stack and if I call Pop again which
element gets popped so I right click run
as Java application and we can see that
this was the representation here at line
20 then I called pop and the popped
element was Germany because now this
Germany was the new top and after
Germany has been removed from this
particular stack then the stack has only
one element which was which is America
so this is how you can work with the
stack and these are the most two popular
methods which are push and pop which you
would basically require to uh to be to
to use in your program if you're working
with stack and let's say you have a
scenario where you just want to view
which element is at the top you don't
want to remove it because pop is also
going to remove the element right so if
you don't want to remove it but just
want to view which element is sitting at
that at the very top of the stack then
you can call the Peak method so this
peak method is basically going to return
the top most element but it is not going
to remove the element from the stack so
let me just verify that as well for you
Ctrl C and after we do the peak I'm
going to print the element again let me
just call it as peaked or let's say just
call it as top element
and then we print the stack again
so let me just comment out this one as
well and now we'll run the full program
let me call this as original stack
so we'll first print the original stack
then we'll remove one element
and we'll print that element and we
print the modified stack then I call the
Peak method and and then again I print
the stack to see if Peak also removed
the the top element or it just return
the top element so let's run as Java
application and observe the output so
the original stack was this where India
was the top most element and Germany was
in the middle and America was at the
bottom of this particular stack and then
we popped the top element which was
India and then the stack got modified
and we had only two elements left into
it then here we called Peak at line 12
line 22 and we just at line 23 we
printed the peaked element or the top
element so in this particular stack if
we call Peak we got Germany but if we
printed the stack again we can see that
Germany is still there because Peak just
return the top element but it did not
remove the top element whereas pop will
remove the top element and also will
return that element to you if you want
to store it so that's all I wanted to
cover in this particular session where
we talked in depth about the stack
features and like I always say please
also go to the javadoc API and read
about all other methods and
functionalities which are provided by
the stack collection in the next session
we are going to focus on cues and we
look at a Hands-On demo of cues as well
let's get started with cues in Java so
again taking it back to the time when we
discussed about the collections
framework we briefly discussed about the
queue interface and what is the property
of the of a particular queue so queues
were again inspired from real life cues
which you form when you whenever you try
to go to a particular place where you
want to get your things done you
generally stand in a queue and this
queue interface is directly inspired
from that particular scenario itself
that it was works on a fifo arrangement
so now if you think about the fifo
arrangement and let's connect it back to
the previous lecture where we discussed
about stacks and we said that Stacks are
a leaf arrangement so in case of a leaf
arrangement you had the last in first
out philosophy but in case of queues you
have the first in first out philosophy
it means the first element which enters
the queue will be the first element
removed from the queue that is the basic
premise around which the queue interface
or the queue collection is formed so
remember that particular concept
whenever you have a situation in your
project where you need to implement this
kind of mechanism that the element which
got inside the collection should be the
first one coming out of the collection
then you should be always thinking about
queues whereas if you have an
arrangement where the last element
inserted should be the first element out
of the collection then in that case you
should think about Stacks so remember
the value proposition of each of these
collection types which will help you
take a decision as to which particular
collection to be used in which scenario
so talking about q q is again an
interface again like I said uh we are
very soon going to cover the concept of
classes and interfaces and Abstract
classes so just hold tight on that
particular concept but connecting it
again back to the theory lecture where
we talked about the collections
framework you can think of an interface
as just a blueprint just a skeleton with
nothing concrete implementation details
inside that interface so the queue is
again an interface and there are few
implementations of it one of the most
popular implementation of Q interface is
a priority queue class so the priority
queue class is again technically it is a
queue which basically works on the
concept of first in first out but at the
same time it also works on a priority
you can assign a priority to the
elements where which will decide when
which element is going to come first and
which which element is going to come
second and that concept is basically
again governed by the same natural
ordering logic which we have been seeing
in other ordered collections like three
set and tree map so that's the basic
idea about priority queue and let me
take you to a Hands-On example so that
you can relate it better
so here I have a class which is called
queue demo it has a public static void
main method and then at line number nine
I'm initializing the queue I'm saying
that this particular queue should hold
only string objects and it is a type of
priority queue and like I mentioned if
you use priority queue you can see the
import of it here uh if you see the
priority queue that you get that natural
sorting or natural ordering logic
phenomena out of the box because we are
using strings here so Java already knows
how to sort strings and it is going to
sort strings in the alphabetical sorting
order if you are providing a custom
class of yours maybe let's say queue of
students then in that case you need to
tell Java how to sort those elements and
like I mentioned in the previous
sessions we are going to cover in detail
about how do we write that sorting we
provide that sorting implementation or
sorting logic to Java in case of custom
classes but we'll cover that when we'll
cover about that sorting logic for now
for the demo sake we are just taking a
string or a queue of strings basically
which is of type priority queue and then
again following the same example as we
saw in the case of stacks just so that
you can build some sort of similarity
I'm again inserting few strings here
which are country names so at first I'm
inserting India then I'm inserting
Germany and then I'm inserting America
so I have basically added three entries
into this particular queue then at line
15 I'm just printing the queue and I
just want you to see if I inserted
elements in this order where India with
an I go first Germany with a G goes
second and America with an a goes third
and if it is a priority queue does it
automatically sort the elements or not
so let's first observe that part and let
me comment the rest of the code we will
cover the rest of the code slowly so
that we build the sort of cognitive flow
so let me comment this code and let's
just print the Q for now so I'm
inserting the elements into the queue
and just printing the element Q has a
concept of head and tail remember that
so the very first element in the queue
is is basically the head and the very
last element is the tail so whenever you
see the term head and tail you can
remember that head is the first element
and tail is the last element so now
let's try to run this code and see what
happens if you just print the queue as
is you're not iterating over it you are
not accessing any particular element but
you're just printing it
so if you do this we see the output here
which says original queue this
particular one says America India and
Germany now this might be looking
confusing right because if I apply
natural sorting then America should come
first which is okay then Germany should
come because after a the G is the is the
next natural alphabet starting point and
then India should come but we see India
in the middle here the reason is because
when you call this call this inside the
system.out.print Ln method let me just
go back if you print it inside this
particular system dot out dot printlnm
method automatically when you try to
print a variable its to string method is
called so technically under the wood
this is what is getting called though we
don't need to write the two string but
the moment you try to print any variable
inside the system.out.printl and
automatically its to string method is
getting called and in the interesting
part is if you call the tostring method
it will call the abstract collection
classes to string method which does not
understand sorting so remember that very
well if you are working with priority
queues then in that case if you just try
to print the queue you will not get the
natural order but once you try to add
elements or remove elements or Peak the
elements in those cases you will get the
natural ordering sequence but if you
just print the queue as is you will not
be able to get the natural order and it
will be random order that's why you see
a random order but let's try to build
our understanding around the natural
order so once we have printed the queue
now let's understand the other method of
the queue which is the remove method and
if you remember I told you that this is
a fee for queue so if you try to remove
an element the head of the queue is
going to get removed the head in this
case is this string America which should
be removed from this particular
collection if I call remove method so
I'm just calling the remove method and
then printing the remove remaining queue
again this queue will be printed in
random fashion but if it is respecting
the priority queues natural ordering
sequence then America should get removed
once I call remove so let's verify your
understanding
so I can see the queue after removing
the head element remains as Germany and
India these are the elements which are
left now and America is removed from
this particular queue now so that
verifies our understanding that when you
call remove the head of the queue will
be removed and the head will be the
alphabetically sorted first element of
the queue there is another interesting
method in the queue similar to Stacks we
have a peak method if you just want to
view which element is sitting at the
head of the queue if you just want to
view it you don't want to remove the
element but you just want to view the
element in that case you can call the
Peak method so I'm just calling Q dot
Peak and storing the output of Q dot
Peak into a variable called head and
then just printing the head so let's see
what happens in this case okay so I'm
getting this message which says head of
the queue is Germany because Germany is
now the new head after America was
removed from this particular collection
so that is our head and like I said
whenever you call these methods these
will respect natural sorting order since
this out will not respect natural
sorting order remember that another
interesting method is Pole so pole
method is basically used to remove the
element and also return the element so
you can see which is the uh head and
which will also remove the head both at
the same time but in case of a move you
were just removing the element you were
not able to see which element was
removed in this case you will be able to
see which element is sitting at the head
and also at the same time the head will
also be removed so for that you need to
call the pole method so I'm calling Q
dot pole and storing this again in the
same variable head so the head variables
value will get just overwritten if I
reuse it again and then I'm printing the
removed head let's see so I'm right I'm
just running this application again and
I see this message removed head Germany
which is coming from here so when you
call the queue dot pole the current head
of the queue got removed which was
Germany and it also was returned from
the poll method so you can store the
removed element and use that removed
element for further processing in your
program and after that only one element
in the queue should be remaining which
is India so at the last line number 26
I'm just printing the remaining parts
portions of the queue so yes now only
India is remaining so you can see all
the outputs here this was where we
started from uh then we removed the head
element of the queue so this element got
removed and we were left with Germany
and India you can see here India Germany
was in this order and here the order was
changed because it is random order when
you use it under Swiss out then we
wanted to just get the head of the queue
but we did not want to remove it so we
use the peak method and we got Germany
then we wanted to remove the head so we
removed the head with the help of pole
method and it also returned the removed
element which is Germany and after the
removal the queue looks like this which
is having just one element left in the
queue and in this case the head and the
tail both is in the in this case so this
string will be both the head and the
tail this is a special case if the if
the queue has only one element left so
this is all I wanted to cover in the
case of uh queues and like I mentioned
in the all the previous sessions as well
do go and check out the Java docs API of
the queue interface and the priority
queue classes learn and just get
familiar with all the different methods
which are available in this class so
that when you start using these queues
types or these collection types you
remember you know what all utilities and
methods are available and even if you
don't know like I always mentioned if
you just do dot here it will automatic
any any good ide will automatically show
you all the methods which are available
here which you can read about in the
documentation here and understand what
each method does and you can use that
method as well so that is also possible
so that's it I wanted to that's all I
wanted to cover in today's lecture and
in the next session we are going to talk
about classes and objects let's get
started with classes and objects in Java
so like I have been promising in the
previous sessions that I will cover this
in a dedicated session and this is a
session where we will go deeper into the
concept of classes and objects you have
been seeing this keyword all along in
the all the sessions wherever I ran the
different examples and let's understand
what this means technically if you go by
the definition a class is basically a
blueprint of an object which brings the
question as what is object an object is
basically an instance of the class I
know this becomes more confusing so
let's break it down into simpler
definitions
a class is technically a logical entity
it's you can think of it as any entity
in the world if you have to let's say if
you have to build a student management
system or a college management system
then all the real life objects which you
see we always say that Java is heavily
inspired from real life examples and
classes and objects are the reason we
say that because whatever you see in the
world is always basically some entity
human beings are an entity cars are an
entity students are an entity lecturers
are an entity so who are all the actors
all the actors which you see in the
world are basically entities and you can
map them as classes in the Java program
now why do you want to map them because
these entities have basically two kind
of specifications
one is every entity will have some
attributes and it will have some
behavior and actually that is how you
identify an entity for example human
beings have attributes like we have
hands we have eyes we have ears legs Etc
these are our attributes then we have
our behaviors behaviors are actions you
can think of them as a human being can
speak so can speak is an action it's a
behavior can listen is an is an action
it's a behavior can walk is an action is
a behavior similarly can eat is also an
action or a behavior so that's how you
basically represent an entity that's how
basically you identify an entity that an
entity will have some attributes and
some Behavior if you see those two
specifications in any entity you can map
that entity or you can write that entity
inside a Java program as a class because
a class in Java will exactly have these
two properties it will have some
attributes which we call as properties
and it will have some behaviors which
technically are called as methods so it
will have attributes it will have
properties and methods similar to real
world entity where we have attributes
and behavior Behavior are methods and
attributes are properties that's how it
is so if you if you apply this simple
philosophy whenever you are taking
requirements from a customer for a
particular project always try to
identify these entities these actors in
your program once you have identified
those you will be able to write a
corresponding Java class in the Java
program which can represent those
entities and without representation of
those entities you cannot write the
program so Java will kind of force you
to think in this direction to find
entities which will have attributes and
behaviors so taking that philosophy
further and taking that example further
here for you I have prepared an example
where I am creating a student class so
basically let's say if you have to build
a college management system or a student
management system then student is
probably one of the main entities which
will be talked about when you take the
requirements
so if you think about the attributes and
the behavior concept A student will have
a name will have an age will have an
address and at the same time a student
can also have some behaviors like can
enroll in a particular course can attend
a lecture can take a leave can take exam
Etc these are all behaviors let's
understand this in in a more detail with
the help of this example where I've
created a class which is named a student
and you see the public keyword here
again I will cover access modifier
public is basically an access modifier
and I will cover this in very detail in
the upcoming sessions for now let's
focus on this part so we have created a
class to represent our entity you put a
curly braces around it it ends here and
after that you provide the attributes so
here I'm saying that a student will have
a name it will have an age and it will
have an address it has three properties
so the technical name of attributes is
properties after that let's skip this
part and I will come back to this part
once you have declared these properties
you would want to provide a way for the
name to be filled or replaced or
received for example if you have created
a student class how do you insert the
name inside the student plus but how do
you insert the age or how do you insert
the address or modify the age name or
address properties for that we have
these Setters and Getters methods we
call them Setters and Getters because
they start with this keyword not keyword
but they start with a string called set
it is not a keyword you can actually
write it as anything you can call it as
modify name that will also be absolutely
fine Java will not give you an error but
the standard naming convention given by
Java is to start the methods as starting
with set and
get this is the this is the standard
naming convention and like I said it's a
naming convention it's not a compulsion
but if you write this way your
co-developers and the people who are
going to maintain this project in the
longer run will be very happy otherwise
they will be very angry if you use
strange methods because like I said this
is the standard naming convention so now
you are going to write a Setter method
for each of the properties in this
particular class for name age and
address so we call set name again you
put public void because this is not
supposed to return anything this is just
supposed to set the value of name with
whatever value you specified then you
call set name
and then you provide the value which you
were supposed to set against the name so
whatever value like any random name John
or Jane whatever we need to supply that
name here value while you call this
method and that name uh whatever you
name you supply will be set against the
name property of this particular class
and remember I use the word this here
intentionally because the way you are
going to represent this is with the help
of this keyword this keyword means
current object it means that you are
when you use this dot name it is
referring to the current object's name
property and this name is basically
corresponding to the name which is
coming in when somebody is trying to set
a name similarly for set age age is a
numeric number if you if you observed
it's basically an integer then I'm
saying int age and whatever value of age
will be coming will be set in this
particular object's age
then similarly for set address we have a
string address argument being passed
into into this method and this gets set
inside the current object's address
property so I've provided a way for the
external world to set the values of name
age and address because for each student
you would need to set these values now
you also need to provide a way to
receive the values or to return the
values or to read the values for reading
operation you need to provide the getter
method so you see this get again this is
not a keyword it's a standard naming
convention so similar when you when you
wrote Set name similarly you will write
a get name method this get name method
is supposed to be reading the current
objects names properties value and will
return that value since name is a string
that's why you see the return type as
string here
similarly get age is going to return the
age which is an integer and address is
going to return the address you can also
write it like this which is absolutely
fine it is not going to complain because
technically it is returning the current
objects name properties and age property
and the address property now let's talk
about this what is what is this section
so this section is basically called a
Constructor and I have a whole session
dedicated on the constructors but let's
understand why we need this
remember when I told you the definition
of the class I said that class is a
blueprint of an object
so you have created a student class and
you have 5 000 students in your college
now you need to create a new student
object for each of those student you
need to initialize this student class
5000 times how do you do that
to do that we do that with the help of
Constructors we call this Constructor
this is a special type of method
remember this is a special type of
method which is provided by Java to
initialize any classes objects if you
want to create multiple objects of the
student class you can repeatedly call
this student Constructor we call this
Constructor so you put public here
because we want this Constructor to be
accessible to the outside world then you
put the exact class name so whatever
class name you have provided here you
need to put the exact class name here if
you don't do that Java is going to raise
an error if I do this here it is going
to you see a red line here because Java
failed to compile this Constructor it
does not understand what is student
triple one but it does understand what
is student so this is how it is going to
be and then you provide all the
properties which are going to create the
student object so you're going to create
the name the age and the address so the
name age and address and then you set
those values again similar to the setter
methods we have seen the reason we need
to use this here because
if you don't if you write it like this
then Java doesn't understand the
difference between the current objects
name and the name coming from the
argument so to differentiate that you
need to use this here if you use n here
and if I just use n here then this is
fine because this only single name
variable in this whole class then but if
I write it like this
then and if I write it like this then
Java doesn't know if this name is
basically the student classes name or
this name is student classes name it
will get confused like you are getting
confused if you if you try to just find
this in mind mapping so that's why we
need to write this here so that it's
clearly differentiable that whenever I
use this dot name I'm referring to the
classes name property and when I'm just
using the name I'm referring to the
method argument
that's what we do in doing this in this
Constructor so you basically initialize
all the properties of your class with
some values with the help of Constructor
so we have the Constructor we have the
settle we have the getter we can cover
about this two string basically this two
string is to print print something but
we can cover that later now uh let's
initialize this particular class so I'm
similar to the initialization we have
seen so far you just write student you
write the object name this can be
anything and then you use the new
keyword which is used to initialize
anything in Java new is a keyword in
Java which you can use to initialize
literally anything in Java so you use
new student and when you say new student
you can provide all the values which
should match its Constructor so here we
have three values string integer and
string and here also we are supplying
three values string integer and string
again so remember to match this exactly
with one of the constructors which is
available in the class if it doesn't
match it is going to fail it will not
work so if I for example if I do this
then I'm supplying four arguments to the
student class but there is no
Constructor matching four arguments so
it is going to complain you see this red
line and the code is not compiling if I
remove this then it is matching it and
that's how you basically create a
student object so an object is basically
an instance of the class remember that
very well an object is an instance of
the class once you have created an
instance of the class then you can call
any method like say let's say you want
to read the name so you can call get
name you can read the name similarly if
you want to so if you if you want to
read the age of this uh student then you
can do that as well so let me just copy
this and to this let's call get
Edge I want to print the name I want to
print the age and I also want to print
the address so get control space I get
suggestion address yep so I'm printing
the name I'm printing the age and I'm
printing the address after I have
initialized the object successfully by
using this Constructor representation
using the new keyword so now let's run
this method or run this class basically
okay so when I ran this class the whole
class got compiled the Constructor the
Getters and the Setters and the
properties and their types everything
was set then the main got called and I
created a new object from this classes
blueprint the object name was John then
I called John dot get name to print the
name which is stored inside this
particular instance of the student class
similarly the age of age which is stored
in this particular instance so we stored
the name as John so when we call
john.getay we get John we got when we
call John dot get H we get the age 25
and we call john.get address We call we
get this particular address whatever
values you specified here the
Constructor got called here and the name
John got set to the student's name value
the age value which you supplied got set
against the students age and the address
value which you supplied got set against
the student's address and that's how you
are going to create a class so remember
whenever you create a class identify the
properties and the behaviors like setups
and getters
write a Constructor which can cover all
the values which you want to initialize
and after that
just initialize that class create an
object of that particular class
basically and once you have the object
then you can call getters you can also
call this in this way if I don't Supply
any of this
then it currently it complains and why
it complains I will cover that in the
following session when whenever when I
will cover the multiple Constructors
concept but remember you see this
Behavior here that if you have created a
Constructor which accepts some arguments
and if you supply this kind of
initialization then student class does
not have a Constructor which is
parameter list student class has only
one Constructor which is taking three
parameters and that's why Java complains
because it is not able to find a
representation of a Constructor which
accepts no parameter but like I said we
will cover this we will find a solution
to this particular problem in the in the
coming in the coming session but for
this session this is all we are going to
cover we covered about classes we
covered about objects and we also saw
how we can write Getters and Setters we
can initialize those methods uh
initialize those objects and we can
access the properties of those objects
using the Getters and we can also call
the Setters to modify the values as well
similar to this
so this is all I wanted to cover in
today's session and in the next session
we are going to dive deeper in the
concept of Constructors and how we can
write different types of Constructors
let's get started with Constructors in
Java now if you remember in the previous
session we covered about the concept of
classes and we walked us through with an
example student class where we had a
Constructor if I just open this back
this is the class which we covered in
the last lecture and we had this
Constructor where we supplied the
required the necessary number of
arguments which can match my students
properties and then I set those
properties calling this dot property
equal to the argument like this but what
if you have a use case where some of the
values are mandatory and some of the
values are optional in these properties
section for example what if all the
students have same address although this
is a very hypothetical situation but
let's assume if if you have a scenario
where you have a particular entity you
have identified the entity but there are
certain properties in the entity which
remain constant for all the objects if
you have such case then it does not make
sense to supply an argument for that
particular property which is going to
remain the same for all the objects what
if you can just initialize it with with
some default values that would be
simpler right because let's say for
example if this property is going to
remain constant for all the student
objects then you can just Supply these
two properties these two arguments in
your Constructor and you don't need to
supply the address let's go further what
if you have a class where you have more
than one property let's say if your
class has 10 properties and eight of
them are remaining constant or are
optional and only two are changing and
mandatory then how would you write that
and what if you have a different use
case for the same class let's make it
even more complicated that you have a
single us the same class or entity is
being used by different consuming
applications one application would
expect let's say these two to be
mandatory and this one to be optional
other consumer application wants these
two to be mandatory and this one to be
optional the third consuming application
wants all three to be mandatory the
fourth consuming application wants none
of these to be mandatory then how are
you going to do that the answer is
multiple Constructors you can write
multiple Constructors for each of those
consuming applications and whichever
application wants whichever Constructor
they can use that Constructor to
initialize the object of the class
so taking that concept further I have
created a class called cuboid and I have
three different properties written in
this class as we know that a cuboid has
basically three properties which are
width height and depth
so I'm taking that example here creating
a class for a cuboid providing the width
height and depth for Simplicity I am
taking this as integers but generally
you will see this as doubles probably
because the values can be in decimal
points but for simplicity's sake I'm
just keeping everything as integer here
then with a standard use case if you
have to create an object of this cuboid
class you would need a Constructor where
you can supply all these three values
and here it is this is the Constructor
which can be called to provide these
three values so I'm supplying the width
I'm supplying the height I'm supplying
the depth depth and then I am setting
all of these values with the this
keyword say this dot is equal to the
coming width this object's height will
be the height which is coming from here
and this object's depth will be the
depth which is coming from here
now for another use case where let's say
there's another consumer application
where it would expect the depth to be
constant for all of its objects let's
say a value 10 and it only wants width
and height to be supplied then you can
create another Constructor Java does
allow the use of multiple Constructors
in the same class remember that concept
so you can create another Constructor
for that representation where you supply
only the width and height
and you keep the depth constant now if a
consumer application calls this
Constructor 100 times all of those 100
cuboid objects will have that depth as
10 only that will be the fixed value and
only width and height will be the
changing values
similarly if there's another consumer
application which wants to have the same
height and width and depth for the
cuboid then it would just require a
single parameter whatever value the
consumer application is providing you
are setting the same value to the width
to the height and to the depth into the
depth so technically this is basically
becoming a cube because then the three
dimensions the height width and depth
are same
and what if you have another consumer
application which does not intend to
supply any of the values because for it
all the objects are going to hold the
exact same values for all the properties
let's say there's a consumer application
which would always expect the width the
height and the depth to be 10 then you
can create a Constructor with the new
arguments you can see there is no
argument here so you can create a
Constructor like this and you can supply
all the default values which are static
values so in this case I have created
four Constructors I have created this
Constructor here which accepts all the
values and whenever you call this
particular object you will have to
specify three values and each object
will have the width height and depth
different
Second Use case where a consumer
application wants the depth to be
constant with the value 10 and only
wants the width and height to be
variable for each of the objects then
this particular Constructor can be
called similarly for another consumer
application which would want to create
just Supply a single value and it would
want whatever value IT Supplies it would
want the height the width and the depth
to be exactly the same as that value
supplied then it will supply only one
value and the same value is going to be
set against height depth and width
and the fourth use case is where the
consumer application does not intend to
supply anything at all but it would want
the class to set some static values for
all of its objects so then it can call
this Constructor
and then I Define a behavior remember
the concept of behaviors I Define a
behavior here I have not defined the
Getters and Setters here but you can
definitely do that there is nothing
stopping us from doing that but for
Simplicity I just skip that here
then I Define a behavior to basically
this class will provide a behavior which
will be to create the calculate the
value volume based on the values which
you supply so whatever value you supply
based on that the cuboid is going to
calculate the volume and as we know the
formula of volume is width into height
into depth that is how we are going to
calculate the volume of a cuboid based
on whatever values of width height and
depth are supplied so let's see this in
action I've created a public static void
main method I've initialized a variable
called volume which is an integer
variable we'll see how we can use that
variable and first let's create a
standard cuboid so I call this
particular Constructor with three
arguments so when I do this this
particular Constructor gets called and
the width height and depth values which
I Supply here three values will get set
and I get a standard cuboid and then I
can call the standard cuboid dot volume
then this particular method will be
invoked and the volume will be
calculated with this formula with these
values
that's how we are going to calculate the
value for a standard simple cuboid and I
am printing that volume value exactly
here so this is basically the uh
standard Constructor being called with
three arguments calling the volume
method and then just printing the volume
Second Use case where I'm calling the
Constructor with two arguments and the
third value should be set automatically
so I'm just supplying two values here
when I call the Constructor with two
values a matching Constructor should be
found here with two values here it is so
width and height will be set with the
values which I am supplying and depth
will automatically be set to 10.
this is what is happening here cuboid
with some defaults and then I again
calculate the volume and print the
volume
I'm just using the same volume variable
here in the third use case I am calling
the Constructor with a single parameter
so I'm just providing one value and the
same value should should get B should be
set against all the width height and
depth values and technically it becomes
a cube so I'll just call it as cube here
then I'm calculating the volume of the
cube and printing the volume of the cube
and then at last I'm using the
Constructor with the new arguments I am
calling this as default cuboid because
I'm not supplying any values and then
I'm again calling the volume method on
this and printing the volume so these
are the four Constructor invocations so
this class is demonstrating four
different kinds of Constructor
invocations let's run this class and
observe the output
okay so let's start from here I called
this particular Constructor with three
arguments 10 20 and 15 and then the
volume was calculated which would be 10
into 20 into 15 which is 3000 so this is
out basically prints this output
then move on to the next one where I'm
saying cuboid with defaults which is
having the value 10 and 20 and the third
value of depth is automatically being
set to 10 so technically when I call the
volume it will become 10 into 10 into 20
which is 2000 and that's how the volume
of the cuboid with default depth is
printed from the line 47 going on to the
next one at line 51 the volume of the
cube is basically the volume which is
calculated after calling this particular
Constructor and calling the volume
method so here the height the width and
the depth all three are set to 10 so it
will technically be when we call the
volume method it will be 10 into 10 into
10 which is 1000 and that's how you get
this output it says volume of the cube
is thousand and then I call the default
cuboid method which is simply providing
no values and we expect everything to be
set with some defaults and the default
Constructor is setting the value is 10
for height width and depth so in this
case if I'm calling the volume method
and if I'm printing the volume it should
be printed as 1000 because 10 into 10
into 10 is 1000.
so this is basically to Showcase you how
you can use different Constructors
there's another thing which you should
know is if you do not provide any
Constructor to this particular class let
me just comment out all the constructors
in this class
and let me comment out most of the code
here as well
so now if you see I have not provided
any Constructor in this particular class
right there is no Constructor let me
just
maximize this so there is no Constructor
being called here there is no
Constructor being left here everything
is commented so there is no Constructor
in this class but this line still passes
there is no compilation error there is
no red line on this particular line the
reason is if you do not provide a
Constructor to a class Java by default
will provide a Constructor which will be
the no parameter Constructor so remember
that whenever you don't Supply any
Constructor you can still create objects
of that class with this
non-parameterized Constructor
representation like student student
equal to new student without any
parameters that will work if you have
not provided any Constructor
implementation inside your class and if
you do that let's see what what value do
we get because I have commented the
default Constructor everything here
right so let's print the value if I go
to run as I get the value as 0 so what
happened here
when I call this particular line the
default Constructor provided by Java
gets called and Java will set the values
of all the properties to the default
values which are supported by the data
type and integer primitive data types
default value in Java is zero if you do
not provide any if you do not assign a
value to an integer variable by default
it is going to be initialized with 0
that's the Java's behavior and that's
what is happening here because we did
not provided a default Constructor so
when we call this new cuboid here
without any parameters without any
arguments the default Constructor of
java gets called and it sets everything
with the default values which is 0 0 0
and then if we call the volume method
it's basically 0 multiplied by 0
multiplied by zero which will eventually
be the output as 0 and that's how you
get this zero output let's try one more
thing what if I enable one Constructor
let's enable any one Constructor which
is known which is having at least one
parameter let's say this one
so I have enabled one Constructor I have
commented in I've just removed the
comments from one Constructor which
takes a single argument and let's go
down now you see an error so this is
something again a Java's behavior that
if you provide even a single Constructor
in your class which is known which is
having at least one parameter
I'll just repeat that if you create any
Constructor in your class
which is having at least one parameter
then the default Constructor
implementation of java will not
automatically work in this case you will
have to explicitly provide a default
Constructor as well the default
Constructor will only and only work if
you have not provided any Constructor at
all in your class the moment you provide
even a single Constructor which is
having even a single parameter in your
class then the default Constructor out
of the box will not work and you will
have to explicitly provide a default
Constructor so to make this work I have
to just enable the default Constructor
code and then only it will pass so if no
Constructor it will work without any
parameter but the moment you provide
even a single Constructor with even a
single argument then you have to either
use that parameterized Constructor or
you have to provide your own default
Constructor implementation because Java
will not use its own default Constructor
implementation in that class so I hope
you find this particular concept useful
and remember this concept because this
is again this can be confusing when you
are reading somebody else's code you
need to always understand what all
Constructors are there and in the next
session we are going to talk about
another very interesting and exciting
Concept in Java which is about streams
let's get started with streams in Java
before I go any further I just wanted to
clarify that when I say stream I am not
talking about the input output stream
but I'm talking about stream as a
concept in general this is a slightly
newer concept which was introduced in
Java 8 and has been there and it is
extremely popular and the reason Java
introduced this the concept of streams
to uh to the jdk was to promote the
functional programming Paradigm what we
have been seeing so far is basically an
object or the same lines of code which
you would write in Java in an in a
classic object oriented way in like
let's say 10 lines the same line of code
that the whole 10 lines of code can be
written in a single line using the
functional programming Paradigm so let's
understand the concept of streams first
so the basic concept of streams is to
help you iterating and manipulating
collections so remember all the classes
which we covered in the collections
framework the list the set the map Etc
streams provide you with a better and
optimized way to basically allow you to
manipulate those collections iterate
over those collections change the
representation of the collection types
Etc so to understand why we need streams
let's understand what is how the
streaming works so let's take a very
simple example if you if you watch a
YouTube video it is basic basically
streamed to your device and when we say
stream it means the whole object the
whole video size is not downloaded at
once on your device and it is being
downloaded bit by bit to your device
piece by piece to your device this is
better in lot of ways your device does
not need the full memory to store the
complete video because it is only going
to process one byte at a time and just
throw it away once it has been watched
so the streaming will basically help you
work on a very large size item in a way
using a very small memory footprint
That's The Power of streams contrary to
that you can also let's say if you are
if you're watching a one gigabytes video
then you can either download the whole
one gigabyte video on your mobile which
is going to consume complete one
gigabyte space on your memory or you can
stream that one gigabyte video onto your
mobile device where maybe only a few
megabytes will be required to watch the
whole video because at a time it will
only consume few megabytes and it does
not need one gigabyte of complete space
to stream that video so that's the basic
idea and that's why streams are very
popular in very optimal way to work with
Collections and let's understand with
the help of an example actually I've
prepared multiple examples of multiple
capabilities of the streams API so
streams is basically an API which is
provided after Java 8 and you can use
that to iterate over collections or
manipulate collections let's see that
and let's also compare that with how you
have been doing this before Java 8. so
here I have created a list you can see
it's basically an integer list and I
have created an arraylist here I have
added few numbers to this particular
error list so numbers are 10 20 30 and
40. so precisely four elements are
inserted into the list now you have a
requirement in your project that you
need to basically calculate the square
of each of the elements of the list and
prepare a new list
that is the requirement so if you are
not using streams you would write code
something like this you will initialize
the list a new list basically which will
which you can call it as anything for
example you can call it as squares list
and then you are going to call an
enhanced for Loop here iterating over
the numbers list one by one taking each
element calculating the square of it and
then adding that element to the new list
and that's how you are going to write
this logic if you were not using streams
so you can see it's basically
technically one two three four lines of
code just to get the list if you were
using streams then you can do this with
a single line let me just comment out
the old old code and let me just bring
this to the same line to show you that
it's a single line code so the same
logic which you wrote here can be
written just like this you can see it's
so optimal so simple for the processor
to compile this code is also very fast
because they can process a single
instruction very fast and very quickly
and streams do utilize the multi-core
capabilities as well so now is the time
and that and the era of multi-core
processors and that's why streams are
more beneficial to use rather than
writing our Bose instructions so let's
understand how this works to convert a
particular collection into a stream you
need to call the collection type dot
stream so here the numbers list was the
collection variable so once you call
this dot stream you will get a stream
representation now the elements of the
list are being streamed one by one they
are not being sent at all at once they
are streamed one by one now so you get a
stream the moment you call stream
then now the stream API has multiple
methods uh utility methods which you can
read about for example if I just write a
DOT here you will see lots of utility
methods which the stream API provides
you which you can use in different
conditions we are going to cover few of
the very important and very popular
methods but again please do read out the
streams API documentation to get the
hang of all the other methods so once we
have the stream then the first method
which I'm going to Showcase to you out
of the stream API is the map method map
method can be used to change the
representation of the elements one by
one and that's what we need to do right
we need to change the representation of
these elements to the square of these
elements so remember that that line
which I said whenever you have to change
the representation of the elements
inside the collection think of map think
of the map method this is not the map
collection this is not the map
collection this is the map method of the
stream API so if you're using stream API
you have a use case to convert the
representation of the elements of the
collection think about Maps always so I
call the map method here and then you
see the strange syntax here this is
basically a Lambda function syntax so
Lambda function is another concept which
Java introduced in Java 8 Lambda is as a
concept has been there in in some other
programming languages like Scala for a
very long time but it's been introduced
in Java of late in Java 8 only and
Lambda is basically you can say is the
Paradigm which will enable you to write
functional programming constructs in
Java and the syntax of Lambda is very
straightforward
you provide a representation of the
element here so each element here one by
one is going to be represented to X then
you write this Arrow here basically a
hyphen and a greater than sign and after
that you write what is the final value
which you want to see for that
particular element so here my
requirement was that I want to convert
the representation of the element to the
square of its element so I just do X
into X because X is the current element
I want to change this to this so
whatever destination representation you
have in your mind write that on the
right hand side of this arrow on the
left hand side it will be the element on
the right hand side it would be the
representation which you want to work
with so you have written your conversion
logic inside the map method with a
Lambda function representation under the
hood if you want to know more technical
details about it it's basically working
on the concept of functional interfaces
do read about the functional interfaces
concept as well that will help you build
the con uh the usage of Lambda functions
and how this whole construct is written
so read about functional interfaces and
Lambda functions to understand map in
detail and what but for to to work with
it like I said this the left hand side
will be the element and the right hand
side would be the final representation
which you want to have for that
particular element once you have done
that still this till this particular
point you have converted the collection
into the stream it is streaming the
elements one by one and you have
successfully also calculated calculated
the square of each element but this is
still a stream now you need to convert
the stream back to a list which can be
used further in your program so to do
that you can use the collect method
which we also call as the terminal
methods this is another
concept which I'm just introducing to
you right now so there is an
intermediate method concept and there is
a terminal method concept
this is what streams understand Java
stream understands when you say
intermediate method those methods are or
those operators are basically the ones
which are used before the final
collection is prepared like the map
method is basically a intermediate
operation and then you have some uh
terminal operations like collect once
you call the terminal operations after
that the stream has been concluded the
stream is dead so once you call this
collect method and if you try to do
something here again let's say if you
want to do something it will not work
because the moment you use the collect
method stream will expect this to be the
last method which you want to use in
this particular instruction after that
the stream is dead and you will get
strange exceptions if you try to write
any further operation after collect so
do you so also do read about what are
the all the different terminal
operations available and what are all
the intermediate operations available
I'm going to cover bunch of these in in
this in the different examples I've
prepared in this particular class but
because I will not be able to cover all
of the methods so do read about those
methods what are the intermediate
operations and what are the terminal
operations and the concept I just
explained you intermediate operations
can be used in in a chaining fashion
after this dot map you can use another
dot map another dot map another dot map
you can again like do this this will
this will work fine you can keep
concatenating multiple map methods and
multiple filter methods and any of the
other intermediate operations which are
available but once you have called the
collect method after this you cannot
call another map if you try to do this
it is going to fade it will not work
because collect is a terminal operation
and what I want to do in the terminal
operation is I want to convert this new
stream which is having the square of the
elements convert that back into a new
list and to do that I can call the
collectors dot to list method the moment
you write this method inside the collect
method it is going to take this stream
of the elements one by one just collate
that stream into a single stream into a
single collection and then return that
collection back into the list which you
want to store it in so remember the
collect method terminal operation and
the moment you you do collectors.to list
the whole streams elements is going to
be uh converted into a list and that
list is going to be stored into whatever
left hand variable you have written and
that is how you can basically write this
whole code which we wrote in four lines
into just a one line and then you can
print the squares list so let's do that
let me comment this particular code as
well so that we don't get any strange
errors or strange outputs
let me comment this part as well we will
cover this one by one and let me cover
all of this as well I'm just going to
comment everything here and we'll focus
on only the squared list which we have
prepared using the streams API so right
click run as Java application there you
go you have the output here so the first
number was 10 the square of it is 100 so
yes you get 100 second number is 20 the
square of it is 400 third number is 30
the square of it is 900 fourth number is
40 the square of it is 1600 so you get
all the values squared by using the
stream API and like I said you can write
the same code in the old way as well but
this is the efficient and the better way
of writing the same code in a single
line this is all I wanted to cover in
today's session let's get started with
streams API in Java in the previous
session also we covered some basic
functionality of the streams API of how
we can convert a list of numbers into
the squares of the numbers of the same
test today we are going to look at an
extension of the same kind of
functionality let's say you have a
requirement where you have a list and
you are asked to convert that list into
a set and while you convert the list
into set you also have to calculate the
square of each number so instead of just
converting the list of numbers into a
set you have to convert the square of
those numbers into a set collection that
is our objective so I'm going to use the
same list which I had created in the
previous example which you can see here
I have a numbers list and I've added
four elements to it 10 20 30 and 40 and
then if I did not have to use stream or
if I did not have the option to use
stream this is how the code would look
like where you would explicitly create a
set of type hash set and then you will
iterate over the numbers list and then
you will pick each item of the numbers
list and multiply it by itself hence
calculating the square and then you will
be adding those that that result into
the destination set this is what I'm
doing here just to show you the
different comparison of how do you write
it in the classical way and then in a
while we will look at how we can write
the same kind of functionality using the
streams API so let's first run this
particular approach where I'm adding all
the square of all the elements into a
set which is a hash set type so the
order of the set is not guaranteed
because I'm using a hash set and then
I'm just printing the hash set so let's
try to run this program so I go to run
as Java application and I get the output
and you can see if you look at the list
here the results are not in the same
sequence in which the elements were
added into the list it is because of the
nature of the hash set but we do get the
result as expected now if I have to
write the same kind of functionality
using the streams API then this is how I
will write it I will just uncomment this
one and will comment out this one
so now if I look at this new code it's
doing the exact same thing but in a
functional programming approach and
using the streams API approach so I'm
again calling dot stream and converting
the list into a stream then calling map
which is to use to uh change the
representation of the elements of the
collection so I am changing the
representation from the single number to
the square of it and then calling dot
collect which is a terminal operator
where I am converting this stream into a
set by calling collectors dot to set so
two set is the method here which is
going to convert this into a set and
then I am printing the square set
so let's run this program and observe
the output
if I run the program I get the same
output so I can achieve the same kind of
functionality but much more efficiently
using the streams API so this was an
example where I could use the
collectors.2 set method to create a set
out of a list now let us move forward to
another interesting and very popular
functionality which is filtering so let
me comment this code again so that we
don't get multiple outputs and let me
uncomment this code here
so what I am doing here is I am creating
a list of languages which is an
arraylist and then I'm adding three
elements to this particular error list
which are Java Python and Scala and this
is a string of the list of strings here
so I'm adding three strings here these
strings can be anything I have just
taken the example of programming
languages here but this can be anything
so technically we have a list of string
objects and then my task is to get a new
list out of this existing list which
will have the elements which start with
the letter P let's say that is your
requirement that you have to get only
the elements of this list where the name
of the element starts with the letter P
if that is your requirement probably
this is how you will be writing the code
if you are not using the streams API
where you will create a new list an
empty list basically and then you will
iterate over the old list which is the
languages
so you will iterate over the languages
list and then you will pick the each
element of this particular list and
check if that string starts with the
letter P if yes then you will add that
particular string element into the new
filter list by calling the add method
and then you can print that particular
list that is how you will be doing it if
you were not using streams so let's run
this program and understand the output
so I'm again going to right click run as
Java application and the output I get is
python because that is the only string
in the list which starts with the letter
P so we get the expected output now
let's try to write the same code using
the streams API so let me comment this
code and I will save the file and let's
look at how we can do the same thing in
a single line using the streams API so
to use to write the same kind of logic
using the stream API we start with the
same kind of syntax where we take
languages dot stream to convert the list
into a stream and and then we call a new
method called filter so filter is the
method which you will be using whenever
you have to write any conditional Logic
on all the elements of the list remember
whenever you have to write a filtering
or a conditional Logic on a particular
list then you will be using the filter
method of the streams API so you will
convert The Collection into the stream
and then you will apply the filter
method to apply the condition this
condition can be anything in this case
the condition is that the elements
should start with P it can be anything
for for example it can be based on the
string length if you want if it's a
numbers collection it can be if a number
is greater than 100 or not so any kind
of if logic which you might have to run
on a particular collection can be run
using the filters method
so if we call the filter method and we
again follow the same Lambda function
syntax where we here this particular s
denotes each element one by one and this
Arrow represents the Lambda notation and
then what we want to do that we want to
run this condition on each of the
element of the stream one by one and the
condition is that the element should
start with the letter P if that is true
then whichever elements satisfy this
particular condition will be getting out
after this execution so the block which
I have selected once the filter method
has completed its execution after that
only the elements which have satisfied
this filtering condition will be left in
the Stream rest of the elements have
been filtered out so once you have the
filtered result then you can again call
the collect method which is the terminal
operator and you call collectors dot to
list same as the example in covered in
the previous session so I am running the
filtering logic and getting a new list
which will have only the elements which
satisfy this condition so I get the
collectors.to list result back into our
new list which is called filter result
and then I'm printing the filter result
so let's see if we get the same kind of
output if we use this logic yes we do
get the same kind of output and this is
something which validates how we can use
the filter operation seamlessly by
applying exactly the same kind of logic
which we use to apply by writing this
much verbose code another benefit is
that the streams API are more efficient
in using the multi-core processors which
are common nowadays on any machine
so this is all I want to cover in
today's session I don't want to elastic
session to be even more longer so we
will conclude today's session at this
particular point and in the next session
we are going to have a look at some more
functionalities of the stream API seeing
how we can sort the collections how we
can iterate over the collections because
even this code is a bit too much for the
uh for for the streams API to iterate
over a collection we will look at a
smarter way of the streams API by which
we can iterate over the collection we
will also have a look at how we can sort
collections let's get started with how
we can use the streams API to sort
Collections and also to iterate over
Collections and I'm going to use the
same collections which we have used in
the previous sessions just to build some
sort of continuity here so I'm going to
use the same arraylist which I created
in the previous session which is storing
a string of elements which is having
three strings which is Java Python and
Scala these are just three strings which
I'm storing into a list which is called
languages and now my task is to sort
this particular collection I have to
sort the elements of this particular
list so that when I access the list I
get the elements accessed in a natural
sorting order so I should get the result
Java first then python as a second
result and Scala as the third result
let's make it bit more interesting let
me put this at the beginning so now I
have and let a element starting with s
being added first then an element
starting with J being added second and
the third element being added which
starts with p let me add one more string
to it just to make it bit more
interesting and practical so let me add
a new language here which can be let's
call it basic so now I have four
elements Here and Now I want to sort
this particular collection so for
sorting streams API provide a very
straightforward way to sort any kind of
collection which is to use the dot
sorted method and we will follow the
same kind of semantics which we have
followed in the previous session which
is you pick the current collection call
the dot stream method on it which will
convert The Collection into a stream and
once the stream has been created then
you call the dot sorted method on the
stream which is going to sort all the
elements of the stream in a natural
sorting order remember we are using
strings here so Java already knows how
to sort strings if you were using a
custom class let's say list of students
or list of customers then you have to
specify your sorting implementation to
Java because Java doesn't know how to
sort customers or how to sort students
so you in that case you will have to
provide your own sorting implementation
and we will cover that in the upcoming
sessions but for now let's understand
this example by using one of the
pre-built data types which is string and
we call the dot sorted method which is
going to sort this particular stream and
then we use the terminal operator which
is dot collect to convert this stream
back to a list and we do that by calling
collectors dot to list we do that and we
get the list out we store that list into
a variable called sorted list and then
we print the sorted list so let's run
this program and understand the output
remember that we have these strings
added here
so right click run as Java application
and this is the result I get I get basic
as the first element when I get the new
list which has all the sorted elements
then I get Java with a J then I get
python with a p and then I get Scala
with an S so you can see that these
strings are presented in a natural
sorted sequential order here and that is
what is happening because we call the
sorted method and this is how you can
use the streams API to sort any kind of
collection hope this is helpful to
understand the concept of sorting now
let's move on to another concept which
is about how do you iterate over
collections using the streams API we
already have a way of iterating over the
collections using the enhanced for Loop
remember we covered this at length in
different sessions in the past so we can
definitely use this particular logic it
doesn't break it will not stop us from
using this we can still continue using
the enhanced for Loop logic to iterate
over any kind of of collection but
streams API provides even a smarter way
to iterate over the collections let's
see how we can do that so let me
uncomment this particular code here and
now if I look at this particular code
and if I try to understand it I will see
a sort of similarity with the way we
have been working with streams so we'll
follow the same drill we'll pick up the
existing collection call the dot stream
method on it this is going to convert
The Collection into a stream and then we
call Dot for each method this is the
method which you need to use whenever
you want to iterate over a collection
using the streams API so we call the dot
for each method again follow the same
Lambda construct where this is each of
the element y represents each of the
element here and then I write the code
which is supposed to be executed for
each element so in this case I want to
just print every element that is my
requirement when I am iterating over
this particular collection so I can just
put this Arrow here let me put just
spaces here to make it more legible so
each element should be applied this
particular Logic on and we are printing
each of the element one by one if I do
that let's observe the output and let me
comment this particular code which we
just covered for the Sorting logic so we
get only one output let's run this code
now
so here we see we get some output here
uh first of all this Swiss out gets
printed which says printing all elements
one by one yes that's there and then
here we are saying element is which is a
static string and then every element one
by one is supposed to be printed and
that is what we see here we get all the
elements one by one and here it's not a
sorted order because we are not doing
any sorting here it's just printing all
the elements so this is how you can use
the for each method to iterate over any
collection in a single line of code
instead of writing all of that code now
you might be wondering what if I do have
to I have to do more than just printing
the element what is it is a multiple
lines of code which I have to run for
each element how do I do that it's
pretty straightforward we just put curly
braces here in the starting and in the
end of the code block inside the for
each method and let me just put an enter
here just to make it more readable so
here you can write the code whatever you
want to in terms of the kind of logic
you want to apply on each element so
once you have put this curly braces you
can write as many lines of logic as
required inside this code in the inside
this curly braces block and this code is
going to be executed for each of the
element one by one if you have just one
line of code you do not need to and you
should not put the curly braces if it's
just one line of code just drop this
curly braces completely remove the
semicolon as well along with the curly
braces and this is how you will run a
single line of code but if you have a
multiple lines of code which suppose
which is required to be run for each of
the element then you put the curly
braces and then you follow the normal
Java construct which is to end every
statement with a semicolon the usual
Java programming code basically which
can go inside the curly braces so that's
how you can use for each for any simple
and complex iteration logic which you
want to apply on a particular program
and this is all I want to cover in
today's session so we talked about how
we can use the dot sorted method to sort
a particular collection and we also had
a look at how we can use the streams API
for each method to iterate over the
collections in the next session we are
going to talk about a very interesting
method of the streams API and a very
popular one which is called the reduce
functionality let's get started with
using the reduce functionality in the
streams API before we go to the
implementation of the reduce
functionality let us understand why do
we need it and how the constructs of the
reduce functionality work so let's
understand first about the requirement
why do we need it so imagine a
requirement where you have a list of
numbers and you are asked to calculate
the sum of all the elements inside the
list a very straightforward requirement
that you have a collection and you are
asked to calculate the sum of all the
elements of the collection now if you do
not use the streams API you can go ahead
and very well write a complex for each
logic or enhanced for Loop logic to
basically run that code and write the
logic where you pick one element all the
elements one by one and keep adding them
to the new element but we can do the
same kind of thing by using the reduce
method and to put it in a generic way if
we have to understand why we need reduce
methods so whenever you have to change
the whole collection representation into
a single result remember that line
whenever you have to change the
representation of the complete
collection into a single result in those
cases you will use the reduce method of
the streams API and if you apply this
definition to the example I gave you I
have a collection of numbers and I want
to calculate the sum of all the elements
of this collection which is a single
result which is a single number so yes
my example does apply directly to the
generic definition of the reduce method
so remember this generic definition this
will help you understand when to use the
reduce method in your program
so how does the reduce method work you
can see I have shown you an example of
the syntax of the reduce method and it
looks a bit complex here so let's try to
understand what is happening here to
understand the functionality of the
reduce method we have to understand
three terms which are identity
accumulator and a combiner let's
understand each of them one by one
identity is basically an element which
is the default or the initial value of
the reduction operation this value will
be used if the stream itself is empty or
it will be used as the first value of
the result which you want to get out
eventually so in this case if I have to
submit all the elements of a collection
the initial value can be set as 0 and
that is the first thing which you have
to pass inside the reduce method so you
can see 0 here the next thing is the
accumulator so accumulator is a function
which will take two parameters the first
parameter would be the ongoing partial
result let's say if you have to
calculate the sum of the all elements
and let's say if you have iterated two
elements so far so the sum of those two
elements is your temporary or partial
result right so you need to store that
partial result somewhere and that is the
first argument of the accumulator method
in this case it is this variable which
is shorthanded as ANS or answer so the
first argument is the partial result and
the second argument of the accumulator
function is the next element of the
stream so whatever the next element is
which is supposed to be added to the
existing result is going to be the next
argument of the accumulator function
which is I in this case so we talked
about the identity we talked about about
the accumulator function then we have a
third one which is called combiner and
this is sort of an optional not in all
cases but in in some cases it is
optional let's understand why do we need
combiner so combiner is an optional
function which you will be required to
use if you want to sum the two elements
which do not have the same data type
what I mean is here this ANS or answer
and I both are integer if both of the
arguments of your accumulator function
are of the same data type you do not
need a combiner and that's why there's
no combiner here but if there is a
requirement where you are let's say
adding uh a correct sum to a student
object then it doesn't work right
because a student object is a custom
object and that current sum is a number
object so a student object cannot be
just added to a number object it can
work if you can do student.get age which
is a number object so a current answer
plus the student dot get age might work
but current answer comma student will
not work in those cases where you have
mismatching data types in those cases
you will have to write a combiner
function but for this case you don't
need to write a combiner function
because both of the elements or the
arguments of the accumulator function
are of the same data type so you specify
that argument function functions
arguments basically and then you provide
the implementation of the accumulator
function which is this one this is the
implementation again using a Lambda
Constructor so you provide the
implementation of this particular
accumulator function and then there is
no comma here to provide further
combiner functions specifications so
there is no combiner here if there was a
combiner there would be a comma here and
then you will write the combiner
specification where you will cast the
current object into the type which is
the same as the partial result
so you don't need that here and you can
just say the partial result plus the
current element and that should work
fine so this is how you will write the
reduced logic and if you have written
this logic correctly then it should
automatically just submit all the
elements one by one and produce a single
result and remember I'm using the
numbers list here which is written here
in the very beginning where I have four
elements to it which are 10 20 30 and
40. so if the reduce operation works
fine with with my intended objective
then 40 plus 30 which is 70 plus 20 is
90 plus 10 is 100 so I should get the
100 as the as the final result of this
reduce operation you will also notice
that after this particular method you
don't need to call any collector method
or any collect method at all the reason
is because this particular function
itself will return a single result which
you can store in the desired variable so
now let's try to run this particular
example and see the output so right
click run as Java application and I get
the result as 100 which is coming from
this particular Swiss out where I'm
printing the sum so yes this is working
as per our expectation where it
basically created the sum of all the
elements of this particular collection
so remember when you will use the reduce
operation remember the generic
definition whenever you have to convert
the whole collection into a single
result that would be the use case where
you will use the reduce operation that's
one thing remember the identity
operators definition remember the how
the accumulator function works and also
remember when to use the combiner
function a reminder of when to use the
combiner function is whenever you have
these two arguments of different data
types that would be the use case where
you would need to write a combiner
function it is also used if you have to
write parallel streams but parallel
streams is an advanced concept which we
are not covering in this particular
title but if you want to learn about the
the whole parallel stream concept do
check out the API docs for that and you
can also have a look at some examples
from the Java tutorial official website
itself
and that's all I want to cover in
today's session in the next session we
are going to talk about the access
modifiers in Java let's get started with
access modifiers in Java so when we talk
about access modifiers let's understand
what is the underlying philosophy of the
reasoning behind this
and the reasoning is very
straightforward it can be even wrapped
into a single word which is called
security the reason is that you will be
creating multiple kinds of objects and
variables while you write your Java
program and you should always write your
Java program or any program in a manner
that only the intended classes packages
modules or applications should be able
to see what they are supposed to see
so as a consumer application I should
only be able to consume the variables
which I am expected to consume I should
not get any variable or I should not
even have access to any variable which I
am not supposed to access so the idea is
providing the least privileged principle
give access to different functions
different variables different programs
only by providing them the the kind of
access which they need to run run
efficiently and do not give them
complete access so with that notion in
mind Java created the concept of access
modifiers and it created these three
modifiers which are called public
protected and private if you do not
provide any modifier then it goes to no
modifier or some people also call it as
default modifier which is also a type of
access modifier so let's understand
theoretically first how it works and
then we will try to have a look at an
example let's understand the first one
first of all these modifiers are
keywords and you can use these keywords
in front of classes in front of
variables and also in front of methods
and you might have already noticed this
particular keyword called public in
front of all the classes I have created
or even when we talked about the public
static wide main method we saw this
public as a keyword it is basically an
access modifier and whenever you put
public in front of a class or a variable
or a method that particular component
becomes available to the whole of the
program it will be available to the
whole world basically any subclass or
any package or any other class which
might have been written in your Java
program will be able to access that
particular class or variable or method
if you put public in front of that the
second modifier level is protected one
of the other thing which you which you
will understand as I explain this is
that as you move down into this
particular table the access level will
start getting more and more restricted
and by restriction I mean that less and
less components will be a able to get
access to those modifiers so if you
write protected in front of a class or
in front of a method or in front of a
variable then everything within that
particular class will still be able to
access it everything within the package
will still be able to access it I still
haven't covered the concept of package
but I briefly touched upon it showing
you how whenever we write a class we
have a package in front of it and
package is technically is just an
aggregation of the classes if you have
to write write multiple classes and wrap
all of those classes into a single
logical bundle that would be called a
package just to show you an example
these all are packages which you see
here you see this square box here and
you see that these names these all are
packages and these packages contain
multiple classes and technically that's
all the packages mean that you can wrap
multiple related classes into a single
package so coming back to the access
modifier whenever you write protected in
front of a class or a variable or a
method then and that particular
component will be accessible to
everybody within the same class
everybody within the same package it
will also be accessible to everybody
which is a subclass of the class this is
again A New Concept which I have not
covered but this basically means a child
of this class now what is a child of the
class we will cover at that Concept in
detail when we will talk about
inheritance but for now you can
understand that it is a basically an
extension of the class so when the
moment you declare something is
protected it can easily be accessible
within the same class in which this
protected component was declared it can
be accessed in the package it can also
be accessed in the subclasses of the
class but anything outside the package
will not be able to access it because
you see an N here then we have the
default access modifier or no modifier
if you do not write anything in front of
a class or a method or a variable it
gets the default access modifier
privileges I and that privilege mean
that anybody within the same class will
be able to access that default variable
for a default component anybody within
the package will also be able to access
it the subclasses of the class where the
default component was declared those
subclasses will not be able to access it
and anybody outside the package will
obviously not be able to access it then
comes the last one which is the most
restricted privilege which is called
private so if you put private in front
of a class or in front of a method or in
front of a variable that component will
only be accessible within the class
where it was declared it will not be
accessible in the package
it will not be accessible in the
subclasses and definitely not be
accessible to anybody outside the
package so private is the least
privileged or least access permission
level you have in Java once you write
private in front of any component that
only the the classes other variables the
the same class in which you declare this
particular private variable only that
class itself will be able to access it
and nobody else will be able to access
it and as you move above the accesses
become more and more lenient you can see
there's just one y and three n here the
moment you move a bit above to the
default modifier you get two y's so
everybody in the class and everybody in
the package will be able to access that
particular component rest of for the
rest of the other world it is still
unknown when you write something as
protected then everything in the class
everything in the package and everything
in the subclasses will also be able to
access it rest of the world cannot
access it and if you write something as
public then anybody can access it it's
like y everywhere so that is how the
access levels work now let us understand
this with the help of example so I will
go here and I've just written a very
simple dummy class here which has uh
which is a class called test and I have
a method here which is a display method
so very simple class nothing fancy here
and if you if you notice I have not put
any kind of public private or or
protected modifier in front of the class
so this will get the default privilege
if something has default privilege then
the whole world will not be able to
access it so let's go to a different
package let's go to this package which
is here and let's try to access this
particular test class so we will try to
access this test.java here in the main
class
so let's try to do that let's say test t
equal to new test I'm just initializing
the same class
so what do I get I get a compile error
let me try to fix it if I can and I
cannot fix it if you see I'm just trying
to use this particular test class into a
different package but that package is
not able to see the class at all I'm
getting a compilation error and if I try
to click on the error generally Eclipse
provide me suggestions to fix the to
import this particular class but eclipse
is not able to fight and find any class
with the name of test which can be
imported in this package which is a
different package than the one of the
test class so we cannot access it
because it's in the default access now
let's go back to the test class and
let's make it public so I've just made
it public here and now if I click on
this again I get the suggestion if you
see the suggestion was not there earlier
now it says import test and if I click
on this double click it gets imported
and everything is happy so you can see
the whole access modifier in effect here
the default versus public you can also
try the other other kind of I access
modifiers let's try private as well I
think private will also have the same
effect because it will still not be
accessible from the package or from the
subclass from part from the from the
whole world we already saw this
particular in effect but we will see the
private in a in a different way now so
going back to the test class I have made
the class as public but the method here
is default I have not exposed this
method to be used outside the class
let's see what happens if I try to call
this display method from the main class
so I have successfully initialized the
class and if I say t Dot
and if I look at the suggestions here I
do not get suggestion of the display
method why because it is default
if I go back
make it private can I now access it
let's try again nope still we can't
access it eclipse is not even able to
find it inside this package because it
is private
let's go back and make it public
so I've made it just public now going
back to the main class and again saying
T dot now I get that display suggestion
as the first suggested method here and
now I am able to use the display method
once I have made it public so you see
the moment you change the uh the access
modifiers the changes are propagated
immediately and you can see the public
versus default versus private in play
here we can even go into further detail
by using the protected but for protected
I have to explain the concept of
subclasses so I will cover this
protected versus subclasses concept when
I talk about inheritance and there we
will see the usage of protected
variables and the protected access
modifier but we saw the usage of public
the default modifier and the private
modifier do check out the documentation
for these access modifiers and I would
strongly suggest you to play around with
this get more comfortable with this
concept of different kind of modifiers
let's also run an example for for
understanding the default modifier in a
better sense because we can see that for
the package it says why right so let's
go back to eclipse and within the same
package where we created test class
let's create another class let's call it
test demo
so I will just click finish I get a new
class let me also write the public
static void main method here so I get
the public static void main method here
and let's try to access the test class
here within the same package so let me
again go back to the default privilege
here so I put the test class axis as the
default class or default access and same
goes for display so can other classes in
the same package access the test class
now let's see that if I go to test demo
and here if I try to get the test class
initialize does it work or does it give
me a compilation error yes it works it
works because the test class and the
test demo are in the same package and
test class has a default access
privilege
so let's try to run one more variation
of it to understand the usage of the
private method better going back to the
test class this display method has the
default privilege right now so going by
that logic if I say t dot I should be
able to get access to the display method
and yes that is possible if I run this
particular program I will be able to get
whatever is given out by the display
method which is hello world
now let's try to make this particular
method as private and let's try to
access this method from one of the other
class in the same package as of the test
class so the class is default the method
is private and if you see this class has
already turned red there is a
compilation error because now the
display method is not accessible to the
test demo class even if it was in the
same package it's not accessible because
the display methods privilege or access
modifier has gone to private now exactly
the same as explained here because it
has become private so the package level
members cannot access it there's an N
here so this is this was another
variation to show you how you can use
public protected and private together to
only expose the members methods and
classes which are supposed to be exposed
to the consumer this is a very critical
and very important concept to be used in
Java and it is used from a very simple
program to all the highly complex
application this is sort of the bare or
the found laying foundation for any kind
of basic security level premise which
you need to build your application so
that's all I want to cover in today's
session where we discussed about the
different access levels in the next
session we are going to talk about the
concept of inheritance let's get started
with inheritance
so inheritance is basically one of the
most important properties of any object
oriented programming language it's
basically a concept and a concept says
that what if you have a scenario where
you want multiple classes to share
similar behavior and similar properties
let's understand this with the help of
an example let's take the example of a
bank when you go to a bank to open an
account there are multiple types of
accounts there can be a savings account
it can be a type of current account
there can also be a different offering
for personal account and Commercial
accounts such as for businesses then you
may also have loan accounts which are
having different kind of properties so
all of these types of accounts are still
technically accounts and they will share
some similar properties for example all
of them will have to maintain some sort
of an interest rate for example all of
them will be used to either deposit
money or withdraw money so there would
be some kind of similarity across all of
these types of account classes but at
the same time there will also be some
sort of differentiality amongst these
classes the way you will calculate the
interest rate for a current account will
be different from the way you will
calculate the interest rate for a
savings account and the same applies for
commercial account personal account Loan
account Etc so you see that we have some
common Behavior but at the same time we
also have some different Behavior so
whenever you have such scenario always
think about applying the concept of
inheritance in your application this is
another simple way to spot whether
inheritance can be used at a particular
place or not inheritance is also called
is a relationship so whenever you read
the requirements from a customer just
try to find the words which use this
particular phrase is a for example car
is a vehicle savings account is a type
of account similarly you will find many
other types of similar examples so
whenever you will see that is a
relationship between two different kinds
of objects or two different kind of
entities that means that there might be
an inheritance relationship being
applied between them and that's how you
will spot the usage of inheritance so so
far we have understood this concept that
there would be some sort of relationship
between the two classes what will be
this relationship the relationship will
be of parent child type there will be a
parent class some people also call that
as base class and then there will be a
child class so the child class will be
inheriting the properties and the
behaviors from the base class or from
the parent class I will be using Base
Class and parent class terms
interchangeably during this session but
the basic idea and basic provides is
like that only that there will be a
child class and there will be a parent
class and the child class class is
extending from the parents class
remember the word extend because we are
going to use that and I've just shown
you the uh what you see here is
basically the official definition which
is given by Java docs here we can read
the definition as well and the basic
idea which I told you lies in the parent
and child relationship and this is how
you can conceptualize it that you will
have a base class or a parent class and
then you will you can have multiple
children of it and then those children
can again have their own children and so
on so forth so this hierarchy this whole
inheritance hierarchy can go as deep as
you want it to be and that's the basic
idea and basic conceptualization of how
you understand and how you visualize
inheritance now let's move to Eclipse
IDE and try to understand this with the
help of an example so for this
particular case I have created a set of
classes basically which we will be using
to demonstrate the relationship of
inheritance and I've taken the simple
example of a bicycle so a bicycle is
again a very definition of any two
wheeler and bicycles can have multiple
types there can be an all-terrain bike
there can be a mountain bike there can
be a city bike there can be a bike which
is specific specifically made for ladies
and similarly there can be multiple
different types of bikes but all of
these bikes will have some similar
properties for example all of them will
have two wheels all of them will have a
seat all of them will have brake all of
them will have some sort of of some sort
of a speeding mechanism whether they can
accelerate de-accelerate so there will
be some commonality but at the same time
a mountain bikes features might be very
different from a city bike feature a
mountain bike features might feature a
mountain bike might have gears for
example whereas a city bike might not
have gears because you don't need that
much of a variation in inclination and
declination when you drive down the road
so I'm trying to conceptualize the same
example here where I've created a class
called bicycle and this is my base class
I Define two properties in the in the
bicycle class which is gear and speed we
will come back to protected in a while
but let's let's leave that there so I
have two properties which is gear and
speed I have a Constructor where I'm
initializing the starting speed and the
starting gear and then I have three
methods here which says set gear apply
break and speed up when I apply brake
the speed is going to get reduced so
that's why you see minus equal to Unity
operator
and when I'm trying to speed up the
speed is going to increase that's why
I'm using the plus equal to unary
operator so when you use the method
speed up the speed is going to be
increased by the value you supply in the
method similarly when you apply the
brake the speed is going to get reduced
by the amount you supply in the method
argument and that is my Base Class
bicycle gear speed and three methods now
let's have a look at the child class
so the way you will Define The
Inheritance relationship in Java is by
using this extends keyword remember I
told you to remember the extends keyword
so what you will do that you will write
your class name as usual and then you
will use extends keyword and then you
will use the parent class name or the
Base Class name so here I'm saying class
mountain bike extends bicycle and here I
am providing an additional property
remember the whole commonality versus
differentiality equation so a mountain
bike might have an extra property to
adjust the seat height so that's the
extra property which mountain bike is
having
and then since this mountain bike is
extending the bicycle class this
mountain bike class has the
responsibility to initialize the bicycle
class as well and the way it will
fulfill that responsibility is by taking
all the arguments of bicycle class plus
the mountain bike class in its
Constructor and that's why you see three
different properties here you see the
start height property which is the
property of this particular class which
is the seat height and then you see the
start Speed and start gear property
which directly are not available in this
class but this class is inheriting those
properties from The Base Class remember
the keyword inheritance here and then
once you do that how do you initialize
the Base Class Constructor is by calling
the super method this is again a keyword
in Java and you will use this super
keyword to refer to the base class
Constructor in this way so what you will
do technically is that you will write
super and you will supply the arguments
which is required by The Base Class
Constructor if I go back the Base Class
Constructor requires two arguments start
Speed and start gear
so I write super and then I write start
Speed and start gear so whatever I got
from here in the Constructor of mountain
bike I am supplying those values as is
to Super and Java will automatically
take care of invoking this particular
Constructor the moment it it Encounters
this kind of statement another another
thing to notice is that this super
keyword or super statement has to be the
first statement inside your Constructor
remember that whenever you are dealing
with inheritance and whenever you have
to initialize the super class
Constructor or the Base Class
Constructor use the super Constructor
invocation as the very first statement
inside your child class Constructor
otherwise Java will not compile the
program and then you will initialize the
local variable I should call this as
this remember I we discussed about this
in this in the classes session
okay and then it just has a method of
set height so there's no extra method
with this mountain bike is providing but
this mountain bike will have access to
all the methods which have been provided
here and all the properties which have
been provided here this mountain bike
can access everything from the bicycle
class and that's the whole idea of
inheritance that the child class can
access the properties of the Base Class
by extending the base class now let's
look at how do we invoke this particular
class so for that I have a simple class
name as inheritance demo which has a
public static white main method and then
I am initializing the mountain bike
class
I'm supplying three values as 20 10 and
1 so the 20 goes to start height
the 10 here goes to start Speed and one
here goes to gear or the start gear and
that's how I'm setting the values so
when I call this particular Constructor
here the mountain bike Constructor is
going to this mountain bike Constructor
is going to get called and which in turn
is going to call the Base Class bicycle
class Constructor as well and everything
will be set accordingly and then let's
try to access the gear property remember
gear is not directly available in the
mountain by class but I am still able to
do mountain bike dot gear because child
class can access the parents class
properties
similarly the same thing goes for Speed
as well and seat height is the local
property of this particular class
mountain bike so it will anyways be
accessible so I can access all the
properties of the base class and the
child class itself seamlessly without
any differentiation now let's try to
call a method so here I'm calling the
method apply break remember apply break
was defined in the Base Class not in the
child class it's defined here so I'm
calling the apply break method and I
want to reduce the speed the current
speed by 1 and then I'm printing the
current speed saying that bike speed
after applying brake is mountain bike
dot speed so let's run this particular
program and observe the outputs
okay so the the first statement which
gets printed is at line number seven
which says gear is one because it's
coming from here then the seat height is
mountain bike dot seat height which is
20 which is the first argument here and
then the bike speed is 10 which is
coming as here and getting printed here
and then when I apply the break let's go
back to the apply break method the logic
is that whatever is the current speed
reduce it by the value I Supply in the
method
so if I Supply 1 10 minus 1 becomes 9
and that becomes the current speed if I
Supply 5 here the current speed will be
10 minus 5 equal to 5. Let's assert that
particular assumption as well yes we can
see that and similarly you can access
other methods of the base class as well
if I just do control space here and you
can see apply break is accessible set
gear set height speed up all the methods
which are defined in the base class are
accessible in the child class as well
this is the power of inheritance one
more thing which I said I will come back
to is around the usage of protected
access modifier remember when we
discussed about the access modifiers in
the previous session I said that
protected is used when you are dealing
with inheritance that whenever you
define something as protected it will be
available to be accessible in the child
classes of the base class so if I Define
this particular variable as as protected
then this particular property will be
accessible in the child class mountain
bike as well let's play around this
let's make this as private and see what
happens so if I make this private now
when I say private the scope of this
particular variable is within the class
only and nobody outside the class will
be able to see it and you can see the
effect of it I can see an error being
coming here in my inheritance demo class
because now mountain bike object cannot
access the gear property because the
gear property is defined in the base
class and now it is private that's why
the child class now mountain bike class
cannot access the property gear and the
moment you make make it back to
protected it will be accessible the
error is gone there's no red line here
so that's how you can you can use the
protected access modifiers it is always
always recommended to use them when you
when you write any kind of inheritance
logic and inheritance logic as well
intentionally if you want to hide a
particular property from the child
classes just make it private and that's
all I want to cover in this particular
session where we dive deep into the
concept of inheritance we had a look at
an example using the bicycle and
mountain bike kind of construct and you
can apply the same kind of construct on
any kind of other other kind of business
requirement remember the is a
relationship
so that's all I want to cover in this
particular session and in the next
session we are going to talk about
another very interesting concept of java
which is about encapsulation let's get
started with encapsulation so again
let's understand what is encapsulation
in general and then we will apply that
concept to Java encapsulation if you try
to break that word if I just write it
here in the form of a comment it's n
capsulation just trying to break this
word into to to make it more visual so
you see you see a word called capsule
here so if you if you try to imagine a
capsule why do you create that and
what's the concept of a capsule capsule
tries to pack a lot of things inside a
small tube like shape and the concept of
encapsulation is sort of inspired from
that not exactly not literally but
that's the basic idea of of this root
word which is called encapsulation so
encapsulation basically means to
restrict accessing the properties of a
class to the outside world if you want
to protect the properties of your class
how do you do that you do that with the
help of the concept called encapsulation
so here you this is a sort of a security
feature you can think it think of it as
a security feature that you want to
protect the properties of your class and
you will use encapsulation to protect
the properties how you implement
encapsulation let's have a look at that
now so basic idea is to encapsulate the
objects create sort of a capsule around
the object which can provide that
protection layer and you will Define how
the outside world is going to access the
properties of the class if needed so
I've created a simple class here and
it's if you if you remember one of the
previous examples when we discussed
about classes I use the same class which
was the student class and I'm just using
the same class for continuity so I've
created a student class here and I have
created three different properties of
this particular class which is name name
of the student age of the student and
address of the student you see
intentionally I have used the keyword
private in front of these three
properties and that is the first thing
which you need to do to implement
encapsulation on your object that you
hide all the properties from the outside
world remember the moment you make
anything as private only the class which
is the student class itself only the
class itself can see these variables or
these properties nothing outside the
student class will be able to access the
name or age or the address directly from
the student class it's not possible
that's the whole idea of making it
private because you don't want the
outside world to access these properties
so you make those properties as private
then you create a Constructor the
Constructor has to be public so that
anybody can initialize the student
object because you want your object to
be accessible remember so you want the
objects to be accessible but you want
the restriction on the access of the
properties of the object and these are
the properties of the object so you have
restricted them by making it private but
that doesn't solve the problem because
there will be some illegitimate
consumers of the student object which
should not have access to the student
properties but there will also be some
legitimate consumers of the student
object which should be having access to
the properties of the student for
example the payroll application will
need access to these particular
properties the examination application
will require access to these particular
properties so how do you do that you
create Getters we call them Getters
because they start with the keyword get
so you create a getter method for each
of the property you create the method
called as get name and this is the
naming convention with Java promotes
that you write get and then you write
the name of the property in camel case
so you write get name and this property
is supposed to return the name property
of this particular object and you here
you say return name so you're returning
the the name which is being stored by
the current student object whenever
somebody calls student object dot get
name and this is the way you have
restricted the access of this particular
object as well so remember you made it
private so that nobody can access it and
then you defined your own way of
providing access to the name property of
this particular class now if anybody
wants to access the name value of your
student object there's only one and one
way to do that which is via calling get
name so you have provided restrictions
and you have also provided prescriptive
guidance on how you are going to expose
the properties of your class that's the
second uh thing which you need to do to
implement correct form of encapsulation
on your object that that is to provide
the getter methods with the right
visibility you want to make them public
so that anybody can call them but since
you are governing which is what is
written inside the method you have full
control on what kind of exposure you
want to give for this particular
property similarly you create a getter
for age calling get Edge which Returns
the age and then you call get ad you
write get address and return the address
here it is simply returning it but if
you want to do more stuff here feel free
to do that like I said you govern the
control of how do you want to return the
name maybe you don't want to return the
complete name and you want to just
return the initials then you can split
the string trim the string and return
only the initial patients so that's the
basic idea of Getters now after you have
created the object there might be use
cases where somebody needs to overwrite
the values of the properties like name
age or address whatever Student's name
was incorrectly mentioned when they
called The Constructor and now they want
to override the name or fix the name so
basically they have to replace the
existing value of the name with a new
name so in that case you need to provide
what we call as Setters and they start
with set that's why we call them Setters
and we follow the same kind of logic
that you provide these Setters for all
the properties of your class so you had
three properties which were named age
and address and you provided the Setters
for all three of them and how do you
provide that you write you again make
them as public because you want the
outside world to access this Setter
method to override the values of the
name this method is not going to return
anything so it is going to be y right
then you write the name of the method
which starts with set and then the
property name in camel case and then you
provide the new value which is the value
which should be which should be the new
value and this is the value which should
replace the existing value so whatever
new value you want to supply just apply
that as the argument of the setter
methods for set name for set age or for
set address and then you write this
particular line which says set the
current name property of this particular
object with the name which is coming in
from the argument so this dot name
remember this dot name represents the
current objects property because this
represents the current object so
whatever is the current object property
value of the name is just overwrite that
value with the argument coming in do the
same thing for age and set age method
and do the same thing for set address in
the in the set address method so this is
how you are going to provide the Setters
and the Getters so Setters and Getters
can also be generated in smart Ides like
like Eclipse so you just right click you
go to source and here you will see the
option of generate Getters and Setters
if you click on this it will give you
the list of the fields which are
available to be had to be having Getters
and Setters currently it says no fields
or all Fields have Getters and Setters
already Yes because they have it let me
just comment this and show this how this
work so for example let me comment all
the Getters and setters so I'm
commenting them and if I right click
Source generate caters and Setters I get
all the fields available for which
Setters and Getters can be generated so
you can select them and leave everything
as default hit generate and it is
automatically going to generate the
Getters and the setter you see all the
code of the getter and Setter is
automatically generated you do not even
need to write it and this is the power
of the smart ID is let me just uh revert
what I did
so you created everything as all the
properties as private and then you
define how you want to replace the
values by providing the Setters and you
define how you want the outside world to
access your properties so you have full
control of the class now you you control
the visibility you control how they are
going to get initialized you are you are
controlling how the properties are going
to be overwritten or set and you control
how the properties are going to be
returned so you have complete control of
the class so you have created a perfect
capsule here a perfect form of
encapsulation in this class and this is
how you can Implement encapsulation and
that's all I'm going to cover for this
particular session in the next session
we are going to discuss about
abstraction let's get started with
abstraction let's first understand the
definition of abstraction before we
relate this to Java abstraction
generally means hiding something when
you want to hide some details of of a
particular or object from the outside
world you apply the concept of
abstraction for example when you drive a
particular car you just hit the
accelerator and the car speeds up now
it's not only one action when you hit
the accelerator the whole Machinery of
the car and all the components different
parts of the car work together to speed
up they would be engine they would be
propulsion they would be fuel they would
be they might be some if it's an
electric car they would batteries there
would be whole different kinds of
pistons and plugs which will make the
car speed up it's not only a single
component it's a lot of different
components under the hood and that's the
concept of abstraction that we only show
the relevant parts to the user and we
hide all the internal details from the
user that's the basic idea of
abstraction so a car manufacturer
abstracts away all the inner technical
details from the driver and just gives
the driver a single pedal to speed up
the car for a User it's a very good
experience because he doesn't need to
know about all the internals of the car
but the car manufacturer can hide all
the details and provide a very simple
interface for the driver to interact
with which is just a gas pedal and
that's the basic idea of abstraction and
we try to apply the same kind of concept
to Java in the form of abstraction and
Java provides this kind of concept
implementation with the help of a
keyword which is called abstract now
abstract is a keyword which can be used
in front of a class or a method when you
use it in front of a class the whole
class becomes abstract abstract class is
a type of class so the class itself
becomes an abstract class one of the
things to remember is that abstract
class cannot be instantiated but can be
subclassed remember we talked about the
concept of subclass and the parent class
when we talked about inheritance so if
you make a class as abstract class you
cannot call The Constructor of the class
us because you cannot instantiate it but
you can extend the abstract class and
create a child class class out of it
that's the concept of abstract class
another concept is abstract method you
can also use the abstract keyword in
front of a method and when you use
abstract keyword in front of a method
then that method is only declared
without an implementation you are not
going to provide any implementation of
the method and you're just going to
declare the method something like this
we will see a similar example in the in
the Hands-On as well but that's the
basic idea that you just declare the
method you are not providing an
implementation as to what does move to
Method actually does because that's the
whole concept of abstraction and it is
the responsibility of the child classes
which inherit the particular class in
which the abstract method would be
sitting so that child class will be
having the responsibility to provide a
concrete implementation of the declared
method let's understand this better with
the help of an exam sample so here I
have created a class called graphic
object and I have made the class as
abstract class this is the keyword which
you need to use in front before the
class keyword and the class becomes an
abstract class now when you create an
abstract class it automatically gets
some properties the first property is
that this particular class must have at
least one abstract method and this is
how you define the abstract methods
where you just provide the Declaration
but you do not provide the
implementation of the draw method or the
resize method and the way you will
create the abstract methods is by using
the abstract keyword before the actual
method declaration starts so General
method declaration would look like this
and if you use abstract in front of it
this becomes an abstract method
declaration abstract class can also have
concrete methods so that is the Liberty
which abstract class gives you that you
can have abstract methods which are just
declared but you can also have normal
methods which are which where you can
also provide the implementation so you
can have normal methods and Abstract
methods as well in an abstract class
so this is the abstract class now if if
you want to provide an implementation of
the draw and resize method you have to
extend this abstract class so we extend
this abstract class by creating two
child classes out of this particular
abstract class which is circle.java
where you can see I create a normal
class and I use the extends keyword for
inheritance and I'm saying that Circle
class is inheriting from the graphic
object class which was my abstract class
and once I use this extends keyword then
I have the responsibility of providing
the implementation of the abstract
methods actually Java will force me to
provide the implementation of these two
methods if I do not provide all the
declared methods so there are two
declared methods here so if the circuit
class does not provide that the
implementation for both draw and resize
methods then Java will throw an error
and it will ask you to take an action
which can be either Define all the
methods meaning provide implementation
for all the methods or make the circle
class itself as abstract let's see if I
just comment this particular out I get
an error you see a red line here and if
you click on this particular balloon
here it will say either you can add the
unimplemented methods or you can make
the circle type as abstracts these are
the two options which you will get to
fix this particular error so an abstract
class can be extended by another
abstract class if the child abstract
class is not implementing all the
methods of the parent if you want to
implement all the methods then just
Implement them and keep and keep it as a
normal class and that's what I've done
here I've just created a normal class
here and provided the implementation and
once you provide the implementation of
both of the methods the error is gone
similarly I have also provided another
child class because it's there can be
there can be multiple children of a
particular parent so rectangle also
extends from the graphic object and it
also provides its own implementation of
drawing and resize because generally the
way you will draw a rectangle and you
resize a rectangle will be different
than drawing or resizing a circle here I
am not doing anything in the methods
because this is just to show you the
demonstration I'm just printing a Swiss
out saying drawing a circle and resizing
or drawing a rectangle and resizing a
rectangle and in the circle class
drawing a circle and resizing a circle
so one abstract class is the parent
class which is the graphic object and
two children Circle and rectangle both
providing the implementation of the
abstract methods which were declared in
the base class now let's go to the main
class where I've defined defined the
public static void main method and here
you see I have created two different
kind of blocks of code here one block is
where I'm saying graphic object creating
a reference of the graphic object named
as Circle and initializing the circle
object now you see a difference here
here is the abstract class and here is
the concrete class so whatever you
define on the right hand side whatever
is the type of object will be the type
of methods being caught so if you
created a circle object and then if you
call the draw method and resize method
these methods will be called from the
circle class if you initialized it as
new rectangle then you are creating a
rectangle class object and then the draw
and the resize method will be called
from the rectangle class that's the
basic construct and that's how you will
initialize a particular class which is
using an abstract class so I I call a
graphic object Circle New Circle and I
call circle.draw and circle dot resize
similarly graphic object rectangle equal
to new rectangle and rectangle dot draw
rectangle dot resize let's run this
program and observe the output so when I
call this particular block of code
Circle object gets initialized and then
Circle dot draw method prints drawing a
circle and circle resize method prints
drawing resizing a circle similarly when
I create the rectangle class object
referencing it with the graphic object
plus
rectangle.draw prints this particular
line drawing a rectangle and rectangle
dot resize prints this particular line
which is resizing a rectangle and this
is how you will use the concept of
abstraction this another very
interesting thing which which is which
is going on here remember I told I do
this and I I create I just put a system
out here
base abstract plus so if I do this here
if I create if I still write a
Constructor though Java says that it
cannot be instantiated if I still write
a Constructor of it and I do not do any
changes here and if I run this
particular program let's see what
happens you'll see the base abstract
class being called here let me just
reformat it by putting Ln here so that
we get a better output so if I run this
particular program you see base abstract
class is getting printed somehow though
we said that abstract classes cannot be
instantiated but still the Constructor
of this is still getting called somehow
when I create a circle class The Base
Class Constructor gets called and when I
click create a rectangle class again the
Base Class Constructor gets called this
is this is the power of inheritance
because in inheritance remember how it
works when you call when you initialize
a particular child object referencing it
with the parent object see the
references of the parent class then the
object is of the child us so whenever
you do it like this first the default
Constructor because I'm calling the
default Constructor here the default
Constructor of the circle class will get
called which will go here remember I
told you that Java provides the default
Constructor automatically if you don't
provide it so the default Constructor of
circle gets called but Java sees that
you are writing this code here which
says Circle extends graphic object so
Java is automatically going to call the
parent class and going to initialize the
parent class as well because that's how
it will be able to see these methods and
so so that's why it will automatically
call The Base Class Constructor even if
you don't call it explicitly in fact you
cannot call it explicitly Java will not
allow you to initialize the graphic
object class explicitly it can only and
only be called by Java itself indirectly
via the concept of inheritance if you
try to do this let's try to do this for
fun and and also for better
understanding so if I write graphic
object g o equal to new graphic object
you see I don't even get an option but
let's write it and let's see what
happens so you see that this particular
it gives basically an error because it's
not able to find the Constructor of the
graphic object class though even I have
defined the default Constructor here but
still Java is not able to find it
because this class is abstract so hence
proved abstract classes cannot be
instantiated explicitly they can only be
instantiated by the child classes
through the internal mechanisms of java
itself and that's all I want to talk
about in this particular session where
we looked in detail about the concept of
abstraction couple of more things which
I did not cover in the previous session
I just want to call them out for clarity
Java does not support multiple
inheritance when I say multiple
inheritance what it means that you will
not have a scenario where a child will
be extending from two base classes Java
does not support supported it does
support it with the with the help of
interfaces but I will talk about
interfaces in the coming sessions but
here just understand this that you
cannot use multiple inheritance with
classes in Java a child cannot have two
parent or two base classes in Java Java
will not allow that it is also called
The Diamond problem because the child
class does not know whether to follow
the route of Base 1 plus or the base 2
class if it is extending from two
different base 1 and base two classes so
a class can only extend from one class
in Java we can find a workaround of it
by using the concept of interfaces but
that's something which will be coming
later another thing to understand is
that when you create an abstract class
here these variables you can declare
declare these variables as well and
these variables will be accessible by
all the child classes as you access them
so that's all for this particular
session and in the next session we are
going to talk about interfaces let's get
start started with interfaces in Java
now again let's understand what do we
mean by an interface in general and then
we will see how do we apply the concept
of interfaces in Java so imagine let's
let's take the same example of vehicle
industry because that's something which
we see every day around ourselves and we
can relate to it so imagine if all the
car manufacturers were creating a
different way of driving a car what if
in one car you have a steering but in
other car you do not have a steering but
you have something else which is which
may be called something else in one card
you have the gas pedal to speed up in
other car you have a button to speed up
similarly in in one car you may have
different kind of doors and in other
cars you may have different kind of
doors which are completely different
looking it's not even a single simple
handle to open it so you see the problem
here the problem here is that all the
car manufacturers are not working on a
single contract correct they are not
respecting a single interface which will
create a poor user experience because
the users whenever the users have to buy
a new car or they have to switch from
one manufacturer to other manufacturer
they are completely clueless as to how
to drive that particular class because
the interface they were using in the
previous car is completely different
from the interface they are being shown
in the other car and that's that's the
basic need for the concept of interface
think of it as a contract agreement you
see it is also mentioned here that if
you apply the same kind of concept to
programming World imagine if every
programmer was writing their own logic
in their own way without following a
single contract or a single guideline
soon it is going to create a problem and
that's the kind of problem interfaces
try to solve so interface is again a
keyword in Java and the basic idea or
the basic construct is that the
interfaces are going to to define the
specifications of how a class would act
let me repeat this in our generic way
interfaces are going to define the
contract or the specification which is
going to govern how an application or
code or programming large logic will
behave that's the basic idea of
interfaces so interfaces are their own
type and the basic property of interface
is that it can only contain constants
method declarations similar to abstract
classes and some default methods or
static methods or nested types what is
nested type we will cover that later
default methods will touch upon a bit
here and the static methods as well but
the basic idea is that when you create
when you create an interface in Java you
cannot write anything concrete in terms
of the behavior of the interface where I
say Behavior always think of that as
method so you cannot Define a concrete
method in an interface you can only
declare methods you can also declare
constants you can create a particular
type of concrete method by using the
default keyword but use it in very
special circumstances you can also
create static methods as well which are
only going to belong to the interface
and nobody else now let's look at an
example and and also before we go to the
example let me also phrase this here
that if an interface cannot Define a
concrete implementation of the methods
then naturally the interface is going to
be extended by a child class a concrete
class which is going to provide the
implementation of the methods declared
in the interface it does sound like
abstract classes but there is a
difference let's understand the
difference with the help of an example
this is how an interface will look like
I've used the same construct of bicycle
and mountain bike just to maintain some
continuity and a less context switching
but this is how an interface would look
like like you will not use the class
keyword but instead you instead of that
you will use the interface keyword you
can only declare methods you cannot
Define methods remember when we looked
at the abstract classes example we were
able to Define concrete methods as well
but in interface that's a strict No-No
you cannot Define concrete methods let
me show you the abstract class in the
case of abstraction which we used this
was the abstract class and it did have a
concrete method right but bicycle.java
here which is because it's an interface
it is not going to allow you to create a
concrete method another thing is that if
you try to declare a variable inside the
class they will have to be constant you
cannot just declare them without any
value for example I cannot do this if I
do this it is going to give an error you
see an error here and it says initialize
field X at declaration something like
this public static final so interface is
going to force you to declare all the
variables as public static final with
some value if you try to use them inside
interface so that is also something
which interface will mandate so you see
interfaces are more strict they are more
strict in terms of what you can do you
can only declare public static final
variables and you can only declare
methods you cannot Define methods so
abstract class is less restrictive
interface is more restrictive and that
is the differentiation which you have to
keep in mind whether to use abstract
classes or whether to use interfaces
that is also a very common confusing
question in the interviews as well and
remember that interfaces are only for
contracts or specifications where in
case of abstract class you can write a
concrete Behavior as well in terms of a
concrete method in the Base Class
interfaces there is no concrete
implementation in the Base Class
abstract classes yes there can be a
concrete implementation in the base
class that's the basic difference moving
on I have created a child class here
which is again mountain bike and it has
three properties seat height gear and
speed similar to the previous example it
has a Constructor and remember into
again interfaces cannot be uh
initialized directly so you do not even
need to call a super method here because
there is nothing to initialize you
initialize a class to create a state
state is denoted by the properties but
interfaces will force you to write a
public static final property and
initialize its value automatically so
you do not need a Constructor for the
interface because there is nothing to
initialize everything has been
initialized in terms of the variables
and the methods are anywhere just
declared that's why you don't need to
call Super here after that the moment
you write this particular keyword here
implements and that is how you will
basically extend from the from the
interface you will use the implements
bicycle keyword here implements is the
keyword and bicycle is the name of the
interval phase if you write this here
then Java is going to force you to
provide the implementation of these two
methods if I if I do this implements
bicycle and if I comment out these two
methods which is coming from the base
class it is going to give an error and
if I read out this error it says either
you add the unimplemented methods or you
make the mountain by class as abstract
there are two ways to fix this
particular class similar to abstract
classes it will force you to write the
implementation of the Base Class
declared methods another thing with Java
will will suggest you and will will also
Force you via some Ides as well is that
you use this particular annotation we
use this particular annotation to tell
Java that we are overriding this method
from The Base Class since apply break
and speed up methods were defined here
in the base class and this child class
is supposed to provide the
implementation of the methods by
overriding them overriding is again a
concept which we will talk about in
detail in the coming session sense but
for now remember that you need to write
this annotation here on the methods
which have been taken from the base
class to provide an implementation and
the implementation is similar to what we
have seen before so whatever value you
supply in the apply break the speed is
going to get decremented by that
particular value and in case of speed up
whatever value you supply in the
argument that value is going to be added
to the current speed and the speed is
going to go up let's look at the main
class here which is called interface
demo it has a public static void main
method and here I'm again initializing
the child class nothing nothing strange
here and then I'm using the getter
method here because I have made
everything as private here and rest of
the things are just here as is I have
the Getters and Setters here for all the
properties and I'm using those here so
I'm using the Getters to just get the
value of gear seat height and speed and
then I'm applying the brake and then I'm
printing the current speed after
applying the brakes let me just expand
this a bit more and then I'm using the
speed up method trying to increase the
current speed of the bike by 10 and then
printing the new speed again so using
the apply break and speed up methods
which are concretely defined in the
child class by using this override
annotation and these were the methods
which were declared in the interface in
the base interface and that's all it
which is happening in this particular
the class let's run this particular
program and these are the values I get I
get the gear as one which is coming from
here I get the seat height as 20 which
is coming from here I get the current
bike speed as 10 this was the value
which it was initialized with then I'm
applying the break and after applying
the break the speed of the bike gets
reduced and it becomes 10 minus 1 which
becomes 9 and that's what gets printed
here and then I'm speeding up the bike
by 10 so the current value of the
current value of the speed of the bike
is 9 and if I incremented it by 10 it
becomes 19 and that's what gets printed
here
and that's all I want to cover in this
particular session where we had a look
at an example of how we can use
interfaces in Java and how we can use
interfaces with the concept of
inheritance and in the next session we
are going to have a look at the concept
of multiple inheritance using interfaces
let's get started with multiple
inheritance in Java using interfaces if
you remember in the previous sessions I
said that multiple inheritance is not
possible in Java and it is not possible
because of the diamond problem or simply
put a one child cannot have two parent
classes that's what Java says and let's
understand why this is a problem so I
have created a very simplistic diagram
to to demonstrate the problem of
multiple inheritance and then we will
see how we can solve that so let's say
you have a class C a normal class then
you created two parents of Class C so
basically Class C is extending Class B a
and you also want the class C to extend
Class B first of all it is not possible
in Java and why it is not possible is
because of there can be a super class
which is extending Class A and Class B
as well so you started with class C you
wanted to have you wanted Class C to
have two parents which is a and b But A
and B also had a common parent which is
super class so now as you know that the
child classes can see the properties of
the base classes as well then if Class C
wants to access something from
superclass which route should it take
should it take this route or should it
take this route that is the problem
which will be called as the diamond
problem and that is the reason why Java
prohibits using multiple inheritance
using classes so that's the problem
statement that we don't have a clear
route to reach to the super class from
class C and we try to solve it using
interfaces so let's jump right into the
Eclipse IDE to understand and how we can
solve it so here I have prepared an
example for this particular problem and
the solution of it so again I'm using
the same bicycle and mountain bike
example for the sake of continuity I
have created an interface of bicycle
which has two declarations which is for
applying break and speed up this is my
simple interface and then I have a
mountain bike class which is
implementing the bicycle interface and
providing the implementation of apply
break and speed up this is something
which we have already seen in the
previous example so nothing new here and
then you have other Getters and Setters
and you have a main class where you can
initialize the mountain bike and get the
gear get the seat height get the speed
we have covered all of this there's
nothing new here but now let's say you
have a requirement that you have another
interface which is called vehicle and
your mountain bike should extend or
implement this interface as well is that
possible able let's try that remember
mountain bike was already implementing
bicycle interface what if you want to
have two parents of this mountain bike
using interfaces like I said previously
that interfaces does solve the problem
of multiple inheritance so let's see if
it does solve that problem so I can just
say vehicle here and see if the code
compiles the code doesn't compile here
and the reason is pretty expected it's
because vehicle has a declared method
which is called can drive and mountain
bike now needs to provide the
implementation of that particular method
so if you click on this balloon and hit
on add an unimplemented methods just
double click on that and you will get an
empty method definition of that can
drive method and let's put assist out
for Simplicity and say mountain bike can
be driven so this is how you can see
this this code is working fine and now
this particular child class has two
parents it has a bicycle parent and it
also has a vehicle parent so if bicycle
and vehicle would have been concrete
classes then this would have caused an
error let me quickly show you that if I
can so let me go to bicycle and I just
change this to class and I put an empty
definition for both of the methods and
then let's go to the vehicle class and
convert interface and convert that into
class as well and again provide an empty
implementation so I've just converted
the vehicle interface and the bicycle
interface into classes and now if I go
back to the mountain bike and if I
change this to extends I get whole lot
of Errors if I go here it says multiple
markers and it doesn't give you the
right error but the right error is
happening because you cannot extend from
two concrete classes now bicycle and
vehicle are both classes and mountain
bike cannot do that because Java does
not support multiple inheritance from
classes but if you go back to the
previous state if I just quickly do Ctrl
Z here and Ctrl Z here in case of
vehicle as well converting both of them
back to interfaces and putting the
implements back here everything goes
fine so using interfaces you can
Implement multiple uh inheritance but
using classes you cannot do that let's
cover one more interesting scenario what
if you have a need to extend from let's
say one interface and one more class is
that possible because we saw the com we
saw the combination of two classes that
was not possible we are seeing the
combination of two interfaces which is
possible now is it possible to extend
from a base class and Implement an
interface let's see what happens if we
try to do that and I have another class
this is not an interface but this is a
class called two wheeler so technically
speaking mountain bike is a two wheeler
and at the same time mountain bike is
also a vehicle and mountain bike is also
a bicycle so what if you have a
requirement that your mountain bike
should also extend from two wheeler
class can you do that let's see if I can
do that I will just write extends uh two
wheeler and let's see if that works it
doesn't work here but let's put it here
if I put it here does it work now yes it
works there's no compilation error here
which means Java does accept this
particular construct so what happened
here first thing when I put this extends
two wheeler after implements Java did
not allow which means that the extends
keyword has to come right after the
child class it cannot come after the
implements Clause it has to come right
after the child class that's first thing
second thing is a normal glass a normal
child class can extend from one concrete
class and can also Implement any number
of interfaces you see I have two
interfaces so now technically this
mountain bike has three parents it has a
concrete class two wheeler as the parent
it has bicycle interface as the parent
and it also has vertical interface as
the parent so three parents so this com
this basically uh justifies the
philosophy or justifies the concept that
a class can extend from only and only
one base class but can Implement any
number of interfaces you can have more
interfaces here as many as you want so
number of interfaces is not a
restriction but number of concrete
classes is a restriction a child class
will have only one concrete base class
but can have any number of interfaces
being implemented from this particular
class that's the basic property and then
the main in the main method uh you can
access any of the vehicle or two wheeler
or bicycle interfaces methods and the
classes methods as well if you want to
so for example if I want to just type
this and if I just do dot here I can see
I I can access can drive as well now can
drive was implemented in the vehicle
interface or declared in the vehicle
interface similarly if I look for the
two wheeler method can I see the two
wheeler method as well let's see if I
can yes and this you can see this is the
two wheeler class method which says can
rotate two wheels so I can call this
particular method which is coming from
the two wheeler class I can call the
vehicle class declared method which was
can drive so this is also possible and
this is possible because mountain bike
is implementing the interface of vehicle
so let's run this particular program and
understand the output so at first I
initialize the mountain bike class and I
print the gear the seat height and the
bike speed values you have already seen
this then I apply the brake and I speed
up so after applying the brake the speed
becomes 10 minus 1 9 and after speeding
up the new speed becomes 9 plus 10 as
90. then I call mountain bike Dot can
rotate two wheelers two wheels which is
going to invoke the method which is
defined in the two wheeler class which
is printing a simple system so I get the
same sys out here this method is being
invoked from the mountain bike object
due to the concept of inheritance
similarly when I say mountain bike dot
can drive the scan Drive was declared in
the interface vehicle and then when
mountain bike implemented this interface
Java forced it to provide an a
definition of this particular method and
this is the definition which is again
assist out and you can see that this out
being printed here so this is how you
can Implement multiple inheritance in
Java using the power of interfaces and
you can also combine the classes and the
interfaces the condition is that only
one class should be the parent class and
then you can have any number of
interfaces as the parent entity if you
want to and that's all I want to cover
in this particular session
in the next session we are going to
discuss about method overloading
Concepts in Java let's get started with
polymorphism so polymorphism is a very
generic concept which means that a
particular object can take multiple form
let's not even call it as object let's
make it more generic a particular entity
can take multiple forms if any entity in
Java exhibits that kind of behavior then
we say that polymorphism is in action
that entity can be a class or an object
or even a method and in today's session
we are going to talk about that type of
polymorphism which is exhibited by
methods so we will see how a particular
method in Java can take many different
forms containing different Logics but
still having the same name and that
concept is called method overloading so
whenever you hear the word third that
you need to overload a particular method
or this is Method overloading happening
technically or conceptually it's
basically polymorphism in action and
polymorphism is being applied on a
method here and that phenomena we call
as method overloading so in today's
session we are going to have a look at
how we can Implement method overloading
in Java so the basic idea of method
overloading is that the name of the
method should remain the same so you see
in this particular class which I have
created to demonstrate the method
overloading so this is the class name
and the method name which I am going to
overload is called multiply and that is
probably the first thing which you need
to remember to implement over method
overloading correctly that the method
name is going to remain the same the
type of the return of the method may
change here you see it's returning in
here in the first instance in the second
instance also it is returning int but in
the third instance it is returning W so
the return type of an overloaded method
can change another another thing which
which can be varied between same method
being defined again and again is that
the number of arguments and the type of
arguments the first multiply method
takes two arguments of integer type the
second multiply method takes three
arguments of integer type and the third
multiply method takes two arguments of
double type so by using method
overloading you can vary the number of
arguments and also the type of arguments
so the basic idea is that you declare
you define the method using the same
name but you do a variation in the
arguments or the return types and that's
how you technically Implement method
overloading in this case in this
particular case the multiply is the
method being overloaded and in the first
case it is accepting two integer
arguments and returning the result of
multiplication of those arguments in the
second case the same method name
multiply here the same visibility public
and the same return type but this time
three different types of integer values
can be accepted and this method multiply
method is going to return the
multiplication of three integer numbers
in the third case at line 15 I again use
the same multiply name the method name
but this time the return type becomes
double and this method accepts two
double arguments and Returns the result
of the multiplication of these double
values so the method name is same but
the arguments vary and also the return
type may also vary that's the basic
premise of how you implement method
overloading so whenever you want to
implement it keep the method name same
vary the arguments and the return types
and after that I am just created a
public static void main method here I
have initialized the class here this
particular class itself method
overloading demo and then I am calling
the multiply method on the object and
based on the number of arguments I
Supply the corresponding method will get
invoked that is something which Java
will take care automatically that
whatever type and the number of
arguments you supply in the call in the
invocation based on the number and the
type of the arguments Java will try to
find a matching method in the overloaded
methods if it is able to find the method
it's going to get invoked if it is not
able to find the method you will get an
error in fact you will get a compile
error itself while you invoke a method
which for which the definition is not
available for example if I try to just
copy this and make an invalid invalid
method invocation let's provide four
arguments and if I do that here itself I
will get the error because Java is not
able to find a multiply method in this
particular class which is accepting four
integer arguments so you will get the
compilation error itself before you can
even run the program but the basic idea
is that you use overloading with
multiple different types and the number
of variables so I'm calling multiply
three times let's run this particular
program and observe the output so let me
just bring this output down yep so first
I call Demo dot multiply and pass two
integer values 10 and 20. when this
happens this particular method gets
invoked and it is it returns a result of
10 into 20 which is 200. in the second
invocation I'm calling again the
multiply method but this time with three
arguments three integer arguments
specifically and this call is going to
match this particular method signature
and it is going to execute whatever is
written inside this particular method
which is the multiplication of the three
arguments being supplied so 10 into 20
into 30 which is 6000 the third case
let's go back here at line 25 the third
case of invocation iteration of the
multiply method is accepting two decimal
based arguments 10.5 and 20.5 so Java is
going to look at the class and trying to
find a method which can accept decibel
values and there it is this is the
method signature which is going to match
the invocation Java is going to do this
matching automatically for you and here
whatever logic you have written inside
this particular method we will get
executed so 10.5 into 20.5 returns
215.25 and that's the output you get so
this is how you can use method
overloading in Java this is a rather
fairly simple example but you can make
it as complex as you want but a word of
caution do not use it too extensively in
fact lot of expert programmers do not
recommend using method overloading
because it becomes very confusing use it
only when you do not have any other way
out use it only where this is the only
way to write correct form of methods
with the right readability otherwise
generally there would be other ways to
avoid method overloading by writing
concrete purpose friendly method names
themselves maybe you don't need to use
the multiply name again again you can
call it as multiply two numbers multiply
three numbers multiply doubles so that
the method name itself is more explicit
and understandable rather than juggling
around different signatures of the same
method especially it becomes more
confusing if you are creating an
interface which is to be consumed by a
third party developers or third party
application so try to use it with
caution that's what I'm trying to stress
here and that's all I want to cover in
this particular session and in the next
session we are going to talk about
method overriding let's get started with
method overriding in Java so in the
previous session we discussed about
method overloading concept now in this
session we'll focus on another
interesting concept by which you can
have the same signature of the method
again and again be used in your code but
in a different way and this concept is
called method overriding method
overriding basically is used together
with the concept of inheritance you
won't you will not be able to use the
concept of method overriding without
using the concept of inheritance
remember when we talked about
inheritance I spoke about the subclass
and the parent class concept sometimes
we also call the parent class as
superclass so the basic idea is that if
a super class defines a method remember
I'm using the word Define here if the
superclass uses the defines a particular
method and then the subclass again tries
to define the method with the exact same
signature this phenomena is called
method overriding now when you do method
method overriding there are some rules
to follow and I'm showing you a tabular
structure here a table basically which
will show you what is possible and what
is not possible when it comes to a
method overriding so let's try to
understand this table so if you try to
define a method with the same signature
as a super class method the rules follow
as per this table let's go with the
first one if you have an instance method
defined in the super class instance
method is the normal method which you
define in your in your classes so if you
have defined an instance method in your
super class and if you define a method
in the subclass with the exact same
signature then that concept is called
method overriding and it will be a
successful override override also let me
also explain what override means here
override means that once you try to
initialize the subclass object you will
be able to invoke its own overridden
method definition if you call that
particular method the subclasses own
instance method is going to get invoked
rather than the super classes instance
method we'll look at that when we look
at the example as well but that's the
normal scenario when where your super
class defines an instance method and
subclass also defines the an instance
method with the exact same method
signature that concept is called method
overriding what if your super class
defines a static method static method is
is basically a method which belongs to
the class but not to the object instance
method is called instance method or
normal method is called instance method
because it belongs to the object you can
call the method on the object but static
methods are called by class so you say
class name dot static method name but
when you when you call instance methods
you just call object name dot instance
method name so that is the basic
difference the static methods belong to
the class once you have defined our
static method the same static method
will be available to all the objects of
the class but instance method are unique
to each object so that was a short tour
of what static methods mean so if you
define a static method in the super
class and then if you try to Define an
instance method with the same signature
in the subclass you will get a
compilation error it will not be allowed
it's not allowed in Java to override a
static method from Super class that's
what it says next one if your super
class has a normal instance method and
then the subclass tries to use the same
signature but creates a static method
out of it then again you will get a
compilation error so that the overriding
of an instance method to a static method
is not allowed and the last concept is
again a very interesting concept and a
very popular interview question about
method hiding so if the super class
defines a static method and the subclass
also defines the static method with the
exact same signature then the super
class static method gets hidden it
basically hides the superclass method so
that's the basic idea behind over method
over lighting so if you see technically
it's a form of polymorphism because the
same method is having multiple
definitions but when we looked at the
previous example the multiple
definitions were in the same class here
the multiple definitions are in
different classes and those classes are
having a parent-child relationship that
was about the theory of it let's go to
an example of it to understand it better
and I've used again the same construct
of bicycle and mountain bike which we
have been using in this in this series
just to maintain continuity so I have a
parent class called bicycle here which
has two properties gear and speed it has
a Constructor nothing unusual there and
then it has defined three methods set
gear apply break and speed up set gear
is just setting the new value as the
gear value apply break is going to
decrement the speed by the value you
supply and speed up is going to
increment the speed by the value you
supply simple this is exactly what we
have seen before now mountain bike tries
to extend bicycle so mountain bike
becomes a child class it defines a
variable called seat height defines a
Constructor called super hair nothing
unusual so far also defines a Setter for
height Setter for the seat height not
exactly following the sector construct
but this is just to set the height but
here things get interesting let me just
bring this down a bit Yeah so here it is
overriding all the three methods of the
base class and by overriding it is
providing its own implementation of the
same methods let's compare them here
when it overrides the gear and whatever
value you supply it adds 2 to the at
plus 2 to that value and then sets that
value as the gear value but in case of
Base Class it was just setting the new
value as the gear value so for instance
for instance if you supplied one here
the gear value becomes 1 but here if you
supplied 1 the gear value becomes 3.
similarly when you apply break on the
mountain by class whatever value you
supply will be subtracted from the
current speed and 10 would be subtracted
even more so if the speed is let's say
50 and your decrement you supply the
decrement value as 10 so it will be 50
minus 10 minus 10 equal to 30 but in
case of bicycle if the speed was 50 and
you supply 10 then it would be just 50
minus 10 40. so there is and there is
extra 10 being subtracted from the speed
when you apply break in case of a
mountain bike similarly for speed up its
increment of 10 in addition to what's
what value you supply so again if the
speed was 10 and you supplied 10 here in
the argument so 10 plus 10 plus 10 30
will become the new speed in case of
mountain bike but in case of bicycle if
you supply 10 and if the current speed
was also 10 then it becomes 10 plus 10
only 20 so that's the difference so the
basic idea I hope you get the basic idea
here is that you override the methods
and your own class provide its own
implementation of those methods that's
the basic premise of method overwriting
all good so far and you do not have a an
uh an obligation to override all of the
methods because here we have the
concrete implementation of the methods
so here in case of mountain bike you can
skip overriding one of the methods if
you like to this is also fine there will
be no compilation error because speed up
has a concrete implementation in the
bicycle class as well so it's up to you
how much you want to override
so let's move to the main class now so
in the main class we have created the
public static void main method here and
let's look at what is happening inside
the class first we initialize the
bicycle glass so bicycle class reference
and bicycle class object nothing unusual
here we Supply the gear value and the
speed value then we print the gear and
the speed value we apply break on the
bicycle and then we observe the new
speed of the bicycle after applying the
brakes let me comment out the rest of
the code and let's observe the output
for only this part of the code which we
just walked through for this section so
if I run this as a Java application and
if I show you what I'm getting what I'm
getting here so bicycle gear is one
which is what you supplied in the
Constructor bicycle speed is 10 which is
again what is supplied in the
Constructor then you applied break and
when you apply break this logic gets
executed and you supplied one here so
current speed was 10 so 10 minus 1
becomes 9 and the new speed becomes 9
which is what you are printing here so
far so good let's move on to the next
section let me comment out the previous
section now and let me uncomment this
section so here I have a bicycle
reference but the object is of mountain
bike remember this concept this is this
is called Dynamic object binding concept
or dynamic binding concept again this
might be asked in your interviews so
here I'm initializing the mountain bike
with a reference of bicycle remember
whatever is written on the right hand
side will govern the variables and the
methods usage we'll we'll see how that
works out what I just said so I am
supplying three values here 50 50 and 3
in the mountain bike uh if I go here in
the mounted by Constructor so the start
height start Speed and gear are the
three values which is supplied as 50 50
and 3. then I am accessing the gear and
the speed now remember gear and speed
are declared in the bicycle class but
they are accessible in the child class
due to the inheritance phenomena which
we have already covered so if I print
only this part I should get the expected
values mountain bike gear is three which
which is what I have supplied here and
mountain bike speed is 50 which is which
is what I have supplied here then I
apply the brakes now let's move on to
this section I apply the brake supply
the value as 1 and then I want to see
what would be the new speed after
applying the brakes so let's see what
happens when we run this particular code
so if I run this code after applying the
brakes the speed becomes 39 before
applying the brakes the speed was 50. so
what happened here is 50 minus 1
basically this this logic is getting
executed here 50 minus 1 minus 10 which
becomes 39 that's why you get the value
as 39 as the new speed similarly if you
want to call another method as speed up
speed up method was also defined here
where I'm saying speed plus the argument
event supplied plus 10 so the current
speed is 39 right now then I am speeding
It Up by 10 so by this logic 39 plus 10
plus 10 which will become 59 and then
I'm printing the new speed after
speeding up so let's see what happens so
if I go to run as Java application and
if I observe all the outputs the speed
was 50 initially after applying the
brakes the speed became 39 and after
speeding up the speed became 59 so this
was a quick demo to show you the power
of method overriding and how you can
override the behavior which is defined
in the base class so this is all I want
to cover in this particular session
let's get started with the static
keyword in Java now let's first
understand the need of the static
keyword and then we'll talk about how
Java implements the static keyword
imagine a scenario let's take the
example of a class which we have been
using in our in our different tutorials
in this particular series which is about
the student class so if you are building
a college management system you have a
student class there and if you have an
entry a property in the student class
which is storing the name of the college
then the name of the college is going to
be the same for all of the students of
that particular College it's not going
to change another example let's say you
are building a employee management
system for our organization and you want
to maintain the employee numbers for the
first object the employee number should
be one for the second object the
employee number should be 2 for the
third object the imply number should be
three so on so forth so when you
initialize all the employee objects the
last employee object has the final total
employee count and you can also treat
this employee count as let's say the
employee number as the employee ID so
starting from the first employee to the
last employee the employee number is the
employee ID which is a way to uniquely
identify defy and employ so we talked
about two different cases in the first
case we had a particular value which was
same for all of the objects which was
the student and the college relationship
and then in the second example which I
quoted where all the employees objects
have to share a particular property
amongst them because if the second
object did not know the previous value
of the employee number it will not be
able to get to the new number it needs
to know what was the previous value so
that it can do plus one so each of the
object needs to know the state of the
previous object two different cases two
different scenarios one single solution
which is static keyword so the static
keywords are used for those members
which belong to the class now apply this
definition to the examples which I gave
you if I make a member of the student
class let's say the college is the
property of the student class and if I
make that property as static now that
static and that member that static
member becomes the property of the class
and not the property of the object it
means it belongs to the class it also
means that all of the objects will get
the same copy of this static member
variable and that's that's one of the
first usage and you can you can make any
property or any member of the class as
static by just putting the static
keyword in front of it we also call the
static member variables as class
variables like I just described so use
it for the cases where the value across
the different objects doesn't change you
can make those class variables and those
variables as class variables or static
variables similarly also try to identify
the cases where a particular value has
to be shared in terms of knowing the
previous state in those cases as well
you can use a particular member in that
particular class and make that static
for example in this case we have a
bicycle class and we have a static
variable which says number of bicycles
so every time you initialize the bicycle
object this number will be shared and
you can see I mean this is here it is
incrementing the number of bicycles so
every time you create the object the ID
becomes plus one to the previous count
of the number of bicycles exactly same
example as they gave you for the
employee number so every time you create
an object you do a plus one to the
previous value next object will take the
previous Value Plus One and so on so
forth so you can use the static keyword
in front of a property of the class and
make it a class level variable which
will be tied to the class and not tied
to the objects you can also make the
methods as static as well and the same
kind of rule will apply on the methods
as well that the methods will become
will belong to the class instead of
belonging to the objects let's say you
have again a common functionality which
you want to share amongst objects just
make that common functionality as a
static method and that would be shared
amongst the objects for example you want
to get the number of bicycles for the
previous example which I just shared in
this particular dock here so you can
just create that method as static and
any object which will call this method
will get the latest count of the number
of bicycles you can also make these uh
these static variables as constants by
putting the final modifier in front of
it so if a variable in a particular
class is static and final both then
technically it becomes a constant so
these are some of the interesting use
cases and constraints of the static
methods and static variables there is
also a thing called Static block which
is just a code block which you can write
inside your class and we will have a
look at that example as well so let's
shift to the IDE and let's have a look
at how we can use this static keyword so
I have used again the same class which I
have been using using in other examples
which is student.java and you can see I
have this same class you have you would
have seen these properties earlier as
well and the code will low is exactly
the same just centers and Getters and
Constructors and it has an additional
property which is college and the
college name XYZ is the same for all the
students so I have just hard coded it
but you see what is happening here is
that every time you create a student
object this variable gets initialized
even though the variable for all the
objects has the same value still it gets
initialized again and again and again so
technically it's a waste of memory
you're just wasting memory of an of a
new allocation every time even though
the value is same what if we create this
object once and this member variable
once and just use it across objects you
can do that by just writing static in
front of it if you do that then you see
this becomes sort of italic here and
that's Java's convention to show that
this particular variable is a static
variable you can also see the static
keyword in front of it and then whatever
value you have specified this will be
initialized only when the class is
loaded remember I'm not talking about
the object visualization I am talking
about the loading of the class in the
jvm so the first time the class is
loaded this particular variable will be
initialized and that's it after that no
matter how many student objects you
create the same College reference will
be used again and again and the college
variable will not be initialized again
it will be initialized once and the same
College reference will be used again and
again that's the power of static
variables for example if I want to
access this particular College variable
how do I do that so let's look at a main
class where I have initialized this
particular student class with an object
named as John and I've specified the
name the age and the address and I'm
printing those values how do I access
the static variable if I say John dot do
I get access to the college variable
yes I do have access to it but does it
work let's see you see a yellow line
here and we will come to the yellow line
in a while but let's first see if this
works yes it works I can see that the
college name is printed here as Xyz
which I have set now let's look at the
error or the warning it says the static
field student dot college should be
accessed in a static way because the way
you are accessing it right now is the
instance way of accessing a particular
member this is not a static way of
accessing a member so if you want to
access a static member of a class you
should access it with the class name and
not the object name why going back to my
original definition that the static
variables belong to class they do not
belong to object and that's why Java
will warn you if you are not accessing
the static variables via the class
because they are supposed to be
accessible via class it will not give
your compilation error but but if you
are working in an Enterprise project
this is going to raise a lot of
violations and a lot of questions for
you as to why you are not accessing it
via the class name so this is the
correct way of accessing it and you will
get the same output now no matter how
many objects you create of the student
class you can always access the
student.college and you can always get
the same value of the college name
that's the first use case second thing
is about static methods so you will use
the static methods in a case where I
described about the counting the
employee numbers and let's say if we
have the same kind of scenario where you
have to count the number of students
because you can use that particular
count as let's say the roll number of
the student so if you have that kind of
requirement then you need to create a
static method because you need to share
the state of the object across objects
remember that so what you can do simply
is create a static method so let's say I
create a normal method and then I just
put static in front of it saying static
void student count and now I want to
count the student so I can let's create
a simple count variable and let's start
it with 0 and then I can increment the
count variable again and again in the
static method right but you see I get an
error here the error is if you go to the
balloon it says cannot make a static
reference to a non-static field count
this is one of the properties of the
static methods the moment you make a
method as static then that particular
method can only access the static member
variables of the class the static
methods will not be able to access the
non-static variables count is a
non-static variable count is a normal
instance variable so a normal instance
variable for that matter name or age or
address nothing would be accessible here
if I try to access let's say try to
access name here so if I just test this
out and I say name it will also give me
give me the same kind of error if I go
here it gives me the exact same error
because static method cannot access the
non-static member variables of the class
so you have to make this count variable
as static as well and then only this
compilation error will be fixed I can
remove this one and now this method is
fine now I can increment the count every
time that object is created and that is
one of the use case of using the static
method that you can share the state
across the different objects and if you
want to fetch this particular variable
then you can simply write a getter for
this
saying end count return count
and then you can return the count you
can see that now an instance method can
access the static member so the reverse
is is fine a non-static method can
access a static variable but a static
method cannot access a non-static
variable remember that a static method
can not access a non-static variable but
a non-static method can very well access
anything including the static variable
that second thing the third concept is
of static block and static block also
has a similar usage that if you have a
block of code it's not just a variable
it's not just a method but you have a
block of logic which you want to execute
only once when the class is loaded into
the runtime if that is your requirement
then you can write a static block and
the way you will write it generally we
write it at the beginning of the class
and the way you will write it is it as
you write static and you put value
brushes and you start writing code here
as to whatever you can say initializer
and you can write whatever code you want
to write the only caveat is that in the
static block you will only be able to
access only the static member variables
of the class so you will not be able to
access these variables you can only
access these two variables you can very
well move these two variables here if
you want to so if I go here I can paste
this and I can drop the static keyword
because everything in the static block
is automatically static so I don't need
to explicitly call out static variable
and now this code is fine you get some
warning because it's not used anywhere
in the class but that's fine because
this is just a simple demo but the whole
point is that you can write the static
block and you can write all these
initializer code which you want to write
here which you only want to execute once
during the whole execution of your
program just to show you the the reason
and the the way it works let's try to
see if the static block works and let me
comment all the static code which I
wrote here and let's go back to the
static demo and let me remove this one
as well so now I just will run this
student dot Java I will I will create an
object of student.java and I will see if
the static block gets executed or not so
let's run this particular class which is
the main class and I have a main method
I have a student object initialized and
I'm printing the name agent address
if I run this you see the first line of
code which gets printed in the output
console is the static block code
which is what I wrote here and let me do
one more thing just for fun sake let me
create more objects of it let me just
call them one two three and four
and let's see and let's see how many
times the initializer code gets printed
you see that the code still gets printed
only once even when I created five
different objects of the student class
and that's the property of the static
block that it will be executed only once
when the program is loaded into the
runtime and that's all and that's pretty
much all what I want to cover in this
particular session eager to uncover the
world of java then have a look at
Caltech coding bootcamp by simply learn
so hurry up and enroll Now find the
complete course details from the link in
the description box let's get started
with nested classes in Java so so far we
have seen that we can create classes in
Java and we can create objects of those
classes to interact between those
classes and objects and other properties
as well but what if you have a use case
or what if there is a need that you need
to define a class within a class so the
that's the concept of nested classes
that Java does allow you to create
classes within the classes now you might
be wondering as to why do you want to do
that and the simple answer is
encapsulation you would be facing some
scenarios while writing Enterprise grade
applications where you have a class
which has its own scope but that whole
scope or the existence of that class is
justified by another class for example
if you try to design an object oriented
design for a house then a kitchen cannot
exist without a house because the
kitchen exists inside the house right so
if you have that kind of relationship
then probably kitchen class has to be
inside the house class somehow and
that's where this nested class concept
will come into picture and that's why we
have this nested class concept here as
you can see what I'm showing on the
diagram that Java programming language
allows you to Define class within a
class and that is called nested class
now when we talk about nested classes
you will hear two different terms
basically nested classes are divided
into two categories which are static
classes or static nested classes and
non-static nested classes now static
nested classes are called simply static
nested classes and the non-static nested
classes are called inner classes because
they are non-static they are just normal
in our class exactly similar to the way
we say a normal method in a static
method similarly if you put a static
keyword in front of in front of a nested
class that becomes a static nested class
and if you do not put static keyword in
front of a nested class then it is
simply treated as a general inner class
that's the overall concept now there are
some more drivers of why you would like
to use it one example is I gave you
about the existence of an object within
an object or or technically speaking the
existence of a class within a class the
whole house and kitchen analogy which I
just shared with you but broadly you
will see three different reasons these
different reasons due to which you will
be using nested classes first of all
it's a way to logically group all the
related classes that are only used in
one place what it means is that if you
have a class which is only serving the
purpose for a larger class then it's
better to group those two classes
together inside a single class or simply
Nest the smaller class inside the bigger
class I might be using the term inner
class and outer class to point out the
static nested inner class and the outer
class that's the first reason the second
reason is like I said it increases
encapsulation because now you have full
control over what you can Expose and
what you cannot expose or what you
should Expose and what you should not
expose because inner classes will also
come with its own set of visibility
constructs like private protected Etc so
you you get more fine-grained control in
terms of what you want to expose to the
outside world collectively from the
outer and the inner class and it can
lead to more readable and maintainable
code though I would honestly say that
this is debatable because in lot of
programming languages static nested
classes are not promoted because they
drop readability imagine if you have 10
classes if you have a single class and
if you have a nested hierarchy of 10
classes it becomes super confusing and
super complex to track the visibility of
the variables and also to understand the
code better so this is debatable whether
it improves to readability and
maintainability or not maintainability
yes to a sense because you have a single
class which is containing the logic of a
inner helper class and the outer class
readability we just know it depends if
if the classes are small size then yes
it does improve readability if they if
they grow larger then it's better to
move the class outside and just make
that class maybe a package private or
something so this is the basic premise
of why we use nested classes now let's
talk about an example which by which we
can demonstrate how to work with the
static nested classes so here I have
created a class it's a simple class but
I've just named it as outer class so
that we understand that this is the
outer class so I have a class here which
is named as outer class and at line five
I am defining a static variable inside
the class you can see the static keyword
here and I've just called it as outer
static member then I have a simple
instance variable this is something
which you have seen normally in in all
the different examples I have given you
and then I have another static variable
but this is private so this one is a
normal static variable this one is a
normal instance variable and this one is
a private static outer variable all
these three variables are sitting in the
outer class but this is private this is
static this is private static and this
is a normal instance method and we will
see how we can access these variables
inside the static nested class to define
the static nested class the way you will
write it as you will be inside the class
opening and closing braces and you will
start writing like this static class and
the name of your class that is how you
are going to define a static nested
class and then you put the curly braces
and whatever goes inside it is just like
any other normal class you would write
so let's say inside the static nested
class I have defined a method called
display and now I am trying to access
this particular variable which was a
static variable defined in the outside
class or the outer class we will see if
we can access the static variables from
the outside class or not so that is what
this system dot out dot println is doing
I'm just accessing this directly you can
see you can directly access the outer
class static member variable inside the
static nested inner class then in the
next statement I am accessing the outer
private member this one so the outer
private member which is also static so
these two static variables are being
accessed here in these two lines
basically and then I have commented out
one more thing to try out if I can
access the normal instance member also
remember the concept which I which I
taught you in the previous session that
a static method or a static block can
only access static variables a static
block will not be able to access
non-static variables so these two are
static variables and this is a
non-static variable so we will see if
the same construct still applies on this
particular class or not so inside the
display method I have these two Swiss
outs and this one is commented out I
will come back to that later so you have
the you have your outer class and your
static nested class ready with a sample
method and now let's see how we can
invoke these outer and inner classes how
do we create the objects of an inner
class so for that I have this static
nested demo class it's basically
containing a public static void main
method as you can see here and let's try
accessing a static nested class so if
you want to initialize or access the
inner static nested class then you have
to follow this kind of construct where
you say outer class dot inner class name
then you give a reference to it and
again you follow the same construct you
say new outer class dot static nested
class name and a simple parenthesis and
this is how you are going to create an
object of the static nested class which
you had defined inside your outer class
remember the syntax this is how you are
going to do this that you type outer
class dot static nested class once you
have done that it will call the default
construct director of static nested
class and you will get an object now you
will also see the dependency which I
talked about there is no way that you
can initialize this static nested class
without referring it from the outer
class you always have to write this
outer class dot to access the static
nested class you will not be able to
access or use this static nested class
directly anywhere in your program so the
whole concept of the inner class only
existing with the outer class holds true
here because you can the inner class
only can exist if you refer it from the
outer class once you have the object you
call the dot display method and let's
see what happens so if I run this
particular program and let's see what
kind of output do I get I get two lines
of output when I call the display method
so let's go to the display method where
I am doing assist out for the static
member of the outer class which was this
variable so that value gets printed as
10 and then I am printing the private
static member of the outer class and
that also is accessible so it means that
you can access the normal static
variable of the outer class and also the
private static variable of the outer
class inside a static nested class
that's one part of it now let's
uncomment this and see if this works you
see that you directly get a compilation
error and you don't even have to wait
for the program to be run you see that
this particular variable instance member
this instance member variable is not
accessible so this this also verifies
our understanding which which was built
previously in the previous session that
static blocks can only access static
members and those static blocks will not
be able to access any non-static
variable or member and this was a
non-static member so that's all I want
to cover in this particular session
where we talked about the nested classes
concept the static nested classes
Concepts basically and we also had a
look at what the static nested class can
access or cannot access and we also saw
how do we initialize an object of a
static nested class in the next session
we are going to talk about the second
category of the nested classes which is
the normal inner classes or the
non-static nested classes let's get
started with inner classes in Java so in
the previous session we talked about the
static nested classes and in today's
session we are going to focus on the
non-static nested classes we also call
them simply as inner classes so whenever
you hear the word inner classes always
clarify whether they mean the static
nested inner classes or the non-static
nested inner classes because people may
use different terminologies but the
official or the standard terminology is
whenever somebody says inner classes it
means the normal nested class and when
somebody wants to convey static nested
classes they will use explicitly the
word as static nested classes so when we
talk about inner classes they look a bit
similar to the static nested classes
with the difference that you will not
see a static keyword well you define the
inner class that's the one type of the
simplest inner class you can create it
follows pretty much the same kind of
construct where you define the outer
class and you define the inner class and
you write the logic inside the inner
class so let's understand this with the
help of an example and we will also talk
about the other type of inner classes
which we have so with that I want to
switch back to the Eclipse IDE and let
me comment this one out because I will
cover this in a while and let me fix an
error here as well so I will comment
this as well okay so let's talk about
the demo which we are which I have
prepared it's a very simplistic demo
just to understand the concept and
please do practice all of these Concepts
in detail to get get more confident
about this so I start defining normal
class just naming it as outer class and
then you can create a class within a
class I'm calling it as inner class you
can obviously name it as anything you
want and you can write any logic which
you want to write inside your inner
class here I just have a display method
where I have a simple sys out which is
verifying if I can invoke this
particular method or not so if you have
this simple kind of construct of outer
class or inner class how do you how do
you initialize the inner class remember
when we talked about the static nested
classes and if we wanted to initialize
the static nested class I had to follow
this particular syntax where I said
outer class dot inner class on both
sides when I try to initialize the
object but if I want to initialize a
normal inner class or a non-stat
non-static nested class the way to do
that is like this so on the left hand
side you again follow the same kind of
construct where you say outer class Dot
inner class you write a reference for it
and then you say new outer class here
you are creating an object of it dot new
inner class so you basically first
initialize the outer class create an
object of the outer class and then that
object of the outer class can be used to
create an object of the inner class so
this is the difference if I take you
back to the static nested classes
initialization here on the right hand
side it was simply outer class dot inner
class and then the parenthesis because
this was a static member so you access
the static members by the class name
that's why class name dot static member
but you access the normal instance
members via the instance and not the
class name so you need to create the
instance first and then once you have
created that instance then you can
access any member variable of this class
and inner class technically is just a
member variable which has been
initialized here so this is is how you
are going to initialize an inner class
then you get an object of it and once
you have got the object of the inner
class then you can call the display
method and whatever is written in the
display method shall be executed let's
run this program yes I can see that the
display method is getting called and it
is printing whatever was written inside
the display method in the display method
I just simply had a Swiss out which said
this is a inner class method and that's
what is getting printed here that's one
type of the inner class which is looking
very simple another a bit more complex
and special type of inner class is
called method local inner class when I
say method local inner class the name
itself explains what it means that you
are trying to create a class inside a
method of the outer class so let me just
uncomment this part so this is a normal
method normal instance method of the
outer class and inside the method I
create a class you see inside the method
also you can create an inner class that
is also something which is supported by
Java and that's what I'm trying to
Showcase here that when I Define the
outer class method I write my whatever
logic I want to write in my method and
then I can create an inner class a
method local class basically I've just
named it as method local class to uh to
just look at more readable and then you
can Define anything you want to write
inside your method local class here I
have just defined a simple method called
local inner method and I have just
printed a statement inside the local
inner method which says in the method
local class method once I have defined
the class then within the method I can
also initialize the class if I want you
can see I am creating an object of the
method local class within the enclosing
method that is also possible so I create
an object called mlc and then once I
have the object I can invoke this method
by the object it and that is what I'm
doing here so this whole logic can be
just embedded inside a particular method
and we call this type of class as method
local inner classes this is also a type
of inner class but this is just to show
you that you can also create method
local inner classes so this is what I've
done here and if I if I invoke this
outer class method what happens let's
see that so here I have written the code
to Simply initialize the outer class
nothing new here this is a normal
initialization and once I've done that
once I've got an instance then I say
outer class dot outer class method I
simply call the instance method and once
I call the instance method everything is
written inside the instance method gets
executed so first I should get this
statement then the class will get loaded
and compiled then an instance of the
class will be created and then whatever
is written inside the local inner method
will be executed so technically I should
see this out and ultimately this is out
if I run those two lines let me comment
the first part so that we can observe
the output correctly and I run this as a
Java application and I get these two
lines so I get the in the outer class
method statement which is coming from
here and then I this this whole code
gets executed and eventually when this
method gets called I get this statement
as well which is in the method local
class method so this is to show you how
you can invoke the method local classes
basically there's nothing new here it's
just a normal class you instantiate the
normal class and then you call the
object you get an object and you call
the method on the object of the method
local class now there is another type of
inner class which is called Anonymous
inner class which we haven't covered so
far Anonymous inner classes are not very
common but sometimes you you might need
to do that you might need to create
Anonymous email classes but always first
understand and discuss with your
teammate as to if there is a way to
avoid Anonymous inner classes because
they are not very readable but let me
cover that as well as part of this
curriculum so if you have to implement
Anonymous in our classes let's first
understand why do we need to implement
Anonymous in our classes and I would
like to do that with the help of a
demonstration so I have again created a
simple interface of bicycle and I will
create an implementation class called
mountain bike so you see a bicycle
interface and I have two methods which
says can speed up and can apply break
just simple to interface methods being
declared here then I create an
implementation class called mountain
bike which implements bicycle and if it
implements bicycle it has to provide the
implementation of those two declared
methods in the interface and that's what
it does here and for the sake of
Simplicity I'm just printing assist out
here all good so far and then if you
have to access or create an object of
this mountain bike class the way you do
that is simply by just saying bicycle
Mountain equal to new mountain bike
remember I'm using the bicycle reference
here and but the object is of mountain
bike so when I call anything on the
mountain bike then that implementation
of the mountain bike will be invoked so
I'm just invoking the can apply brake
method and can speed up methods nothing
new here you have already seen this when
we were talking about interfaces session
but what if you want to create an object
of the bicycle class itself you don't
want to create a mountain bike class at
all is there a way to avoid creating
mountain bike class and still being able
to write this logic yes there is a way
and that is the anonymous inner way so I
can just say bicycle bicycle equal to
new bicycle if I say new bicycle
remember I'm not saying new mountain
bike because mountain bike does not
exist or I don't want to create mountain
bike class then you can write this
instantiation right for the interface
class but the moment you hit control
space and you will get this option where
it will say okay I will get you an
object of bicycle interface but it has
to be of anonymous inner type which is
of which is lying in this particular
package so if you just click on this
this whole code will be generated for
you so you see the moment you double
click on this this whole code was
generated automatically for you which is
providing everything technically
everything which you wrote in the
mountain bike class so the whole logic
which you could write in a child class
gets embedded right into the
instantiation code itself and this is
your Anonymous inner class you see it
automatically looks a bit ugly and
imagine if you're writing this for a
real production code where each of the
methods may have lot of logic and you
may have lot of methods then it can grow
very long and it can look very ugly
that's why I was saying always try to
create a child class instead it can be a
simple use case but try to create a
child class or try to avoid writing
anonymous process if you can if there is
no way out then this is the way you do
it you can there's also a bit nicer way
to do this using using Lambda function
for functional interfaces but that is
also something which will not uh improve
the readability a lot though it will
make the code look smaller so here you
can write the exact logic which you want
to write in can speed up and can apply
break basically whatever you wrote in
the in those two methods in the mountain
by class can very well be written here
and the code will still be executed so
let's let's just do that quickly so I
will just go here and copy this is out
from speed up method I'll just put it
here and I will copy the can apply break
method and I will put it here and I will
comment the mountain bike code so I'm
creating I've created the object of
bicycle class here and now if I say
bicycle dot can apply break and I can
say bicycle dot can speed up so now I
can access these two methods and the
implementation will be in invoked from
this Anonymous inner class
implementation so if I run this I will
get pretty much the same output yes you
can see I get exactly the same output
it's currently printing both of this is
outside the same because I did not
change this is out here and yeah I have
written the exactly same text in both of
the cases so if I just change text to
say can apply break and I do the same
thing here I say can apply break and if
I run this so you get the same output
and if you uncomment if you comment this
back and if you use the above code you
also get the same output yep so that's
the basic construct of anonymous inner
classes that you can use the interface
instantiation if you do not want to
create a child class of it just
instantiate the interface and Java will
automatically generate the concrete
override implementation for all the
methods which are declared in your
interface and then you can provide the
implementation of those methods in line
and that's all I want to cover for this
particular session so we cover a whole
lot we covered about the normal inner
classes we covered the method local
linear classes and we covered the
anonymous in the classes let's get
started with packages in Java now I have
been using the concept of packages all
the while in all the sessions but we
never focused particularly on packages
and why we need them how do we create
them what are the thumb rules so we will
focus on all of those questions in this
particular session so first of all just
to get the definition out a package is
basically a grouping of related types
now these types can be classes they can
be interfaces they can be abstract
classes they can be nested classes or
what not but the basic idea is that you
try to keep everything which is related
to each other at one place it's quite
similar to how you arrange your house or
how you arrange your office or how you
arrange your work desk you try to keep
the similar kind of stuff together for
example you might have a particular Rack
in your Almera where you keep all the
books you might have a different track
where you keep clothes generally you
won't mix books and clothes together in
a single rack right because they don't
belong together and that's the concept
basically with Java packages try to put
you or give you to implement in your
programming language and your project as
well so it's a logical way of grouping
related classes and types together
that's what packages do and if I take
you back to the Eclipse IDE before I go
any further you will see all these
Square looking objects right these all
are packages you see the square icons
these boxes these are packages and the
way you create packages is basically if
you just go to the SRC let me go back to
the SRC and you right click on this you
go to new you will get an option of
package so you can go click here and
write any name of your package let's say
test dot package couple of things to
note is that packages follow this
convention of Dot and that is how you
Nest a package into other or that is how
you create a hierarchy of packages and
sub packages so you can create this as a
package which is fine and you can also
create dot something dot something else
dot something else dot something else
and you can go further as well other
thing to notice is that this will not
accept keywords you can see it says else
is not a valid Java identifier because
else is a keyword a reserved keyword in
Java so make sure that you are not using
those reserved keyword names in the in
this particular package name so it can
be test DOT test one dot test two DOT
test three whatever so just make sure
that you are not using keywords here and
you can create the hierarchy now how do
you name them different organizations
and different project teams follow
different naming conventions this is
your area this is fully customizable so
you can write it write it the way you
want it generally what companies do is
they put their domain name from The
Backwards so for example uh google.com
might have a package called com.google
similarly amazon.com might had a package
called com.amazon internally this this
is something which might have been there
but they can they might have chosen
something else but this is sort of the
standard convention that you just
reverse the domain name of your
application and you write the package
name backwards that is the general
convention and after that once you have
written that let's say if you have
written com dot Google this is the top
domain name now after that you specify
what you want to do let's say you you
are implementing a web package then you
can be even more specific okay web
package is a is a huge pack huge package
what is specifically your this package
will be doing inside the web package so
let's say HTML HTML might not be a right
example but let's say some front-end
code front-end auth logic let's say so
now this can be a valid package because
if somebody reads the package they can
understand what would be lying inside
the package this hugely improves
readability and please do spend good
amount of time in naming your packages
right because once you write the code
the code is going to be living for many
many years to come and many other
developers once you leave the
organization many other developers will
be looking at that code and you would
like to make their lives Easy by by
understanding The Code by just looking
at the package name so please name the
package names correctly and once you
have written this package name as for
example in this case front-end auth
logic or let me say frontend dot auth
logic once you have written this package
name as auth logic then make sure that
only the classes which belong to this
particular business requirement are
present inside this package no other
unrelated class should go inside the
package that is something also which
developer have to take care of so this
is again the responsibilities of the
developers that they make sure that
whatever goes inside these this
particular package is only relevant to
the package there's no irrelevant stuff
which should go inside the package again
this is to improve readability
searchability maintainability and tons
of other uh out of the box uh benefits
you get so that is how you create the
packages now let me go back to the
documentation and talk about why would
you use that let's look at some of the
more benefits of it so if you scroll
down in this official documentation you
will find bunch of reasons and benefits
of it first of all you and other
programmers can easily determine that
these types are related because if
something if some classes and some types
are sitting inside a package then there
is an expectation that those classes and
types serve the purpose of that package
only you also it also provides a benefit
that you and other programmers can can
easily find the types that can provide a
particular type of functionality again
the same concept of aggregating simple
single functional classes into these
packages that if you are writing let's
say a banking application and if you if
you have a package called uh interest
rates then everything inside the
calculation of the interest rate and the
specification of the interest rates
should sit inside that particular
package only similarly the names of your
type would not conflict with the type
names in the other packages that is also
a huge benefit of packages that you once
you start writing a particular class
inside a package and if you make that
particular class as private package then
that particular class will be visible
only within the package and you can
again recreate the exact same class with
the exact same name in another package
let me give you an example so if I go to
let's say The Inheritance example here I
have a class called bicycle this is a
bicycle class and if you see
strategically I have not put public here
I have removed the public identifier
here so this class is only visible
within this package called dot
inheritance this particular class will
only be visible in this package to these
other classes now if I go let's say if I
go to Method overriding I have another
bicycle.java here if I open this this is
also a class these two classes are
exactly the same but they don't conflict
with each other because both of them are
package private and they live in
different packages and only those
packages can see them this particular
class is present in this particular
package which ends with DOT method
overriding and this particular class
ends in a package with ends with DOT
inheritance so if I go here let's see if
I go to the main class and if I try to
type bicycle and I put control space you
see I only get the suggestion of this
package private bicycle class which is
sitting inside the method overriding
package itself what if I change this the
visibility of this inheritance package
bicycle class to public let's make it
public and now if I go back to the
method overriding demo which is sitting
in the method overriding package where I
already have a bicycle class and now if
I type bicycle and I do control space I
get two options one is from the local
package and because I have made the
other bicycle class as public I get that
as well as a suggestion and if I import
this one you see now the inheritance
package bicycle class has been imported
in the method overriding package it can
create a lot of confusion that's why it
is always a good practice to work with
the access modifiers really well and try
to restrict the visibility of the
classes to what they should be
accessible at and that's why it's a good
practice to keep the classes within the
package private visibility so that they
are only visible within the package this
will help you in lot of ways
providing any kind of uh any kind of
problems around ambiguity so ambiguity
is a big problem when you have huge
projects with lot of similar class names
so that's all I want to cover in the in
the session of packages and you can
obviously Nest packages within one other
you can go as long as the package name
you want to be just make sure that there
are no keywords in those package names
so that's all for this particular
session let's get started with recursion
in Java so let's first understand what
do we mean by recursion and then we will
look at the details of the class which
you are seeing on your screen so
recursion is the phenomena of an a
method calling itself so so we we have
the scenarios where we call a particular
method or an object right but what if
you have a scenario where a method wants
to call itself now you might be
wondering why a method would call itself
because this will go into an infinite
Loop right if you write a method called
sum and then the sum inside the sum
method you again invoke the sum method
then this will keep running into Loops
till your program goes out of memory I
will show you the example of that as
well but the basic idea is the use case
where if you have a need where the where
the method wants to call itself that is
where you will use the recursion concept
another thing whatever you can achieve
with recursion generally you can achieve
the same output using for Loops as well
but when you reuse it for for Loops it
will require you to write lot of code
recursion will reduce the number of
lines you need to write and manage in
your code but on the other side
recursion can get a bit complex because
it requires an advanced understanding of
how methods actually work in Java so
before I go any further understand that
methods whatever you define inside the
method that goes on to a stack remember
I covered about stacks and it's a leaf
arrangement so whatever you define
inside your method all those variables
and all those statements they go on to a
stack and then the stack gets emptied
one by one executing the statement which
is sitting on the top of the stack that
is the concept of the method execution
that under the hood it is using a stack
now when we talk about the recursion it
also follows the same stack insertion
and stack item removal concept that how
do you insert elements into the stack
and how do you remove them so we are
going to walk through an example of
recursion with the help of a use case
called factorial now if you if you have
studied about factorial in your in your
school classes you might remember that
factorial is a way where let's say if I
have to calculate the factorial of 10
then it would be 10 into the factorial
of 9 into the factorial of 8 into the
factorial of 7 so you see I am repeating
the concept of calculating the factorial
again and again first I am calculating
the factorial of 10 in 10 into factorial
of 9 then I say 9 into factorial of 8
then I say 8 into factorial of 7 then I
say 7 into a factorial of 6 and so for
and so forth so this is the concept of
how do you calculate factorials another
example where you can use recursion is a
Fibonacci series so when we talk about
the Fibonacci series the basic idea is
that you sum the previous two elements
and that's how you create the next
element then this then you sum the
immediate previous two and you create
the next element so again you perform
the operation of summing the past two
elements again and again to calculate
the next element so you see again you
are repeating the same operation again
and again so try to identify that
particular thing where you have to
repeat the particular operation again
and again on the whole sequence that
would be the use case where you might be
needing to use a recursion concept so
here I have prepared an example for
calculating the factorial of a number so
what you see on your screen is a class
called complex function and then it has
a method called calculate factorial and
inside the method you supply an argument
which is basically a number for which
you want to calculate the factorial so
if you supply 5 a factorial of 5 will be
calculated if you supply 10 a factorial
of 10 will be calculated now the first
thing which you need to do when you
write a recursion function is to know
the exit condition that is probably the
most important concept when you write
recursion you should know when to end
the program if you get it wrong then
your program will start will be stuck
into an infinite Loop and it will only
exit when there would be a stack
Overflow basically there will not be
enough memory inside the jvm to run your
program it will crash technically so
remember always to define a exit
condition some people also call it as a
base condition but remember the base
case or base condition or the exit
condition either of the terms can be
used interchangeably but always remember
to First Define the base condition so
here when do you end calculating the
factorial you know the factorial of 1 is
1 and it cannot go any further so that
would be your base condition that once
if if you if you encounter a scenario
where somebody inputs one as an argument
then you simply return one because the
factorial of 1 will be one so this is
your base case this is what is going to
make sure that your program exits
smoothly if you get it wrong your
program will never end it will go into
an endless mode then in the else
condition you write the factorial logic
based on the recursion so like I said
what does a factorial function does is
if you calculate the factorial of 5 then
it would be 5 into factorial of 4 4 into
factorial of 3 3 into factorial of 2 2
into factorial of 1 and that's when it
will end so here I'm saying let's say if
n was 5 so you say 5 into you again call
back the same function 5 into calculate
factorial of 5 minus 1 so now again the
function will be invoked with an N equal
to 4 it will go here this condition will
not be met because n is 4 it will goes
to the else block again the same thing
will happen 4 into calculate factorial
of 3 so you are again invoking the same
function but this time supplying n as 3
so it will go here n will be supplied as
3 it will again check the base condition
and is still not 3 and still not 1 so it
will go to the else block so 3 into
calculate factorial of 2 it will again
go up and again it will invoke the
calculate factorial method but this time
with n equal to 2 this condition is
still false because n is still 2 it will
go to the else block and it will say 2
into calculate factorial of 1 it will
again go up this time it will invoke
with n equal to 1 and it will go here
and it will satisfy the condition and
that's where your program will have its
first output you remember previous
execution of 5 into factorial 4 into
factorial 3 into factorial 2 did not
result into an output these were the
executions of the method call which were
just going Going On The Stack so you
were just at first you had the calculate
factorial of 5 on the stack on top of it
you had the calculate factorial 4 on the
stack then you had calculate factorial 3
on the stack then you had two and then
you had one but when you had one your
program did uh received or reached any
particular end so that was your first
output once you have your first output
ready then you go back to the previous
one so the first statement has been
popped now you go back to the calculate
factorial of 2 and you calculate that
once you have the output of that then
you go back to calculate factorial of
three and so so you basically unpack the
stack now you basically try to remove
the elements from the stack to visualize
this this is how it will look like that
you first call the factorial five let me
just change the name of it just to make
it look exactly how it will go on the
stack so this is how it is going to go
on the stack so you first you call the
calculate factorial of 5 which in turn
called the the calculate factorial 4
which in turn called calculate factorial
3 calculates factorial 2 calculate
factorial 1 and once you had the
calculate factorial 1 you got the first
output and once you had the first output
then you start unpacking it because you
had the value of the calculate factorial
one so you can say 2 into calculate
factorial once output calculate
factorial once output was 1 so 2 into 1
becomes 2 and this is the output of
calculate factorial 2 right then it goes
to the next step basically this one
sorry this one and calculate factorial 3
was demonstrated as 3 into calculate
factorial of 2 so 3 into calculate
factorial of 2 which is this one two so
this gets replaced here 2 and you get
the output as six now you have this one
also resolved the next one on the stack
was calculate factorial of 4 which was
written as 4 into calculate factorial of
3 so 4 into calculate factorial of 3 is
output so so this function calls output
this function's call output was 6 it
goes back and it says 4 into 6 24 and
you have this one also calculated now
you go to the last statement which was
calculate factorial of 5 which was
written as 5 into calculate factorial of
4 and calculate factorial of 4 has been
already computed as 24 so now you can
simply say 5 into 24 which is the output
of calculate factorial 4 and you get the
output as 120 and this is the final
return statement which will be returned
to you so if you try to understand this
till this particular point you are just
calling function after function after
function with a different value of N and
everything started getting into a result
due to the base condition this was the
base condition and that's why the base
condition is very important now imagine
there was low base condition then this
would never return and it will keep
calling calculate factorial calculate
factorial and it will keep going down
the stairs it will never be able to come
up because because there is no base
condition and that's why base condition
is very important at the same time also
understanding how recursion works is
also very important always remember that
the output of the first execution gets
supplied in the second execution the
output of the second execution gets
supplied in the third execution and
that's how the stack unpacks or empties
itself so here I'm just doing the normal
drill here where I am saying complex
function complex function equal to new
complex function and then calling the
calculate factorial method passing 5 to
8 and then printing the eventual result
and if I run this I get the output as
120 which I just walked you through so
remember how to use the recursion why to
use the recursion how to define the base
condition all of these things will will
be of of very much importance when you
try to implement recursions practice
this a lot recursion is a concept which
takes time to to get used to so practice
many different examples and many
questions of recursion and you will be
more confident about it read more about
this concept in the Java docs look at
different examples on the internet that
will help you build more knowledge
around this and that's all I want to
cover in this particular session and in
the next session we are going to talk
about how do we call methods basically
how the method calling works we will
look at different examples and the pass
by value concept Etc when we look at the
method calling let's get started with
method calling in Java now when it comes
to defining the methods I have been
talking about methods throughout this
particular series and the syntax is
pretty familiar where you first specify
the access modifier then you specify the
return type then you specify the actual
name of the method and after that you
specify all the arguments which this
method is going to accept and inside the
curly braces you do your calculation and
based on the return type you return an
appropriate value we have seen many
examples of it and let me show you a
quick example to just understand the
method Anatomy better and then we will
talk about how do we pass arguments to
methods so in this simple class student
I have some properties I have
Constructor and then I have methods
these all are also simply methods we can
see we have an access modifier which
will decide whether this particular
method should be visible to the outside
world or not you can also either remove
this particular access modifier or make
the method private if you want or you
can also make the method protected if
you want so all of the possibilities are
there and that and what what kind of
access modifier will you keep depends
upon upon your use case so that is the
access modifier and then if your method
is not supposed to return anything then
you would just say void void is the
default keyword in Java which is used
for use cases when you do not want to
return something void just means empty
or nothing so when you have nothing to
return you are going to put void you
cannot skip this if you remove if you
remove this the method signature is not
complete so you have to provide this
there is no way around it so you need to
provide the method return type after
that you provide the name of the method
this is a free text string and you can
name it whatever you want just follow
the camel casing convention where you
start with a small alphabet and for
every new word in the method name you
start with the first letter as capital
after that you put normal braces and you
supply the arguments which this
particular method is going to accept for
example if this method was about
calculating interest then probably you
might Supply the interest rate as the
argument and the principle is the
argument if this method was about
calculating the price of the car then
you might supply all the different
mileage details and the manufacturing
details which would decide the price of
the car so it depends upon what you are
doing and that's how you will understand
what kind of arguments your method is
going to need when you define the
arguments you need to define the data
type of the argument and again a name
which you can give it give it as
anything this is again a free text
string and after that it depends upon
you what kind of logic you want to write
inside the method the basic need for
writing a method is to not do the same
thing again and again at every place if
you have a functionality let's say if I
take the same example if you have to
calculate interest and the interest
calculation logic is required at let's
say 15 different places in your
application then just create a single
method for calculating the interest rate
or the interest and then just reuse that
method again and again at different
points in your application just call
that method that's that's how we use it
so that is the basic idea of creating a
method to keep reusing the functionality
over and over again across all the
different methods in your application
let's take another example of this
particular method because it has a
return statement again I specify our
Public Access modifier I specify the
return type which is string in this case
then I specify a name of the method and
I can also choose not to supply any
argument if the method does not need any
argument to do its computation or to run
its logic if you put a return type any
any other return type then then void
here then you have to provide a return
statement the return statement will be
the last execution step of your method
remember that the return statement will
be the last execution step of your
method execution this has to be provided
if you provide a return type other than
void inside your method in this
particular case this method expects a
string return type which means when I
call get name I should get a result back
which should be of type string then I
need to write a return statement and
return a variable which should be of
string type for example if I just change
this method to say let's say if I say
int I equal to 1 and if I say return I
this is going to give you an error you
see there is a compilation error and if
you hover over the balloon icon it says
cannot convert from int to string it is
trying to convert this particular return
type and trying to match this into this
particular turn type and it's not able
to match into string so you get an error
so it has to exactly match the return
type the data type of the of the return
value which you have put here it has to
match exactly with the with the return
statement variable type if it doesn't
match you are going to get a compilation
error that's the first thing now there
might be scenarios where you have
multiple branches of execution in your
method for example if you have if let's
say if I just use this condition of I
equal to 1 and I write if I equal to
equal to 1 then return let's say a test
string else return the name I'll just
cut this and put it here and we'll
change this to name this is also
possible and this is possible because of
the same statement which I told you
earlier that return statement has to be
the last execution step of your method
execution in this particular method
there are two branches of execution this
is one branch and this is the other
Branch at a particular time either the
if block or the else block is going to
get executed there would never be a case
that both of the blocks get executed in
the same execution cycle it will always
be either this block or this block and
that's why if you use these kind of
statements then you have to provide
return type in each of the branches you
can also do something like this let's
say if I say string return where equal
to null and then I say say Ctrl C Ctrl V
I assign test string to the return where
and then here also I assign name String
to the return where and at the end I say
a single return and I say return where
this is also fine because here I am just
assigning different values in the if
Block in the else block and then just
returning the placeholder variable which
is also absolutely fine so you can use
either of the way the better way is to
return from within the branch itself so
this was a quick tour for you to see how
methods work and what kind of anatomy
method represent now let me just quickly
revert everything which I did here and
bring it back to return name that's good
and now let's talk about the method
calling patterns and how do we call the
methods so for that I have prepared a
class called method calling demo it has
a public static void main method and
here I have just declared a simple
variable I and initialize the value of i
as 1. then I am calling a method which
is named as change value and if you go
to this particular method it has a very
simple implementation it is accepting
the argument which I created here I'm
passing this particular variable as an
argument to this method and then
whatever argument I Supply I am
incrementing that argument by one and
just return and and not returning
anything from here just incrementing the
value of I and that's it and after that
I'm printing I so what would be your
guess here what would be the value here
I'm going to pause here for a moment and
to let you think about what is going to
happen okay I hope you have you would
have done some calculations in your head
to see what is going to happen and what
is the value of I eventually at line
eight let's run this program to
understand that okay so I had initialize
I as1 then I passed the value of IE in
this particular argument and I said I
equal to I plus 1 so it should be 1 plus
1 equal to 2 and I the new value of I
should be 2 but at line 8 I still get I
as 1 why is that happening it's
happening because of the concept of pass
by value remember that concept that in
Java every argument which you pass to a
method is passed by value and not by
reference in simple language what does
it mean is that when you pass this
particular argument a copy of this
particular argument is a copy of this
particular variable is passed to the
method argument it's not the exact same
variable we are not passing the same
reference of I here we are passing a
copy of it a unique local copy of it
that's why whatever you do with I inside
this particular method is not going to
change the state of I which is defined
here because it is passed by value or
since simple language the object is
copied over locally to the method it's
not the same reference which is being
passed upon that's why you see this
value if you want to get the return
value then the one way is to just change
the return type and say return on I and
then just store this return I value here
saying end result equal to whatever is
returned from here and we are returning
the new I here and then you can print
the result and you will get two if I run
this now I get is2 so this is to just to
validate that this everything in Java is
passed by value there is no concept of
pass by reference when we talk about
method calling in Java let's take a more
complicated example this was a simple
variable let's go back to the
student.java so I have the student class
here let's create some objects of it and
try to follow the same pattern so here I
have created an object of the student
class named John age 25 address 23 East
California I am doing some Swiss outs
which are not really important here but
let me just uncomment this particular
method so here what I'm doing is I'm
calling a method I'm basically defining
a method which says change name in the
same object and I'm supplying find the
student object so the student object
gets here and then I'm overwriting the
name in the student object that's what
I'm doing here so now let's just call
this particular method and see what
happens so I'm going to call this
particular method here and pass the
object John inside it and then let's try
to print the name of the object
referenced by John if I say get name so
I'm calling this particular method
passing the uh John object here where
I'm overwriting the name John with Jane
and then I'm printing the new name of
the John object let's see what happens
now so if I run this particular program
yes I can see that the name has been
overwritten from John to Jane now this
happened because you passed the
reference pointed to the object inside
the method and then you overwrote the
name in uh on the object which was point
by this particular reference so here you
might think that this is passed by
reference but this is still passed by
value because this reference is not the
same reference as this one this is a
different reference but both references
are pointing to the same object that is
the only commonality here so you can
mutate a particular object inside a
method and be very careful of that do
not ever try to do that because it is
going to create lot of unpredictable
results for you because it might be
possible that you are calling a
particular method from some other
application which is doing lot of
changes in the same argument object
which is supplied and then you don't
know what is the state of it so it's a
very dangerous pattern and very
dangerous way to mutate the objects do
not do this let's find another way to
deal with this problem if I don't want
to mutate the same object how do I solve
that problem so we can solve that
problem simply by creating a new object
and changing whatever we want to change
so I have one more method here which
says change name in a different object
it is also accepting the student object
and then here it is creating a new
student object and here it is
overwriting the name but getting the age
and the address as the same values from
the argument so we keep the age and the
address same but we create a new name
but we don't override the same object we
create a new object and then we can
return this particular new object if we
want to I can do click this and I can
say return new student and then I can
store the value of this particular
method calling I can call this method
here Supply the same argument as John
let me comment this one and then I can
store the value of the result student
result obj
and I get the value here and then I can
say result obj dot get name and if I run
this program now remember I'm calling a
different method now which is going to
create a new object and then change the
value I do get the same effect but now
my previous object John is not touched
at all it is safe and sound I can reuse
this John object anywhere in my method
in my application and I can be assured
that nothing is changing in terms of the
state of the object so always follow
this particular pattern whenever you are
calling methods and passing arguments to
the method and if those arguments happen
to be your custom classes and even
Java's classes in fact then always try
to create a new copy of the object
inside the method if you intend to
mutate or change the state of the object
let's get started with today's topic
which is about exceptions in Java let's
first understand what are exceptions and
why do we actually need this concept the
simple reason for having exceptions
existence is that developers make make
mistake we do create bugs and errors
while we write code it's natural it
always happens that whenever you write
code you might miss out some condition
or the other which creates a bug in the
application which creates a defect in
the application and then the testing
team finds that defect and then we fix
that defect and that's how a normal
software development life cycle works so
to handle those kind of exceptions and
errors every programming language
provides their own exception and error
framework to support the developer in
spotting those errors and fixing those
errors and handling those errors instead
and Java also provides its own exception
framework so what you see on the screen
right now is basically the a snapshot of
the exception framework of java and you
see it has a long hierarchy of different
classes here this is also an inheritance
hierarchy just to give you context and
the whole exception framework hierarchy
starts with a class called throwable so
throwable is is the class which is the
root or the parent class of handling all
types of exceptions and errors and
that's where the next differentiation
comes exceptions and errors Java treats
these two things differently and I will
go in detail as to what is an exception
and what is an error but let's first
understand the hierarchy further under
the exception hierarchy you see some
exceptions like IO exceptions which is
an exception which comes when something
goes wrong in the file writing or file
reading or the file handling operations
then you have SQL exception which comes
whenever you are talking to the database
writing SQL queries and something goes
wrong you also have class not found
exception which comes when a class is
not found in the in the runtime or in
the OR at the time when the class is
being loaded in the jvm and then you
have also runtime exceptions which are
like arithmetic number format and there
are a lot and lots more of this type of
exceptions as well on the right hand
side you have the error type and then
you have some errors like jvm error when
memory error and framework error so now
coming to the differentiation between
exception and error exception is a type
of problem which can be recovered in a
program from which the program can be
recovered which the developers should
handle so exception is a type where the
developer focus is the developer is
responsible to make sure that none of
these exceptions occur in the program
and if these exceptions occur in the
program then the developer has the
responsibility to handle these
exceptions properly we will look at the
examples of how the developer can handle
these exceptions on the right hand side
is the error type where the developer
does not have any control you cannot do
anything if the jvm has an error or if
the underlying memory of the computer or
the jvm memory gets an error or the the
whole framework or the Java itself
Library itself as an error you can't do
anything about that and those are the
kind of problems which go into the
category of error that's why Java has
created these two different categories
one is exceptions which is the
responsibility of the developer and
other is error which are not the
responsibility of the developer and in
fact developer cannot do anything if
this happens so this was a quick tour to
you to what kind of the exception
framework is present in Java do read
about this framework in detail in the
Java docs as well but just to extend
this understanding further we'll have a
look at some examples of the exceptions
and how these exceptions occur so with
that I'm going to switch switch to the
Eclipse IDE and I have created bunch of
classes to show different types of
exceptions so let's go through the first
class which is named as simple exception
demo it has a main method it has a
variable of int type the variable name
is data and what I'm doing here is I'm
dividing 100 by 0. so if you see this
carefully you know that this is going to
result in an infinite value you cannot
divide any number by zero and Java also
prohibits doing the same because it
doesn't make sense to divide anything by
zero so if you run this particular line
if you execute this particular line this
is going to throw a runtime exception
these are the runtime exceptions
remember so let's try to comment rest of
the code and let's quickly try to run
this so I run this program and there you
go I get an exception which says
exception in the thread main main is the
main thread which the exception type is
java.lank.arithmetic exception and this
is the exception type divide by zero and
it will also give you the line number at
which the exception happens if you click
on this it will directly take you to the
exact line at which the exception
happened and this is you know if you see
now this helps the developer a lot this
information which is printed here is
called exception stack trace and you can
look at the stack Trace go to the last
line and this would be the line from
where the exception actually originated
if you click on that particular line it
will take you exactly at the place where
the exception might have occurred and
then you can look at the line fix the
code and rerun the program to see if the
exception is gone that's why I said that
developer has to handle this exception
now as far as handling these exceptions
is concerned I am going to cover that in
the next session but in the in this
particular session we are just going to
focus on the types of exceptions and how
they occur this was an example of
arithmetic exception where we are trying
to divide something by zero let's take
another example let me uncomment this
particular line of code and comment back
this one so here I am creating a string
a but the string is null and null means
nothing it's it's a it's a void
reference it has nothing in it and now
if I try to do some operation on this
particular string so remember a is null
and whenever you are trying to operate
something on a null object Java is going
to throw an exception because you can't
operate on null because null means
nothing empty it it is it is a dummy
thing so you cannot do anything on this
particular null reference and if I run
this program I get an exception which
says null pointer exception java.lang
dot null pointer exception and it will
give you the exact reason cannot invoke
string dot Care at int string dot this
is a string type string dot Care at int
because a is null so it will give you
the exact reason as to why this program
failed and then again if you click on
this particular line it will take you
the exact line where the problem is and
then you can fix the problem maybe you
need to initialize the string properly
to make sure that this error doesn't
occur so these are all the runtime
exceptions which the developer has to
take care of which the developer has to
fix to make sure that the program runs
smoothly if they don't handle it the
program is going to fail and the program
will actually force them to fix because
the program will not run unless they fix
those exceptions now these are the
examples of runtime exceptions you can
all also create these kind of exceptions
which are called checked exceptions
runtime exceptions are also called
unchecked exceptions you might hear this
term as well some some people use the
term runtime exception instead of
unchecked exception and use both of them
interchangeably so runtime exceptions
are also called unchecked exceptions and
these exceptions are called checked
exceptions why do we call them checked
and unchecked is because these
exceptions are something which you do
not have to explicitly specify in your
program in this program I did not have
to expressly specify this particular
because I don't know if this line of
code is going to result into a null
pointer exception or not but these
exceptions are something which Java will
force you to handle let's look at an
example of this so I have created one
more class which is named as checked
exception demo and I'm doing some file
operations basically reading a file
writing to a file Etc I'm using some
classes of java named as file reader and
some methods like read line and close
and if you see the moment I'm trying to
read a file this line has a has a red
marker there's a compilation error if
you scroll over it it says unhandled
exception type file not found exception
so Java is forcing you to handle this
error this particular exception because
file not found is a checked exception so
if your expression your line of code is
throwing a checked exception then Java
will force you to do something about it
it will not compile the code until you
either handle this exception or you read
through this exception again how do we
handle this is something which we will
cover in the next session but you can
you can always rethrow this exception
but you have to do something about it
you cannot just skip it so what I can do
if I don't want to handle this is I will
pass on the responsibility of handling
this exception to the quali program so
whoever is going to call this main
method has responsibility now to handle
the file not found exception because I
have just thrown it I've just passed it
on I've just passed my responsibility to
the colleague and you can do similar
thing here as well if I go here you see
it says unhandled type exception IO
exception and if you remember IO
exception is here it is a checked
exception so I can do one more throws
here comma V and now if I just resolve
the import whoever is calling the mail
method has the responsibility of
handling the file not found or IO
exception you can also handle it like I
said or you can just add throws Clause
to the method signature and then the
caller has the responsibility to fix or
handle the exception so this is how the
checked exceptions work remember in the
unchecked exception in the runtime
exception we we can see that these two
lines do through exceptions but there is
no forced Way by Java to tell us that I
have to fix it because Java doesn't care
about unchecked exceptions at the
compile time it will only encounter
those runtime exceptions at the runtime
that's why they are called runtime
exceptions but checked exceptions are
compiled time exceptions and you have to
fix them handle them or throw them right
at the time of compiling the code so
that was about checked exception now
there's also a possibility that you can
create your own exception if you want to
so for that I've just created a very
simple class here called my exception
and the way you create your own custom
exception is by just extending your
class with exception class you just
write this extends exception and you can
write a default Constructor or a
parameterized Constructor whichever
makes sense for you and this is your
exception class ready to use and you can
just invoke this exception explicitly
remember whenever you are creating your
custom exception It Is by default a
check exception so your program has to
handle it for example if I go back to
this particular class and if I do this
let me just comment all of this code now
and remove the throws Claus as as well
so if I go here and I'm saying through
new my exception my exception was my
class so I'm explicitly throwing an
exception which was my custom exception
and I again get the error if I hover
over it it says unhandled exception type
my exception so I have to handle this
exception or I can just throw this
exception and let the caller handle it
so this also works so this basically
builds our understanding that broadly
there are three different types of
exceptions which we work with there is a
runtime exception which is also called
unchecked exception which happens
because of developers mistakes in the
program like this one then there is a
checked exception which developer might
not be responsible for creating the
exception but developer has to handle it
and there are some classes in Java which
throw those checked exceptions like file
not found exception and I O exception
whenever you are working with file
handling operations Java will force you
to handle those checked exceptions or
read through those checked exception
using the throws Clause similarly the
third type is when you create your
custom exception type and custom
exception types are also checked
exceptions by default and whenever you
are explicitly throwing your own custom
exceptions you again have to either
handle the exception within your
enclosing code or you can just read
through the exception and let the caller
handle it so this is a quick tour of
different types of exception and
including this exception hierarchy let's
get started with exception handling in
Java using try and catch blocks so in
the previous session we had a look at
the scenarios where an exception can
occur how do we see that there's a
runtime exception or there's a checked
exception or there's an unchecked
exception or there is a custom exception
now we did not talk about how to handle
those exceptions and now we are going to
focus on the handling part so whenever
you have to handle those exceptions the
way Java provides for that is using the
try catch block
so try catch block is basically a bunch
of syntax which you have to follow to
handle different types of exceptions in
your programming code
and the syntax of the try catch block is
pretty straightforward you write try and
you put curly braces and then you write
whatever code
which might throw an exception you don't
know that but it's always safer to
enclose your code in a try catch block
so that you know that if an exception
occurs in the try block then you can
handle it in the catch block so it's a
it's always considered a better practice
to enclose your application code in a
try catch block so that you can handle
the exceptions so you put this try block
and write write all the suspicious or
non-suspicious code which may or may not
throw an exception inside the try block
once you have done the try block part
then comes the catch block part
so let me go to the catch block
so this is how the syntax look like once
you have written the try block then you
write catch and you put braces and you
write the exception type which this
block of code might throw or the
exception type which you are interested
in catching you might not be interested
in catching all the different exceptions
but only a few Ones based on your
business requirements so whatever
exception type you want to catch you are
going to catch it like this
and if an exception occurs in the try
code let's say you have specified an
arithmetic exception here and if any
line of code in the dry block throws an
arithmetic exception then this catch
block is going to catch that exception
and then inside these curly braces you
can decide what to do with that
exception whether you want to log that
exception or whether you want to read
through that exception whether you want
to embed some error code or get an error
code out of it or convert that exception
into a business or custom exception of
your own choice so it's up to you what
you want to do with that but catch block
will be able to catch that arithmetic
exception
similarly you can specify as many
exception types to be caught as you want
and keep adding more and more catch
blocks
remember that these catch blocks work in
a in a sequential fashion so if an
exception occurs here it will first go
to this particular block to match the
exception type if it didn't match then
only it will move to the second type if
it did match the first type it is not
going to execute the second type so that
is how the try catch block work
you can see an example here that if the
code here is throwing an index out of
bond exception then it is going to be
caught here and we are just printing the
index out of one exceptions message if
it is throwing an IO exception then I
can do this so you can keep adding
different checked and unchecked
exceptions in the catch block
you can also catch more than one type of
exception with one exception Handler so
rather than writing these multiple catch
Blocks individually you can combine
these exceptions together if your logic
of processing both of these exceptions
is the same
remember if the logic of processing
these two exceptions is the same logic
means whatever you write inside these
curly braces so if that code is going to
be the same for both of these exceptions
then why bother writing two catch blocks
just write one catch block like this use
the pipe operator to separate different
types of exceptions and write the common
code which is going to be applied if
your try block is going to through an IO
exception or an SQL exception
so that depends upon you
that's the second piece the third piece
of the try block is the finally block so
we talked about the try block we talked
about the catch block now there's a
finally block as well remember this is
finally and not final
the finally block is used
together with the try catch block when
you want to perform some cleanup
operations
imagine you are opening up a file
Handler
in the try block you're doing something
with it and then you want to just close
the file Handler irrespective of the
fact if there was an exception in the
try block or not because even if there
was an exception the file Handler
resource is going to remain open and is
going to consume memory in your
application you might you don't want to
do that similarly if you opened a
database connection inside your try
block
irrespective of the fact of what happens
in the try block you always would like
to close the database connection and you
can write that closing code in the
finally block that's the purpose of the
finally block that you can write the
code inside the filey block which is
supposed to be always executed
irrespective of the fact whether an
exception occurs or doesn't occur
so now we have built a good
understanding of what is the try catch
what is what is the try blocks catch
block and the final block now if you
just put it all together
this is how it is going to look like
that you write the try block you do
something inside the try block
then you write the catch blocks
after that you write the finally block
you can write the finely block without
the catch block as well remember that if
you do not have any exception to catch
but you have some resources to close or
free up after executing the try block
you can skip the catch block and just
write try finally that is also possible
with that understanding let's switch to
the IDE and let's look at some example
so I have a writer helper class which is
having a method called right list I have
a try block here
and this try block is basically
initializing an error list adding an
item to the error list and then I'm
accessing list dot get one
remember when I added this particular
value let me make it 10 to make it more
understandable when I added 10 to this
particular list this goes to the index 0
position and here I am trying to access
index 1 position which does not have
anything
so in such case it might throw an error
because there is nothing at least not
get one so this is my method where I put
the try block code and then because I
don't want to end up in a position where
I get an index outer Bond exception
index outer bonds exception comes if you
are trying to access an index
which is illegal which is does not
having any value so I'm putting a catch
block and catching the index out of
bound exception and just printing the
message of the exception and then for
just for Simplicity I'm showing a
finally block as well though I do not
have any resource to close here but this
is just to show you how this looks like
in the code
this is just to show you that I'm
putting I'm printing assist out here
this is what my method is and if I go to
the main class the try catch demo class
I'm creating an object of the writer
helper class and calling the right list
method which we just worked through
let's run this program and see what
happens
okay so first I get this statement
saying entering try statement so if I go
here
I call this method the execution goes
inside the try block and I get this is
out which says entering try statement
then I try to access the second element
in the list because the position is one
this is going to index 0 and I'm trying
to access index 1 there is nothing at
index 1 so I get an error saying index
out of bounds exception index 1 out of
bounds for length 1.
because the total length of the list
currently is one because there's just
one element and that one element is
sitting at 0 and not one
so I get the exception which is the
index outer Bond exception but the index
outer Bond exception is caught by my
catch block and the system dot error dot
println is something which gets executed
and I get this particular
line this particular line
from this line number 17 and then
irrespective of the fact whether an
exception occurred or not my final block
always gets executed
let's fix this and see if the finely
block gets executed even if there is no
exception so now accessing get 0 and
let's see what happens
yep I access the element 10 no exception
but the finally block still gets
executed so this is to assert our
understanding that the finally block
will always be executed irrespective of
the fact whether there was an exception
or there wasn't
now you can also Nest different try
blocks if you want to let's look at an
example where I have multiple dry blocks
so you can initi you can write a try
within a try within a try if you want
and you can go as deep as you want but
remember the more indentations the more
hierarchy you create the program is
going to get more and more complex so
always remember to have that kind of
trade-off
so I write multiple try blocks I
initialize an array I print added 10
obviously array 10 does not exist
because this array has just four
elements so this is bound to through an
index out of bound exception and I'm
catching that exception immediately in
the catch block this is the exception
printing assists out and just to read
through in the exception you can also
read through the Exception by just using
the throw keyword remember this throw is
different from the throws keyword which
comes in the method signature this is
just to throw any exception from your
code
so this is array index outer Bond
exception for this try block
then I have another array index outer
Bond exception for this try block
which starts from here block 2 and then
I have another catch block for the block
one try block
so you can see it is already getting a
bit complicated where I have multiple
hierarchies but you can do that
so this is what is happening in this
particular program now let's try to run
this and see what happens and try to
decipher the output
okay so at first I get this particular
line which says
array index out of bounds exception in
Block 3. what happens here is that this
line gets executed
it throws an array index out of bounds
exception
at line 13 that array index out of
bounds exception is caught which was
generated from this line and then we go
inside the catch block we execute this
is out this is what you see here the
same Swiss out and then we read through
the exception
if we read through the exception the
exception goes to the enclosing try
block the enclosing try block is this
one
there was an exception rethrown from
this try block and now it has gone to
this try block
and now this try block block 2 will try
to see if it can catch this array index
out of bound exception yes we can catch
it so it can so so the block 2 again has
a catch block which catches the array
index out of bound and it prints assist
out here which says exception in Block
2. which we see here and it again
rethrows the exception
and if it rethrows the exception so now
the block 2
now the block 2 is rethrowing the
exception so this whole code
is now rethrowing the exception if this
block 2 is rethrowing the exception it
goes to block one just going one
hierarchy up and then it sees if it can
handle the exception in the catch block
of this block one so yes the block one
try block also had a catch exception
which said array index out of bound E4
and here it just had a sys out so if I
just bring back the output yes we do get
this a particular exception uh printed
here which says array index out of
bounds exception in Block one this is
what you see here
and this is where the exception just
stops going propagated because I'm not
rethrowing the exception from this
particular catch block so that's where
the exception ends the reason you see a
hyperlink here is because the text
the text which I have printed here
exactly matches with the name of the
exception so Java is pretty smart in
that case if you use the exact same name
exception it will link it to the
matching class name in Java which is
pretty cool I also have a redundant
catch block here which does not have a
try block this is just to show you that
you can write a catch block without a
try block but it doesn't make sense it
is of no use so I can just remove this
particular catch block and the program
still will compile file
so this was a quick demo to show you how
you can use try catch and finally blocks
and when would you use the finally block
and if you want you can use a nested
hierarchy of try blocks and you can
rethrow the exception from within the
catch block only to be caught in the
outside or the outer or the enclosing
block so this is all I want to cover in
this particular session let's get
started with equals and hash code in
Java
this is probably one of the most
important and interesting Concept in
Java and extremely extremely popular
when it comes to Java interview
questions so let's cover this in detail
to understand why we need equals and
hash code and what equals and hash code
is all about let's first understand the
object class of java remember I'm
calling it an object class and not just
an object
object is a class as well in Java and it
is the super super class of any class
you create in Java so anything you do in
Java any class you create it will
automatically be inherited by the object
class object class is the super class of
any class created in Java and if you
look at this documentation and if you
come here you will see that object class
defines this equals method which
indicates whether some other object is
equal to this one or not and it also
defines a hash code method which returns
a hash code value for the object
so let's understand both of them one by
one
first of all let's establish that this
these methods have their concrete
implementations available inside the
object class
but how do you do that and how do how
does it come into effect
remember when we talked about hash set
and I said that hash set will maintain
uniqueness automatically
how does it maintain uniqueness
automatically
it is because of the equals method
implementation which it inherits from
the object class
that's how it maintains uniqueness and
if you remember I also told that you can
do you can maintain uniqueness in a hash
set if it's a built-in data type like
integer or string or float or double Etc
but what if you are trying to create a
hash set of student objects then Java
does not know how to perform equality on
two student objects because student is a
custom object Java doesn't know how to
run equality and that's where equals and
hash code comes into picture so the
contract is that whenever you are
creating your own custom objects and you
have a need to perform equality on those
objects you must override the equals
method in your own class you have to
override that if you do not override
that then two student objects will be
compared based on the reference and not
based on the actual object values we
will see all of that with the help of an
example
another thing which says that whenever
you are overriding equals you should
also override hash code method reason is
because hash code is also used in
certain Collections and we will cover
that in a while but let's just focus on
equals first
and let me switch back to the Eclipse
IDE
where I have a student class again it's
a very familiar class which we have
covered in other lectures as well
and I have three different properties
here roll number name and address
I have a Constructor and I have Setters
and getters
now if I go here and I create three
different
objects of the student class
you see I have created three different
objects
the student object has a role number one
name John and the address is the same
one
second object has a role number two
and the name John
and the address is the same as this one
and third one again has a different role
number but the name and address is the
same it's a hypothetical situation
so let's do one thing let's make this
row number as one as well so now these
two student objects are exactly
identical
so what happens if I compare John with
John 2.
by looking at Naked Eyes these two
objects look exactly the same so John
equals John 2 should return true
let's run this program
but we get false the reason we get false
is because the default implementation of
equals is being run on the on comparing
the student objects because Java still
does not know how to equate these two
objects why you are getting false
because these two are different
references Java created a new memory
location somewhere and put this object
created a reference down to it then Java
created one more new object in this line
and created a new reference John 2. so
these two different references are
pointing to two different memory
locations of the objects though their
internal values are same but their
memory locations are different
that's why you get this particular value
as false because these are pointing to
two different memory locations and that
brings me to the hash code contract
you need to overwrite the hash code
contract as well along with the equals
to make sure that your equality runs
perfectly
let's go back to the student class and
let's fix this problem because we can
see that these are identical objects you
don't want to store the same student
twice in your database right so you need
to fix this so I go back to the
student.java and I have commented this
equals method and let me uncomment this
now
so what I do that I override
the equals method
and the equals method contract looks
like this where you supply an object
which is an which is a foreign object
and now you need to compare this for an
object with your current object of the
student class which is this
so at first you need to run this
particular condition which says are
these two objects for these two
references that this reference and the
obj reference pointing to the same
object if they are pointing to the same
object then this will return true and
then we will say that the object is that
that equality holds true because both
are pointing to the same object so obj
equals this
if that doesn't hold true if this
doesn't hold true then it moves on to
line 50 and it runs a condition saying
that is obj null or obj dot get class is
not equal to this dot get class
get class is a method which will tell
you the Class Type here we are checking
is the obj class object is of the type
student or not if it's of different type
let's say vehicle or something then then
definitely they will not be equal and we
can directly return false so that's why
I'm checking that it should not be null
or the class types should be matching if
these two conditions are if either of
these conditions are holding true then I
return false and I say that objects are
not equal so I've covered this condition
where both of the references are
pointing to the same object I covered
this condition where the class types
were not matching or the obj itself was
null then then we return false
if we passed all of these sanity checks
then we do the actual comparison
before doing the actual comparison I
need to do this explicit casting so I
cast the obj object into the student
type if you remember that's it this is
how we did this this the casting for
other data types as well
once you have converted this obj into
the student object then you need to
Define your own business logic based on
which you are going to Define uniqueness
so how are you going to uniquely
identify a student in your application
will govern this logic in this
particular example I'm saying that I am
going to identify a unique student based
on its role number so even if two
students have exact same matching
details but if their role numbers are
different then these are two different
objects for me but if two objects have
are having the same roll number and even
if they have a different name and
address I am going to say that those two
objects are duplicate so roll number is
the is the condition on which I'm
defining uniqueness equality and
duplicity
so I Define this and say If the roll
numbers are equal then the object is
equal objects are same basically or
duplicate and if the roll numbers are
different then these two are different
objects
good so far coming back to the main
class so now I have the same roll number
here let me change the name just for fun
and address as well
so I have a different name and a
different address but the roll number is
exactly the same
remember we have defined the equality
condition based on the roll number and
here we are comparing if John is equal
to John 2 or not
so let's run this program
foreign
the reason I get true is because this
equals method is is used
to run this equals comparison
so this establishes how we can use the
equals contract to maintain uniqueness
now I also said that whenever you have
you are defining the equals method you
also have to override the hashcode
method and to understand why do we need
hash code as well let's go back to how
hash Map works remember in the hash map
or let's say even hash set in the hash
set you have to maintain uniqueness now
Java maintains uniqueness using both
equals and hash code
hash code is nothing but a memory bucket
in the in Java's memory where your
object is stored it's basically a memory
location
so every object has a hash code and that
hash code is the actual memory footprint
where the object is stored
and whenever you are dealing with hash
set or hash Maps you will be required to
override both of these methods let's
understand how this works so if you have
a hash set and you are trying to insert
an element then first Java will use your
equals method definition to check if an
object similar to the object being
inserted is already present in the hash
set or not
if it finds an object it will basically
flag that this is a duplicate object and
it will not insert it
let's understand how an object is
fetched from hash set let me open a hash
set example just to give you some sort
of a visual representation of what I'm
talking about
so if I go to my hash set example in
in the collections package somewhere
and let's open a hash set demo plus yeah
so when we were doing these insertions
though this is this was a string object
so it was the Java already knew how to
use the equals and hash code of it but
if it was a student object and you were
doing multiple ad and then when you were
actually fetching the element or you
were doing the contains then how does it
work is basically first it is going to
calculate the hash code of the object
let's say you're saying hash set dot get
b or hash set dot get john1 then it is
going to calculate the hash code
of your John 1 object
hash code is your memory footprint and
hash code and the way it is going to
calculate the hash code is going to be
based on the definition which you have
provided
so the definition which you have
provided this hash code will be run to
calculate the memory footprint and then
that particular memory Java will go to
that particular memory footprint and see
if there is an object present there or
not
now Java has a memory location right and
there can be multiple objects stored at
that particular memory location this is
possible in Java so if there are
multiple objects present in that
particular memory location which was
calculated based on the your hash code
implementation then Java is going to run
the equals method to find the exact
matching object
so just to try to visualize this if I
try to visualize this let's say you have
this memory locations
and let's say your hash code came up to
memory location 2. and then at two
memory location
you had multiple objects obj1
obj2
obj3 Etc this is possible
multiple objects can point to the same
memory location so if this happens then
Java is going to use the equals contract
to compare your Join one object with
obj1 with obj2 and with obj3
this is where the equals will come into
use so you see the both hash code and
equals are being used here to point to
the right memory location and that's why
I said that hash set and hash maps are
where equals and hash code will come in
full force where you will be required to
implement this and it's a good practice
to always override the equals and hash
code in your application whenever you
are creating classes the reason is that
you don't know when and where these
classes will be stored into a hashtag
collection or a hashmap collection so
it's always a good idea to have equals
and hash code being implemented and when
you implement hash code the rule the
thumb rule is that you should use the
same parameters which have been used in
the equals contract in the hash code
contract as well the reason for that is
what if you used here let's say you use
name here and you use role number here
then two different properties are being
used to
find memory location and uni and the
uniqueness and remember this logic which
I just gave you here both hash code and
equals are working together to find the
right object so if you are going if you
make any mistakes in defining the equals
and hash code or if you made any mistake
in defining the Symmetry between equals
and hash code then you may get
unpredictable results
how you define your hash code up to you
but make sure to use the same properties
which you have used to define the
equality always keep this consistent to
avoid any unexpected results
you can also do this just say return one
and every and what happens what will
happen that when you use this particular
student class in a hash set all the
objects are going to be stored at a
single memory location
and then this particular situation will
occur where you will have a single
memory location and all of your objects
will be present at that memory location
and when you are trying to fetch
anything
the hash code will always point to the
same memory location and then equals
will make sure to find out the right
object you are trying to fetch from the
hash set
so this is all about equals in hash code
which I wanted to cover in this
particular lecture do read about this in
detail there are tons of article
available on this particular concept
because this is a very important and
popular concept both from implementation
perspective and from interview
perspective and that's all we are going
to cover in this particular session
let's get started with comparable in
Java and before we go there let's
understand why do we need comparable the
need for comparable comes from the
requirement whenever you have to sort
your collections so to understand that
let's move over to the Java docs to
understand how this works
so the basic idea is that you want to
sort your collection and to do that Java
provides you with a method called
collections dot sort you just provide
you just Supply your list or your
collection inside the sort method and
all the elements or objects inside your
collection will be sorted based on the
natural sorted ordering
this holds true for built-in data types
but what if your list is of type student
objects then again the same constraint
applies that Java does not know how to
sort student objects it knows how to
sort strings and hints and floats and
doubles because those are built-in data
types but student is a custom type and
Java doesn't know how to sort it and to
solve that problem Java provides an
interface called comparable
so comparable is the interface which you
need to implement from your class
whenever you have a need to sort your
objects or of your class type
so this is the interface which your
class needs to implement this interface
provides a single method which says
compared to
and it provides the foreign object and
then you need to compare this for an
object with your current object
so let's go back to the Java class and
understand how do we work with this
comparable interface
so again I have used the student class
for the sake of continuity and I have
the same properties as roll number name
and age but this time I say implements
comparable of type student this is a
generics type we are we will be covering
generics in a bit more detail in this
whole in this whole series but the basic
idea is that to Define that this
comparable interface will only work for
student types you define the type in
this particular construct which we also
call as generic type
so you do this and the moment you do
this Java will force you to provide the
implementation of the compare to method
which I have provided here
so the way this implementation works is
you have a foreign object here but this
time this for an object since I have
defined this as of type student so if
you the moment you do this Java will ask
you to override this method and using
Eclipse IDE if you override this then
you will get this signature
automatically let me show you this how
this works
so if you do this you will get an error
here and if you click on this balloon it
will say add unimplemented methods if
you double click on this
you will see a compared to
implementation here
and this is exactly the skeleton which
you see here by default it says return 0
but I'll just come back to that in a
while
so this is how this method came up here
and once you have the signature
available then you need to provide your
implementation on how do you want to
sort the objects
remember you need to Define your your
logic here so again I would like to sort
my students based on the roll number
which is the natural sorting order for
me for the student objects so this is
your custom sorting logic which you
which you can call As Natural custom
logic sorting order for your student
objects so I want to sort them based on
Roll number but you see I've done a
strange thing here I've done a minus
here so what I'm doing is that the
current object's roll number minus the
foreign objects
roll number so if this value
comes as a positive number then this
this object is going to take priority
this is going to be sitting before the
student
if this result returns in a negative
value then this object will come first
and
this will come second so the student
object will come first and this object
the current object will come second
and if this returns 0 then it means both
of the objects deserve the same priority
or the same order priority and any one
of them can come after the other so the
basic idea is that if this return if
this results in greater than zero then
the current object is going to take
precedence
if this is going to return in a negative
value then the foreign object which you
are supplying here is going to take
precedence and if this returns in 0 then
any one of them can take precedence
so you need to Define your compared to
logic in the compared to override
implementation
once you have done that let's understand
this with the help of an example I have
created a comparable demo class which
has a public static void main method and
I create an error list and I create
three different student objects
first student object is named as John
second is Gene and third is Tom
the first has a roll number of three
so John has a three row number of three
Jane has a roll number of 1 and Tom has
a roll number of two so if my compared
to logic runs perfectly then Jane should
be coming first after after I sort this
collection after I add these three
elements into my list and once I sort
this collection then Jane should come
first ROM should come second and John
should come third based on my natural
ordering ordering custom logic which I
have implemented in the compared to
method and that's what I'm doing here
after I have sorted the list I'm just
printing the list by using the for each
construct of the streams API I'm just
printing the name to see which one comes
first and which one comes second
so let's run this program
and this is how it looks like so Jane
comes first because she had a rule
number one
Tom came second because he had a roll
number two and John came third because
his roll number was 3.
so no matter how many times you run this
program you are going to get the
collection in the same sorted sequence
and this is happening because of the
compared to implementation which you
provided here
now if you comment this implementation
let's see what happens and I remove this
implements comparable as well from here
I just create a simple student class and
now I try to run this sort
now you see that you get an error here
and if you hover over this balloon it
says that the method sort in the type
collection is not applicable to the
argument arraylist of student Java does
not know how to sort this so it will
force you to provide a sorted
implementation
and the moment you provide comparable
implementation here
and if you go back to the main class the
error is gone so this also will force
you to provide your comparable
implementation now you can use this
sorting for any kind of collection
sorting as well and whenever you are
doing this always make sure to provide
the compare to implementation and
remember that contract which I gave you
about greater than 0 less than 0 and
equal and that's all I'm gonna cover in
this particular session let's get
started with comparators in Java in the
previous session we talked about
comparable where we said that whenever
we want to implement a naturally
occurring sorting order where you just
say collection dot salt and you sit back
and relax if you have provided they
compare to implementation you would
expect things to work
but what if you have a custom sorting
requirement
let's take a hypothetical scenario where
you created an application and your
application has a student object and you
created a collection of student objects
and now you have different consumer
applications let's say you have a
payroll application you have a
attendance system you have an
examination system you have another
extracurricular activity system and all
of them want to get the student
collection but all of them have
different sorting requirements payroll
wants to have the Sorting based on the
roll number attendants want to have the
Sorting on some other mechanism
extracurricular application want to have
the Sorting on some other mechanism
so how do you implement custom sorting
or multiple sorting Logics for your
collection and that's where comparators
comes into picture
comparator is again an interface as you
can see here in the signature and this
interface provides you the flexibility
to Define your own custom sorting logic
multiple times so you can create
multiple comparator implementations and
each comparator implementation will
focus on a particular sorting order
so that's that's the basic need of
sorting so remember whenever you want to
sort the object in an order other than
natural ordering or ordering or you want
to sort some object that don't Implement
comparable so whenever you have these
kind of conditions always think of
comparator apart from that always think
of comparator when you have to provide
multiple sorting implementations on the
same collection
so let's see how can we do that with the
help of an example
so here again I have the same student
class and I have the same properties
currently by default I have provided a
comparable student implementation which
is exactly the same as we covered last
in the last session
and if we use this particular
implementation uh you we create an
arraylist we created multiple student
objects we added them to the list and we
called sort so what happens if I just
comment the new code and if I just run
this particular code
remember the Sorting is happening on the
roll number so here roll number one Jane
will come first roll number two Tom will
come second and roll number three John
will come third but then you had one
more application which wanted to have
the Sorting based on the age of the
student so these are the age values of
the students and some application wants
you to provide the Sorting
implementation for the age now age is a
custom sorting logic which you need to
provide and whenever you have that kind
of situation create a comparator
how do you create a comparator
like this simply create a class
name your comparator anything
try to end it with the suffix comparator
so that you know that this is a
comparator implementation and then you
say Implements comparator of the Class
Type
this is what you need to do and the
moment you need to you do this it will
force you to override this compare
method
remember the comparable interface
provided compare to method
where you supplied the just the foreign
object
it its name was compared to
Which single object
in comparator the name is just compare
and you have two objects here student
one and student two let me just call
them student one and student 2 for
Simplicity
four one and O2 look a bit weird
so I've just refactored this one and I
will refactor this one as well
so I have student one and student two
and this is an age comparator so I want
to apply the Sorting logic based on age
simply put Whoever has whoever is
younger should come first and whoever is
older should come later in the
collection once I sort it
so let's see how this sorting logic is
implemented
this is a single line code so let me
just put braces around it so that it's
more easily readable you can write it
without braces as well if you have a
single statement inside the if block or
else block
but you can always write it like this
and let me just
format this as well
okay so this is the compare
implementation the first logic which
I've run is saying which says that if
the first student's age is less than the
second student's age then return minus
one
similarly
if the first student's age
is greater than the second student age
then return plus one
and if both of the students age are same
then return 0.
so this is your custom logic and this is
where you need to Define your logic and
remember this will also govern whether
the Sorting is going to be ascending or
descending so for example if you have
provided that student once age is less
than student two's age then return -1
then this is going to maintain the
natural sorting or the ascending order
sorting
now if you want to have a descending
order sorting just change these values
saying that if this is less than return
1 and if it is greater then return -1
and this is going to run the Sorting in
a descending order fashion now so it
depends upon what kind of sorting order
you want and based on that you can
Define the values but the default is
always like this that whenever the first
object's value is less than the second
object value
return minus 1 and if the first object's
value is greater than the second
object's value then return plus 1
otherwise returns 0.
minus 1 means this one this one will get
precedence over this one
so this is how you have provided your
age comparator
going back to the main class and
uncommenting the other part of the code
here I have called the sort method where
I want to sort the list but since I want
to supply a custom sorting operator or a
custom sorting comparator here I need to
provide that comparator object here
so remember the age comparator which you
created here you just need to provide
the comparator you need to tell Java how
to sort this particular list if you do
not tell Java how to sort this Java is
going to look for the comparable
implementation in the student class and
it will sort the student objects based
on the compare to implementation
provided inside the student class
but if you want to have more custom
control over sorting then you need to
tell Java how to do that sorting and if
you see this is an overloaded
representation this is a method
overloading example as well where the
method signature is same but just the
number of arguments are different so
this is how you provide your custom
sorting you supply your comparator now
you can create multiple comparators you
can com create another comparator based
on let's say name you can have one more
property here create one more comparator
so you can have as many comparators as
you want just keep creating them and
keep supplying them individually one by
one in the sort method you can just
duplicate this and add one more
comparator
so this is how you are going to have
more control and if you have multiple
consumer application
call multiple sort methods Supply their
corresponding comparator and you will
get the sorted collection
so here I'm just printing the list based
on the age comparator sorting
and these are the objects so let's see
how this works
and understand the output from the
beginning so the natural sorting order
is something which we have already
covered which was done based on the roll
numbers so Jane comes first
Tom comes second and John comes third
and this is how you get this this
particular output
now coming to the age comparator you
print you print this particular
statement which is coming here and then
you print these values
so let's see how the edge comparator is
working the youngest here is John so
John comes first
then we have Tom who is 20 years old so
Tom comes here and then we have Jane who
is 21 years old and Jane comes in the
last so we can see that our age
comparator has fired here and it has
sorted this in an ascending order
now let's flip the values
I am going to change the values here
and now it should work in a descending
sorting order for the age comparator
so let's run this application again and
now you see Jane comes first who is 21
then Tom comes who is 20 and then John
comes who is 18. so now the age
comparator is working in a descending
order
so this is all I want to cover in this
particular session and in the next
session we are going to have a look at a
project which will cover all the
concepts which we have talked about so
far eager to uncover the world of java
then have a look at Caltech coding
bootcamp by simply learn so hurry up and
enroll Now find the complete course
details from the link in the description
box hello guys this is vikesh and let's
get started with spring Boot and how we
can build a simple application using
spring boot before we go further let's
understand why we need spring Boot and
the basic idea of spring boot is to
build restful web services if you want
to know more about what are restful
services please you can read about the
restful concept as a concept what does
rest stand for but the basic idea is
that if you are accessing anything over
HTTP then that particular component can
be built as a restful component and
spring boot is the most popular choice
for building restful web services today
and even in fact micro Services which
you might have heard about so you can
build microservices which also run on
https using spring boot so what I'm
showing you right now is the official
guide of spring which you can use to
build an application with spring boot it
will list down all the requisites which
you need in terms of the jdk
installations Maven on and how to
complete this guide etc etc you can
again use the same spring initializer
which I talked about in the previous
session you can use this to generate a
spring boot project for you specifically
so all those options are available here
so I've already done that and I am not
going to repeat what I just did in the
previous session and will directly jump
to an IDE where I have created a sample
spring boot application and the
structure here you can see the structure
would look very similar with one change
that in the previous example when we
were dealing with MVC we had an SRC main
resources folder and that SRC main
resources folder was having all the web
components or not the htmls but since in
restful web services you do not render
the HTML but you just send back the
response the response can be the
response body can be pure XML or it can
be pure Json but you do not send back
and View and that's the main difference
between spring MVC and spring boot that
in Spring MVC it will you are required
to return a view technology like in the
in the previous session we sent a die my
lift template which is basically in HTML
you can also return a JSP but with
spring boot you do not deal with the
view technology and that's the world we
are living in today when you write
spring boot you do not have to worry
about how this is going to be rendered
on the web page whether it is going to
be rendered using HTML or what not what
you need to take care of using spring
boot is to return the right response
body the exact text of the response and
that's it so with that in mind the
spring boot was born and the structure
apart from that the structure would look
very similar there's a palm.xml here
which will provide all the list of jars
and dependencies which are required for
this particular project so you can see
all the dependencies here pretty much
the similar ones we have a starter web
we have a starters test and we have a
spring boot Maven plugin and we have an
application file which is the entry
point again having a public static void
main method so you need to put the at
the red spring boot application at the
top of the class to make it an entry
point if you don't do this spring boot
will not run this class and spring boot
will it even not run your application so
what we are doing as part of this
example that we are just printing all
the beans which are provided by Spring
that's all we are doing like I said it's
a very lightweight and the introductory
session so we will keep the Logics to
minimum and I'm just getting all the
beam definitions sorting the beam
definitions and just printing them one
by one how do you get the bean
definition you get that with this
application context class which is
returned when you run the application
and how you run the application is
basically using this line where you say
string application dot run and you
supply application.class with any
command line arguments which you might
want to use once you do this it is going
to return an application context object
to you and the application context
object can be used to get all the beam
definitions by calling this method which
says get bean definition names so that's
the basic logic which is being run in
the main class now we also have a
controller but this time it's not a web
controller but it's a rest controller so
you see in the previous example we just
had written something like this it was
just a pure controller but here we have
become more specific we are saying that
hey this is not a simple MVC controller
but this is a spring boot controller or
technically a rest controller so spring
provides a separate annotation for that
which is ADD iterate rest controller so
you write that particular annotation or
that on the top of the controller class
which you are creating and then you
provide a request mapping similar to
what we did in Spring MVC but while you
return it you do not return a view
technology you just return the raw
response here I'm just returning a
string but you can return a Json object
you can written an XML object or
whatever you want to but not a view
technology that's what I'm doing like
like you can see there's literally
nothing I'm doing in this it's just a
simple string return statement which I
have printed here and that's all the
code I have right now here I just have
these two classes okay so that was all
about what I have written in the project
and now it's time to run the project so
I have just reached to the location on
inside my terminal where the projects
palm.xml was present and if I just do an
LS you will see that there is a palm.xml
available here and all the code
directory is also available here so now
I will just run this application and to
run this app application I'm just going
to type mvn spring hyphen boot colon run
and hit enter once I do that the spring
application is going to Spring boot
application is going to get started and
let's go back to uh the controller and
actually the main app main endpoint and
see what we were doing there I did a sys
out here which said let's inspect the
beans provided by Spring Boot and then I
was printing all the beam names and if I
go back to the output I will see the
same line being written here which was
around let's inspect the beans so you
can see that message which says let's
inspect the beans provided by Spring
Boot and then all the beans which are
available in the application context are
printed here so that's that's the basic
idea which I want to give you that you
can actually build a spring boot
application and you can write your rest
controllers return a string body from it
and once this is run then you can also
run your application for from the web
brow browser as well so let's try to hit
that particular URL which I wrote here
so the URL of hello so for that let
me just open a new Cognito window and
our application is already running so if
I just say HTTP localhost 8080 slash I
get this message here which says
greetings from Spring Boot and this is
the message which we were sending from
the rest controller so this validates
our understanding that we can invoke a
test controller which is a spring boot
rest controller via the same method but
this time we are not getting an HTML but
we are just returning this particular
string now you can use the string in any
ways you want so it depends upon the
consumer so that's all I want to cover
uh as part of the spring boot now spring
boot is a huge huge topic and we can
spend hours and hours talking about
spring boot but since this is more of an
introductory session so I just wanted
the concept to get introduced and
remember the value proposition of why
you would need spring boot the basic
idea is to build restful web services or
build restful microservices that's the
basic idea behind using spring boot in
your applications and also remember the
difference between webmv spring MVC
application and spring boot application
spring MVC is for building web
application spring boot is for building
restful applications which might not
have a web interface integrated with
them at that moment let's get started
with our demo of a project which is
using spring boot to build a restful web
service so a restful web service is
nothing but any endpoint which you can
access or you can consume the data from
via an HTTP layer or via a simply a web
layer because most of the web traffic
which we deal with is built on HTTP so
to take an example if you go to any
website where you sometimes see on the
top right corner you see today's weather
so how is that today's weather coming in
it's coming in Via our rest web service
the a website which you are accessing is
basically hitting an HTTP endpoint which
is uh where the where the weather
application is sitting and it asks for
the weather data and the rest web
application just Returns the data and
that's how the website is able to show
you the current weather so restful web
services are everywhere and they are the
most popular way to build applications
today where you just build your restful
web service and you expose an HTTP URL
and then the consumers need to just
access that HTTP URL to consume the data
from your application and you see this
makes it very easy because there is no
data type restrictions there is no tight
coupling here it's just an HTTP endpoint
so that's the basic idea and we will
look at a project where we will be using
spring boot to build a restful web
service and then we will try to run that
web service to save some data and also
to return some data so here on the on
the package Explorer you see I have
created a project called rest service
and let's just walk through the
structure of it and and then we'll go
into the details of it so we have an SRC
main Java where I have a package and I
have bunch of classes here and before we
go to the classes let's first also
access the dependency file because every
project needs some dependencies some
jars to execute it for example spring
itself is basically a jar so you need to
include the spring jar in your project
so that your project can become a spring
project and there are generally two
dependency tools one is Maven and one is
Gradle in this particular project I am
using Maven dependency tool for
downloading and managing the
dependencies which are needed to run
this project successfully and the way
you will find if it's a maven project or
if it's a Gradle project for a maven
project you will see a file called
pom.xml form.xml and if it's a Gradle
project you will see a DOT griddle file
that's how you can spot whether the
project is using Maven for dependency
management or it is using Gradle for
dependency management so let's open the
pom.xml since it's in XML file it will
be a bit verbose but if you just read it
piece by piece it will become easier to
understand first of all since this is a
spring project I need to include the
parent dependency which brings lot of
good defaults sensible defaults from
Spring boot automatically and this is
the jar name this is the artifact ID
which is spring boot starter parent so
any spring boot project you are starting
do include this parent this parent is
basically bringing all the dependencies
from some other jar and you can make
your project as a as a child of this
particular parent so all the spring boot
projects have this as a parent as a
standard practice after that you provide
your own details in terms of what is the
package name how do you want to see the
jar name on what is the jar actual name
what is the jar version etc etc you also
set the minimum required Java version to
run this application and then you in the
dependency sections you provide all the
jars which you need to run your project
successfully both compile and run your
projects successfully so we added the
spring boot starter web on dependency
which basically brings all the
dependencies around making a controller
or making a repository count the context
component scan all the interesting
features which spring provides get
wrapped up inside the spring boot
starter jar and you can actually go to
the mvn repository and and have a look
at what all classes it provides it's a
lot of classes so I'm just telling you
in a brief that it provides all the
restful functionality then you have the
next dependency as spring boot starter
data jpa which is going to enable this
project to also have a database and if
it has a database then you need Java to
talk to the database and the Way Spring
suggests to talk to the database is via
using the spring boot data JPI Library
we will see this how this Library can be
used but basically this provides ways to
represent your Java object in the
database and then you need to also add
the actual dependency of the database
and in this case we are using an
in-memory H2 database so I'm not using
an external database like MySQL or
Oracle or post SQL because that will
just make more configurations more
complicated I just wanted to keep it
simple and generally you in this H2
database you can easily access by adding
this dependency and it will be an
in-memory database created for you then
I've also added a string boot starter
test here which will be used whenever
you are writing unit tests and you must
write unit test for your project and
then we need to add the plugin so that
spring boot can run this project that's
all I have in the palm.xml now let's
move to the interesting part the Java
section part let's start from the main
class so this is how the main class
looks like where you have you just
create uh any any name with the class
and then you add a public static void
main method inside the public static
white main method you call Spring
application dot run and this run method
is basically going to run your
application and you just provide the
same class name which you just wrote
here so you just say dot class and if
you're supplying any command line
arguments it can interpret that command
line arguments as well if you want so
you would always need an entry point in
an application and this is the entry
point which springboot supports and this
is if you see this code this is just
normal code to make spring be aware
about this class being treated as an
entry point you need to add add the red
spring boot application annotation on
top of the class this is one of The
annotation which is coming directly from
the spring boot Library you can see this
import so once you add this then only
spring will be able to treat this class
as an entry point otherwise spring
doesn't know where to start from so when
you run spring it will fi it will try to
find a class with an annotation spring
boot application and then inside the
class it will try to find a public
storage a static void main method and
once it has found both of them then it
will just run the application so it's
very simple nothing fancy here and what
we are dealing with here is a student
object so we will try to insert the
student object and we will try to
retrieve the student object so if you
ignore these annotations which I've
added it's just a pure pojo it's just a
plain old Java object you create a
student class Let's ignore this field
lesbian for now I'll just come back to
this annotation in this field but this
is just a student class it has three
Fields as name age and address an empty
Constructor and a parameterized
Constructor and some Getters
intentionally I have removed the Setters
because generally whenever you are
building any Enterprise grade
application you would like to keep your
objects immutable means once they have
been created you would not like somebody
to allow to change the values of the
object this just makes programming much
much more easy if you treat all the
objects in your application as immutable
that's why I have not added Setters here
it's just considered a good practice so
apart from the standard things which we
have already seen there are two things
here which I want to talk about let's
first talk about this one so at the rate
entity is The annotation which is coming
from java X persistent entity
persistence entity and this makes spring
boot save this particular object into
the database this is The annotation
which you need to put on your class so
that springboot knows that this class
represents a table in the database so
you need to add this to make sure that
this represents a table second thing a
table will have a ID it will have sort
of a primary key so I've created a new
column called ID which is basically
representing the student's row number or
something or maybe a registration number
and here I'm using couple of more
annotations if you see these annotations
are also coming from java X persistence
library and these annotations will
basically allow the a new ID to be
created every time you create a student
object so you don't have to specify the
value of this ID variable spring boot
will automatically generate a new ID
value every time you create a new
student object and how does it generate
you you can provide the generation type
as well so currently I've just said that
set it as automatic but you can set it
as identity sequence or return or
control by table you can also see the
explanation of each of these here but
I've just kept it as Auto which
basically uh let the persistence
provider pick any appropriate strategy
for the particular database in our case
the database is H2 so that's about the
entity class let's call this as entity
class now let's move to the repository
so you need a repository class like I
explained in those in that three-tier
architecture you always need a dow layer
or a repository layer to store your
student object into the database so we
have enabled the student object to be
saved but we need a Handler which can
save this particular file this
particular object into the database and
the repository classes are the classes
which will allow you to do that so you
create a very simple interface you what
you name whatever you want to name your
interface as and then you say extends
jpa repository the type of the object
and the unique identifier of the object
so the type of the object is student
here and the unique identifier of the
student object is the ID which is of
type long so you need to just Supply the
types type of the object type of the
primary key or the type of the unique
identifier and this annotation is coming
from Spring boot you can see
specifically spring boot data Library
which we added so you just need to
create an interface extend it from JP
repository and make sure that you add
this annotation as well spring heavily
uses the concept of annotations and this
will help spring understand that this is
a repository layer class and it will
apply some more metadata to this class
while this class is running in the jvm
so what happens here we just created an
interface it did not provide any method
to create or any method to delete or any
method to get a student object because
all of that is automatically provided by
springboot via the jpa repository class
if we go inside this class and if you
scroll down you will see the find all
method find all find all by I ID save
all flush save and Flash delete
Etc and if you go further up this also
extends the paging and sorting
repository which provides pagination and
sorting facilities but the interesting
one is that paging and sorting
repository again extends a current
repository and if you go to the credit
repository you will find all the basic
methods to save an entity save multiple
entities find an entity by the ID that's
why it needed that long type to make
sure this that it can execute this
method you can check the existence of an
object find all the entries find all by
ID count them delete them so all the
basic crud functionality so we call them
as crud because the reason it is called
crud because create read update delete
that's the basically the generic acronym
so because uh this credit repository
provides all the methods and their
implementations automatically we do not
need to write any code at all so that's
why spring boot is so awesome and that's
why spring boot is very popular because
it's Z 0 code in the repository and you
still get all the correct functionality
so that's about repository now we have
covered the entity class we have covered
the repository class we have covered the
entry point class now the only thing
which is remaining is the is the end
point the HTTP endpoint which I talked
about and that you can create by
creating any class generally try to
suffix it with the controller so that
your code developers can easily find
this class and make sure that you put at
the red rest controller annotation on
top of it this annotation will allow
spring to treat this particular class as
an endpoint class then you can Auto wire
the student repository so if you
remember I talked about the whole
dependency injection and inversion of
control so here dependency injection is
in action so here you are just telling
student controller to Auto wire the
student repository and now what will
happen that at runtime student
controller or actually spring will
automatically create an object of the
student repository and Supply the that
object of student repository to student
controller so you as developer do not
have to create an object of student
repository explicitly that's the benefit
and that's how the dependency injection
is working because you inverted the
dependencies now the dependency is just
injected into the class and as a
developer you don't have to take control
of creating the objects it's the spring
which will automatically read the Auto
World annotation and will automatically
Supply an object whenever it is required
then I have two methods here since we
are talking about HTTP endpoints so I
have represented a post method here and
a get method here the way you will write
a post method is via at the rate post
mapping annotation and then you can
provide the URL path on which somebody
should call your endpoint to save
something so for example somebody can
call it HTTP localhost 8080 slash
student slash create whenever they hit
that URL the control or that request
will directly hit this particular method
why because you have provided the your
URL mapping here in the post mapping
annotation so since it's a post method
there would be request body what is the
actual request body which the client is
sending and you can represent its
request body with the add direct request
body annotation and you can provide the
type of the request body and here I'm
saying that hey if you want to access
this particular URL yes all good but you
need to supply me with a text
representation of the student object or
a Json representation of the student
object and then I inside the method I'm
calling student repository dot Save
which is going to save the student
object which is coming in so you see
this lot going on here I will I will
show you how the student is represented
in the request body as well and then I
will come back to how it got converted
from Json to to Java but this is how you
can store this particular student object
you can hit this API as many times as
you want and keep inserting a new
student object every time then if you
want to fetch a particular student then
you can do that by supplying the slash
student and and then in the curly braces
there's an ID written here so basically
you can supply the value of the ID of
the student so generally there would be
another method here which would be find
all to see all the students uh and with
their ID and then you can pick a
particular student's ID Supply that
student ID value here dynamically that's
why the curly braces curly braces
supports Dynamic value so here it can
insert One Two Three or whatever the
student ID you want to fetch the value
for you provide that value in the
student slash ID and all good then some
if somebody is hitting the URL with
saying localhost 8080 slash student
slash one then student with the ID 1
will be returned from the request and
you need to put add period get mapping
to make sure that this method is treated
as an HTTP get method and you can
provide the type you can set say get
student and here this Dynamic value is
captured with the add the rate path
variable because you need to know the ID
right whatever ID somebody has supplied
it in the UI URL you need to capture
that IDE and then use that IDE for
calling the repository so that's you can
do that by using the add the red path
variable so here I'm just saying
whatever ID is coming in I will store
that value inside this IDE once I've
done that then I can again call student
repository dot find by ID which is again
a built-in method provided to me by the
credit repository I can supply the ID
and this actually is going to return an
optional object which is uh which is an
object which may or may not contain a
value so it's a just a types a defensive
programming style so this will return an
optional and you can call a get method
to return the actual student object this
will return an optional of student so
option of student means that this
optional object may have a student or
may not have a student why did spring do
that because the ID somebody is
supplying that ID can be invalid also
right so optional object tree and takes
care of that that if there is no student
found then you will not get a null point
exception and if there's a student found
you can return that so it's just a
defensive programming style which spring
has adopted by returning an optional of
the student object rather than directly
the student object but if you're
confident that this particular option of
student object does contain a student
object then just call optional.get which
I've called here which will return the
actual student object sitting inside the
optional object you can read more about
the optional object and its usage from
the official Java docs and there are
tons of examples available on it on
internet so this is about the controller
we have covered all the classes now it's
time to run the application so you go to
the command prompt you go to the
particular file folder location and
there you just say mvn spring hyphen
boot colon run so I just hit enter and
this is going to run the application
it's going to split some logs here and
if everything is fine you will not get
an error and you will just be getting a
message saying that application got
started and it's running on Tomcat look
localhost 8080 with no context URL so
this is not a web application this is a
restful web service right this is a
restful service this is not a web
application so there is no web interface
so how do you access this you just have
an HTTP URL so you can use any of the
rest client available on the internet
there are probably hundreds of different
rest clients available on the internet
you can choose any one of them I am
using Advanced rest client which you can
also install as an extension from the
Chrome browser itself so if you just if
I just open the Chrome browser and I
just say rest client if you just write
this and hit enter you will get many
different options and the first option
you get is from Google Play Store's App
Store so you can go to the App Store
that basically the Chrome web store not
the play store but the Chrome web store
and you can just install this since this
is already installed you can click on
launch app and it will open this
interface for you so this is pretty uh
this is not a tutorial for advanced rest
client so I'll just be quick here you
can choose the method type which you
want to hit so let's say I want to do a
post and then you can provide the URL
here so remember the URL which we put
here in the controller method this has
to exactly match so HTTP localhost slash
student slash create should be the URL
so let me just copy paste this one here
okay so the URL is good here it's a post
type of method which I want to do and I
want to hit this particular URL now I
need to supply the content type and the
body so in the content type you can
choose application Json because I'm
going to supply a Json object and in the
body this is how the Json object looks
like Advanced rest client also provides
a nice visual interface to basically
create this Json if you are thinking
that Json creation is very tough it's
not actually tough It's just curly
braces and then you put key and value
key value comma let me just put an enter
here so that it's more readable so you
just put curly braces starting in end
and then you just put key value you put
a key which is the variable name and the
variables value variable name variable
value and these Keys have to exactly
match the students properties so the
student.java had this name page and
address right so it has to exactly match
otherwise this will request will fail so
this is all good now I can send this
particular request when you click Send
it is going to hit my spring boot
application which is running on
localhost 8080 it is going to call the
student slash create method it is also
going to convert this Json into a Java
object because here I am supplying a
Java object so it will convert the Json
which I'm sending from here to Java
object automatically and it is going to
automatically save it here because I've
called the repository.save method so
let's hit send here once I hit send I
get a 200 okay it means everything went
fine and in the response header I get
the object back because I have returned
the object here you see this save method
is going to return the same student
object which you created uh so
everything is good here my object has
been stored here and now it's time to to
fetch the object so it has already been
saved in the into the H2 in memory
database and you can obviously go and
connect to the in-memory H2 database and
have a look at it but for Simplicity I'm
just going to do this here and let's say
the first object is generally added as
the ID 1 by default by the H2 database
so let's hit this particular URL when I
hit this URL it is going to hit the
student controller here and in the
student controller it is going to hit
the get student method which is having a
student slash ID URL and it is going to
find the database with that ID and if it
finds a student object with that ID it
is going to return that so let's confirm
that now let's hit this particular send
button and it is going to hit a get
request with this particular URL string
boot is going to find if a student with
the id1 exists in its database so once I
hit send I get a 200 OK and you see in
the response headers I get the same
student object back which I added let's
try with two now let's see what happens
I see two and I get 500 internal server
error because there is no object stored
in the H2 database of the spring
application with the id2 yet because we
only inserted one object that's why only
one student object is there and the
first ID which H2 database created for
it automatically was one so when you hit
for get request with a student id1 you
get the object when you put any invalid
value and you hit this you get a 500
internal server error you can also make
it look nice by not sending the 500
internal server error and sending a nice
exception from the back end so from here
you can also send a nice exception that
if this object is not found you can say
something like that or else throw which
is again an optional object and here you
can supply a particular type of
exception which you want to supply
instead of just throwing 500 internal
server error but that's just additional
thing additional defensive programming
you can do you can add more and more
validation and constraints into this
project as you build this project in a
more complex Paradigm so this is
basically what I wanted to show you that
and that we have created a springer boot
application we have connected it to a
database we haven't created also an HTTP
endpoint with student controller we ran
that application we used any random rest
client in my case I used Advanced stress
client and we first did a post request
we provided the exact URL the URL has to
exactly match with the controller URL
and then the body the request body also
has to exactly match with the student
objects property especially the case of
the names have to exactly match so if
this all this matches then you will get
a response back that the object has been
created if you want to fetch the value
of the object you are going to use the
HTTP get method and you again provide a
URL which has to exactly match to some
method in some controller in the spring
boot application which is running on
localhost and if you provide the right
ID you are going to return get a valid
result if you provide an invalid ID
you're going to get a 500 internal
server error and from here on you can
make this controller as robust and as
mature as you want you can add find all
methods you can add update student
method you can add a delete student
method you can have all different kinds
of filters like for example return to me
all the students starting with the name
a or return all the first students with
the rule number one and 100 or between
100 so you can write as many endpoints
as you want and build this application
in as with as much maturity and as much
complexity as you want let's get started
with working through a particular
project using all the concepts which we
have learned so far
so in this session we are going to focus
on a particular project and the project
we are going to focus is is about an ATM
application
so you might have interacted with
different ATM Stores in your cities
where you go in you insert your card you
enter your PIN and then you can view the
balance you can withdraw some amount you
can also deposit some amount from the
ATM so we will try to look at it from
that perspective and and we will see
what kind of different uh Java and oops
Concepts we can use to build such ATM
application this is not a super
versatile application but this is just
to give you the idea of how to use those
oops Concepts to build a simple or a
complex Java application so let's start
from the options menu class because that
will give us the understanding of what
kind of functionality I'm using and here
you will use that I am using different
concepts which I have taught you so far
in this particular series
so for example we are using the io
exception we are using the hashmap class
we are also using the scanner class
which is used to take input from the
command line
so this option menu class is extending
the account class and I will come to the
account class in a while but let's see
what this option menu class is doing
this particular class has uh it is using
a decimal format money format class
which is to denote what kind of format
of money you have
then we have a hash map which is storing
the couple of records of account number
to pin mapping so we create a map and
inside the get login method we add
couple of entries to the map here the
first entry the first integer is
pointing to the customer number
and the second integer is pointing to
the pin of the account of this
particular customer number
so if we call the get login method this
method will insert the data
after that it will ask the customer to
enter the customer number which has to
be one of these two if you provide any
other value then there should be a logic
in the application to reject the input
so whatever a customer number the
customer inputs we pass that inside this
particular method called set customer
number again I will come back to that
and once you have provided a valid
customer number then this method is
going to ask you to enter a PIN number
and remember I told you this is the
customer number to the pin number
mapping so whatever customer number you
select from here you will be providing
the corresponding pin number and again
if you provide an invalid pin number you
will get an error
so that will all happen inside this try
block and if you enter any invalid
characters in the pin number or of the
ATM customer number then you will get an
exception which I am writing inside the
catch block
this is all what we have seen so far
after the successful enter of the
customer number and the pin number I
fetch those values from these two
methods again I will talk about what
these methods are doing and again I'm
doing some basic validation checks but
things get interesting in this method
so what we covered so far was the get
login method let me close this method
here
so we covered the get login method the
second method which is defined in this
particular class is the account type so
here the we will ask the once the
customer has provided the customer
number and the pin number we will ask
the customer to provide the account type
this application supports two different
account types which are checking account
or a savings account so whatever so the
customer has to choose one of them again
we will be taking the input from the
command line using the scanner class
and then I'm using a switch case if the
customer entered one then I will execute
some code for the checking account which
is defined here in the case one
and if the customer entered two then the
case 2 will be executed
and if the if it enters three then I
will exit the application by just
printing assist out
so here I'm using the switch case
construct to provide different options
to the customer
there's also a default case specified
here which says invalid choice
so this is what is happening in the get
account type method
the next method is if the customer has
used the option one
then we call the get checking method
so let's go to the get checking method
which is the next method which is
defined in this particular class so if
the customer has selected a checking
account then we provide the following
functionality to the customer
which is the customer can view the
balance customer can withdraw the funds
customer can deposit the funds to the
checking account or they can just exit
the application
and again I'm using a switch case here
based on the customer types one two
three or four the corresponding case
block will be executed for example if
the customer wants to view the balance
then this block will get executed and I
call the get account type method
if the customer selects the 2 as the
withdraw fund then get checkings with
withdraw input method gets called and
then get account type gets called
similarly if the customer enters 3 then
we deposit the fund and for that also I
have defined a method I will go to the
definition of these methods as we go
along but right now we are just building
the framework
so the get checking deposit input method
will be called to whenever the customer
selects the option three
and for option 4 we just exit the
application
so this is what is happening in the get
checking method
now if from the account selection if the
customer selected second option which
was savings account then we were calling
get saving method
so this is where the get saving method
is defined
and again it is following the exact same
format as we saw in the get checking
method
where we present the following options
like viewing balance withdrawing the
funds and depositing the funds in the
savings account
and I have some methods defined here for
example get saving withdraw input get
saving deposit input
so we Define the switch case here based
on the customers choices here
and that is what is happening in the get
saving method so let me close this
method as well and that's all what is
defined inside the option menu class so
we ask the customer to enter the
customer number the pin number from this
get login method then based on that we
provide the customer the options to
choose the account type whether they can
choose the savings account or the
checking account
and based on that whatever account type
they use we call the get checking or get
saving method and inside this method we
provide the customer the other options
to either withdraw the money deposit the
money or view the balance that is what
is happening inside this option menu
class
now let's go to the account class and
all the methods which we saw here will
be provided a definition in the account
class
you also see this option menu is
extending the accounts class so an
inheritance concept is being used here
let's go to the account class now
so this is the account class where I
have defined some private member
variables like customer number so now
you will be familiar with the customer
number pin number which I just described
and also with the checking balance and
the savings balance
you can also divide this account class
into two child classes where you have a
savings account class and a checking
account class but for Simplicity I've
kept it to one class I am initializing a
scanner input which will be used at
multiple places and then I have the
Setters and Getters for these four
member variables so you see set customer
number get customer number if you
remember this set customer number was
called in the option menu class if I go
back to the get login
once we ask the customer to enter the
customer number we call the set customer
number which gets called here
similarly
we call the set PIN number
which gets called here
similarly once we have said that we then
we were fetching the values using the
get customer number and the get pin
number and that is that is also defined
here in terms of the Getters get pin
number and get customer number
similarly we also have the Getters for
the checking balance and the saving
balance member variables we do not have
the Setters for them because they are
not technically Setters but we have to
calculate the balance it's not a simple
Setter where you can just return the
value
so now let's look at some of the
business functions of the account class
how do you deposit how do you view the
balance how do you withdraw the balance
Etc so you see these two methods
which are specifically when the customer
is trying to withdraw the money from
their account and these methods are
basically called internally by other
methods so we will come to that let's
just understand that we have two methods
for calculating the withdrawal amount or
executing the withdraw transaction
for the checking account account and the
savings account
similarly I have two more methods here
which are calculating the depositing for
the checking account and calculating the
depositing for the savings account
and then we get the the bigger methods
which are using these calculation
methods so I Define four calculation
methods so far calc checking withdraw
calc saving withdrawal calc checking
deposit and calc saving deposit
basically withdrawing and deposit for
both of the classes
and then we have these business
functions called get checking withdraw
input and get saving withdraw input
get checking deposit input and get
saving deposit input so these getter
methods are something which were being
called from the option menu class if you
remember
if you go back to the option menu class
and if you choose the checking account
you get these options and let's say you
chose option two which was withdraw
funds but option 3 which was deposit
funds then the corresponding methods
which were being called were get
checking withdraw input and get checking
deposit input
and this is the exact same method get
checking withdraw input and get checking
deposit input
so if you see what is happening inside
this particular method is couple of sys
outs
then we take the scanner input amount
and we convert that amount to the double
after that we check if the amount which
the customer wants to withdraw is
smaller than the checking balance or not
and I'm running this condition to check
that
if the amount is smaller than the
checking balance then we call the calc
checking withdraw method which was
defined right here
remember I told you that these four calc
methods will be used and this is how
they are used so here I am actually
subtracting the value so whatever amount
the customer wants to withdraw subtract
that from the main balance and then
return the new main balance
that's what you do right if you have
thousand rupees and if you want to
withdraw 500 you subtract 500 from
thousand and then you send back the
remaining balance
so that is what is happening when we
call this method and then we print the
new checking account balance
that is what is happening in the get
checking withdraw input method
similarly if you chose option 3 which
was
depositing funds to the checking account
then get checking deposit input gets
called
and it is defined right here
get checking deposit input and here
instead of subtraction we are doing the
addition
so here I'm again doing a condition
check that the current balance plus the
new amount which has been supplied by
the customer from the command line
the total sum of it should be greater
than zero what if the customer entered
an amount minus 5000 I should not allow
that so that's the reason I'm putting
this condition in place and if the
current balance plus the new amount
which is supposed to be deposited to the
account the sum of it is greater than
zero then call the calc checking deposit
method
and this is where the calc checking
deposit method is present and where I'm
just doing present balance plus the new
amount and returning the new balance
that's all which is being done here
and you will see exactly similar logic
running for the savings account as well
if you look at the get saving withdraw
input which is used to withdraw money
from the savings account so I take the
input from the command line and I run a
condition check that the amount which
the customer wants to withdraw should be
less than the current saving accounts
balance if yes then call calc saving
withdraw method which is defined here
where I subtract the amount from the
current balance and I return the new
balance
and similarly you will see the exact
same functionality in the get saving
deposit where we add the money instead
of subtracting the money
and this is all what is defined in the
account class
so we talked about the option menu class
we talked about the account class and
now we have the ATM class which is the
entry point which basically initializes
the option menu class and calls the get
login method remember get login was the
first method which asked you to provide
the customer number and then get login
called the method to choose the account
type and the account type methods then
called the method to choose the option
to withdraw deposit or exit
so now we have built a fair
understanding of what is happening in
this application so let's run this
application
so I just ran this application and let
me bring the console here it's first
asking for a customer number so I will
go to the option menu class and I will
pick up one of the customer number which
I have hard coded here
so I will provide that customer number
and hit enter
then it asks me for the pin number
so remember you have to provide the
correct pin number corresponding to the
customer number
so I'm taking this pin number just
copying it and pasting it here
then this whole code got executed
and then it called the get account type
and the get account type method provided
you with these options which you see
here on the screen so based on what you
select the case block will get executed
and let's say I want to go for a
checking account so I press one and I
hit enter
once you select the checking account the
case one gets selected and it calls the
get checking method
and the get checking method again
provides you with another menu view
withdraw or deposit or exit
so let's say I want to deposit funds so
I press three
and hit enter
it says the current balance is zero and
enter the amount you want to deposit
let's say I want to deposit 500.
and I hit enter
you get the message saying the new
checking account balance is 500 and you
have successfully deposited the money
and that is what I did for the checking
account
now let's try to withdraw something from
the taking account so you again get back
the same option because inside the get
checking method
we call the once we have successfully
done the business operation we again
call the account type method to display
the menu again to the user
so let's say again select the checking
account class
and this time I want to withdraw the
funds remember I've added 500 there
so let's say I want to withdraw so I
choose the option 2 as the choice
current balance is 500 and it's asking
me the amount you want to withdraw from
the checking account
so I enter let's say 100 and I hit enter
when I do that the new checking account
balance becomes 400 so the 100 got
subtracted from the 500 and the new
balance is shown to your screen
you can do exactly the same thing for
for the savings account as well and
let's also run uh negative condition so
I again select the checking account
and I want to withdraw the funds I
choose the option to
current balance is 400 and I I would
like to withdraw 1000.
what happens
if you do that we get a message saying
balance cannot be negative and this is
coming from the calc checking method
which which is defined here so what is
happening that I wanted to withdraw the
funds from the checking account
and here get checking with the draw
input dot called
here this condition was checked so the
checking balance was
400 and the amount I wanted to withdraw
was 1000 so 400 minus 1000 is not
greater than equal to zero so it jumped
into the else block and it said balance
cannot be negative
so this is how you can also build some
error conditions in your code which are
mandatory and which should be built
otherwise your application will have lot
of bugs we can also exit the application
so if you just type three
and hit enter
you will exit from the application and
will again call the login method where
it will again ask you to enter the
customer number
so this is how you can run this
application and this is this was a
simple use case for you to show how you
can use the different object-oriented
Concepts like classes objects methods
Setters Getters switch case
Etc to build the application with the
correct business logic
and this is all I want to cover in this
particular session and in the next
session we are going to have a look at
another interesting core Java project
just to build our understanding more
better about the core Java concept let's
get started with walking through a code
Java project using all the different
oops concept we have learned so far
so in this example we are going to have
a look at a calculator application and
this calculator application supports
primarily four different operations like
addition subtraction multiplication and
division
so let's see how do we build that app
so in front of me right now is open the
main class
so I have a main app class here which
has a public static void main method and
the first thing we see is a read input
class which is calling a read method
so if you go to the read input class
it has a simple static method here which
is the read method and it is using the
scanner class if you remember I talked
about the scanner class which is used to
take inputs from the command line from
the user
so we initialize the scanner class and
we start taking the inputs and whatever
the user inputs in terms of the
expression let's say the user entered
four plus five or whatever that whole
expression gets sent back into this
input line as a string and that comes
back here in the input expression
once we have captured the input
expression the next thing we do is
divide the input expression in the
numbers and The Operators basically an
expression would be either something
like
4 plus 5
into 3
divided by 2 let's say
let's say the user entered this
expression so this has either numbers
or operators
so that's what we are doing here we are
using the split method of the string API
the string class basically and this
split method is going to split the
numbers and operators into two different
string arrays and here I am providing
the split expression that split at every
time you encounter one of these symbols
so this when you execute this particular
statement it is going to return a
numbers array
which will be created based on this
expression so you will get an array with
4 5 3 and 2 and similarly in the
operator array you are going to split or
pick out the elements every time you
receive a number so this operator array
is going to hold this plus sign this
multiply sign and this divide sign
hope you get the understanding that we
are just splitting the whole expression
into two different arrays where first
array is holding only the numbers and no
mathematical expressions and second
array is just holding the mathematical
operators and no numbers
and we'll see why we need to do that in
the upcoming lines
once I've created this string array I
just want to
store or convert these string arrays
into a queue so I convert this array
into a list by calling the array dot as
list so this expression is going to
return a list and then I'm going to
convert this normal list into a linked
list
and then going to store this linked list
into the queue of numbers
and I'm going to do exactly the same
thing for the operator array as well
converting this into a generic list
converting that generic list into a
linked list
and then storing this linked list as a
queue
so I have an operator's queue and I have
a numbers queue both of them have been
stored into a queue now
and then I am using the pole method if
you remember the pole method of the
queue is used when you want to fetch the
first front element the head element of
the queue so whichever element is
sitting at the head of the queue will be
taken out the moment you call the pole
method so I fetch the first number from
the numbers queue so in this case 4 will
be fetched here
in this variable and after that I run a
loop on the numbers queue and I'm going
to run this particular Loop till this
particular queue is not empty if you see
there's a negation here so I'm going to
pick up numbers one by one from this
numbers queue till the number Q becomes
empty
and inside the loop I do this exact same
pull operation for the operations queue
so this operations queue is holding all
these mathematical operations like plus
star and divide
so I'm going to pick the head of it so
in this case plus will be picked up and
will be stored in this variable called
opr and then I am going to run a switch
case on this opr basically as I told you
in this particular calculator
application we are supporting four
operations which are addition
subtraction multiplication and division
so I Define a case for each of the
mathematical expression
so you see there are four different
cases here and for each case I am
initializing a class if it's a plus sign
then I'm initializing the add class
if it's a minus sign then I'm
initializing the subtractors for
multiplication I have a class called
multiply and for division I have a class
called divide
let's have a look at what these classes
are containing
so if I go to the add class first of all
it is implementing an interface called
operate
and this operate interface has just a
single method called get results which
is accepting a variable argument array
if you remember I told you that you can
also use a where ARG array this is
called a ARG expression this means that
this numbers will be an array of
arbitrary length it can be a one element
array it can be a two element array it
can be a Four Element array or whatever
you supply but it is still going to be a
fixed length array but the length is
going to be dependent upon how much
argument you supply to this particular
method
so that is what this interface operate
is doing it's it just has one method
declared which is called get result
which is accepting an array of numbers
so if the add class is implementing the
operate interface then it has to
override the get result method and here
it is just doing a summation of all the
numbers which have been supplied so if
you supply four numbers it is just going
to add up those four numbers and return
the sum and the exact same kind of logic
or similar logic will be seen in other
operate classes so if I go to the
subtract class it runs the exact same
operation but it subtracts the values
if I go to the multiply class it is also
implementing the operate interface and
in the get result it is just multiplying
all the values
similarly in the Divide class
it is also implementing the operator
interface and it is dividing all the
numbers one by one so it's doing pretty
much the same thing in terms of the
expression and the logic
the only difference is whether you are
using an ad operation or a subtract or
multiply or a divide
so we have checked all these classes and
the operate interface as well and let's
go back to the main app now
now you also see that I've defined a
reference of operate here and each of
the switch case block I am assigning the
object type to this interface reference
so I'm using the concept of dynamic
binding which we talked about when we
talked about interfaces that we can also
do Dynamic binding where we can assign
an object
to an interface type
and the object type will depend upon the
expression
so once we have filled that based on the
case while
filtering out this expression and
picking up plus star and divide
sequentially then we go to the next line
outside the switch case block which is
to pick the next number from the queue
remember we already did one pole here
so as per this example 4 was here in
this rest
and now when we do this number dot pool
again
5 will be picked up because that will be
the next head of the queue so we pick up
5 here and then we call operate dot get
result now this get result will be
called based on the expression which was
encountered first in the queue
again looking at the example the first
expression encountered will be plus
so the expression was plus so the
operator type object is of add type
and when you call operate dot get result
the get result method of add class is
going to get invoked
and it is going to Sum 4 and 5. this
rest is holding 4 right now based on
what I described here numbers dot Pole
and this num is holding the the second
operand basically
basically five here so 4 plus 5 gets
evaluated here in this case and then it
again goes back here and it checks if
the number Q is now empty no it is still
not empty because we still have 3 and 2
left there so again it does the
operations dot pole and it picks up
multiply sign here
then it again runs the switch case since
it's a multiply sign it will go here and
it will initialize the operate interface
reference as the object of multiply
class
then coming here it will do a numbers
dot pole and this time the numbers dot
pole is going to pick up three
so three will be picked up here and then
the current value of result which is
already 9 4 plus 5 was 9 the current
value of result will be updated here so
rest will be 9 here and num will be 3
here and when you call operate dot get
result the multiply classes get result
will get called and it will say 9 into
3. which will become 27
it will again go back here to this
particular line and it will check again
if the numbers queue is now empty no it
is still not empty because we still have
one element left
then it pulls uh the queue of the
operations where the expression divide
is present there which is the only
element left in this particular
operations Q
and since we have the opr value as
divide this case block gets called and
the New Divide class gets initialized
the Divide class basically gets
initialized and we come here and we do
numbers dot Pole now the last number
which is available in this queue is 2
which gets picked up here
and then we again call operate dot get
result this times is the operate object
refer object operate reference type was
of divide class type so when we call
operate dot get result The Divide
operation or the get result method of
the Divide class basically this method
will get invoked and it will divide the
current value of result which was 4 plus
5 9 into 3 which was 27 so it is going
to divide 27 by 2 which was the last
value of the numbers dot pole it is
going to execute 27 by 2 and whatever
value it gets it is going to store a
value back into the rest variable and
then it is again going to go back here
and again going to check the condition
if the numbers Q is not empty but now
the numbers queue is empty because 2 was
the last element so it is going to come
out of the loop and it is going to print
the final result
that is how this whole program is
working
now let's try to see this in action and
we'll try to execute the exact same
expression
so if I right click and go to run as and
run this as Java application
and I Supply an expression saying 4 plus
5
star 3 divide 2.
and if I now hit enter
I get the value as 13.5 which is exactly
what we ran through because 4 plus 5
will be evaluated first which will
result into 9 then 9 into 3 will be 27
and 27 divided by 2 will be 13.5 exactly
so this is how this whole program is
running where we first take the inputs
and then we divide the input into
numbers and operation arrays or in fact
queues and once we have those queues
built up then we pick up the first
number and we keep running this Loop
till the numbers Q is not empty inside
the while loop at each step we pick up
the first expression or the operator we
check what is the operator whether it is
an addition subtraction multiplication
or division operator and whatever kind
of operator we have we initialize the
corresponding class of it and then we
fetch the next value in the numbers
queue and then we call the get result
based on the expression and whatever
result we get from the get result we
store it back into the rest variable so
we keep updating the rest variable at
every step that's the reason the result
of 4 plus 5 gets stored in the rest and
next time you are calling the get result
for a multiply operation here the rest
value is 9 now and it says 9 into 3
again in the next time the rest value
will be updated to 27 because we are
storing the result back into the result
variable
so this is all I want to cover in this
particular session where we looked at an
example of a calculator application
purely from the console standpoint
obviously there can be lots more stuff
which we can do into this particular
application make it more error free and
cover a lot of corner cases like
validating the inputs
Etc also looking at putting some
conditions around the exception handling
handling the divide by zero scenario Etc
which is not here but this is just to
show you the basic idea of how you can
build simple to complex CLI applications
using the core Java Concepts started the
idea of computer programming began in
the year 1948 many languages were
developed in a quest to become better
than their predecessors out of thousands
one stood Valiant facing the test of
time to prove it's the best of all
worlds you're right we are talking about
the Java programming language Java was
introduced in the early 1995s due to its
exceptional features Java managed to
build many operating systems application
software and many more more than 35
percent of developers use Java worldwide
Java has one of the biggest programming
communities resources and online
repositories the minimum salary of a
Java developer in the United States of
America is about two hundred thousand
dollars per annum and in India the
minimum salary of a Java developer is
around 10 to 15 lakhs per annum based on
your experience
if you are one of those aspiring Java
developers came to know the perfect way
that explains how to become a successful
Java developer in 2023 then you are at
the right place you're watching simply
learn and if these are the types of
videos you'd like to watch then hit that
subscribe button and the bell icon to be
notified without further Ado here's how
to become a successful Java developer in
the year 2023 if getting your learning
started is half the battle what if you
could do that for free visit scale up by
simply learn click on the link in the
description to know more
first we begin with the core Java
fundamentals what's better to learn Java
than getting started to code core Java
covers the Java fundamentals like Java
variables data types in Java conditional
statements and Java looping statements
in Java object-oriented programming
paradigms in Java and Java Collections
learning core Java fundamentals will be
a strong foundation for becoming a
successful Java developer you can get
started with core Java tutorial link to
this video proceeding ahead we need to
get started with Advanced Java Advanced
Java programming covers real-time
programming paradigms like error
handling exception handling Java
servlets Java API programming Java
database connection that is the jdbc
Java Enterprise programming which is
Java ee Java Lambda functions junit
testing and much more to clarify
Advanced Java is the most important part
of becoming a Java developer as the
corporate mainly works in the advanced
Java segment of java once you are strong
with the core Java and advanced Java
fundamentals you should start building
your own Java projects there are a wide
variety of java projects you can build
you can get started with core Java
projects to help you lay a stronger
foundation in learning how to work with
Java IDs and build and maintain an
actual project simply learn has code
Java project ideas and complete core
Java project building tutorial to guide
you not just that we also have Java API
programming tutorial Java jdbc
programming along with the top 10
Advanced Java project ideas and a fully
fledged Advanced Java project tutorial
that will help you the actual
programming stage is when you encounter
errors and compile time issues I want
you to know that the help is just around
the corner sign up and join some biggest
and most popular Java communities the
online programming communities will have
top programmers and experts who have
tried and tested solution to multiple
problems including yours communicating
your problems will help you learn new
things and build a better team player
profile that companies are accustomed to
and looking to hire
simply learn has a dedicated team and
Java programming community and multiple
social media platforms like Telegram and
the link to it is in the description box
below proceeding further practice to
enhance your skills and participate in
online boot camps by now you must be the
master of all critical Java Concepts
despite being a programmer comfortable
in Java testing your skills and learning
where you stand makes you a complete
programmer next you can try practicing
your programming skills and answer some
online brain tasing questions many
websites host competitive programming
events based on Java and that can be
resourceful to test your programming
caliber these questions will be prepared
by real-time industry experts and hiring
managers these technical questions will
test your skills to the Limit and
determine how strong are your algorithm
skills
Cold Quest by simply loan has multiple
questions that can help you analyze the
algorithms and devise a perfect solution
finally we must build a resume matching
the recruiter's requirement every
recruiter has a specific requirement
before you apply for a certain job role
I'd recommend you go through the job
description that explains the
requirements in detail ensure you have
all the skills listed and design your
resume in a realistic way that explains
your skill set and experience the
important point is to try to put your
skills and experience aligned to the
recruiter's requirement not just these
let's say you walk into an interview
with a decent portfolio of projects that
align with your recruiting firm explain
to your hiring manager about your
portfolio and say I am working on a
similar project and I'd like to learn
more and add a few inputs from my end
now who would say no to that say simply
learn has a wide spectrum of Open Source
Java projects that can help you learn
the fundamentals of project building
using Java they can also help you build
and manage a dominant Java portfolio
certifications help you get one step
closer to your dream carrier so what are
you waiting for head straight to the
simply learned website to upskill and
get ahead please do let us know if we
need to include any important pointers
and we call it afrap we have come to an
end of the session on how to become a
successful Java developer in 2023 in
conclusion the future of java looks
promising it possesses the caliber to
reshape all the technology sectors and
there is simply no stopping it eager to
uncover the world of java then have a
look at Caltech coding bootcamp by
simply learn so hurry up and enroll Now
find the complete course details from
the link in the description box
[Music]
okay so shall we start
yeah that's right okay so can you give
me a small introduction about yourself
uh so thank you for the opportunity uh
my name is Baba I'm from bhubaneshwar
and I've done my b-tech from computer
science branch I got 7.8 cgp in my
colleges and I got a 78 in my 12th
standard I am regarding technical skills
computer science is present in every
field as everyone knows so I spent the
last four years owning my Technical and
software skills in computer science I've
learned programming in Java C C plus
plus JavaScript which I'm learning right
now I've learned database Technologies
like SQL minusql mongodb I've created
some projects like Library management
quiz app and a calculator and there are
other small projects that are made I
think that they're in my CV actually you
can find the GitHub links for those
their small small projects are there as
well apart from that I think what has
helped me the most is uh participating
in a lot of hackathons both online and
offline it really helped me to you know
be aware of what my peers are learning
and kind of kept me ahead of the curve
so that I can keep myself updated with
technology and apart from technical
skills regarding personal life I have
few Hobbies I love to play football I
love
reading as well and I love watching
science fiction movies in particular so
they think that wraps up everything
about me okay okay so my next question
is what are your long-term goals
uh my long-term goals would be to gain
as much experience as I can in my domain
that is additionally I plan on what I
learned using these initial formative
years from a uh for my next
few years which can help me move into a
more senior position so uh using
previous segments will help me so that
when opportunities come for promotions
or any other opportunities come then I
can make use of it if I use the correct
skills as such having a long-term Vision
in while starting out a career in
corporate can be very helpful so that
you can apply yourself in the right
direction and be aligned with that plan
I think that's my long-term goal as of
now at least okay good can you state the
difference between hard work and smart
work
I really both are necessary in a person
one person needs to understand how when
to use Smart work and when to use hard
work but I think uh what really
differentiates is using less resources
and less time to achieve the same result
by putting more effort in high yielding
activities rather than mindlessly
slaving away I think that's what makes
the distinction between hard work and
smart work more prominent it's like uh I
think there's a quote by Steve Jobs or
something uh no I'm sorry that that
quote is from Bill Gates where he said
that I will find a lazy person to do a
difficult job because he'll find an easy
way to do it
so I think that pretty much sums set up
the difference between hard and smart
work okay good very good uh now let's
start with the technical questions sure
first treat yourself in Java out of 10.
uh I think I rate myself for 6.5 out of
10 in Java
okay okay good now tell me what are jdk
jvm and GRE
please explain about them
sure let me go one by one uh first would
be the jdk which is the Java development
kit software package of jvm and Jr it
contains both it jdk basically provides
the standard edition of the Java
application programming interface
second was jvm which is the Java virtual
machine it's basically converts the
program into byte code which basically
means it converts a user-friendly syntax
to machine language that the machine can
Java machine and The Interpreter can
understand okay
third one will be the JRE which is the
Java runtime environment and it provides
the libraries and the resources for jdk
to execute the Java programs I think
that's the main distinction between
these three yeah right right so uh can
you tell me does Java include pointers
um no Java does not include monitors can
you just please explain
okay so basically the first point of
pointers are the main benefit I would
say would be to uh for uh taking a
memory allocation purposes so Java
already has jvm like you mentioned
before so jvm automatically takes care
of memory allocation so there is no
real-time use case as such and when it
comes to a side benefits or pointers uh
like uh clearing memory because it just
points to a specific memory for clearing
memory Java also has this garbage
collector so all in all there is no
particular use case uh majority of the
cases in Java where we would actually
require a pointer that is not something
already being done by Java right itself
okay so you are saying Java does not use
pointer in real time programming right
correct whatever all those benefits or
pointers that they offer in C Java takes
care of it on its own okay okay good uh
list some Java 8 date and time apis
I think the Three core apis would be the
local date local time and local date
time okay
uh what is the default method and when
does it get used the before method
actually involves an implementation and
it is found and then interface the
method adds new functionalities to an
interface while preserving backward
compiler backward compatibility with the
classes that have already implemented
that particular interface I think that's
a main purpose of our default method
okay okay
uh okay can you mention the main classes
implementing the list interface
first I think the most important will be
the linked list which basically linked
elements with no index and arraylist
which can be indexed then Vector which
is similar to array in some aspects and
it also can be indexed and the fourth
would be a stack stack which follows the
last in first dot methodology of the uh
of data structure
okay you just said uh array can you
explain what is an array
array can be referred to as a collection
of items which are stored in a
continuous memory locations it's it must
contain items of the same data type when
it organizes data in a related set of
values that can easily be sorted
searched manipulated
Etc so basically it helps create a
collection of similarly uh defined
variables uh values in a single array
variable okay so we cannot store any
other data types in Array right yeah all
elements must be of the same data type
there cannot be any mix and match okay
okay good can you explain what is in
linked list
it's kind of similar to array but it
refers to linear data structure in which
the elements are not necessarily stored
in a continuous manner like they are
stored in an array so it's basically a
sequence of nodes with each node
pointing towards the next node then
that's how it forms a chain-like
structure that's how it's different from
an array okay mention the link list
supported by Java
a Java supports to a singly linked list
and W linked list single linked lists
where each node points to uh stores the
data and references to the next node
whereas the W linked list has points to
two different modes which is the one
before it and the one after
these are the only two that are the job
okay good uh can you tell me what is
regretation
what is recursion
you must have read about this
yes recursion would refer to a function
calling itself under a particular
terminating condition follows the last
in first order methodology and it makes
use of the stack
data structure okay now please tell me
which sorting algorithm is best
according to you
uh I don't think any sorting algorithm
can be considered the best there are
many like bubble sort selection sort
balloons or Radix or all those things
are there but I don't think we can turn
any one of them as the best because they
all have different use cases if the if
there would have been a single best
sorting algorithm all of us would be
using only that one right so I don't
think there's particular best they're
fit for the specific type of data
structures where it performs the most
efficiently so no I don't think there is
particularly in my opinion I don't think
is the best sorting algorithm okay right
uh what is the difference between system
dot out system dot e double r and
system.in
error
can you just explain about it
yes uh system dot out and system.err
represent the monitor by default and
this can be used to send data or results
to the monitor so system dot out
specifically is used to display normal
messages and results is basically the
print function of the Java family
system.err is used to display the error
messages and setup dot in third refers
the input stream which uh is saying
pushing object actually which by default
represents standard input device which
in almost 99 of the cases is a keyboard
okay now can you write down this syntax
on how to create a linked list and a
vector in Java you can just type it in
the chat box
here only sure
I'll actually create a new object okay
author linked list class here yeah
I just want to see the logic only okay
okay
uh this is to create only the object
variable for the linked list I know
actually uh
[Music]
syntax of vector okay
[Music]
it's quite similar to the link list
object but we have to add two more
parameters which would be the size and
increment okay
let's type it here only I think I have
shared
okay
okay fine
so my next question is how do you get
the highest number that exists on a list
just write a code here only okay uh
should I just put a sample uh yeah yeah
I just want to see the approach you are
using sure okay I'll just write the code
again highest number that exists on a
list you can take any random list
I'll create a list with integer
value
[Music]
I just declared the list with the link
numbers yeah
and now I'll print out the final list
okay
you're using mapping right yes okay
I think that should be enough like
should I elaborate more or do you think
it's yeah it's fine it's fine I just
wanted to see the approach that you're
using okay now can you write how to do
the reverse in string in Java
reversing a string right yeah okay
you can just take a string hello and
just reverse it okay I'll put it in a
variable
[Music]
I'll create a
dummy variable named reverse where the
actual reversed output will be stored
first I'll take the length of the string
store it in the length variable like I
just shared next I'll start off for Loop
uh there's a single line in the body
I'll just
write that down separately okay
basically it's taking all the elements
and it will keep adding them to the
reverse variable that I had declared
before and the next step would be to
just print out the final reverse
variable
I think that will reverse the string
completely okay
okay fine
now
how many objects will be inside the hash
map
um there can be two elements with the
same hash code but when two elements
have the same hash code Java uses the
equals to further differentiate so there
can be one or two objects depending on
the content of the objects
yeah okay okay now give an example how
to create a hash map
in the chat only okay so like a sample
yeah
okay sure
I first import the necessary libraries
this is a hashmap library then I will
import
the mapping Library
okay I'll start the main function okay
the class declaration
now I would go with
[Music]
and now I'll start the body of the main
function
if you need time to just think of the
approach you can take time with this
shine so much
I'll be putting two string values
declaring a new hash map right now
um
[Music]
[Music]
to create the new or initialize the new
hashmap then I'll start storing data in
these hashmaps
using the put function
this would be the first element and next
would be
similarly I'll put another element just
to show
you are taking the car names correct
foreign
[Music]
just basically close the main function
that's it
I think this will
look at this let me read once
it's good
okay can you please tell me what are
your greatest strength and weaknesses
okay I'll start with my strengths I
think my ability to work well in a team
is one of my finest assets I have a
strong sense of self motivation and I'm
a very quick learner
whatever assignment I get I usually I
tend to finish it very diligently and
preferably ahead of schedule
I don't know if there are any standout
weaknesses as such but one thing that I
believe can be improved about myself I'm
a people skills indulging in
conversation with co-workers and people
I'm not very comfortable with or talk
regularly with uh but I have been
working on that a lot and there has been
a lot of progress and there is going to
be more for sure moving on
I think that's the only thing that I can
count as a weakness okay be good so
where do you see yourself in five years
uh I think initially I would first uh
like to grow my skills as a team player
in the first few years at any
organization uh then understanding how
upper level management works and then
ultimately uh get up earn a managerial
position
most likely handling a very high output
team and being able to Mentor a bright
group of people who who are prepping for
their next step in their career just
like I would have done by them
now tell me why should we hire you
uh have very strong sense of motivation
I really push myself to improve and
learn more I am very open-minded as well
and I pick things up rather quickly I
like to solve difficulties and hopefully
solve roadblocks for teammates come as
me okay
um apart from that from apart from
spills perspective additionally I
believe that the values of this
organization and mind are very
compatible so that's why I think I
believe that this job in this position
will support my interests and present me
with enough engaging and exciting
opportunities that will help me advance
myself and the company
that's why frankly I'm very excited
about this chance okay okay good okay so
thank you this is all from my side if
you have any questions you can ask me
I think uh I really have only one
question uh can you tell me about a
company and the more importantly the
daily responsibilities that I'll be you
know asked to ahead on a day-to-day
basis okay so wherever right now I can't
tell you everything but we are a
software company we develop software
according to the needs of the clients
and everyone is Young and energetic here
so the environment is also very good
okay I think that's all I needed to know
okay okay thank you so much for your
interest
we'll let you know the results very soon
okay so thank you so much I will
definitely look forward to hearing you
so here we wrap up with Java full course
if you have any queries feel free to add
it in the comment section and our
experts will be happy to help you if you
like this video do subscribe to Simply
learn and hit the Bell icon to never
miss any updates from us thanks for
watching
staying ahead in your career requires
continuous learning and upskilling
whether you're a student aiming to learn
today's top skills or a working
professional looking to advance your
career we've got you covered explore our
impressive catalog of certification
programs in Cutting Edge domains
including data science cloud computing
cyber security AI machine learning or
digital marketing designed in
collaboration with leading universities
and top corporations and delivered by
industry experts choose any of our
programs and set yourself on the path to
Career Success click the link in the
description to know more
hi there if you like this video
subscribe to the simply learned YouTube
channel and click here to watch similar
videos turn it up and get certified
click here