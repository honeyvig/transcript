foreign
developer data structures are essential
to their daily lives helping them
organize store and access information
more efficiently while data structures
are primarily used in computer science
and engineering they can also be applied
to many aspects of your daily routines
for example shopping personal
organization Finance Management social
networking and many other areas of
everyday life can be managed effectively
using data structures data
representation and manipulation can be
done in a way that makes it simple for
algorithms to operate with the
performance of your program can be
enhanced for instance by selecting a
data structure to store large amounts of
data that needs to be frequently
accessed or modified arrays LinkedIn
lists Stacks queues trees and graphs are
some common data structures used each of
these data structures has advantages and
disadvantages and selecting the
appropriate one for your problem can
significantly improve the efficiency and
maintainability of your code in fact
data factors are crucial tools for
programmers and computer scientists
since they aid in optimizing data
storage and processing in various
applications on that note hey everyone
welcome to data structure full course
part 1 video by simply learn in this
video we'll begin with an introduction
to data structures followed by an
explanation of an algorithm and then we
learn about data structures pointers and
structures next we'll move on to topics
like arrays linked lists types of
linking list and finally the fundamental
distinctions between arrays and linked
list then we'll dive into little
Advanced topics like Stacks queues trees
and graphs covering their various types
of it in the next part so without any
further delay let's get started over to
our training experts data is an
information that has been translated
into a form that is efficient to
movement or processing in Computing as
it relates to today's computers and
transmission media data is an
information that has been converted into
binary digital form the the term raw
data refers to the data in its most
basic digital format after defining data
let's look at what data structure
entails a data structure is a data
organization management and storage
format in computer science that allows
for efficient access and modification or
a data structure is an algebraic
structure about data that contains a
collection of data values their
relationships and their functions or
operations that can be applied to the
data
we will now understand why exactly we
need data structures now that we have
already defined what is a data structure
so let us have a look at some of the
data structure characteristics the first
one is each data structure allows data
to be stored differently following that
the data structure allows for more
efficient data search and retrieval then
specific data structures are chosen to
solve specific problems last but not the
least it enables the management of large
amounts of data such as last databases
and indexing services such as hash
tables let us now look at some real
world examples of data structures first
and the foremost we have the dictionary
assume that we are looking for the word
simply learn in the dictionary
and we know what begins with the letter
s so we can search for this word
beginning with the letter S and then
this is an example of array data
structure as a result this dictionary
can also function like an array data
structure following by that we have a
music player example if you have a
playlist with three songs the second
song will play after the first and the
third will play after the second so
these will be played without any
Interruption because all these three
songs are linked with each other using
linked list type of data structure this
is followed by linked list the next
example we have is the data structures
the stack of books analogy is a perfect
example of the real-time working of the
stack data structure subsequent to that
assume there is a line of people at a
ticket window and the person who comes
first gets the ticket
this particular movie window queue is an
example for the real-time implementation
of Q data structure
last but not the least Google Maps
Google Map is the graph data structure
in which all the cities and states are
connected if we want to go from one
place to another there may be many ways
to do so so we can use some algorithms
to find the shortest path
as a result the Google Map is a perfect
example for the graph data structure
working analogy
following that we will look at some
different types of data structures in
this tutorial
so the first type is the linear data
structure
the elements in the linear data
structure are arranged subsequently one
after the other they are simple to
implement because the elements are
arranged in specific order followed by
the first type the second type is the
non-linear data structure which we will
be discussing a bit later
so in linear data structures we have
four different types the first one is
the array data structure memory elements
are arranged in a continuous order in
arrays and arrays elements are of scene
type the software program also
determines the type of elements that can
be stored in arrays so followed by
arrays we have linked list linked lists
are completely similar to data
structures data elements in linked list
data structure are linked together by a
series of nodes furthermore each node
contains the data items as well as the
address to the next node
the third data structure is the stack
data structure elements in a stack data
structure are stored using lifo
principle in other words the last
element stored in the stack is removed
first in stack operations can only be
performed in one end namely the top and
the last data structure is the queue
data structure unlike stack queue data
structure operates in the fifo principle
which states that the first element
stored in the queue is removed first in
a queue insertion and deletion are
carried out from opposite ends now we
will discuss the second type of data
structures which are the non-linear data
structures
the non-linear data structure is the
second type of data structure non-linear
data structures do not have elements in
any order as opposite to the linear data
structures instead they are arranged in
hierarchical order with one element
connected to one or more others
so the first one in the non-linear data
structures is the three data structure a
tree data structure is built using nodes
and edges each element in the three data
structure is called as node or vertex
each Vertex or node is connected to the
other nodes or other vertices using
edges and the second one in the list is
the graph data structure a graph data
structure is completely like a tree data
structure it also has the vertices and
edges each vertex in a graph data
structure is connected using HS the only
difference between a tree and graph is
that entry you can have n number of
vertices but in graph you will have only
two vertices
after discussing the graph data
structure we will move ahead into the
last segment of this tutorial that is
importance of data structures so the
first one data structures are widely
used in almost every aspect of computer
science both for simple and complex
computations
next data structures are used in all
areas of computer science including
artificial intelligence Graphics Big
Data operating systems and much more
after that the data structures are an
essential component of many computer
algorithms because they allow
programmers to manage data efficiently
so how does algorithm work in real life
so we'll have a use case here on my
screen we have a lady and she is Shreya
Shreya wants to make some tea and for
that she is following some steps
so the first step is she'll take a pan
and fill it with water and place it on a
gas stub
followed by that the second step is
she'll make sure that the water comes to
a nice boil and then she adds some tea
leaves and sugar
followed by step 2 we have step 3 where
she'll allow the leaf to be fully
expanded and she'll add some milk after
that
next we have the step 4 where she will
wait for the tea to come for a good
decent boil
next we have step 5 where she'll turn
off the gas and she'll take the pan off
from the stub and the tea is ready to
get filtered and lastly we have the step
6 where she is all set with the teeth
so in computer science an algorithm is a
method or set of rules that we must be
following to perform some specific
calculations or other problem solving
operations
as a result an algorithm is a collection
of rules or instructions that govern how
a work needs to be conducted step by
step to achieve the desired results to
accomplish a task we first provide some
input and then follow a sequence of
steps to acquire the required outcome of
the input so that is the fundamental
definition of an algorithm and we also
had a use case and now we will move
ahead and understand the characteristics
of algorithms
so basically we have six characteristics
of algorithm so the first one is it
should be clear and unambiguous the
second one is that it has to be well
defined inputs and the third one is that
it has to be having well-defined outputs
as well the fourth property of an
algorithm is its feasibility followed by
that finiteness and finally we have
language Independence
now we will look into each one of the
characteristics in detail so first we
have clear and unambiguous so this
statement is the one which states that
the algorithm should be straightforward
simple and easily readable each one of
its steps should be distinct in every
way and Lead it to a single conclusion
so the next one is it should be having
well-defined inputs so this means that
an algorithm should indicate what output
can be expected as well as the input
should be properly well defined now we
have the third one similarly we should
also have well-defined outputs so the
well-defined output characteristics of
an algorithm means that the algorithm
must clearly indicate what output can be
expected as well as the output should
also be well defined followed by the
third characteristic we have the fourth
characteristic that is the finiteness of
algorithm so the finiteness of algorithm
says that the algorithm must be finite
and it must not result in infinite Loops
or similar situations so followed by the
fourth one we have the fifth
characteristic that defines about the
feasibility of an algorithm so
feasibility of an algorithm states that
the algorithm must be really simple
generic and practical it must be able to
be executed with resources available
now the last characteristic of the
algorithm is being independent of the
language
so it means that the algorithm should be
defined in such a way that it is
completely independent of the language
it must be simple instructions that can
be implemented using any programming
language
so these were the six major
characteristics of algorithm now let's
move ahead and understand how to write
an algorithm writing an algorithm does
not have any hard and fast rules
next algorithms are never created to
support a specific programming language
as we all know algorithms should be
capable enough to support the
conditional statements such as if if as
switch Etc an algorithm should be
capable enough to execute some of the
conditional statements such as if if
else switch Etc and also it must be
capable to execute the iterative
statements such as for Loop while loop
blue while loop Etc
May usually create algorithms in a
step-by-step manner however this isn't
always the case after the problem domain
has been well defined algorithm writing
is a procedure that is carried out
we build an algorithm to find a solution
to a problem a problem can be resolved
in a variety of ways let's look at an
example of how to write an algorithm
consider the following scenario we need
to create an algorithm to determine the
largest number among the three given
numbers X Y and Z as a result the
initial solution to the problem can be
written in this manner so we begin with
reading all the three numbers and in the
second step we will have a condition
that says if x is greater than y we will
proceed to step 4 else we will proceed
to step 5. next in Step 4 we establish a
condition that if x is greater than Z
then X is the largest of the three
numbers otherwise Z is the largest if Y
is greater than z z will be the greatest
number otherwise y will be the largest
number amongst all the three in step 5
and the procedure will be terminated
let's have a look at what the next
solution has to offer in this algorithm
We Begin by reading all the three
variables then compare all the three
numbers in the third step to determine
the largest number which is if x is
greater than y then there is another if
else statement that states that if x is
greater than y then X is largest
otherwise Z is the largest then there's
if else statement which says that if Y
is greater than Z then Y is greater
otherwise Z is the greatest of the three
numbers so this is how we have multiple
solutions to the same problem so after
discussing these Solutions we will move
ahead and understand algorithm analysis
the algorithm may be studied in two
levels first before it is made and then
after it is created the two analysis of
an algorithm are as follows the first
one is priori analysis and the second
one is the post analysis so first we
will talk about the priori analysis
priori analysis refers to the
theoretical analysis of an algorithm
performed before its implementation
before implementing the algorithm other
parameters such as processor speed might
be considered which does not affect the
implementation component next we will
talk about post analysis a practical
analysis of an algorithm is called as
posterior analysis and it utilizes any
computer language to build the algorithm
the purpose of this analysis is to
determine how much time and space the
algorithm takes to operate now after
being understood the algorithm analysis
we will be able to comprehend the
algorithm complexity two methods can be
used to assess the algorithm complexity
the first one is time complexity which
states that the amount of time required
to finish an algorithm's execution is
known as its time complexity
followed by time complexity the other
one is the space complexity which is
calculated by the quantity of space
required to solve a problem and produce
an output of space complexity of an
algorithm
let's take a closer look at these
complexities now we will begin with time
complexity of an algorithm the Big O
notation is used to express an
algorithm's time complexity the
asymptomatic notation is used to depict
temporarily complexity of Big O notation
the time complexity is mainly determined
by counting the number of steps required
to complete the task
let's take a look at an example to
understand this time complexity in a
much better way if we want to find out a
multiplication of n numbers we can do it
by executing a loop from 1 to n then
calculating multiplication when the loop
ends then multiplication holds the N
numbers multiplication and last we
return the calculated multiplication the
loop statements time complexity will be
at least n and when the number of n
increases the time complexity will also
increase while the code's complexity
that is returns multiplication will
remain constant because its value is
unaffected by the value of N and it will
obtain the result in every single step
next we will discuss about space
complexity which is expressed with Big O
notation just as time complexity
these four items are stored in space
complexity it initially says program
instructions then stores constant values
then stores variable values and finally
it keeps track of function cells jumping
statements and so on the sum of
auxiliary space and input size is used
to calculate space complexity the extra
space or temporary space used by an
algorithm is referred to an auxiliary
space after learning about algorithm
complexity we will look at some of the
algorithms pros and cons so let's start
with the advantages of algorithms
firstly algorithms are easy to
understand next algorithms are
step-by-step representation of a
solution and lastly the problem is
broken down into smaller bits or steps
in an algorithm making it easier for the
programmer now an algorithm also have
various drawbacks one of which being it
takes long time to write hence it is
time consuming second cone of the
algorithm is algorithms make it harder
to demonstrate branching and looping
statements so followed by the advantages
and disadvantages of algorithms we now
enter into the final segment where we
discuss the differences between
algorithms and programming so the first
difference is that an algorithm is a
type of programming on the other hand a
program has more directly associated
with the computer performing one or more
tasks but an algorithm is more of a
notation a technique for solving a
problem
now let us discuss the second difference
an algorithm can be decoded or run by a
human whereas the program has only run
or decoded by a set of compilers of the
computer
now the third difference basically an
algorithm is a design of the solution to
the problem
here we can only analyze the solution
but we can never run it but whereas on
the other hand programming is completely
a different ball game here you can
directly Implement a certain phase or an
entire program and test the programs and
get an output so the fourth and the last
difference between an algorithm and
programming is an algorithm is written
using natural human vocabulary
whereas programs are written using any
programming language such as C C plus
plus Java python Etc
pointer is a variable that points to an
address of another variable it is
declared using a star symbol also called
asterisk
and then we allocate a memory of a
variable to it we can access a
variable's address using the Ampersand
symbol in the same manner as the pointer
declaration let's write a code
we will declare a variable a is equal to
5
and a pointer PTR
then we will assign this variable A's
value to pointer PTR
now let's write a print statement to
directly access the variables value
using variable name
let's write another print statement to
print the value of a using pointer
let's try and execute this program
foreign
as you can see we have successfully
accessed variables value using both
variable name and pointers
let's get back to our slides
now let's discuss different types of
pointers
first up null pointer
void pointer
wild pointer and dangling pointer
let's discuss these in details
first up null pointer it is a kind of
pointer that points to a null memory as
you can see in the figure here is a
pointer which is pointing to a null
memory
to get a better understanding let's try
a simple program in the code editor
let's write a code first we will declare
a pointer where
then we will assign its value to null
now let's try to print the statement
let's execute this
as you can see since this pointer points
to a null or nothing that's why it
doesn't print anything
let's get back to our slides next void
pointer when a pointer is created with
data type void then this pointer is
called void pointer if we want to print
the variables value then we have to
Typecast this pointer to avoid any error
for better understanding let's get back
to the code editor and try it with a
simple code first we will declare an
integer variable a is equals to 5.
and avoid pointer PTR
now we will assign address of a to
pointer PTR
let's write a print statement to print
this pointer
let's run this program
as you can see we are getting an error
that's because we can't print a void
variable
in this we have to Typecast this
variable to integer let's do this
we can type cast a variable like this
now let's print this
as you can see we can print it now
let's get back to our slides
next while pointer when we create a
pointer but don't initialize it by
assigning any memory to it then this
kind of pointer is called wire pointer
these pointers can be very tricky they
can even cause a program failure or a
segmentation fault
let's get back to the curator and try it
with a simple code
first let's declare a pointer PTR
but they will not assign it with any
address
let's write a print statement to print
it this time we will directly print it
let's execute this
as you can see we are not getting any
results because there is no value
assigned to it sometimes it may even
show segmentation error
let's get back to our slides
next dangling pointer
let's Suppose there is a pointer P which
is pointing at a variable now if we de
allocate this memory using a free
function
then this pointer will point at a free
space or a non-existing memory
then this pointer will become a dangling
pointer to get a better understanding of
this pointer let's try it with a simple
code
let's declare a pointer PTR
here we will dynamically allocate memory
using a mailoff function
to do this we will put int star in a
bracket
then
mail log function
and in another bracket we will put
memory size to be located
now let's declare a variable a
and assign its address to the pointer
now to make it a dangling pointer we
have to de-allocate the memory of this
pointer
we will use free function for that
now let's write a print statement to
print this pointer
let's execute it
as you can see since we have deallocated
its memory that's why it is pointing to
nothing hence it doesn't print anything
now let's begin by understanding what a
structure is in same
as we all know array is a collection of
elements of the same data type similarly
a structure is a collection of elements
with the same or different data types
for example unlike an array a structure
can have members of different data types
like int float care Etc
now let's have a look at structure
declaration in C
we use the struct keyword before the tag
name to define a structure tag name is
nothing but a structure name whatever is
declared inside the structurally
brackets are members of this structure
once the members are detected the
variable has to be created to access the
members of the structure now let's see
the example we have struck keyword
followed by student as a tag name then a
list of structure members and they are
name of type care roll number and age of
type int and S1 as a structure variable
we can have a list of structure
variables
another way of structure declaration is
we can declare structure variable
outside the curly brackets by using
struct keyword followed by a tag name
and then declare variable list for
example
keyword then student tag name and S1 as
a variable name
in structures in C programming we cannot
assign values during the definition of a
structure it indicates the wrong way to
the Declaration so now let us try to
understand the right way of assigning
values to the structure members in C
to assign values to all the members of a
structure and access we use dot operator
also known as a period operator
look at the syntax below to clearly
understand how we access and assign
These doctor members first the structure
variables followed by the dot operator
and structure members for example S1 dot
roll number is equal to 34 S1 dot h is
equal to 18 and we make use of the
string function strcpy to copy the name
next we have structure initialization in
C
we can also initialize the structure
variable and to initialize we can
directly assign values of all the
structure members inside the curly
brackets with an assignment operator for
example
struct student S1 is equal to inside the
curly brackets enter the values
separated by comma operator
in this particular example name is John
the roll number is 22 and the age is 18.
now that we know how to declare an
initialize structure variables in C
let's see how this structure elements
are stored in the memory
as we know CAD takes one bytes of memory
space so according to the size of the
string the characters will occupy in the
memory in structures the memory is
created once the structure variable is
declared as per this example S1 dot name
is a string so that memory will be
allocated and its Base address will be
obtained
for the S1 variable the total memory
allocated is 8 bytes that is 5 bytes for
s1.nic two bytes for S1 dot roll number
and two bytes for s1.h
so I think you got a good understanding
of how memories are located for the
structure elements okay so let us move
on to the structure within structure in
C
when a structure contains another
structure as a member it is known as a
nested structure or structure within a
structure for example
let's consider a structure name student
and another structure name as a date in
this example a structured date as a
member so a structured date has its own
members and they are date month and year
of type int and structure variable for
date is doj
and this structure variable is
initialized for both the members of the
structure that is name admission number
age date month and year
now let's execute a simple structure
program
if getting your learning started is half
the battle what if you could do that for
free visit scale up by simply learn
click on the link in the description to
know more
as you can see in this particular
program using the structure we have
initialized the variables and trying to
print the values
and by using the dot operator
we are accessing the members of a
structure so now let's run it
and here we got an output name roll
number and age of a student structure
in our next program using structure we
are using another way to declare
variable and initialize the structure
members
as you can see we have declared variable
outside the structure curly bracket
and inside the main function we have
initialized the structure members
so now let's run the program
so here we got the same output
so to understand this let's go through a
simple concept
let us imagine that we have some data
and the data is related to students
right so if we wanted to store the marks
of individual students then we had to
declare a variable for each of the
student
so you can see we have student 1 student
2 student 3 4 and 5 and their individual
scores so the score one is assigned to
student 1 and so on with student 5 being
assigned to score 5.
so in the real time this might be a
little clumsy we have here just five
students so that is okay but what if we
had 500 students or 5000 students right
that might be an issue there we have to
create some 500 or 5000 variables and it
would be a little tough to handle that
right even if we wanted to apply some
operations collectively on all the
variables that might be a little tedious
so what if we had one variable which
could store all the five students or 500
students or 5 000 students all together
and make it really easy for us to apply
some operations collectively on all the
students right this sounds a little bit
logical
so similarly we do have a data structure
which can do that which can collectively
store all the data elements in it as a
single variable and it will also help us
to apply the operations which are
logical or mathematical on all the
variables and their values together as a
whole so that is the purpose why we had
created Aries that is the purpose why we
needed Aries
so far we have understood what was the
necessity for Aries now we will
understand what exactly are Aries
foreign
so basically an array is a linear data
structure that stores the elements in a
sequential manner one after the other
and when you declare an array the
variables will be stored one besides the
other that is adjacent to each other in
a sequential order now let us understand
how the array is represented by the
compiler
now the next part that is the memory
representation of Aries
now let us imagine that we have declared
an array which stores character type
data and another important point to
remember about R is when you declare an
array it stores only a single data type
typed elements only for example here we
have declared a character type array
right so we cannot store integer type
data or flow type data in it we only
have to save character type array or
character type elements in this
particular array
so now let's imagine that we have
created an array which is of character
data type and these are the elements
which are a r r a y now how does the
compiler represent it in the form of
memory
so when you create an array these are
formed that is the index values and the
address so basically compiler will
select a block of memory and it has
addresses to that block and it can be
anything right here we have 11 12 13 14
and 15. and in real time it might be a
thousand one thousand two thousand three
thousand four thousand five the main
motto is assign a sequential block of
memory and this is the array and the
elements are a r r a y and this
particular one which is the last one is
the index of the array that is the
position of the array for users so using
this index you can access the elements
in the array more on that in the
accessing part so let us imagine that we
wanted to access the element R so how to
access it we might not know the address
right in that instance we will use the
index this is for our reference so we
will tell I want the element from array
index number 2 and then we'll have the
ARR R element so in the Practical form
this is how we use the index
now let's continue with the lower bound
and the upper bound so the first initial
location is called as the lower bound
and at the last or the max value of the
array is called as the upper bound now
let's jump into the next topic where we
will understand the different types of
arrays
so these are the different types of
Aries
one dimensional Aries and
multi-dimensional arrays
in multi-dimensional arrays we have two
more types that is two dimensional
arrays and three-dimensional arrays
so how are arrays different from each
other
right so the first one will deal with
the first one that is the one
dimensional array now how is an array
declared as one dimensional for that we
need subscript so one dimensional array
requires only one subscript to specify
the number of elements in an array so
how is it actually represented so here
you can see an example right on my
screen
so here is how a one-dimensional array
looks like so here we have the data type
that is integer data type and marks is
the name of the array and this is the
size of the array and here the elements
will be stored and here it is the index
value of the array and remember the
index value of array always starts from
zero in the previous example that was
only form basic understanding so I just
started that with one in the practical
way the array index always starts from
0. so followed by the one dimensional
array we will deal with the
multi-dimensional arrays in that we have
the following the first one is the two
dimensional array and the second one is
the three-dimensional array
in the multi-dimensional arrays we
require more than one subscript in the
previous example we had one dimensional
array so this subscript is just one that
is 10 columns
right so we just had one single row and
10 different columns but in the
multi-dimensional arrays we need
multiple rows and multiple columns right
so we need two subscripts for two
dimensional array and more than two
subscripts for three dimensional arrays
so first we have the two dimensional
arrays the 2D array is organized in the
form of a matrix which can be
represented as a collection of rows and
columns so here is the example as you
can see on my screen we have three
columns and three rows and we have two
subscripts that Define the number of
rows and the number of columns and the
elements in each and every row so the
one two three confines the first row
four five six confines the second row
and 7 8 9 will be the third row now
similarly we have three dimensional
Aries a 3D array is a collection of 2D
arrays which consists of three
subscripts block size row size and
column size
so here we have an example for that
so we have three subscripts that is the
first one is block size the second one
is the row number and the third one is
column number
so this happens to be the first block
this happens to be the second block and
this is how a three dimensional array
can be represented
now we have the next stage where we will
understand how to declare the Aries and
the syntax is right on my screen you
need to specify the data type of the
array which is integer of load or
character any selection which you make
followed by that you need to select an
array name for your array and inside
that you need to declare the array size
and sometimes you can also eliminate the
array size if you wanted to you know
have a dynamic array
and here is an example for that
you have integer data type name of the
array is example and the array size is
6.
so the compiler will allocate continuous
memory block of 6 integer type blocks
so these are the few more methods to
initialize the array so here you can see
integer data type array name is a
element size S5 and we have five
elements the method two is remember I
have said and you can eliminate the size
of the array right so here you can use
this way as well integer data type
rename a and no size here and you can
directly declare the elements
and the method third so here you have
the name of the array size of the array
and you are allocating the elements to
the individual memory locations this is
also another method to initialize array
and method for as using a fault you can
just initialize a for Loop and the I
value will be stored in the array
locations starting from 0.
now let us understand how to access the
elements in an array
so to access the elements in an array
you need to specify the name of the
array and memory block where you have
that element that you want to access so
here we have an example which is integer
data type name of the array is XYZ and
the element we wanted to access as five
so here we have an example that is
integer type array array name is XYZ and
it has the size 5. and now we wanted to
access the first element in an array
that can be done using the first index
that is x y z of 0 index that is the
first element and accessing the second
element and so on x y z of 1 will be the
second element x y z of 2 3 4 will be
the third and fourth and fifth elements
now let us understand some basic
operations that can be performed on the
array elements so the following are the
operations that can be performed on the
array elements that is the traversal
insertion deletion
searching and sorting
now let us get into practical mode and
try to execute some examples based on
traversal of the array insertion of an
element into the array deletion of an
element from an array searching for an
element in an array and sorting the
complete array so at first we'll carry
out the traversal operation so here we
have an array that is a of 5 and the
elements are 1 2 3 4 and 5. now we're
going to use a for Loop to Traverse
through this array and print all the
elements sequentially now let us execute
this code and see the output
so as you can see the code got
successfully executed and the elements
that as one two three four and five from
the array a are printed sequentially now
moving ahead we'll try to execute some
examples based on insertion of element
into the array so on my screen you can
see an example for inserting an element
into the array at the starting position
of the array now let us try to execute
this code and see the output
don't worry about the codes these code
documents will be attached in the
description box below and you will be
able to have an access to it and run
these codes in your personal laptop and
get a better learning experience
now you can see the code got
successfully executed and now it is
asking for the size of the array let's
declare it as 5. and now let's enter the
elements into the array
now it is asking for the element to be
added at the beginning of the array now
we have 2 3 4 5 and 6 existing in the
array let's add the first element 1 and
there you go the resultant array is 1 2
3 4 5 and 6. the element which we added
at the ending which is one is supposed
to be in the first or the beginning part
of the array which is here at at the
first index location as planned now
let's get started with another example
on the insertion now let's try to insert
an element at any given location as per
the user's choice
so as you can see we have a program on
my screen and running this program must
help us to insert an element into any
given location of the array
now let's try to quickly run this
program and see the output
so there you go enter the elements into
the array let's enter 1 3
let's try to run this program and say
the output
so there you go the program got
successfully executed and now the output
is asking for us to tell it the number
of elements in an array now let's say
four elements
so now let's enter the four elements
one
three
four five and six
okay
so the four elements which is one three
four five are been inserted now it is
asking for the location where you want
to insert the element now let us insert
it in this second location
now let us set the value as 2 and there
you go the resultant array is one two
three four and five and the element
which is 2 was supposed to be added in
the second location and it has been
successfully added now let's try to
execute another example based on
insertion where you will try to insert
the element in the last position
now this program on my screen will help
us to add an element at the end of the
array let's quickly run this program
now it is asking for us to enter the
five elements of the array let's enter
that
now it is asking to enter the element to
be inserted now let us enter the element
and this element should be added at the
endless location as discussed the
resultant array is
13579 and 11.
now let's continue with the deletion
operation
now the program on my screen is an
example for deleting an element from the
beginning position of an array now the
program got successfully executed and
it's asking for us to enter the size of
the array let's enter the size as 5.
and now let's enter the elements of the
array that is 1
.
2 3 4 and 5.
now the element from the first location
that is 1 has been deleted and the
resultant array is 2 3 4 and 5. now the
code on my screen will help you to
eliminate the element from the ending
location of an array now let's try to
quickly run this program and say there
so you can see that the program is
successfully run and it is asking for us
to enter the size of the array let's
enter 4. now let's enter the elements of
the array that is 1 2 3 and 4. now after
eliminating the last element from the
array that is 4 we have the resultant
array that is 1 2 and 3.
now a little homework for you guys let's
try to execute an example for deleting
an element from any location of an array
this will be a homework now don't worry
try on your own and if you don't get
that you can refer to the comment
sections below where you have the code
document attached in the description box
and you can refer to it
now let's continue with the next
operation where we will search for a
given element in the array so you can
see that on my screen we have an example
which will help us to sort the elements
in an array let's quickly run this
so there you go the program got
successfully executed and now it's
asking for the array size let's enter a
file and now let's enter the elements in
a random order
[Music]
now the resultant array should be sorted
so there you go the array after being
sort is it's 2 3 5 4921 so there you go
the array got sorted so now we have
finished our practical session let's
have a quick overview again
so traversal in an array is a process of
visiting each element once traversal can
be done by various means that is by
counting the array elements printing the
values sorted in the arrays and some of
all elements present in the array and
many more
so this is how we Traverse our array
from the first location to the last
location again the insertion operation
insertion in an array is a process of
including one or more elements in an
array and it can be done at the
beginning at the end and at any given
index of an array which we executed for
all the three types of examples
now next we have the deletion operation
so deletion operation or deletion of an
element is a process of removing a
desired element and reorganizing the
array and it can be done at the
beginning at the end and at any given
index so we have executed the example
for at the beginning and at the end and
the homework was at the given index
don't worry if you don't figure it out
you can always refer to the example
document which is mentioned in the
description box below
now the search operation searching is a
process of finding a given value in the
list of values and it decides whether
the search key is present in the array
or not and we have executed an example
on that
and again the sort operation where we
will sort the given array if the given
error is not in the default order or in
a given order that is ascending or
descending then we can sort the order of
the array by the user's Choice given it
is ascending order or descending order
now in the next section of the tutorial
we will discuss the advantages of using
Aries
so the first one is aristos multiple
elements of same data type with same
name
next one elements in an array can be
accessed randomly using just the index
number
array memory is predefined so there is
no extra memory loss
array Awards memory overflow and finally
2D arrays can represent the tabular form
of data in a very efficient way now let
us also have a look on some of the
disadvantages of using arrays
the first one the number of elements in
an array should be always predefined so
there is no chance that you can add some
extra element in the last moment
array is static in nature so its size
cannot be varied after declaration what
if considered that you wanted to store
10 student data in one array and you end
up having just seven students so the
remaining three is a waste right so you
are wasting memory there that's the
problem and insertion and deletion
operations in an array is quite
difficult as the aristos elements in a
continuous form and finally allocating
excess memory band required mainly to
memory wastage
so we will see a brief definition of
arrays the array is a data structure
that stores elements of the same data
type in a sequential order
two dimensional arrays are considered as
an array of arrays
two dimensional arrays represent the
information in the form of rows and
columns which is completely similar to a
tabular form of data following by the
definition and briefing of the
two-dimensional arrays we will
understand the need for two dimensional
arrays so the main advantage of using a
two-dimensional array is the elements
can be represented in the form of a
matrix that is rows and columns using
two dimensional arrays we can initialize
access and print multiple elements in
The Matrix form by just running one
single code segment you can see an
example right on my screen here this is
an example of marks list suppose a class
has three subjects namely English
science and maths
we have four students and we wanted to
represent the data in the form of a
database so here the marks of the four
students can be represented using two
dimensional arrays
now we will see the syntax of a two
dimensional array so here the syntax
at first we need the data type the data
type can be integer character float
string Etc then we have the name for the
two dimensional array and later we can
have two subscripts which represent two
Dimensions that is the rows and columns
the first subscript defines the number
of rows and the second subscript defines
the number of columns and note that the
column number can never be null
at the end we have a semicolon to
terminate the syntax
and here we have some examples of two
dimensional arrays so in the first
example we have the name of the
two-dimensional array and we have three
rows and four columns
and followed by that we have another
example which is of character data type
and the name of the array is names and
we have 7 rows and 15 columns
next we will see how to visualize two
dimensional arrays
we read earlier that two dimensional
arrays are a collection of rows and
columns let's see an example of two
dimensional array we will consider an
array with 6 rows and four columns as
you can see on my screen we have integer
type array and the name of the array is
array and we have six rows and four
columns
the product of rows and columns will
give us the total number of elements
present in a two-dimensional array in
the current example we have 6 rows and
four columns and the product is 24 so we
must have 24 elements in this array next
we will see how to initialize two
dimensional arrays
so there are two ways to initialize a
two-dimensional array so in the first
method we declare the elements in the
set of curly brackets
this array consists of three rows and
three columns
note that the index always starts from
zero here we have three rows it means
the row starts with 0 and ends with 2.
the same goes for the column but
sometimes this method might be a little
confusing so we have a better method the
advantage of this method is clarity
we can visualize all the elements with
better Clarity compared to the previous
method so the first three elements are 9
6 and 1. they are present in the first
row
and in the second row we have 144 70 and
50. they comprise the second row and
finally the third row in which the
elements are 10 12 and 78. so far we
have learned how to visualize and
initialize a two-dimensional array so we
have done it by using the index values
that is the row index and the column
index so the row index value was 3 and
the column index value was 3. for
accessing an element in the two
dimensional array we need to pass the
name of the two dimensional array
followed by the row index value and the
column index value for example let us
assume that we wanted to access the
element 9 for doing so we will pass the
name of the array followed by the row
index value and the column index value
as shown below that is end first 0 comma
0.
and an important Point here is indexing
always starts with zero we will now
start printing the two dimensional
arrays so to print a two-dimensional
array we will be using two nested for
loops
so to understand the process of printing
the two-dimensional array let's get back
to the Practical mode and we will work
on a code
so on my screen you can see an example
for two dimensional array so here we
have declared an array with the name
first and we have three rows and three
columns and inside that the first row of
elements is 961 and the second row of
elements is 144 70 and 50 and the third
row of elements is 10 12 and 78.
followed by that we have two counter
variables which are I and G so we are
using the first counter variable I in
the order for Loop and the second
counter variable J in the second in the
fall
and inside the inner follow we have a
print statement which is used to print
the elements in the array
now
let us try to execute this code and see
the output
so you can see the code got successfully
compiled and we have our elements here
which is 961 144 70 50 10 12 and 78. now
let us understand the logic so here we
have declined the counter variable as 0
and the condition is I should be less
than 3 which is true so the control will
enter into the second in the follow here
we have J is equals to 0 and J should be
less than 3 which is true so here the
condition or the statement
is valid and it will print the first
element 9.
followed by that J will be incremented
again J is now equals to 1 and J is less
than 3 so again we'll print the second
element 6.
again J value will be incremented to 2
so 2 is less than 3 then we will print
the third element that is 1. now when
you increment the value of J from 2 to 3
the condition will fail because 3 cannot
be less than 3. so the control will
enter into the outer for Loop here we
have I value is equals to 0 which will
be incremented to 1. so 1 is less than 3
again the control will enter the inner
for Loop here again we will check for J
is equals to 0 which is true so we will
print the second row of elements that is
144 70 50 in the same way how we printed
the first row right so J will be equals
to 0 so then we'll print the first
element so J will be incremented to 1
and 1 is less than 3 then we will print
the second element that is 70 and again
J will be incremented to 2
and 2 is less than 3 so we will print
the third element that is 50 in the
second row and again J will be
incremented to 3 now the compilation of
the condition will result in false so it
will exit the second follow point but it
will come back to the first outer for
Loop now the value of I will be
incremented to 2 so 2 is less than 3 the
control will enter into the inner for
loop again then we will print the third
row of elements that is 10 12 and 78 in
the same way how we printed the first
row and the second row
after printing the third row the
condition will fail When J value is
incremented to 3 and it will enter the
order for Loop here the I value will be
incremented again from 2 to 3 and the
condition fails now the overall control
will come out of both the for loops and
it will terminate here
so that's how we got 9 6 1 44 70 50 10
12 and 78.
a linked list is a linear data structure
made up of nodes these nodes consist of
two parts data and reference to another
pointer
typically a linked list starts with a
head node which goes all the way up to
the last node which is called tail
next let's discuss why do we need linked
list a linked list is a linear data
structure like arrays but an array can
only offer a fixed size whereas a linked
list can dynamically increase its size
also operations like insertion and
deletion are much easier in a linked
list than in an array
now let's try to implement the link list
in the code editor
let's start by creating a node
to create a node we need a class
let's declare a class node
we will declare its member as public
the first member is end data
and the second member is node
pointer
next
now we will go into the main block and
initialize our first node
to initialize the node we need to use
node star
the node name had
equals to
null
similarly we will create more nodes
and our last node
tail
now we will allocate these four nodes in
the Heap to do that we will use a node
name
equals to
new node
star
new node braces
now we will allocate all the nodes in
the same manner
now we will assign data to our first
node
to access the member of the node class
we will use Arrow formation
then we will use data
equals to
let's give it a value as 2.
now we will link this first node with
that second node
to do that we will use add
same Arrow formation
and next
which will be equals to
our N1 node
and now we have created our first
complete node now let's create other
nodes as well
and one Arrow
data
is equals to
let's give it three
and one Arrow
next
is equals to N2
and 2 Arrow
data
is equals to
5
and 2 Arrow
next
to Arrow next
is equals to
tail
now L is equals tail Arrow data
equals to 7
and
Arrow next
is given
null
now let's call up function to print this
list
we will give head as the argument
as we we can only Traverse a linked list
from its head
let's write a definition for this print
list function
this function will be a void function
argument is node star
a
we will use while loop to Traverse this
linked list we will give its it
condition if a is not equals to
null
then
see out
is
a data
and L
now we will change our cursor from the
current node to the next node to do that
we will use a is equals to a arrow next
now let's try to execute this code
as you can see we have traversed a
complete linked list
now let's get back to our slides
now let's discuss different types of
linked list the first single linked list
next is the doubly linked list
the circular linked list and finally we
have the circular doubly linked list
let's discuss each one of these in
details
first up single linked list it is a
unidirectional linked list
while using the single linked list we
can only Traverse it in One Direction
that is from head node to the tail node
next up doubly linked list
it is a bi-directional linked list we
can Traverse it in both the directions
in this linked list the node has an
additional pointer that points to the
previous node
next up circular linked list
it is a regular linked list except for
its last node point to the Head node
programmer needs to be careful while
traversing it or they might get stuck in
an infinite Loop
next up the circular doubly linked list
it is a combination of w linked list and
a circular linked list
its last node points at the head node
and the previous pointer of the head
node points to the last node it is also
bi-directional linked list so that we
can Traverse it in both directions we
have now discussed the linked list why
do we need linked lists and types of
linked list now let's learn about some
operations we can apply on linked list
we can use majorly two operations on
linked list
first up insertion and deletion
we can perform these operations in three
different situations
first at the beginning at the last or at
a specific position after a node
next we will discuss these operations in
detail
first of insertion we will discuss first
insertion at the beginning
we have to give the first nodes address
to the new nodes next pointer to execute
this
next up insertion at the end
we have to give the new nodes address to
the last notes reference pointer
next up insertion at a specific position
to do this we will have to change the
reference address of the previous node
to the new nodes address and the new
notes reference pointer to the next
node's address
now let's discuss deletion
first up deletion at the beginning
we have to change the first node's
address to the null to execute this
next up deletion at the end
we have to change the second last node's
address to the null
next up deletion at a specific position
we will change the reference address of
the previous node to the next node's
address
we have learned a lot about linked list
during this session now let's discuss
some benefits of linked list
first up a linked list is a dynamic data
structure that is we can dynamically
increase its size
next it offers easy insertion and
deletion than other linear data
structures like arrays and string
since it can dynamically increase its
size resulting in no memory base stage
next it is pretty handy in implementing
complex data structures like stacks and
queues Etc
now let's talk about some disadvantages
as well
first up since the linked list is made
up of nodes it takes extra storage for
storing data and reference pointer
next the traversal in the linked list is
a bit harder than other data structure
reverse traversing is easy in doubly and
circular doubly linked list but since it
uses one extra pointer it takes extra
storage making it another limitation
so without any further Ado let's get
started with introduction to singular
linked list
a single linked list is a linear data
switcher made up of notes these nodes
consist of two parts data and reference
to the another pointer
these nodes can be traversed using
pointers
it starts from the head node all the way
up to tail node
now let's try to implement the singly
linked list in the code editor start by
creating a node to create a node we need
a class
let's declare a class node
we will declare its member as public
the first member is int data
and the second member is node
pointer
next
now we will go into the main block and
initialize our first node
to initialize the node we need to use
node star
the node name had
equals to
null
similarly we will create more nodes
foreign
now we will allocate these four nodes in
the Heap to do that we will use a node
name
equals to
new node
star
new node braces
now we will allocate all the nodes in
the same manner
now we will assign data to our first
node
to access the member of the node class
we will use Arrow formation
then we will use data
equals to
let's give it a value as 2.
now we will link this first node with
that second node
to do that we will use add
same Arrow formation
and next
which will be equals to
R N1 node
and now we have created our first
complete node now let's create other
nodes as well
and one Arrow
data
is equals to
give it three
and one Arrow
next
is equals to N2
and 2 Arrow
data
is equals to
5
and 2 Arrow
next
to Arrow next
is equals to
tail
now L is equals tail Arrow data
equals to 7
and
will
Arrow next
is given
null
now let's call up function to print this
list
we will give head as the argument
as we we can only Traverse a linked list
from its head
let's write a definition for this print
list function
this function will be a void function
argument is node star
a
we will use while loop to Traverse this
linked list we will give it it condition
if a is not equals to
null
then
C out
is
a data
and L
now we will change
now we will change our cursor from the
current node to the next node to do that
we will use a is equals to a arrow next
now let's try to execute this code
as you can see we have traversed a
complete linked list
now let's get back to our slides we have
now introduced the single link list now
let's discuss some of the operations we
can apply on a linked list first up
insertion
we can perform insertion at three
different situations like at the
beginning at the last or at a specific
position after a node
next up deletion similar to the
insertion we can perform it in three
different situations as well at the
beginning at the last or at a specific
position after a node
let's talk about them in detail first up
insertion at the beginning
to execute this we have to give first
notes address to the new nodes next
pointer
next up insertion at the end
to execute this we have to give new
notes address to the last node's next
address
next up insertion at a specific position
to execute this we will change the
previous nodes a reference address to
the new notes address and the new nodes
reference pointer to the next node
address now let's try these operations
in a code editor as you know a linked
list is made up of node so we should
start by creating a node to create a
node we need a class node
and they will Define its members as
public
and data
and
node pointer
next
now we will create a function to insert
a new node in front of the list
for this function as an argument we will
give the reference to the head of the
list
um
and integer dot new data
now in the definition we will allocate a
node
new node equals to
now we will put in the data in the new
node
we will use arrows to put to access the
data
equals to new
now we will make the next of this new
node as head
now we will move the head to point to
the new node
now we will create another function to
insert a node after a specific position
as arguments we will give it the address
to the previous node
and
repeat and the integer new data
we will first check if the given
previous node is null
it is we will print
foreign
and then we will return the function
otherwise
otherwise we will allocate a new node
and then we will enter the new data in
there
now we will make the next of the new
node as the next of the previous node
foreign
now we will write a function to insert a
node at the end of the list
as an argument we will give it
a node pointer to pointer
add
and integer new data
you will first allocate a new node
we will also create a last node
and give it
now we will put in the data in the new
node
since this new node is going to be the
last node so we will make its next as
null
now if the linked list is empty then
we'll make the new node as head
to check that we will use
if
star hat
is equals to equals to null
if it is then we will do
the head
equals to new load
else
we will Traverse it to the last node
while
last
null
last
is equals to
ask
next
now we will change the next of the last
node as new node
later
foreign
this list
while
node is not null
dot Arrow data
thank you
and
node
equals to
node
now we will write the code for the main
block
first we will Define a head node
and Mark it as null
now we will start using those functions
to make a linked list
first we will use append function
to add six in it
next let's let's use another function
push
foreign
in it
now we will try to insert one at the
beginning
so we will use push again
comma one
now let's try to insert 4 at the end
so far the list looks like one seven six
four null
now let's let's try to insert eight
after seven
to do that we will use insert
after
as argument we will use head next as 7
is present next to the Head
foreign
now let's try to print this linked list
C out
created
this
print list
add
return
let's execute this
as you can see we have created the
linked list in the correct order
let's get back to our slides now let's
talk about deletion first up deletion at
the beginning
to execute this we have to change first
nodes next address to null
next up deletion at the end
to execute this we have to change the
second last notes address to the null
next up deletion at the specific
position
we will change the previous node's
reference address to the next node's
address
now let's try these operations in a code
editor
we will start by creating a class
load
in this class we will declare the
members as public
print
data
and the node pointer next
now to insert a data in the node we will
use
foreign
push
as argument we will give pointer to
pointer node
head
and
integer new data
we will allocate a new node
we will give this new node the data as
new data
and
and new notes next as head
foreign
now we will write a function to delete
the node
as argument we will give a node pointer
to pointer
head
and end key
now we will store head in a temp node
foreign
ode itself holds the key to be deleted
we will use if
m is not equals to
null
and
temp
data
is equals to equals to key
then head
equals to
temp next
now we will free the old node
else we will search for the key to be
deleted
else
while
amp is not equals to
and
temp data
is not key
so Rev
equals to temp
and temp
will be iterated to its next
if the key is not present in the linked
list
then we will just return the function
else we will unlink the node from the
linked list
and delete
now we will write a print list function
to print the list
its argument will be a node pointer node
while
a node is not null
layout
less than
node
data
and we will iterate this node using node
equals to
load next
now we will move on to the main block
we will start with the empty list
node
start
head
equals to null
now we will add the element to this list
so push
ampersand
had
comma 7
.
next push
it
had
comma
2
push
ampersand
that is
comma
5.
next push
and percent
add
comma
nine
now see out
created
test
print list
add
now we will use delete node function
delete
to
we will use argument as a person head
comma
2
.
thank you now we will check the link
list
of
two
different test
let's try and execute this
as we can see we have deleted the two
from the linked list
our doubly linked list is complex as
compared to a single linked list in the
doubly linked list the traversal happens
in two ways forward and backward
Direction and each node consists of data
and address of the previous and next
node as it is clear from the above
diagram that the first nodes previously
spawning to null which means no more
notes before it and its next part is
holding the address of its next node
that is the address of second node
similarly second node previous is
holding the address of the first node
and next is holding the address of the
third node followed by that the third
notes next is pointing to the null
because no other node after it and its
previous is holding the address of the
second node this will continue as many
nodes are in the W linked list
and the elements are located at some
random location in the memory for
example as you can see if the first
element is inserted at the location 2000
then the next element would be located
at 2016 and then at the next relocation
and so on
moving ahead let's have a look at the
doubly linked list memory representation
let's consider one example and
understand the representation of a
doubly linked list so consider three
elements to be inserted into the list
where each node consists of data part
and address part of previous and next
node and it is stored at some address
2000 2016 and 2022
the address of the first node is stored
in the special node called Head node as
I discussed before
the first notes previous is pointing to
null because there are no nodes before
it and the last note next is pointing to
the null because there are no notes
after it
every node in a linked list is collected
in two ways from forward and backward
Direction with the other through the
pointers called previous and next that
points to the address of its previous
and next note
it is represented by the arrows in this
diagram
for example
so let our elements to be inserted be 10
20 and 30.
and the address of the first node is
stored in the head node
and the next part of the first note that
is this
is holding the address of the next node
that is 2016.
and its previous is pointing to the null
similarly the second node is holding the
address of the third node that is 2022
and its previous is holding the address
of its first node that is 2000.
whereas the third node the previous is
holding the address of its previous node
that is 2016 and its next is pointing to
the null and in this way they are linked
together
up next we have the syntax of a doubly
linked list
a doubly linked list consists of an
extra pointer compared to a single
linked list
so the syntax starts with a stuck
keyword followed by structure name
called note then we have the variable
stick light that is data and stuck node
asterisk next and previous a pointer
variables pointing to an element of a
structural node
so with this let's try to execute a
simple doubling Place program to
understand in a better way
so from this program we are going to
create
four nodes and insert the elements into
it so we have previously discussed this
syntax of a doubling list so here we
have a previous and next pointer
variable
so going ahead we'll see that we have a
head note and we are creating first
second and third and fourth note so
initially those are null so they are
initialized to null and for creating we
need to allocate the memory for it right
to create a node we need to create
memory for it for that we have we are
using analog function
to allocate memory for the note first
second third and fourth and once we
create memory we are going to assign the
values to it so here the values are 10
20 30 and 40. so these values are
assigned in the First Data part and the
second data part third data part and the
fourth data part of every node
and once after assigning we need to link
these nodes together so for that we have
the first next part is assigned to the
second that means it holds up the second
element
and its previous is assigned to null
because they are no node before it
and the second notes next part is
assigned to Third and its previous is
assigned to First similarly the third
next is assigned to Fourth and its
previous is assigned to the second note
and the last note that is fourth nodes
next is null because they are no node
after it and its previous is assigned to
third that means it holds the address of
a third
element
and now the first is assigned to head
that means the address of first node is
holding in the head node
and finally displays the first so this
display function we have to display all
the element in a doubly linked list so
this will
so as you can see here we got the output
the doubly linked list elements are 10
20 30 and 40.
okay so now let us move on to the
operations on a w linked list
first we have insertion operation next
deletion operation and finally traversal
operation so let's understand them in
detail
under insertion operation we have
insertion at beginning so basically we
insert the element at the beginning of
the element list next insertion at end
that means it inserts the element at the
end of the element list and lastly
insertion of the specified node that
means it inserts the element after some
specified node
so now let's run the program and
understand these operations practically
so using insertion operation we are
going to execute a simple program
so we have previously discussed that we
have two pointer variables that is
previous and next that is pointing to
its previous and the next node
and first let's discuss the insertion at
beginning operation so basically we are
going to insert a node at the beginning
of a linked list
so for that we are creating a new node
and allocating memory for it using
analog function once creating the memory
the new data part the new nodes data
part is holding the new data
and the next is pointing to the head and
its previous is pointing to the null
because there are no nodes after it
so if head is not equal to null that
means the heads previous is equal to Nu
and now mu is assigned to the Head
so it's simple now the head is holding
the address of a new node next coming to
the insertion at n
so here again we we are creating a new
node allocating memory for it and on
that new data is holding the new data
and its next is pointing to null because
there are no more nodes after it and we
are creating a temporary variable where
to hold the address of a head
so now if the head is equal equal to
null that means new previous is pointing
to the null and Nu is assigned to the
head and written while
the temp next if it is not equal to null
then the temp next is assigned to the
temp variable and the new now the new is
assigned to the temp next and temp is
assigned to the new previous
so now the last node is inserted
now coming to the insertion of the node
that means inserting in between of two
nodes so if previous node is equal equal
to null that means the given previous
node cannot be none
for that we are creating again a new
node and allocating memory for it using
analog function and its new data is
holding the
a new nodes data part is holding the new
data
and the new node next part is is
assigned to the previous nodes next
and Muse is changing the addresses so
now here previous node next is pointing
to the new
and
the previous node is now assigned to the
new previous
so if new next is not equal to null that
means new next previous is equal to new
so coming to the display here
while node is not equal to null it will
print all the node data till the till it
finds the null
and here
in the main function
we have we are creating a head which is
initialized to null initially and when
it comes the control comes to the
insertion at end
it will print a value 4. and next when
it encounters the insertion at beginning
function that means it will insert 2 in
front of the element 4 and again
insertion at beginning so it insert the
element 1 in front of element 2. and
similarly insertion at end that means it
will print element 5 after the element
4.
an insertion of the node head next that
means it will insert the element after
the element 2. so now let's try to
execute and run the program
so as you can see the elements are
listed
in a proper way that means we have the
elements 1 2 3 4 and 5.
followed with that we have deletion
operation to delete from the beginning
delete from the end and delete of the
specific node so now let's run a program
so now we are going to perform the
deletion operation so for that we have a
function called deletion node so
basically we are going to delete a node
from a list so first
it checks the condition if head is equal
equal to null or node delete is equal
equal to none that means a node to be
deleted is also equally or equal equal
to null then it will return that means
the deletion is not possible
next it checks the next condition if
head is equal equal to node delete
that means if a node to be deleted is
our first node
then
hit is equal to head notes next that
means the head note next is assigned to
the Head
next condition if node delete next is
not equal to null that means if it is
not the last node that means point the
previous next node to the node delete
previous
and finally if no delete previous is not
equal to null that means if the node to
be deleted is not the first node then
point the next previous to the delete
node node delete next and finally we are
going to free up the memory space for
that node
and coming to the main function where we
have print function after deleting an
element it gonna delete the node
so here after the head next one two
three fourth so after the fourth note it
gonna delete the fifth element that is
it will delete the last element five so
let's check the output
so as you can see
after deleting an element
so our previously inserted elements were
one two three four and five and after
deleting now the element fifth is
deleted
finally we have traversal operation
in this operation we visit each and
every node at least once maybe to
display all the data elements or to
perform operations on it so let's
understand it practically
so here we are going to perform a
traversal optician that means it
actually visit each and every node at
least once and display them so here
using a display function we are going to
display all the elements that are
present in a linked list so now let's
try to execute and run it
so as you can see first the inserted
elements were one two three four and
five and after deleting an element now
the elements are one two three and four
that means The Fifth Element got deleted
and now the final list of elements are
one two three and four
I hope you got it clear understanding of
how to perform insertion deletion and
traversal operations in doubly link list
now let's begin by understanding what a
circular single linked list is in C
in a circular linked list we can perform
a circular single linked list and
circular doubly linked list so this
session is on a circular singly linked
list
in the circular singly linked list there
is no null in any of the nodes instead
the last note's next pointer holds the
address of the first node so basically
there is only one pointer variable in
the circular linked list
and a traversal of a circular linked
list is until we reach the same node we
started in a list
let's have a look at the circular singly
linked list memory representation
foreign
so first let's consider four elements to
be inserted into the list and for that
we have four notes where each node
consists of data part and address part
stored at some address 2000 2016 2022
and 3000.
in the singly linked list the last node
points to none but when we compare a
circular linked list to which singly
linked list we don't find a null which
means in a circular linked list the last
note's next pointer holds the address of
the first node in other words we can say
that the tail loads address is pointing
towards the head node of the linked list
and as I discussed before every node in
a linked list is connected with the
other through a pointer that points to
the address of the next node
and that is represented by the arrows in
this diagram
for example
so later elements to be inserted be 10
20 30 and 40. as you all can see the
last node next is holding the address of
the first node that is 2000.
and the next part of the first node is
holding the address of its next node
that is 2016. similarly the second node
is holding the address of its third node
that is
2022 and the third node is holding the
address of its next node that is 3000.
and the last node is holding the address
of the first node and in this way they
are linked together
up next we have a syntax of a circular
singly linked list
the syntax of a circular single linked
list is similar to that of a single
linked list so we have a stuck keyword
followed by a structure name called node
then we have a variables declaration
that is data and struct node asterisk
next a pointer variable pointing to an
element of a structure node so with this
let's try to execute a simple circular
single linked list program to understand
in a better way
so in this program we have a pointer
variable called next
and inside the main function we are
creating nodes and they are first second
third and fourth so for every node we
need to allocate memory for it so using
mL of function we are creating memory
or we are allocating memory for it and
once allocating memory we are inserting
values into it and the elements are 10
20 30 and 40.
and once inserting value we need to link
each and every node so for that first
next is holding the address of second
node second next is holding the address
of third node and third next is holding
the address of fourth node and the last
note that is fourth note next is holding
the address of its first node and last
is equal to Fourth
and display function will display all
the elements in a circular single linked
list so it first check the condition if
the last node is equal equal to null
then the list is empty
pointer is equal to last nodes next do
so it checks the condition
it prints the values that is pointers
data it prints the data of every node
and then checks the condition while
pointer not equal to last notes next so
now let's try to execute
and here we got the output the elements
are 10 20 30 14 inserted into a circular
syn cleaning list
okay so now let us move on to the
operations on a circular singly linked
list
first we have the insertion operation
next the deletion operation and finally
the traversal operation
let's understand them in detail
under insertion operation we have
insertion at beginning so basically we
insert the elements at the beginning of
the element list next insertion at the
end that means it inserts the element at
the end of the element list and lastly
insertion after a specified node that
means it inserts the element of this
unspecified node
now let's run the program and understand
these insertion operations practically
so in this program we are going to
perform insertion operation so first
let's start with insert to empty list
so we are going to insert a new node
into an AMT list so if head is not equal
to null then return head create a new
node and allocate memory for it
and once creating memory
assign a data
and now the new node is equal to head
and head next that means creating a link
to itself head next is equal to head and
written head
and next we are going to perform
insertion at beginning so insert a new
node at the beginning of a linked list
so if head is equal equal to null then
return to insert to empty list function
create a new node and allocate memory
for it and then assign a value for a new
node it's a new data is equal to data
Now new next is equal to head next
so the new is the head node return head
next
we are inserting an element at the end
of our linked list so for that it checks
the condition if last is equal equal to
null return to insert to empty list
function
and create a new node allocate memory
and assign a data
and now link the address so new next is
equal to last next now the new node is
the last next
and written last
we have insertion of the node so it
checks the condition last is equal equal
to null then return none
else we have we are creating here the
new and a pointer variable
pointer is equal to last next so do if
pointer data is equal equal to element
that means if we find the element then
allocate memory for the new node and
assign a data
and now new next is assigned to pointer
next
and now the pointer is assigned to the
pointers next and if pointer is equal
equal to last
then assign new to last and return last
pointer is equal to pointers next so
while pointer not equal to last next the
given node is not present in the list
and written last
we have display function where it
displays all the linked list elements
so for that is check the condition if
head is equal equal to null then the
list is empty
s it will print all the elements of a
node
so now
coming to the main function here we have
inserting values there are 20 25 10 15.
so first insert to empty list so we are
inserting the 20 to the empty list that
is the first element is 20 and then
coming to insert at end after 20 it will
bring 25
and insert a beginning so before 20 and
25 it will insert element 10. and insert
often note that means after 10 it will
print 15. so now let's execute and see
the output
as you all can see it is printed in a
order 10 15 20 and 25.
followed by that we have a deletion
operation to delete from the beginning
delete from the end and delete after a
specific node
so now let's run a program
so in this program we are going to
perform a deletion operation so we are
basically deleting a node
so for that we have a delete note
function it first checks the condition
if last is equal equal to none that
means if the linked list contain no
elements then it return
else it will check whether the list
contain a single element so if last data
is equal equal to Keynote and large next
is equal equal to last then free the
last and assign last is equal to null
and return
next creating a temp variable is equal
to last and delete note
so here it will delete a last node so
for that if last data is equal equal to
Keynote
and why temp next is not equal to last
and assign temp next to temp
so here
the last next is assigned to Temp next
and free the last
and temp next is assigned to last
then we are traversing to the node or we
are finding the node to be deleted so
for that we have y 10 next is not equal
to last and temp next data is not equal
to Keynote then assign temp next to temp
and
if the temp next data is equal equal to
Keynote that means if you find the node
to be deleted then assign the temp next
to delete node and delete note next to
Temp next and free up the delete note
space
and then coming to the main function
it prints after deletion the linked list
elements so we are going to delete the
element 15 from the list and it displays
the element so now let's execute it
so as you can see
here the linked list elements were 10 15
20 and 25 so after deletion that means
we deleted the element 15. so after
deletion the linked list elements are 10
20 and 25.
and finally we have traversal operation
in this operation we visit each and
every node at least once maybe to
display all the data elements or to
perform operations on it so let's
understand it practically
so in this program the display function
works as a traversal so it travels the
every node in a linked list so basically
it first checks the condition if head is
equal equal to none then the list is
empty it prints the list is empty if it
does not find any node in a linked list
then it returns now assign the head next
to pointer so that it prints the
data of every node
and checks the condition while pointer
not equal to head next
coming to the main function here we have
it prints the elements of a linked list
that means after the insertion and
deletion operations it will print all
the elements present in a linked list so
now let's try to execute it
so here linked list elements are 10 15
20 and 25 so after deletion the linked
list elements were 10 20 and 25 then it
displayed the elements after deletion
and insertion the elements are 10 20 and
25 so the final linked list elements are
10 20 and 25.
so at first what exactly is an array so
an array is a linear data structure that
stores homogeneous data elements in a
continuous form so homogeneous in the
sense you will be able to store only one
single data type of elements in an array
for example consider that you have
declared an array and you wanted to
store some elements in the array so you
can declare a data type first after that
the name of the array and if you declare
that the array should store integer data
type then you can only store integer
elements in that particular data type
you cannot store any other data type
like float or character that is the
meaning of this particular definition
and it stores the elements in a
continuous order that is in the adjacent
format as you can see in the example
here 10 20 30 40 and which are located
in the adjacent location status 0 1 2
and 3. now let us understand what
exactly is a linked list
so similar to Ari even a linked list is
a linear data structure but the only
difference is it has a dynamic data
structure here you can increase or
decrease the size of the linked list in
runtime the only difference is here the
memory locations are not adjacent to
each other but they are taken from the
memory here so there is a huge memory
chunk out of that the linked list will
borrow some of the memory locations and
one after the other the memory nodes
will be interconnected using pointers so
that was the difference between array
and linked list and similar to arrays
even the linked lists store homogeneous
type of elements that is if you declare
a linked list of float data type then
you can only store flow data type in it
you cannot store any other different
data type like character or string
now followed by that let us understand
the types of arrays so basically we have
three different types of arrays those
are the one dimensional arrays and
inside multi-dimensional arrays we find
two more types those are the two
dimensional arrays and three dimensional
arrays now one dimensional arrays will
be having only one subscript that is
where they'll be having only one single
row whereas in the two dimensional
arrays we will be having two subscripts
that is it will be having rows and
columns and in the three dimensional
arrays it will be having three
subscripts that is the row column and
the block address now followed by the
types of arrays we will understand the
types of linked lists
so similar to Iris even linked lists are
divided into three types they are singly
linked lists doubly linked list and
circular linked list the difference
between them is a single linked list
will have two parts that is the node
address and node element in this
particular segment the element will be
stored and in this particular second
segment the address that points that the
next node will be saved and similarly in
the circular linked list the only
difference between the single linked
list and the circular linked list is at
the end of the single linked list you
can see a null pointer which indicates
the end of the linked list but in
circular linked list the address will
not be null instead it will point back
to the Head node that is what which
makes it as a circular typed singly
linked list or a circular linked list
when it comes to the third type that is
the doubly linked list we can see there
are two address locations the first
starting node will have null as its
first address location then we'll store
the element and the second address
location will point to the next node and
you can see in the second node we'll
have element and the first address
location will point to the previous node
and the second address location will
point to the next node and at the end
the second address location will be
pointed as null which indicates as the
end of the linked list now that we know
the types of linked list and arrays we
will look into the fundamental
differences between arrays and linked
lists
so the First Fundamental differences
between the arrays and linked list is
the array element can be accessed
randomly using just the index values but
whereas Random Access is not possible in
linked list if you want to access any
element in linked list you need to
perform the Traverse operation
sequentially
the second difference between the both
is array is static which means memory
size is fixed which cannot be changed in
runtime but whereas in the linked list
the memory is dynamic which means you
can either shrink or expand the memory
in runtime according to your
requirements
followed by that the next difference is
each element in Array is independent in
nature that is you can access any
element just by giving the index
location whereas in linked list the
elements are interdependent on each
other whenever you want to access a
specific element you need to go through
the other elements or Traverse through
the other elements
next one is the array takes more time in
operations like insertion and deletion
whereas linked list takes less time to
perform the operations of insertion and
delete
followed by that the next difference is
accessing any element is faster in re as
random access is possible and the array
data structure just by using its index
values but whereas accessing an element
in linked list is slow because we know
that we need to Traverse through all the
node elements to access a particular
element
now the next difference is in case of an
array memory allocation is done in
compile time whereas in linked list the
memory allocation is done during the
runtime
memory utilization is inefficient in an
array as it is allocated as in static
and it is allocated during the compiled
time in case of linked list the memory
utilization is very efficient as the
memory is allocated during the Run what
is a stack
so basically stack is a linear data
structure just like arrays and linked
list the only difference is that it
follows a specific order when an
operation is implemented on it so what
is the specific order that it follows
that is lifo last and first out or filo
first in last out in the next part we
will understand this order in a much
better way
all operations can be done only at the
one end of the stack that is on the top
now we will discuss much about that in
the operations part of the stack now let
us understand the First Fundamental that
is the representation of Stack that is
how do you represent a stack normally
so a stack can be represented using two
different methods that is using an array
or using a linked list so in an array we
will be using the continuous memory
and in stack we will be using a
non-continuous memory and the stack will
behave like a dynamic stack or a dynamic
data structure
now the first method that is the array
method
so in this method an array is used to
represent the stack as you can see in
the image below we have a stack
so the name of the stack is stack itself
and you can see two more things here
that is dot is equals to 2 and Max is 4.
so the max is the value of the array or
the length of the array the maximum
length of the array and top is the
position where the last element of the
stack is present here in this case 56 is
the last element in the stack and top is
inclined or it is addressing to that
particular address that is too
and now let us discuss about the linked
list representation of Stack
so in this method a dynamic data
structure that is a linked list is used
to represent the stack this
representation leads to a dynamic stack
it does not need to define the maximum
number of elements present in the stack
remember in arrays we had to define the
max value in the previous example we had
the max value as 5 but in here you need
not to assign the max value as the stack
itself is dynamic
the pointers links are used to store the
address of the upcoming notes and the
variable used in this method is top so
the top is holding the address of the
top most element in the linked list
representing the stack
now moving ahead we shall understand the
basic operations on stack now here we
will understand the previously discussed
definition that is Push Pull
Etc in a much better way so the basic
operations on a stack are push pop or
pull and Peak
now let us discuss each one of them in a
detailed way the first one is push
operation so the push operation is the
mechanism of inserting a new element
into the stack
as you can see we are trying to insert
the elements from the top so the push
operation basically involves the
following steps check if the stack is
either full or not so basically whenever
you are trying to insert an element into
the stack you need to make sure that the
stack is empty or it has some space if
it is full you cannot insert an element
into the stack Step 2 if the stack is
full produce an error and exit that's
what I was talking about now the step
three
if the stack is not full increment the
top by one that is when you're inserting
an element then you need to update the
top value for example in the previous
slide when we had the array
representation of a stack we had the Top
Value as 2. so if you try to include an
element into the stack then you need to
update the Top Value from 2 to 3 that is
incremented by one
now the fourth step add data elements to
the stack where the top is pointing
and finally success the push operation
has been successful so this is how you
insert or push an element into the stack
now followed by push operation we have
pop or pull
so the pop operation is a mechanism of
eliminating or deleting or removing one
data element from the existing stack
so we shall understand the
pop operation in a much more detailed
way the operation involves checking the
stack is empty or not if in case the
stack is not empty then you can carry
forward the pop operation but in case if
the stack is empty then you have to
provide an exit status and exit the
control and leave the stack
so if the stack is not empty approach
the data element at the top that is at
the top position for example in the
previous array example remember right we
had the top position pointing towards
two so you need to take the control to
the top position and pick out the
element and popped
and finally decrease the top by one so
when you eliminate the top element then
the Top Value from 2 will be decremented
to one so this is how the pop operation
is carried over on a stack
next one is
the peak operation the peak operation
involves returning the topmost data
element from the stack without moving it
so here you can see the top is pointing
to the element number four and you're
picking the element number four and
you're not removing it from the stack
you're just returning the topmost data
element you're passing the value of the
top element
so to understand the push pop and Peak
operations on Psych in a much more
better way let's carry out a practical
example now we are on the Practical mode
and here you can see on my screen we
have the code example for the stack now
first we'll be checking if the stack is
empty as per the steps mentioned in the
previous discussion we will check if the
stack is empty or not if it is empty
then we will return else we will
continue and again another step we also
check if the stack is full if the stack
is full Whoever likes it else we will
continue with the operation whatever it
is speak pop or push and here we have an
example for the peak operation that we
discussed previously and followed by
that we have a pop operation we are
trying to exclude an element from the
stack and another one we have the push
operation where we'll be trying to push
the elements into the stack so these are
the three functions for push pop and
Peak now we'll try to push in the
elements and also pop and
try to involve some functions on it or
run some operations on the stack now
let's run this code and see the output
so you can see that the code has
successfully executed and we have the
statements here the first one says this
tag is not full that is false and stack
is empty that is true right and after
that you can see that the elements which
we try to push into the stack that is
1176 71 15 and 66 are been pushed into
the stack and if you clearly observe it
we have The Element 11 in the bottom 76
upon that 71 upon that and 15 and last
66 so the order is first in last out
that is the first element was pushed
first and when you are trying to
eliminate the elements from the stack
then you will first pick out 66 followed
by that you will pick out 15 followed by
that you'll pick out 71 and so on so
this is the rule what stack follows now
I hope I made myself clear with the
example now we should continue with the
applications of check
so these are the few applications of
Stack the first one is expression
conversion so you can see we have the
infix notation prefix notation and post
fixed notation so the infix notation is
no rocket science there is only one
thing here to learn that is we have two
operands A and B and we have one
operator that is the addition operator
in between those two operands and when
you use the prefix notation you will
have the operator located at the first
place then you will have the operands
followed by it
and in the post fix one you will have
the operands first and followed by the
operands you will have the operator
so basically all the infects prefix and
postfic notations give out the same
results but the only difference is the
representation of those operands and
operators
now let us understand this in a much
more detailed way
so conversion of expression from one
form to another form is the main
application of stat so we have the first
one that is in fix to prefix and infix
to post fix now let us see an example
here you have one plus two star three
plus four so this is the normal infix
notation and when you try to present the
same expression in the form of prefix
notation so this will be the result and
this is a result for post Twix
the next one prefix to postfix and
prefix to infix and this is the way you
write the prefix notation and if you
want to convert that to infects this is
how you can write it and this happens to
be the result of post fixed notation
and finally post fixed or prefix postfix
to nfix and these are the results
now followed by expression evaluation
the next important application of Stack
is checking parenthesis
you can see if the parenthesis is set
properly the expression gets evaluated
if not it will not be evaluated
now the last one memory management and
function call the very useful thing of
using a stack is the memory will not be
allocated to your stack elements unless
the function is called here you can see
it is the main function and these are
the elements that you wanted to declare
into your stack and unless you make a
function call the elements will not be
declared their memory or the elements
will not get the memory allocated for
them
now another good application of Stack as
the backtracking problem or the end
Queen problem
the end Queen problem is an example of
backtracking properly the end grain
solution to this problem is to position
the queen in such a way that the
opponent Queen cannot attack your queen
now another example is string reversal
you can see on my screen we have a
string that is a b c d and e Now using
Stacks you can reverse this
right so you're basically eliminating an
element and relocating it to the first
place
and finally after reversing your string
this will be your result A B C D and E
followed by that we have conversion
evaluation
so stack is used to evaluating the
expression as shown in the example
since parenthesis has the highest
precedence 5 plus 4 gets evaluated first
and it will result in 9. then
multiplication and division have the
same precedence now the associativity
comes into picture so the associativity
is always from left to right so first 4
into 9 will be executed which will
result in 36 and then 32 divided by 4
which will give us 8.
now we have 36 minus 8 which will give
us an answer that is 26. now the last
application is the Tower of Hanoi so the
Tower of Hanoi is a mathematical puzzle
consisting of three rods and N discs
this puzzle consists of some rules
the first rule states that one disk can
move only at a time the second rule is
that the disc can only be moved when it
is at the uppermost position on the
stack
the third one no disc is allowed to
place on the top of the smaller disk
so this is how the Tower of Hanoi works
so stack is a linear data structure that
follows fifo or first and first out
principle all the operations on the
stack are done only from one end that is
the top
so you can see this image here and this
particular image of books can be
considered as stack and you can see that
the addition or elimination of elements
that a spokes in this particular case is
happening only through the top section
now we will understand what are the
basic operations that can be performed
on a stack so the basic operations that
can be performed on a stack are push pop
and Peak
so this particular image on the right
side will help you understand what
exactly is push pop and Peak as we
discussed the elements will be added
into the stack from the top so when you
add an element from the outside into the
stack it will be pushed from the top
that is the push operation and if you
want to eliminate an element from the
stack it will be eliminated from the top
that is the pop operation
apart from these two that is push and
pop we have another operation that is
called as Peak the main intention of p
is just to see the element which is on
the topmost part of the stack it will
just retrieve the element from the top
it will not pop it or it will not push
any other element onto the top it will
just copy and it will just print what is
present on the top so these are the main
operations that is push pop and Peak
now let us see how to implement this
stack using array
so implementation of Stack data
structure can be done in two ways that
is array and linked list
now in this particular session we will
learn how to implement stack using array
data structure now without further Ado
let's get started with the
implementation of Stack
so we will be performing push operation
that is inserting a new element into the
stack
now followed by that we will be
performing the pop operation onto the
stack that is eliminating or deleting an
element from the top position of the
stack
and followed by that the last operation
that is the peak operation where we will
be just retrieving the topmost element
from the stack without removing that
element from the stack or without adding
any new element to the stack now that we
have a detailed understanding of what
are the basic operations that can be
applied onto the stack let's get started
with the Practical implementation
now you can see that on my screen we
have the basic fundamental operations
Ultra stack that has the push and pop
now without further Ado let's get
started with running this code don't
worry about the code this particular
code will be present in the description
box below or if you need it you can
always write down to us in the comment
section below and we will have it sent
to your mail ID so that you can have a
better understanding of the code and try
to execute the code in your local system
now let's run the code and see the
output
as you can see the code got successfully
executed and the topmost element is a
and the topmost element is B after the
element is being popped away and it says
that the element B was popped out and
after that the topmost element was a and
after that the element a was also popped
out and now the top is pointing to -1
which means to say that the stack is
empty so with that we have come to an
end of this tutorial on stack
implementation using Ari data structure
so first up what exactly is a linked
list so linked list is a dynamic data
structure it allocates memory
dynamically the nodes are maintained in
a non-continuous memory that is in
linked list we have nodes so each and
every node is connected via a pointer
which points to the address of the next
node
each node contains next pointer that is
the next Pointer's address which gives
the reference to the next node and it
also has another section which stores
the data the topmost node always
contains null in its address
and this is how a linked list looks like
so this is the top which is the
beginning position of the linked list
and this is the address of the first
location and this is the next node this
is the following node then this is the
last node and this points back to the
Head node so this is how you can
Implement a stack like data structure
using linked list you can see that we
can perform stack like operation that is
the elements are located one above the
other and the top is pointing to the
Head node now let us go through the
implementation of Stack using linked
list first we will go through traversing
off stack using linked list so
displaying each node of the linked list
representing stack is termed as
traversing copy the head pointer to the
temporary pointer and then move
temporary node through all the nodes and
display values of each node
so you can see the animation here will
explain you how the traversal goes
through the linked list in real time
now another linked list implementation
of Stack is the push operation
so adding a new node to the top of the
stack is termed as push operation
generally in stack we have three
operations that is push pop and Peak so
one of the operation is pushed where you
add an element into the stack in the
same way using linked list you can add a
new node to the stack and point it as
the top of the stack or the first
element which represents the top in
terms of Stack
now create a node first and allocate a
new memory to it if the list is empty
and node consists of data and null is
the address it will be inserted as the
first node if there is some node already
existing then add a new node at the
beginning to avoid violations
so the following animation will help you
understand how we add a new element or
the top element to the stack using
linked lists
now followed by the push operation we
have the pop operation
so now let us go through the pop
operation removing a node from the top
of the stack is turned as Pop operation
in the same way we will be eliminating
the first node from the linked list
which is termed as dot underflow
condition may occur when you try to
remove the node if the stack is already
empty
Instax node can be removed from one end
only therefore the value stored in the
head pointer must be deleted and the
node must be free
followed by the pop operation we have
the peak operation
retrieving the topmost node of the
linked list representing stack without
removing the linked list node from the
top of the stack is terminal speak
operation generally when you are using a
stack data structure just retrieving the
value of the top node is called as Peak
operation you are not going to eliminate
or you are not going to add a new
element to the top you are just going to
copy the element or you are just going
to retrieve the element which is pointed
as talk this operation is called as Peak
now in the linked list you can also
perform this operation of peak now with
the theory discussed let us execute a
practical program based on stack
implementation using linked list
now on my screen you can see a code
example using which we will Implement
stack using a linked list now here we
have the pop Operation Push operation
and top and then the main function don't
worry about the code this particular
code snippet will be attached in the
description box below or you can also
request us and we will have it sent to
your mail ID and you can understand the
code and try executing in your local
system now without further Ado let's
directly run the code
so there you go the code got
successfully compiled and we have tried
to add some elements into the stack that
is A B C and C is being the topmost
element of the stack and that element
has got popped and followed by that the
element on the top currently after C
being popped.s B and the node element B
got popped again and the only element
which is present in the stack is a and
that element is also popped out after
performing the pop operation and now
currently this stack is empty you can
see that we have tried to push the
elements ABC and also we try to pop the
elements APC
you know that all of us depend on
messaging applications like WhatsApp
Facebook Messenger Instagram chats to
communicate with our friends and family
members and while using them you must
have observed that the person you are
trying to communicate with receives
messages in the same order as you have
sent them now the question that arises
here is how is this happening how are
these applications maintaining the order
of these text messages and the solution
to these questions bring us to queue
basically in these applications a queue
is maintained for each user containing
the messages to be delivered to the user
when the user connects to the network
all the text messages in the queue gets
delivered and once the messages are
delivered mtqs get deleted
this example clearly illustrates the
importance of data structures so let's
dive further and understand the
structure of the queue in depth
but before doing that let's look at a
real life example of cues to understand
it more clearly
the most common and relevant example of
a queue is a movie ticket counter
in the movie ticket counter you must
have observed that both of its ends
remain open also these ends are fixed
with the help of parakeets and that is
why no one can enter in between these
ticket lines
Additionally the person who enters first
receives a ticket first and the person
who enters last will obviously get
served at last cues and data structure
resembles all these properties of a
movie ticket counter which makes them
better at creating virtual first come
first serve systems basically they are
defined as a linear collection of
different data types that allow
insertion at one end and deletion at
another
unlike any other data structure the
queue ends remain open allowing it to
have different functionalities at both
ends the end at which insertion takes
place is called rare
and the end at which deletion takes
place is known as front
furthermore there are two approaches to
consider the structure of the queue and
both of them depend on the approach of
the programmer that means being a
programmer if you consider the left tent
as front then your rare node will be at
Right End otherwise if you consider the
left hand as rare then the Right End
will be your Q's front node
unlike Aries and linked lists elements
in the queue cannot be operated from
their respective locations here they can
only be operated from the front or air
position moving on let's discuss the
operations in Q data structures one by
one
the first operation is NQ it is used to
store the elements in the queue
next up is DQ this operation is used for
removing them
further we have is full and isnal
operations is full function scrutinizes
if the queue is full or not and the is
null operation evaluates if the queue is
empty
we also have a peak operation that helps
you get the element from the front of
the queue without removing it
let's Now understand how these
operations work with the help of the
following examples
here we will look at nq5 and q1 and Q
minus 2 then is full then DQ Peak and is
null
but before explaining these operations
it's essential that we initialize the Q
data structure by assigning some random
size to it
for example intq of 3 by this
declaration we are assigning only three
spaces for insertion in Cube
also at this phase there is no element
in the queue as it's empty so both the
front node and rear node will point to
the same location with null memory space
in the storage system let's consider
that null index to be -1 for ease of
arcan mention now the first operation on
our list is NQ of 5.
as we discussed previously NQ operation
is nothing but the insertion of data
into a queue data structure it begins
with checking if the queue is full or
not
if the queue is full then the previously
assigned memory is completely filled
with data elements so insertion would
not be possible this is also known as
overflow error in terms of programming
but as IQ is empty so the insertion can
be performed here for that we have to
increment the rare pointer to index 0
from index -1
and once we do that the data element 5
will be added to the queue also for
front insertion both front and rear will
point to the same location as there is
only one element present in this queue
let's insert two more elements into this
queue with the operations in q1 and then
Q minus 2.
for that we have to increment the rare
pointer to the next index which will be
1.
now as the point is incremented so the
data will be entered into this position
next up is NQ minus 2. again we have to
follow the same process of incrementing
the rare pointer we will increment the
rare pointer to point towards the next
index that is index 2 and hence the data
element with value -2 will be entered
here
the next operation on our list is is
full
in this operation if the rare pointer
points to the max size then the queue is
considered to be full as there is no
space left for insertion in our case the
max size of RQ is 12 bytes
additionally we are considering to enter
only three integer elements
and one integer data element takes four
bytes of the memory space that means
three integer elements will take 12
bytes hence this function will prompt Q
is full on the screen
now we will discuss the DQ operation if
we want to access data from a queue we
have to perform two subtasks the first
one is access the data where the front
is pointing and another is to remove the
data after axis and this complete
process is called as DQ operation
the first step of this operation is to
check if the queue is empty
if the queue is empty then there is no
element available for deletion this is a
case of underflow error
but SRQ is not empty we can proceed with
the next steps we will be accessing data
from the front node and later we will be
incrementing the front pointer in order
to remove the link to the previous note
so that the data gets removed now front
will point to the index 1.
thus the data value Phi will be removed
from the queue and will also be prompted
on the screen therefore this function
comes with an integer return type
next up is Peak operation
in this operation element at the front
node will be accessed without deleting
it
the algorithm for this operation begins
with checking if the queue is empty or
not
if the queue is not empty then data at
the front node will be accessed with
temporary variable and printed on the
screen
advancing further let's perform two more
DQ operations here first is DQ of 1 and
another one is DQ of minus 2.
the data at a French node will be
accessed primarily and the front pointer
will be incremented to point to the next
data element
when we do the point incrementation the
link to the previous node gets removed
which results in data deletion
similarly we will perform a DQ of -2
operation here now the front will be
pointed to null memory space as there is
no element left in RQ and the data minus
2 will be removed
the last operation on our list is smt
this function checks if the queue is
empty or not in the previous procedure
we mentioned that if the front points to
the null memory space then the queue is
empty and in our case the front is
already pointing to -1
so the output of this function will be Q
is empty
this is all about operations in the
queue I hope that you all are clear with
these operations
next we will discuss different types of
queues and their structures at a glance
basically there are four types of cues
linear queue circular queue priority
queue and double ended queue
the structure which we have discussed
till this time is that of a linear queue
so now we will move on to Circular queue
the circular queue is almost similar to
the linear queue except that the last
node of this queue is connected to the
first
it is also known as ring buffer as all
the ends are connected to another end
additionally this circular queue is a
better version of the linear queue as it
removes the drawback of insertion in the
linear queue
the empty space available in a circular
queue can be filled with the new element
by simply incrementing the value of the
rare position we will learn about this
in detail in the further sessions
a priority queue is another special type
of queue data structure in which each
element has some priority assigned with
it
based on the priority of each element
the elements are arranged in a priority
queue if the elements occur with the
same priority then they are served
according to the first and first out
principle
in the priority queue the insertion
occurs based on the arrival while the
deletion occurs based on the priority
the above figure shows that the highest
priority element comes first and the
elements of the same priority are
arranged based on the first in first out
structure
the last type of queue is DQ
DQ is a linear data structure in which
the insertion and deletion operations
are performed from both the ends we can
say that DQ is a generalized version of
the queue
DQ can be used as stack as well as Q as
it allows the insertion and deletion
operations on both the ends
if the insertion takes place at one end
and deletion at another then that EQ is
known as a linear queue and if both
addition and deletion are performed at a
single end then that EQ is called stack
advancing further let's discuss some
applications of cues to gauge an insight
into the importance of cues
the Q data structure is used in
computers printers and applications to
utilize the benefits of the first come
first serve technique
in computers whenever you work on
documents or ppts you must have observed
that whichever key you press on the
keyboard appears in the exact same model
on the screen but when your processor is
too busy with other tasks you might
notice that the keys you press appear on
the screen with some delay after you
press them basically those keys are
stored in queue and when the processor
becomes free it processes in the order
the keys are pressed that means the key
pressed first will be written in a Word
document first
so this is how computers use a queue to
eliminate Deadlocks when multiple
processes are in a ready state
next up is printers
a q data structure is used in Printers
to maintain the order of pages while
printing that means the pages are stored
in a queue in the order that you want to
print them and once the page is removed
from an ordered queue it gets printed
another most common application of queue
data structure is their usage in web or
mobile apps
applications like Domino swiggy uses a
queue for maintaining food order status
if you place an order from an online
portal your order ID enters the queue
and once the previous orders before your
order ID gets catered then your order
will be catered as well
from these examples we can clearly say
that queues are used Whenever there is a
need for an fcfs strategy in software
development so whenever you work on
projects that need a first come first
serve approach then remember that you
have to implement a q data structure to
complete it successfully
finally let's have a look at some key
takeaways that we discussed in this
session
we started this session by examining the
structure of the queue we learned that
the queue is a linear data structure
after that we talked about different
operations of queues in which we learned
enqueue and DQ are responsible for data
manipulation in a queue later we discuss
different types of queues as well
finally we discovered some applications
of cues and how they fulfill the need of
fcfs systems
we have also made it clear that cues can
handle multiple data types as well we
will be discussing about stack versus
queue primarily we will discuss the
definitions of both these data
structures first the stack is a linear
data structure similar to arrays and
linked lists restricting the random
access of elements in the case of arrays
or linked lists you can access Elements
by either traversal or random indexing
which is reframed in stack data
structure
you can understand the stack by
visualizing it as a container of
elements in which elements can only be
placed on top of each other
and remove from that same direction only
stack as a data structure in computer
science is not very different from stack
as a way of organizing objects in the
real world
so stack can be thought as the way you
arrange books stacked on top of each
other these books can only be placed
upon each other from the top end
furthermore to remove any particular
book you will first have to remove books
stacked over it this scenario accurately
depicts sequential book access
equivalent to the stack data structure
in computer science
queue in data structure is also a linear
data structure like a stack having some
restrictions on insertion and deletion
in the case of Q insertion is performed
from one end and the removal is
performed from another or opposite end
the qn data structure can be understood
using the real life example of a food
Coach Line in any food Coach line or a
movie ticket counter line the customer
who enters first always gets served at
first and the customer who enters last
will absolutely get served at last
furthermore both the ends of these
queues remain open performing different
operations
the rear end of the food court queue
performs the insertion of a customer
whereas the front-end performs the
removal of the customer after providing
him with the service that he desires
both the stack and queue data structures
follow the different operational
principles to execute data manipulation
operations
the stack data structure follows last in
first out or first and last out
principles to execute its operations
in simpler words the stack data
structure removes the last inserted
element at first and the first inserted
element at last let's understand the
principles mentioned about with the help
of an example
as you can see in this example tree is
the last inserted element and if we
start removing elements from this stack
three should get removed at first and
seven should get removed at last unlike
stack the Q data structure follows fifo
which is the first in first dot
principle to execute its operations
according to this principle the element
which gets inserted in a list at first
gets removed at first as well
for example in this queue 6 is the
element which is inserted first
so while performing the deletion it
should also get removed before all the
other elements inside the queue
moving forward let's discuss different
data manipulation operations for both of
these data structures
the first parameter that we will talk
about is the insertion operation
the process of inserting data entities
in the stack is called a push operation
this operation can only be performed at
the top end of a stack
for instance consider the simulation of
Stack inserting few data elements the
elements that are getting inserted
inside the stack are of homogeneous data
type
thus we can see that stack can only
store one type of data element the
insertion of elements in a queue data
structure is referred to as an enqueue
operation it gets executed at the rare
end of a queue
the simulation given in this section
represents the execution of R and Q
operation
the next data manipulation operation we
have on our list is deletion
the deletion of data entities from stack
data structure is achieved using pop
operation the deletion of data entities
from stack data structures is achieved
using pop operation this operation
removes the elements where a top pointer
is pointing thus we can see that the
stack performs the removal of data
entities from its top end
the simulation shows how the removal of
elements happens in the case of a stack
data structure
now let's move to the deletion in queue
data structure
the process of deleting data elements
from the Q data structure is called DQ
this operation is usually performed at
the front end of a queue
the simulation given below represents
how deletion happens from the front end
of a queue abiding with the first and
first out principle
both of the data manipulation methods we
reviewed earlier can be matched with
previous real-life examples what I mean
by that is
the book stacking system can only place
books at the top end as well as it can
remove them from the top end only
furthermore The Waiting queue analogy is
deemed to be consistent with Q data
structure because it adds people from
the back end and removes them from the
front end
now here's interesting question that we
want you all to answer
so until now we have understood the
structural differences between stack and
queue data structures and both of these
data structures can be implemented using
static or dynamic data structures
So based on your comprehension of these
data structures which implementation
strategy for constraint memory
management is the best choice
the first option is array implementation
static and your second option is linked
list implementation Dynamic do think an
answer it will be interesting to see how
many of you all will get this right
so guys leave your answers to this
question in the comment section Below in
a week's time we will be announcing the
right answer and you all can check it
out
so moving ahead we will discuss about
the pointers maintained in the case of
both these data structures
for stack data structure our ADI only
remembers one location that is the
address of the topmost element
this tracking of a topmost element is
achieved using one pointer which we name
as a top for our convenience
whereas in the case of Q we maintain two
pointers named front and rear the rare
pointer points to the last inserted
element in the queue and the front
pointer points to the first inserted
element in the queue
we use and maintain these two pointers
to execute different operations at both
the front and rear ends
the last parameter that we have for
differentiating stack and queues is when
to use which data structure
the stack data structure is mainly used
to solve problems that are recursive in
nature for example memory management and
programming environments the resource
allocation and execution of the programs
is a repetitive process based on the
invocation of different function calls
and stack is the basic memory management
architecture for any modern Computing
environment a stack is at the heart of
the runtime environment for Java C C
plus plus Ada Fortran and other
languages which is independent of their
native codes like x86 sun or wax
the stack memory management unit is
compatible with old and new operating
systems including Windows nt10 Solaris
and Linux runtime environments
the next applications of the stack on on
list are expression handling and
backtracking algorithms
the expression handling algorithms
evaluates the output for arithmetic
operation closed inside the parenthesis
the stack data structure is also used to
perform expression conversions as infix
to postfix in fixed prefix postfix to
infix or prefix to infix
furthermore the backtracking algorithm
is also implemented using a stack this
algorithm moves backwards in perform
steps to evaluate a more Adept solution
now let's discuss about Venture use
queue data structure
the Q data structures work on sequential
processing of data hence whenever your
application needs a sequential
processing a queue data structure can be
implemented
for example
Q is used in messaging applications
you are probably aware that we all rely
on messaging apps like WhatsApp Facebook
messenger and Instagram chat to interact
with our friends and family
and you must have noticed that the
person you are attempting to communicate
receives a messages in the same sequence
as you have sent them irrespective of
whether he's online or offline
actually the queue is implemented in
messaging applications at the user's end
containing the messages to be delivered
to the user
so when the user connects to the network
all the text messages in the queue gets
delivered and once the messages are
delivered mtqs get deleted
the next application of Q is its use in
operating systems
multi-user multi-programming and time
sharing environments are common in
today's computers
in this OS setting a system handles
multiple jobs at once and the concept of
a queue is employed to manage these
activities
so remember guys you can Implement stack
data structure to solve recursive
problems and queue data structure to
solve problems that need sequential data
processing
queue implementation using array first
we are going to take a small recap On
Queue in data structure
we then dive into the Declaration of a
one-dimensional array and pointers for
queue implementation
finally we will formulate code for Q
data structure using the C plus coding
language
on that node without any further Ado
let's get started with the recap on Q in
data structure in the last session we
introduced you to Q data structure as an
abstract data type as we know when we
talk about data structure as ADT we
Define it as a mathematical or logical
model we specify all the features or
operations available with the data
structure so considering that we learned
a few basic features of a queue in the
last session let's go ahead and learn
more
a queue is a linear collection of
different data types that allow
insertion at one end and deletion at
another unlike any other data structure
the qns remain open allowing it to have
different functionalities at both ends
Additionally the queue works with a
restriction that insertion should be
performed at the rare node and deletion
at a front node
those processes of insertion and
deletion are called NQ and TQ
respectively we discovered both of these
operations along with three more
supportive procedures named as Peak is
full and is null
now that we are considering to implement
a q data structure so all these
operations will become different
functional blocks additionally all these
operations must take constant time and
it must not depend upon a variable like
the number of elements in queue or the
size of the queue
by that what I mean is the complexity of
all these operations must be o of 1.
having said that let's dive deep into
the strategy to implement Q data
structure until now we have understood
that Q is a special kind of list with
some restrictions on insertion and
deletion and there are two approaches to
deal with queue implementation the first
one is array based and another one is
linked list based in this session we are
going to focus on array based
implementation
initially let's say we want to create a
queue of integer elements for that
purpose firstly it is essential to
declare an array of random spaces let's
take 100 as the size of rre that means
our array can have a maximum of 100
integer elements the Declaration of an
array is made with this line of code
intq 100
where inch represents integer data type
and Q is the name of our array and
hundred is its size
the array that we just initialized is
going to store RQ by that what I mean is
at any random index of an array queue is
going to start with two Mark tense front
and rear
in this array I am showing front of the
queue towards the left and red towards
the right
for making those end notes we need to
initialize two pointers front and rear
at this moment as our queue is empty so
both of those pointers should Point
towards -1 so initialization of these
pointers should be done as inch front is
equal to -1 and int rare is equal to -1
when the insertion on deletion happens
in queues these pointers will be either
incremented or decremented so they are
an essential part of this queue
implementation process
now you must be clear with the array and
pointers declaration part so let's dive
further and formulate code for queue
implementation using a one-dimensional
array in C plus plus
it is essential to include header files
into our source file as we cannot access
standard C plus functionalities without
them
that is why here we are going to load
iostream and standard input output files
along with using namespace sdd
once this is done we will initialize our
array along with front and rash pointers
remember we always have to declare the
size of an array before compilation that
means we cannot update the size of an
array at runtime
this scenario is the biggest limitation
of queue implementation using arrays
having said that let's proceed with
Pointer's declaration
now we are done with the initialization
process we will now work on
implementation of Q functionalities
let's first work out supportive Q
functions like is null is full and Peak
Isner function validates if the queue is
empty
and as per our previous discussion when
both front and rare points to -1 then
the queue is considered to be empty
so the condition to determine if Q is
empty will be
if rare is equal to is equal to -1 and
front is equal to is equal to -1 it will
return Q is empty
if the queue does not satisfy the
previous condition then it is not empty
so by using the else condition we can
display the queue is not empty
next up is is full function this
function validates if the queue is full
and we can clearly say that if the rare
pointer is equal to the max size of the
queue then RQ is going to be completely
full
next speak
the peak function extracts the element
where the front pointer is pointing
without removing it from the queue
for this functionality to work our queue
must contain data elements in it
what I mean is RQ should not be empty if
RQ is not empty then data at the front
node can be accessed
this is how we Implement supportive Q
functions let's immediately dive into
the development of main queue operations
NQ and DQ
for enqueue operation if the queue is
full then our function should prompt an
overflow error for that to happen we
have to put this condition
if the front pointer is pointing to -1
then we have to increment the front
pointer to zero manually
otherwise it can be incremented by Rare
plus plus
after pointer incrementation we have to
ask for a data element to enter into the
queue once the data is given it should
be inserted at the position where the
rare is pointing now
finally let's code the final main queue
operation called as DQ
if the queue is empty then there is no
element for deletion so it should prompt
an underflow error on screen
also if there is only one element left
inside Q then both pointers should again
be pointed towards -1
for that let's write another condition
here
huh
if both the previously mentioned
conditions are false then deletion of an
element can be achieved by just pointer
incrementation
we have implemented all the Q
functionalities here but we haven't
implemented a function that can show us
how our queue looks so for that let's
Implement one more function with the
name display
this function should prompt the elements
of the queue on the screen
elements will only be printed if the
queue is not empty hence we have to
check for the emptiness of the queue
first
finally we are done with the hard part
so let's arrive at the main function to
contemplate these operations in order to
visualize outputs
we are going to use a switch case to
take a user command thus not to waste
your time on this let me just get done
with this block ASAP
that's all we are done with the queue
implementation using arrays let's just
examine if our code works fine or Not by
compiling it
this program should return a console
that asks the user to give commands for
performing different operations so as
you can see on your screens if I input 1
I can perform insertion in a queue
let's perform some insertions now we
will insert four elements first three
then 21
next 78
and finally 12.
after inserting these elements we will
print the state of the queue using case
3.
now let's also check the DQ function
if we perform a DQ operation then 3
should be removed from the queue
let's check if it is removed using the
display function
foreign
and yes our code works just fine
now if you're concerned about this code
then don't be as we can send it over to
you if you drop your email IDs in the
comment section below
Additionally you can also try to run it
on your local system to have a better
understanding of the concept
we will be discussing about queue
implementation using linked list at
first we will quickly revisit the queue
functionality that we have covered in
previous sessions
followed by that we will understand the
need for Linked list implementation of Q
advancing ahead we will deal with
representation of Q using linked list
and the challenges that occurs while
implementing Q using linkages finally we
will cover the coding implementation of
Q data structure I hope I made myself
clear with the agenda now let's get
started with our first topic which is
quick recap On Queue functionalities
Q as we know from our previous
discussions is a structure in which
whatever goes in first comes out first
for example customer service queue in a
customer service queue the customer who
enters first will leave the billing line
first and the customer who enters last
will definitely get served at last this
scenario for insertion and deletion is
also known as first in first out
principle moving ahead let's discuss
some features of this queue data
structure
basically Q is a linear data structure
that follows certain restrictions on
insertion and deletion the insertion can
only be made from one end and deletion
can only be performed from another end
further deletion is called as DQ and
insertion is called as enqueue along
with these two primary Q operation there
exists three more supportive Q
operations named as Peak is full and is
empty Peak operation should simply
return the element at the front without
removing it from list and it's full and
is empty operation should return the
state of q that is empty or full all
these discussed operation must take a
constant execution time by that what I
mean is the time complexity for all
these operations should be Big O of 1.
now moving ahead we shall understand the
need for Linked list implementation of Q
when we discuss the implementation of Q
using arrays we discussed the limitation
of pick size according to that
limitation an array will always have a
fixed size and it should be declared
before the compilation of program
furthermore once all the positions in an
array are taken or it is exhausted then
we only have two options we can either
deny insertion by saying that the queue
is full and we cannot insert anything
now or what we can do is we can create a
new larger array and copy elements from
the previous array to the new large
array the time complexity for this copy
operation will be proportional to the
number of elements inside field array in
other words we can say that the time
complexity of this copy operation will
be Big O of n but again as we are giving
random larger size to the array there is
a possibility of massive memory loss
like right now in this area 70 of the
memory is unused and the memory is a
crucial resource that we should allow
always be protecting it's not that some
amount of unused memory will be real
problem in today's modern day computer
but it's just that while designing
Solutions and algorithms we should
always analyze and understand these
implications regarding memory
along with this memory wastage there
exists another sort of memory management
issue that occurs while utilizing an
array to implement a queue data
structure the space of an array which is
used to store elements can never be
reused to store the queue elements
because items can only be inserted from
the front end and the front ends value
may be so high at that time the space
before the pointer will be lost for
eternity let's have a look at an example
to understand this drawback more clearly
in this example of array representation
of q a q of size 10 having 5 elements it
shown the value of the print pointer is
5. therefore we cannot reinsert values
in the place of already deleted elements
before the position of front that means
the space of the array before print
pointer can never be reused for storage
purpose
these drawbacks represents the need for
a more appropriate method to implement
queues and by using a proper Dynamic
data structure like link list these
drawbacks can be easily removed on that
note let's discuss about the
representation of Q using a linked list
a link list as we know is a collection
of data elements that we call nodes
these nodes are stored at non-contiguous
locations in memory further each node
contains two field one to store data and
another to store the address of next
field or the reference to the next node
let's assume that the node in this
figure are at addresses 200 400 and 500
respectively I have filled these
addresses in the address field as well
the identity of the link list that we
always give with us is address of the
head node we often name a pointer or
reference variable at which we store the
address as head
so now we are saying that we want to use
a linked list to implement queue data
structure and the basic definition of
queue conveys that a queue is a linear
data structure in which insertion is
performed at the rear node and deletion
at the front node it's really effortless
to enforce this property of a queue in
linked list we can simply pick one side
of a linked list for insertion and
another site for deletion if the head
node is considered to be print then the
tail node will be the rear otherwise if
the head node is deemed to be the rear
then the tail node will be the printing
whatever side we are picking for
whatever operation we just need to make
sure one thing and that thing is the
operations that we are carrying out must
take a constant time or in other words
that time complexity should be big of 1.
I hope that you guys are clear with the
representation of a linked list as a
queue data structure now moving forward
we will discuss about its implementation
but before that let's have a look at the
time complexity management challenge
which occurs in queue implementation of
a link list in the case of linked list
the cost for insertion or removal from
the head side is Big of one but the cost
for insertion or removal from the tail
side is Big of n so here is the D in a
standard implementation of Q using
linklish if we insert element at one
side and remove them from other side
then one of these operation NQ or DQ
depending on how we are picking this
side will cost us bigger of n but the
requirement that we have specified
before for queue implementation suggest
that both these operations must take a
constant time
so we'll definitely need to do something
to ensure that both NQ and DQ operations
take constant time
let's call this side front and this side
rear so I want to enqueue a node from
the tail side and I want to perform a DQ
at the head side we are good for Decay
operation because removal from the front
will take a constant time but insertion
or enqueue operation will be costing us
big of n let's first see why insertion
at the tail will be costlier and then
maybe we can try to do something to
insert an element at the rear end what
we will have to do is first we'll have
to create a node let's say I have got
this node at address 350 and the integer
that I want to enqueue is 7. the address
part of this node can be set as null now
we have to build a link with this
created new node and to do that first
we'll set the address part of the last
node as the address part of this newly
created node but the only identity that
we always keep with us in case of linked
list is address part of head node so to
get appointed to any other node we need
to start at head that is why first we'll
create a pointer variable temp and will
initially set it to head node and now
using this temp pointer we'll try hours
to the end of our linked list that is
the tail node and here using this
pointer temp we can write the address
part of the newly created node at the
previous tail node to build this new
link
this traversal of pointer from head to
tail is taking all the time for
insertion we use a statement like temp
is equal to temp.next to move the next
node what we can do is we can avoid this
whole traversal with the help of pointer
variable just like head node we can call
this variable tail or even rear let's
call this variable rear for now and also
the variable with storing an address of
head as front in any insertion or
removal will have to update both front
and real now but from now on whenever we
will perform NQ operation we can
directly check where a real node is and
update its address to formulate a new
insertion name this simple addition of
one pointer resolves a problem with the
cost of insertion let's understand this
scenario with the help of an example
previously we were traversing from head
node to the tail node but now as we know
the location of tail node there is no
need for any traversal we can directly
update the address part of real node to
make a link for new node
here the new node with data element 7
will be linked to the previous node and
the rear pointer will also be updated to
point towards the newly inserted node
now the complexity for both the
operation will be big of 1.
which means we can now begin with the
coding implementation of Q using a link
list so let's dive directly into that
in order to get started with our coding
implementation we'll need to load some
dependencies that are called as header
files I have already included those
header files here so first of all we'll
declare a structure to create nodes for
our linked list and inside the structure
we'll initialize data and address part
so let's get started with creation of
this structure struct
node
now the initialization of data and
address part
and data
struct
node
star
next
Now using this created structure we will
initialize front and rear pointers so
let's create this front and rear pointer
struct
node
star
front
is equal to null
similarly struck
node star
real
is equal to
none
the Declaration of variables that we
have done here is in global scope the
reason behind that is to make sure that
these variables will be accessible to
all the functions so moving forward
let's work out the primary Q operation
we'll start with enqueue operation so
let's create a function for that void
NQ
and inside this function will pass an
argument in X to insert a element
now
inside the enqueue function will take an
integer as an argument in this function
we'll create a new node for purpose of
insertion so let's create that new node
struct
node
star
then
is equal to
struct
node
star
malloc
size of
truck no
so with this size of function we have
allotted the size of address bar as well
as the data part
one more thing I want to tell you guys
is I am using malloc in C here for
dynamic memory allocation if you want to
implement this code using C plus plus
then you can use new operator instead of
malloc the purpose of using malloc here
is to create a node in dynamic memory
now moving ahead
we can start working on two cases of
enqueue operation primarily there won't
be any element inside the queue so for
the first insertion we'll manually set
both front and rear to the address of
this newly created node so to do that
first we'll have to create a if
condition if
front
is equal to equal to null
and then rear
is equal to equal to null
front
is equal to real is equal to 10.
which is nothing but the new created
pointer variable and will return
[Music]
the control
if this condition fails that means there
are already some elements present inside
our queue so using else condition we can
write another statements real
dot next
is equal to 10.
and Ria
is equal to
10.
basically these two lines of code are
just updating the address part of the
next node along with setting the
temporary data into real nodes data
field
this code will be further clear if I'll
show things moving in simulation so
let's revisit PowerPoint for that
purpose
let's say initially we have an empty
queue so both front and rear will be
null null is only a macro for address
zero at this stage let's say we are
making a call to enqueue function
passing number 2 as an argument now
let's go through the NQ function and see
what will happen first we'll create a
node the data part of this node will be
set as 2 and the address part will
initially set as null let's say we got
this node at address 100 so a variable
name temp will store this address right
now the front and rear both are null so
we'll go inside this if condition and
simply set both front and rear as 100.
after the first enqueue operation our
queue will look like this
let's say we are making another call to
enqueue function at this stage passing
number 4 as an argument once again a new
node will be created let's say I got
this new node at address 200 this time
the queue is not empty so in this
function we'll first go to the statement
rear dot next is equal to 10. so we'll
set the next part of this node at
address 100 as the address of a newly
created node which is 200 so we'll build
this link now and now we'll store the
address of this new real node in this
variable named rear so this is how my
queue will look like after the second
enqueue operation
I hope that you guys are clear with the
implementation of NQ operation and the
working of its code let's deal with the
next queue operation named as DQ in our
code editor
now inside this DQ function I'll create
a temporary pointer to the node in which
I'll store the address of the current
front or head node so that we can
directly delete it so the statement I'll
write for that is struct node
star
10 is equal to front
now the first condition that will write
in this day
this date so let's begin with if log F
front
is equal to equal to null
printf
Q
s and empty state
slash n
and return the control to the next
function
otherwise in next case when both front
and rear will be equal we'll set both
these pointers to the null manually so
to do that we'll insert another if log
if front
is equal to equal to real
front
is equal to real
that's equal to null
this if log will get activated when
there is only one element inside the
queue in all other cases we can simply
make a front point to the next node so
we'll simply do a front is equal to
front dot next so for that we'll write
else block
else front
is equal to front
Dot next
in all three previous mentioned cases we
are trying to remove elements and that
can only be done by implicit call of
function free so let's call function
free to delete the front node from our
queue so the statement that we'll write
is from free
the temporary variable which is actually
storing the head node address
next we'll work on Peak operation and
for that we'll create a new function
in
Peak
basically the peak function is used to
extract the value of print pointer for
print pointer we will simply check if
the queue is empty if it is empty then
obviously there is no element at front
node to extract but if it is not empty
then we can extract a value from print
pointer so for that we'll create a if
block if
front
is equal to equal to null
which also means the queue is empty then
we'll return
printf
Q
is empty
slash n
foreign
the data present at front node
now we have implemented all important q
functionalities but we won't be able to
check the state of queue with the help
of these functions so let's formulate
one more function called as print to
visualize our queue so let's define this
function void
print
and set this function will create a
temporary pointer struct
node star
temp
is equal to front
we are initializing this temporary
pointer to the front so that we can
Traverse the whole queue elements using
iterator element so moving forward let's
create this iterator element using a
while block so the statement that will
write for that is while
time
is not equal to null
printf
modulus d
comma
10
Dot
data
and we will say 10 is equal to Temp dot
next
nothing but the traversal of linked list
now we'll also print f
slash n
so that
all elements will be printed in order
with this we have completed the
implementation of print function as well
now let's work on our driver method
called as main function to contemplate
the output of our program
and set this will make call to the
enqueue function NQ
to
and we will print the state of our queue
using print function next we'll make
call NQ
4
and we will also print the stair using
print function
next we'll make call to NQ 6.
and will also print the state of our QR
distance
now after this we'll dequeue few
elements DQ
print state
next we will enqueue one more 11 and Q8
now that we are done with decoding
implementation of Q using linked list
let's execute the program and visualize
the output
this is the output that we have received
let's compare it with the calls that we
have made in order to judge its
correctness the first call that we made
was nq2 so the print function has
printed two over here
after that we inserted 11 4 and 6 and
our print function has printed the state
after these operations as well next we
deleted the element present at front
pointer which is 2 so after deleting 2
the output that we got is 4 and 6.
finally we inserted one more element to
check if it is getting inserted at the
rear end and that element was it which
is exactly inserted at the rear end of
queue we will be discussing about
circular queuing data structure
so at first we'll discuss why the
concept of circular queue was introduced
followed by that we will understand how
we can represent a circular queue using
an array and linked list advancing ahead
will deal with the implementation of a
circular queue using array and linked
list and finally we will cover the
applications of a circular queue to
understand its importance I hope I made
myself clear with the agenda now let's
get started with our first topic which
is why the concept of circular queue was
introduced
in our previous sessions of queue
implementation we discussed the
challenge of memory wastage while
operating on linear queue and as per our
previous discussions we know that memory
is a crucial resource that we should
always be protecting it's not that some
amount of unused memory will be real
problem in today's modern day computers
it's just that while designing Solutions
and algorithms we should always analyze
and understands implication like memory
usage as well as the time taken for
execution
in the case of linear queue we have
already learned that insertion is done
at the rear end and deletion is done at
the front end initially when the queue
is empty both of these pointers point to
null memory space that is -1 according
to our convention
but as we keep adding elements into the
queue the rear pointer keeps
incrementing until it reaches the max
size of the queue in this particular
example of the queue the new data
element will be inserted after each
incrementation of a rear pointer until
the pointer reaches the end of a queue
when the front pointer remains pointing
at the exact same location until we
perform DQ operation
But Here Comes The Challenge when we
perform those DQ operations the empty
space gets created at the starting part
of the queue and there is no way we can
reutilize this blank space as the rear
pointer has already reached the end of
queue so to overcome this limitation the
concept of a circular queue was
introduced
a circular queue is nothing but the
extended notion of a linear queue as it
also follows the principle of first in
first down with the exception that the
last position of this particular queue
is connected to its first position
making a circular link this circular
link is responsible for naming of this
queue as a circular queue or a ring
buffer additionally this new circular
link feature resolves the problem of
memory wastage in a linear queue
let's understand how this problem is
actually getting resolved with the help
of an example
this figure is an illustration of a
circular queue having size 5. the
element at the front node is 7 and the
element at the real node is 9. as we can
clearly see this queue is completely
free and if we try to perform enqueue
operation it will definitely return an
overflow error we can only perform a DQ
operation on this queue but if we
perform DQ operation the front pointer
will be updated to point to the next
available data element further due to
this DQ operation the empty space will
get created in the beginning part of a
queue but because of the circular link
rear pointer can arrive back at the
empty space for making insertion of a
new data element hence the circular
queue concept is better version of a
queue data structure considering its
benefits over a circular queue
moving ahead we'll discuss how we can
represent a circular queue using an
array and linked list
however initially we should also look
into the principle of circular
implementation which drives the
insertion in a circular queue the
circular queue incrementation is a
process of pointer incrementation that
allows zero pointer to arrive back at
the beginning part of queue once it
reaches the max size of queue let's
understand how circular incrementation
works with the help of an example
the simulation of a circular queue shown
here has Max size 6 which means it can
store 6 data elements in the first
scenario when Q is empty it can store
Elements by simply incrementing the rear
pointer as shown in the animation
the other scenario for insertion in
queue is when the rear pointer is at the
end of queue and there is an empty space
at the beginning portion of a queue due
to DQ operations in this case the rear
pointer can arrive back at the beginning
of queue to insert a new element at any
empty space
but the biggest question that arrives
here is how the circular incrementation
is happening logically or arithmetically
let's contemplate the logic for this
process of circular incrementation with
the help of previous example in the last
example of a circular queue the max size
of a queue was 6 and rear pointer was
pointing to the index 5 where print
pointer was pointing to index 2. now for
the new incrementation to happen we have
to bring rear pointer to the index 0.
let's analyze how we can do that if we
simply add 1 to the rear pointer then we
will get 6 as a result which is also the
max size of our queue now if you guys
remember the modulus operator in
programming you can clearly achieve the
circular incrementation for example in
this case Ria plus 1 modulus Max size
will output 0 the result which we want
so with the help of modulus operator we
can perform the circular incrementation
to formulate a circular link using
arrays now that you have understood how
circular link is implemented in case of
array implementation of circular queue
we will now look into representation of
a circular queue
in the array representation of circular
queue you can clearly see that the last
index of the array is connected to the
first index by circular incrementation
process
moving forward we'll look into the
different cases of inserting an element
into the queue the first case that we
are going to discuss is to determine if
the queue is full as we cannot insert a
new element into the queue when it is
full but how can we judge if the queue
is full well that's quite easy if the
result of circular incrementation
matches to the index value of front
pointer then there is no space for
insertion of a new data element that
means if rear plus 1 modulus Max size is
equal to front then the queue is full
and insertion cannot be achieved
the next case for inserting an element
into a circular queue is when there is
space at the beginning of a queue let's
say the size of an array is 5 in which
the rear pointer is pointing to the
index 4 and the front pointer is
pointing to index 2. by making circular
incrementation we can insert element at
the empty space by using rear is equal
to rear plus 1 modulus Max size
statement we can bring our rear pointer
to the beginning part of our queue to
make a new insertion
that's all about array representation of
a circular queue now moving ahead we
will discuss the representation of
circular Q using a linked list the link
list representation of a circular queue
can be achieved by changing the
reference field of the tail node for
that we can just add the address of head
node in the reference field of the tail
node the implementation of a circular
queue using linked list is more
efficient than array implementation as
it manage memory more effectively
further it is a dynamic structure that
can be allocated with more memory space
if required at the runtime on that note
we have covered the representation of
circular queue using both arrays and
Link lists now we'll Implement a
circular queue using both of this data
structure with the help of C programming
language
first let's dive into the array
implementation of a circular queue using
the C programming language for that
let's visit our code editor and get
started the program for array
implementation will begin with the
Declaration of array and pointer
variables so let's create an array first
in a closed braces and semicolon now the
size that we want to allow to this array
is 5 so let's define our Max size value
as 5 first
hash Define
Max
underscore size
as 5.
now let's pass this as an argument to
this array
now we will Define the pointer variables
as well
so end
front
is equal to minus 1.
and also the real pointer
we have successfully created our array
and pointer variables so after this
we'll begin with the implementation of
circular queue operations the first
primary queue operation that allow us to
manage data flow in a queue is NQ so we
will create this function first
void
and queue
and will pass an argument variable X to
insert an element
for implementing this operation we have
to check if the queue is empty if a
circular queue is empty then we'll set
both the front and rear pointer to zero
manually for that we'll write a
statement if
front
is equal to equal to minus 1
and and
rear
is equal to equal to minus 1
then set
front equal to real equal to
zero
we have just written the condition for
instance when the queue is empty next
we'll write the condition to check if
the queue is full so for that we'll
create else if condition else f
real
plus 1
modulus
Max underscore size
is equal to equal to front
then printf
Q as full
slash m
and return the control to the next
function
if both these above mentioned conditions
fail then we'll have to increment the
rear pointer using the technique of
circular incrementation so for that
we'll create another else Loop
else
real
is equal to
Ria
plus 1
modulus
Max
underscore size
foreign
and outside this we will make an
insertion into our array
with this we have successfully created
our NT operation now we'll move towards
the DQ operation
for that we'll create another function
void
DQ
the DQ operation is responsible for
removing the element from the print node
of a queue further an element can only
be deleted when there is at least an
element to delete so first we'll have to
check if a queue is empty or not for
that we'll write a statement if
front
is equal to equal to minus 1
and and
Ria
is equal to equal to minus 1.
now inside this block will
printf
Q
is empty and we cannot delete any
element
and we will return the control to the
next function
in addition to that if there is only one
element inside the queue we'll have to
set both front and rear pointer to the
null manually so for that we'll write
another condition else if
front
is equal to equal to 3A which must be
the zeroth index or the last element
inside Q
and inside this function we'll write
front
is equal to real
is equal to minus 1 which means we'll
set it back to the null state
if both these conditions fail then we'll
simply have to increment the front
pointer using technique of circular
incrementation for that we'll write
another condition else
front
is equal to front
plus 1
under basis
modulus Max
underscore
size
with the help of these three conditions
we'll be able to delete element from our
queue now moving forward we'll look into
another operation that is print function
so let's create a new function for that
void
print
we will understand this function with
the help of PowerPoint because it will
be more understandable to all of you if
I show things in moving simulation so
let's visit PowerPoint for that purpose
the count variable used in this print
function is supposed to count the number
of elements inside the queue we'll
understand how it is operating
arithmetically with the help of an
example
let's say the max size of our array is 5
where front pointer is pointing to index
1 and rear pointer is pointing to index
4. to work out the value of count
variable we'll need to perform following
operation real plus Max size minus front
modulus Max size plus 1 is equal to
count
by filling the values in this operation
we'll get 4 as a result which is the
exact number of elements inside the
queue
now we will iterate through the queue
using for Loop and will also print the
elements I hope you are clear with the
implementation of this print function
now moving forward we'll revisit the
code Editor to write main function and
to check the result of our program in C
inside this main function we'll call lq
function to insert some elements into
the queue and after few insertion
operations we'll call Print function to
represent the state of our queue
so let's insert few elements at first
and Q
5
and Q
seven
next element that we will insert is in Q
minus 3
next
and Q
0.
now
let's write one printf statement
the element
s
inside
Q
r
and then next line we'll return the
state of Q using print
function
well there is single mistake in this
code here we have written printf
statement in uppercase which is a case
error in C programming so we'll change
it to the small p
now will dequeue few elements to
understand the operation of DQ as well
so let's DQ two elements
one more time
and after these two operation will also
print state of Q once again using the
print function
well we'll write one more statement
printf
the state
of Q
after
2
deletions
and also
we want this statement to come in next
line so let's write slashing
okay
so with this we have successfully
completed a coding implementation of
circular queue using arrays so let's
compile this code and check if it is
working fine or not
well here is the output that we have got
the elements inside the
qr57-30 so let's check our order of
insertion so we encode 5 7 minus 3 and 0
and in similar order
the elements are inserted in our queue
also we deleted two elements from the
print node that is 5 and 7 which are
also deleted here with this
we can say that our code works fine so
let's move towards linked list
implementation of circular queue
for Linked list implementation of Q
first we'll need to create structure of
a linked list and pointer variables so
first we'll create a structure for node
struct
node
and data part
and
the address part
[Music]
now we'll create pointer variables so
for that we'll write statement struct
node
star front is equal to -1
similarly
extract
node
star
is equal to
-1
after done with this point the
Declaration we'll begin with the
implementation of Q operations the first
operation that we'll work on is NQ
operation for that let's create a new
function void
NQ
and
X
and inside this function we'll create a
temporary node using the previous
structure of node so for that
we'll write statement struct node star
new node
is equal to
struct
node
star
malloc
sides of
dropped
node
after creating a new node now we will
also insert values into both data and
reference Fields data will be the
argument provided by the user and the
reference field will be set to null
initially so
let's do that here new node
Arrow operator
data
is equal to
X
and similarly
new node
Arrow operator
next is equal to
zero
now there are two conditions for
inserting a new node into the linked
circular queue in the first condition
we'll insert a new node into an empty
queue in this case both the front and
rear pointer must be not so let's write
a condition for that if
real
is equal to equal to minus 1
then
front
is equal to real is equal to new node
and rear
Dot
next
is equal to
front
now in the second case the queue already
contains more than one data element
the condition rear is equal to equal to
-1 becomes false in this scenario we'll
just update the rear pointer to point to
the new node for that we'll create a
else block
else
rear
Dot
next
is equal to
new node
and rear
is equal to
new node
where
Dot
next
is equal to front
with this we have successfully
implemented our enqueue function so now
let's move towards DQ function for that
we'll create a new function void
DQ
and inside this function body we'll also
create new temporary
pointer so let's create that struct
node
star
10.
and we'll set this time is equal to
front so that we can delete it from a
queue
next we'll build a condition for
deletion the first condition that we'll
check is if our queue is empty or not
for that we'll write statement if
front
is equal to equal to -1
and and
Ria
is equal to equal to minus 1.
if
this condition becomes true then we will
printf
Q
is empty
let's add slash in here
so that it gets printed in next line
and semicolon
okay
further if there is only one element in
the queue then we'll set both front and
rear pointer to the null manually so for
that purpose we'll create another block
else f
front
is equal to equal to Ria
which will happen when there is only one
element in a queue
and inside this condition we'll put
front is equal to real is equal to minus
1.
and we will
free
the temporary variable
which is also storing the front pointer
okay now if both these above mentioned
conditions fail then we will update the
value of front pointer to point to next
node and will also delocate the memory
of deleted node using free function for
that we'll write another else condition
else
front
is equal to front
Arrow operator
next
and real
Arrow operator
next is equal to
front
and we will free
the pointer present at front node which
we have previously stored in this
temporary structure
with this we have successfully
implemented the DQ operation now we'll
work on the display function which will
represent the state of our queue for
that let's create
new function
void
display
and inside this function will also
create
the temporary node
strapped
node star
10.
it's equal to front
foreign
now let's write one printf statement
to display the elements in a queue the
elements
inside
QR
semicolon
now the first condition that we are
supposed to check inside this function
is if a queue is full or not for that
we'll write if statement if
front
is equal to equal to minus 1
uh
and and
Ria
is equal to equal to minus 1
then printf
q h m p
let's start selection
foreign
we will print the elements inside the
queue using while block
temp
Arrow operator
next
it's not equal to
front
then
print
f
modulus d
which is nothing but
the data part of
our temporary pointer
and again
print f
modulus t
comma
10.
data
okay with this we have successfully
completed the implementation of our
display function now next we'll look
into our driver method that is main
function
inside this driver method will call
enqueue function to insert
few elements
first we'll pass Five
then we'll insert
minus 32
then
6
and we will enqueue
3 final
now let's
print the state of queue using display
function
now after this we will teach you few
elements
and we will display the state document
once again
but before this
we'll write one more
statement
printf
the state of Q
after
deleting
two elements
and let's have slash n so that this
statement gets added to the next line
with this we have successfully
implemented our linked list
implementation code for circular queue
so let's compile it and check if it is
working fine or not
okay there are few
we have successfully implemented our
code now but the only problem we are
facing here is all the elements are
getting placed close to each other to
remove this close proximity will have to
make changes in our display function so
let's do that
we'll add space before modulus D in both
the cases and again compile it so let's
run it again
okay so now our output looks fine right
the elements inside the queue are 5
minus 32 6 and 3 and after deleting
first two elements that are front
elements
we will remain with 6 and 3 that means
the first two front elements 5 and minus
32 will get removed out of our circular
queue
okay so we have finished the circular
queue implementation using linked list
as well so let's move back to our
PowerPoint presentation the last topic
that we have on our agenda is
applications of a circular queue so
let's deal with this topic to understand
the importance of circular queue
the first application of a circular
queue that we are going to discuss about
is data buffer after that we'll discover
CPU scheduling algorithms and computer
control traffic light systems
data buffer is a region of a physical
memory which is used to temporarily
store data while it is being moved from
one place to another typically the data
is stored in a buffer as it is retrieved
from an input device such as a
microphone or just before it is sent to
an output device such as speakers
basically when the input is provided to
the microphone while using applications
such as Google meet WhatsApp Zoom
meeting Etc then the input does not get
stored in the physical memory of the
device instead it gets stored in data
buffer implemented in this application
the data buffer will store the input
signal in order and similarly it will
dequeue it in exact same order just like
first in first out circular queue
furthermore this data buffer is also
used in Internet streaming applications
let's understand how it is used in case
of one of the most famous streaming
platform Netflix Netflix uses Amazon
cloud services to cater for their
Computing as well as storage needs the
server of Netflix are deployed over AWS
Cloud which are further connected to the
content delivery network servers that
are spread across the globe these
servers work together to provide fast
delivery of Internet content in the form
of audio and video chunks or packets
these packets will be received in a
virtual data buffer implemented inside
Ms silver site which is an application
used by Netflix to stream content on
remote devices this buffer acts like an
accordion in this streaming application
it gets filled when packets are being
delivered at a rate that exceeds the
video stream data rate and empties when
the packets are not being delivered fast
enough
the next application of a circular queue
is a ready queue in CPU scheduling
algorithms CPU scheduling determines
which process will own CPU for execution
while other processes are on hold the
main task of CPU scheduling is to ensure
that whenever the CPU remains idle the
OS at least selects one of the processes
available in ready queue for execution
the algorithm named Brown Robin uses a
circular queue to implement the ready
queue state
the radiq stores all the processes that
are available for resource allocation
having their own burst time the burst
time is the time that processes need to
hold the CPU for their execution but in
this algorithm the CPU has assigned with
timestamp of 2 microsecond this
timestamp is the actual period for which
the processors can hold the CPU for
execution so for example the first
process P1 had a burst time of 4
microseconds but it can only access the
CPU for 2 microseconds due to its time
stamp so this process will again
re-enter the Queue at the rear end
further the empty space created at the
beginning of ready queue will be managed
by the process of circular
incrementation this is the advantage of
implementing ready queue using a
circular queue
the next application is computer control
traffic system the circular queues are
used in this systems to activate the
signal lights for constant intervals of
time the computer system used for
traffic light control stores a circular
queue containing the commands to let the
traffic lights these commands will be
activated for a certain amount of time
and will be re-inserted at the rear end
of a queue this process is an example of
circular fifo principle which is
followed in insertion and deletion for
circular queue we will be discussing
about priority queue in data structure
we'll start this discussion with
introduction to the priority queue
followed by that we will understand how
we can represent a priority queue
advancing ahead will deal with different
implementation strategies for priority
queue after that we'll understand what
is a heap data structure and what
different types of priority queue are
available followed by that will
contemplate different operations in
priority queue once finished with that
we will implement the priority queue
using Heap data structure and finally we
will cover applications of priority
queue to understand its importance I
hope I made myself clear with the agenda
now let's get started with our first
topic introduction to Priority queue
primarily we will have a look at the
real life example of priority queue to
understand it better a hospital
emergency queue is almost an ideal
example of priority queue when you go to
the hospital you must have observed that
the person who needs immediate medical
attention will be treated first
irrespective of his arrival at the
reception that means treating a person
who is in agonizing pain or in emergency
medical condition is the priority of the
queue of patients priority queue in
computer science also works with same
approach so what exactly is this
priority queue well a priority queue is
an abstract data type that operates
similar to the normal queue except for
the fact every element has certain
priority assigned to it this definition
of priority queue suggests that this
particular type of queue also follows
the same restrictions for insertion and
deletion of data elements the insertion
in the priority queue will only be
achieved at one end and deletion at
another or opposite time Additionally
the priority of data elements will
determine the order of removal the
elements which have higher priority will
leave the Queue at first and the
elements which has lower priority will
definitely leave the Queue at Large
as a side note I would like to tell you
guys that the priority queue only
supports the elements that are
comparable meaning the data that we are
going to insert into priority queue must
be orderable the compiler should not be
facing any difficulty while comparing
these data elements otherwise the
execution of a priority queue will
definitely fail moving ahead let's have
a look at an example of priority queue
in this priority queue we'll insert 7 to
45 23 and 12 respectively these elements
are not ordered so how the priority
queue is going to store them in order
well at the time of insertion the
priority queue conducts a comparison of
each element with every other element
present inside a queue to store them in
order but as there is no element inside
a queue so the first insertion that is
an element with value 7 will be attained
followed by that the next element will
be inserted in a queue since the newly
inserted element is smaller than that of
previously inserted element we'll swap
their positions in order to maintain
order remember the element with least
value will have a higher order and the
element with greatest value will have a
least priority or order
now we will insert the next element in a
queue that is 45 as 45 is a larger
element than the elements inside the
queue there is no need to shuffle
elements but we make the next insertion
The Element 32 will get inserted at
index 3. now this element is smaller
than that of 45 so the algorithm will
have to swap the locations of these
elements now we will perform the final
insertion into our queue we'll insert 12
at index 4 now but as you can see this
11th is smaller than both the previous
elements thus the algorithm will have to
swap their positions now 45 will reach
the end of Q as it is the element with
highest value and 2 will remain at the
front of queue as it is the least valued
11. as a human we could see the numbers
visually inside the priority queue and
further we can easily arrange them but
how does the machine know this does it
restore all the elements inside the
priority queue before each insertion no
obviously that would be highly
ineffective as there will be n
comparison for insertion of n elements
leading to time complexity we go up n
Square this is an enormous time
complexity which we cannot allow in any
software application we will understand
how the priority queue manages to reduce
this time complexity in upcoming topics
but right now we will contemplate
different properties of a priority queue
that we have learned from previous
example the first property of priority
queue suggests that each element has a
certain priority assigned to it that
priority might depend on value of data
element it can be either larger or
smaller the next property states that
element with higher priority will leave
the Queue at first where the element
with least priority will leave the
priority Queue at last
further if two elements have the same
priority then the element will be
removed from the priority queue based on
their arrival that means the elements
which arrived at first out of the
elements having same priority will be
removed first
now moving ahead we'll deal with the
representation of priority queue using a
linked list as usage of array is not an
ideal way to implement priority queue if
we consider array implementation of
priority queue then inserting items into
the sorted array will cost us Big O of N
and in general processing each element
will further cost of Big O of n Square
as discussed previously so in this
tutorial we'll just look into the linked
list representation of priority queue
we will understand the representation of
priority queue with the help of an
example initially let's say there are
three elements inside a link priority
queue and all of them are in order three
being the list element has highest
priority where 43 has the least priority
the purpose of keeping 3 at the head
node is that we want our priority queue
to delete elements according to their
priority
now we want to insert a new node
consisting of data element 2 and as the
data element is smaller than the element
at head node that is 3 so this new node
should be inserted prior to it
this particular scenario of insertion
seems pretty perfect that it does not
cost us more time but what if the
element is significantly larger than all
the nodes in queue for instance let's
say we want to insert 45 as a new
element
in that case primarily it will be
compared with element 2 and as fortify
is larger than 2 our temporary pointer
will move to the next node for
comparison
now 45 will be compared with element 3
and again the temporary pointer will be
moved to the next node for comparison
after two comparisons the temporary
pointer has reached element 17 for
performing the next comparison and here
also 45 is larger than 70. so the
temporary pointer will again move
towards the next node
now finally our temporary pointer has
arrived at the tail node consisting of
element 43. again in this case the 1145
is larger than 43 thus the new node will
be inserted after node containing data
element 43.
from this specific example of insertion
into a priority queue we can clearly see
that there are n comparisons leading to
the time complexity big of n where the
complexity of deletion remains constant
that is bigger of 1.
while understanding the representation
of priority queue we came across some
facts that make priority queue
implementation using link list quite
vulnerable so here we will again try to
recall them the first drawback of
priority queue implementation using
linked list is that it cost us bigger of
n for inserting a new element further it
also cost us big of n for Peak operation
and as memory and time management is the
purpose of data structure hence we must
try to analyze other implementation
strategies that is why in upcoming
slides we'll look into different
approaches to implement a priority queue
there are three approaches that
Implement a priority queue with
complexity less than bigger pen Square
we have already discussed the link list
so let's also look into other two
approaches binary Heap and binary tree
provides almost similar complexity these
approaches cost us big of login for
insertion and deletion and big of one
for Peak operation but which one of
these operation is most optimal approach
to implement priority queue
well to answer this question we again
need to discuss about memory management
in the case of both these data structure
you guys know that binary Heap data
structure is implemented using arrays
and since it utilizes array there is
always a better locality of reference as
well as operations become more cache
apprently the binary search tree uses
pointer to implement front and rear node
which definitely takes up more space in
memory due to that building a cell
balancing BST cost us bigger of n log n
where binary Heap just cost us big of n
these facts clarify that the binary Heap
is the best data structure to implement
the priority queue
now you must be thinking about what
exactly the Heap is and how does it work
so moving forward we'll look into the
definition of Heap and its properties
basically a heap is a tree based data
structure that satisfies the Heap
invariant or in simpler words he
property the Heap invariant states that
if a is a parent node of B then a is
ordered with respect to B for all nodes
A and B in t what that means is the
value of parent node is always greater
than or equal to the value of child node
in the Heat or other way around the
value of parent node is less than or
equal to the value of child node for all
nodes in a heap further there are two
types of Heap named as Max Heap and
minimum Heap first we will look into
maxi the max Heap is Heap in which value
of parent node is greater than the value
of child node
for this particular example of Max Heap
you can see that the root node is the
biggest element in tree and each child
node is smaller than its parent node
the next type of Heap is minimum heat
the mean Heap is Heap in which the value
of parent node is less than the value of
child node
in this specific example you can observe
that each child node is larger than its
parent node and the element at the root
node is smallest element of the Heat
both the structures that we have
discussed are binary heaps as every node
has only two children in upcoming slides
we'll discuss some complex structures of
Heap data structure to better understand
how we can judge if a tree like
structure is Heap or not
okay so you can see a three leg
structure on your screen and we are
supposed to check whether if it is a
valid Heap data structure or not but
actually here I would like you all to
give it a try by yourself you can also
pause this video if you want but here I
will provide you with a short moment to
inspect this structure
foreign
I can clearly say that this is not a
valid Heap data structure as you can
observe the highlighted part is
violating the Heap invariant
moving forward let's analyze another
tree like data structure to consider if
it is a valid Heap or not
well yes this is a valid Heap because
even though this one is strangely
structured we are free to move around
the visual representation of nodes to
make it organized now you all must be
thinking how we can do that well we'll
understand that scenario in upcoming
slides
now
how about this one is this a valid Heap
no right this is not a valid Heap this
structure is not even a tree as it forms
a closed cycle and every Heap must be a
tree so it's pretty clear that this is
not a valid Heap now what about this one
is this a valid Heap
yes this is a valid Heap as it satisfies
the Heap invariant that all the child
nodes must be greater than or equal to
or smaller than or equal to its parent
node
now this is the last structure that we
are going to check if it is a valid Heap
or not
what you guys think
is this a valid Heap
well I think it's pretty clear that this
is not a valid Heap but it can be
converted into a heap by making a one
small change now if we make 6 as our
root node then this structure will get
converted into a maxif which is
absolutely a valid Heat
I hope you all are clear with the Heap
invariant and how to judge if a given
tree is a valid Heap or not
now moving ahead we'll discuss the
different types of priority queue
basically there are two types of
priority queue based on the priority of
elements if the element with smallest
value has highest priority then that
priority queue is called as Min priority
queue and if element with higher value
has the highest priority then that
priority queue is known as Max priority
queue furthermore it's vividly clear
that the mean priority queue can be
implemented with a minimum Heap where
the max priority queue can be
implemented using maximum Heap moving
ahead will deal with the operations in
priority queue considering the Heap as
implementation strategy
the common operations that we can
perform on priority queue are insertion
deletion and Peak but there is one more
hidden additional operation that gets
performed during these operations that
operation is called as hipify hepify
manages the priority of data elements in
a heap by shuffling the data elements
after new insertion or deletion
first of all we will understand how
insertion in priority queue happens with
the help of an example in this example
we are inserting a new data element that
is 43
but due to disinsertion the structure
disobeys the priority queue invariant
that the parent node of the max priority
queue must be greater than its child
node
now the hippify operation solves this
problem by rearranging data Elements by
carrying out the comparison in this
particular case 43 becomes the parent
node where 40 becomes the China
the next up is deletion as we know the
highest priority element will be the
first to leave the priority queue and
further it is stored at the root node of
a maxi so definitely the element present
at the root node will get removed
but due to this operation the order of
priority queue gets affected however the
hippify operation comes to the rescue it
reshuffles the elements of the priority
queue to rearrange them in order
the next operation that we are going to
discover is peak the peak operation
simply Returns the element present at
root node without removing it and it is
easily accessible thus the time
complexity of this operation is Big of
one
I hope you all are clear with the
operations that can be performed on
priority queue moving forward we'll try
to implement them with the help of
minimum Heat
as discussed earlier while implementing
a heap data structure we know that all
the elements will get stored in an array
and we don't have any pointers pointing
to either child or parent nodes so how
exactly does the Heap data structure
remember nodes like parent nodes and its
left or right nodes well if you have
learned binary trees then you must know
the formulas present on your screen
these formulas determines the left child
right child or even the parent node of
any binary tool
let's understand how this phenomenon
works with the help of an example we'll
begin with index 0. if we enter 0 in
this arithmetic expression then we will
get 1 and 2 as output that means the
element at index 1 will be the left
child and element at index 2 will be the
right side and tree structure will look
like this
now moving ahead let's take an example
of index one for index 1 the left child
will be at index 3 and the right child
will be at index 4.
similarly for index 2 the left child
will be at index 5 where the right child
will be at index 6. using these formulas
we'll be implementing HiFi and primary
queue operations so note them down for
further reference
now moving further we will visit code
Editor to implement priority queue data
structure using C programming language
previously I mentioned that Heap is
implemented using arrays so to begin
with Heap implementation primarily we
will create a structure consisting of
different variables or objects needed to
implement Heap data structure so let's
create a structure
struct keep
consists in size
and count variable
and
end
the
Heap array
which is a dynamic array that we are
creating here
and next we'll also declare a pointer to
Heap structure along with size and count
variable in a global scope so let's do
that end
star
Heap
comma size
comma
count
we'll create one more variable and
initial
underscore size to represent the initial
size of our priority queue and let's
assign it value 4 for now
okay
now it's time to allocate memory to our
Heap array for this purpose we'll create
a new function called Heap underscore
init so let's create this function void
Heap underscore init
and inside it we'll pass an argument
struct
Heap
star
h
which is a reference of this structure
that we created previously
okay
in this function let's initialize the
variables that we have created inside
this Heap structure so for that we'll
initialize h
Arrow operator
count
is equal to zero
similarly
h
Arrow operator
size
is equal to
initial underscore size
and
h
array
is equal to
n
star
malloc
sides of
end
star 4.
this statement is just allocating four
integer variables to our Heap array
basically our Heap array is dynamic data
structure that's why we have to provide
it with dynamic memory using malloc if
you are using C plus plus programming
language to implement this data
structure then you can use new instead
of malloc
moving forward
now we'll work on our condition f
not h
Arrow operator
allocates memory to Heap array then
printf
error while
allocating
the memory
and
that slash on
next we will write exit command
okay
okay
with this we have successfully
implemented our Heap init function now
moving ahead let's Implement hipify
function to move the nodes for that
we'll create a hipify function void
Max underscore
if I
end
star
data
and
log
and
count
so all these are required variables to
implement this apify function that we
have passed in argument for this Maxi P5
function now let's create few more
variables that we need and left
comma right
comma largest
comma temp
now as discussed earlier left
will be equal to 2
star
location
in Array Plus
1.
and right
will be equal to
left
one
now let's
say largest is equal to NOC
and
will work on conditions now f
left
it's greater than or equal to count
and add
data
left
it's greater than
data
largest
that it's
the location we have stored in largest
variable
then
largest is equal to
left
with this block what we are doing is we
are checking if the element at location
left is greater than the element at
recent position and the value at left is
also greater than the value of recent
location if these conditions are 2 then
we will set the recent location as left
and here we are getting signal that
there is semicolon missing over here so
we'll add it
okay
now let's work on next condition
now we will check the value at right
position if the recent location is
greater than the right and the value at
right is greater than the largest value
then element at largest will be set to
right so for that we'll write condition
f
right
it's
count
foreign
data
write
it's greater than
data
largest
then largest
is equal to right
otherwise if
largest
it's not equal to
location
then
we will store
the data present at location in
temporary variable
and
data Loc
is equal to data
largest
this is a swapping operation that we are
carrying out here and next data
largest
is equal to
10.
and now we'll make recursive call to our
Hefty file function Max underscore
if if I
data
comma largest
comma count
with this we have successfully completed
our hipify function
now we will work on insertion operation
on priority queue let's call this
function hip underscore push
because we are treating this structure
as Heap right so and if insertion is
called as push operation so we'll call
it
void
Heap underscore push and will pass
arguments
struct
Heap star
h
int and
value
and inside this function will create few
more variables and index
and parent
if you guys remember the initial size
that we have allocated to our array is
16 bytes
you can verify with this statement here
that we are providing 16 byte size to
our Heap array
but what if you want to insert elements
more than 4 then what we'll do well for
that we'll need to increase the size of
our Heap array so we'll do that here
for this resize we'll create if
condition
f h
Dot
count
it's equal to equal to H
Dot
size
then
h
dot size
plus equal to
1.
and H
Dot
Heap array
is equal to
realock
h
Dot
Heap array
size of
int
star
h
thank you
Dot
signs
basically we are using real lock
function in C to extend the dynamic
memory space for our Heap array and in
order to increase the size we have to
increment the size variable first so
that's what we have done in this
statement here and now once done with
this we'll check if our dynamic memory
is getting allocated or not so for that
we'll add one more if condition inside
this if block so it can be called as
nested if if you guys want
Dot
Heap array
then
exit
minus 1.
now we'll move out of this a block
and we will set index variable
to
h
Dot
count plus plus
basically we are iterating with help of
index variable here
so next we'll add four condition for
Loop
index
to index
is equal to parent
and then set this condition
will make parent node is equal to
index
minus 1
by
2.
this is nothing but the formula that we
have discussed in previous part
now
we'll add one more condition inside this
for Loop if
h
Dot
Heap array
parent
it's greater than or equal to
value
then we will break this fall
otherwise
H Dot
Heap array
index
will be equal to
h
Dot
foreign
Loop and we'll add one more condition of
insertion that is H
Dot Heap array
and add
position index
we will add
the value provided by
user using argument to Heap push
function
okay with this we have successfully
created our Heap push function now we'll
move towards the next function that adds
Heap underscore delete for that we'll
create new function keep
underscore delete
and let's make this function
integer
and will pass
truth
keeps star
Edge as an argument
we will create one more variable
temp
is equal to
h
Arrow operator
keep array
and inside this will pass a negating
index that means we are using this
temporary variable to Traverse through
all list of elements so for that we'll
write dot dot minus minus
Edge
Arrow operator count which will
decrease count one by one
now next we'll add condition f
h
Arrow operator
count
it's greater than or equal to
h
Arrow operator
sides
Plus
2
and and
h
Arrow operator
size
it's also greater than the initial
underscore
size okay
then what we will do is we will
set
foreign
to negate itself
by 1 for each iteration and then
we will
add edge Arrow operator
Heap array
is equal to realock
h
Dot
keep array
comma
size of
and
star
H Arrow operator
and size
sorry
sides
and semicolon
so basically what we are doing here is
we are checking if count is smaller than
the size of heat plus 2 and and the
dynamic size of Q is also larger than
initialized sides that is 4 then what we
are doing is we are reducing the size
for deleting an element using this
statement and in next statement we are
reallocating that deleted space
so this is how this if block works
now moving forward we'll add condition
to check if memory is getting located or
not for that will write condition if
not h
Arrow operator
Heap array
then
what we'll do is exit
with
minus 1.
okay now let's move out of this block
and now
we will
set this removed variable to
Edge Arrow operator
Heap array
and index 0.
so if you guys remember 0 is the index
of the highest element in our maximum
Heat
what I mean here is the element with
highest value is stored at index 0 for
maxi now moving forward to delete this
element what we'll do is we will set h
Dot
Heap array
and index 0
is equal to
temporary variable
or pointer that we have created
previously
and next what we'll do is we'll call Max
underscore ap5 function
to rearrange the structure of our
priority queue which has been shuffled
due to this delete operation now for
that we'll
past arguments are Heap structure that
is Heap array
and next
the index which was removed and the
count
variable
and we'll return the remove element
okay with this we have successfully
implemented our delete function
now to understand the order of deletion
in priority queue we will Implement one
more function called as mtpq so let's
create this function
and in this function we'll pass the
reference of Heap structure in order to
operate on it so let's pass
structure
star
h
and and set this function
we will create a while loop
h
Dot
count
as not equal to
zero
then
printf
modulus d
and
recursive call to Heap delete function
and which will pass h
now
we are done with this mtpq function
further you will create one more
function to visualize our priority queue
let's call this function void Heap
underscore display
and then set this will pass
structure Heap
star
h
and now
we will create one iterator element
using that iterator element we'll create
for loaf I is equal to zero
to I
it's greater than
Arrow operator
count
plus plus I
and inside this for Loop we will print
the elements present in our queue using
this moment
modulus d
and we'll call
Heap
array but for that we'll need to call
structure as well
will pass
this I trade a variable into it
okay and then next we'll get outside
this for Loop and will print as
to the next line using slash n
okay
now we have implemented all the required
function for our priority queue moving
forward will work on our driver function
that is main method to contemplate the
result of our program so for that we'll
First Call struct
keep Edge
then we'll call init function to create
Heap structure so Heap in it and will
pass
the address of
h
next we will call
Heap
underscore push function to insert
element
and H
comma 1.
next
I'll copy this
part
will paste it to insert another element
now we'll insert 5 here
next
and we'll pause three
next we'll insert element seven
next will
insert element nine
and after this we'll insert element 8.
okay so now let's display the elements
inside our key using Heap underscore
display function
and let's press and Edge object
print it and
again
will call
empty PQ function
empty
EQ
plus h
and after deleting all elements
it will return the state of our Heap
array again or our priority queue so
finally we'll add return 0 statement
and now our code is ready so let's
compile it and check it if it works fine
or not
so we are getting four errors here guys
so we'll need to resolve them first
we'll need to check line number 82.
2
okay here we haven't added semicolon
so I think this should be fine now still
we have two errors
before I
teach there
so let's recompile it and check it if it
is working fine now
foreign
so we have received our output now now
if you look at our output our output is
printing elements
97815 and 3 and deletion of elements is
also happening according to their order
so 9 is getting deleted first after
eight seven five three and one
so that means our elements are getting
removed in proper order further we can
say that our program for priority queue
implementation works fine now if you
guys are worried about this program then
not to worry we have you covered you can
mention your email IDs in comment box
below and we will send it over to you
remember guys we can make comments
private to protect all your data so you
can fearlessly put all your email IDs in
comment box below
now we will discuss applications of
priority queue to understand its
importance
the first application that we are going
to discuss is use of priority queue in
Google Maps you must have used Google
Maps several times to navigate from one
city to another or from your location to
nearest desired location have you ever
wondered how Google Maps managed to do
that how does it provide an optimal path
to reach your location
algorithm implemented in Google Maps
actually manages to do that by gaining
access to all possible paths this
algorithm uses the priority queue to
maintain all the parts in order let's
understand how it works in detail
now when you provide the location of
place you want to reach via your mobile
device Google Maps feeds the data of all
possible path to digestra's algorithm
those paths or Road are stored in
minimum priority queue considering the
distance as parameter for priority
assignment and we have learned that the
minimum priority queue maintains the
lowest value at the front or root node
this is how the priority queue helps
Google map to search for an ideal path
for reaching destination location
the next application that we are going
to discuss is data compression in WinZip
or gzip these applications use Huffman
encoding algorithm to reduce the size of
files
is a lossless data compression algorithm
and in this algorithm a variable link
code is assigned to input different
characters the code link is related to
how prequet characters are used most
recurring characters have the smallest
course and longer course are for the
least frequent characters
this is how the generated codes will
maintain the complete data while
utilizing less memory space
let's understand how this process works
with the help of an example let's say
our text file contains these random
characters
the Huffman encoding algorithm creates
scores for each character based on its
number of occurrences for instance the
frequency of character a is more
prominent than b and character C has
less frequency so the length of code a
is smaller than b and length of code B
will be smaller than C
now according to the amount of generated
code the priority queue will determine
the priority of characters and will
store them these codes takes less size
than the actual characters in memory
space and due to the mapping of
occurrences data does not get lost
I hope now you guys understand why the
priority queue is stated as an abstract
data structure itself and why it is the
better version of queue data structure
the stack is a linear data structure
similar to arrays and linked lists
restricting the random axis of elements
in the case of arrays or linked lists
you can access Elements by either
traversal or random indexing which is
reframed in stack data structure
you can understand a stack by
visualizing it as a container of
elements in which elements can only be
placed on top of each other
and remove from that same direction only
stack as a data structure in computer
science is not very different from stack
as a way of organizing objects in the
real world
so stack can be thought as the way you
arrange books stacked on top of each
other these books can only be placed
upon each other from the top end
furthermore to remove any particular
book you will first have to remove books
stacked over it this scenario accurately
depicts sequential book access
equivalent to the stack data structure
in computer science
q and data structure is also a linear
data structure like a stack having some
restrictions on insertion and deletion
in the case of Q insertion is performed
from one end and the removal is
performed from another or opposite end
the Q in data structure can be
understood using the real life example
of a food Coach Line in any food Coach
line or a movie ticket counter line the
customer who enters first always gets
served at first and the customer who
enters last will absolutely get served
at last
furthermore both the ends of these
queues remain open performing different
operations
the rear end of the food court queue
performs the insertion of a customer
whereas the front end performs the
removal of the customer after providing
him with the service that he desires
both the stack and queue data structures
follow the different operational
principles to execute data manipulation
operations
the stack data structure follows last in
first out or first and last out
principles to execute its operations
in simpler words the stat data structure
removes the last inserted element at
first and the first inserted element at
last let's understand the principles
mentioned above with the help of an
example
as you can see in this example 3 is the
last inserted element and if we start
removing elements from this stack three
should get removed at first and seven
should get removed at last unlike stack
the Q data structure follows fifo which
is the first in first out principle to
execute its operations
according to this principle the element
which gets inserted in a list at first
gets removed at first as well
for example in this queue 6 is the
element which is inserted first
so while performing the deletion it
should also get removed before all the
other elements inside the queue
moving forward let's discuss different
data manipulation operations for both of
these data structures
the first parameter that we will talk
about is the insertion operation
the process of inserting data entities
in the stack is called a push operation
this operation can only be performed at
the top end of a stack
for instance consider the simulation of
Stack inserting few data elements the
elements that are getting inserted
inside the stack are of homogeneous data
type
thus we can say that stack can only
store one type of data element the
insertion of elements in a queue data
structure is referred to as an enqueue
operation it gets executed at the rare
end of a queue
the simulation given in this section
represents the execution of rnq
operation
the next data manipulation operation we
have on our list is deletion
the deletion of data entities from stack
data structure is achieved using pop
operation the deletion of data entities
from stack data structures is achieved
using pop operation this operation
removes the elements where a top pointer
is pointing thus we can say that the
stack performs the removal of data
entities from its top end
the simulation shows how the removal of
elements happens in the case of a stack
data structure
now let's move to the deletion and Q
data structure
the process of deleting data elements
from the Q data structure is called DQ
this operation is usually performed at
the front end of a queue
the simulation given below represents
how deletion happens from the front end
of a queue abiding with the first and
first out principle
both of the data manipulation methods we
reviewed earlier can be matched with
previous real life examples what I mean
by that is
the book stacking system can only place
books at the top end as well as it can
remove them from the top end only
furthermore The Waiting queue analogy is
deemed to be consistent with Q data
structure because it adds people from
the back end and removes them from the
front end
now here's the interesting question that
we want you all to answer
so until now we have understood the
structural differences between stack and
queue data structures and both of these
data structures can be implemented using
static or dynamic data structures
So based on your comprehension of these
data structures which implementation
strategy for constraint memory
management is the best choice
the first option is array implementation
static and your second option is linked
list implementation Dynamic do think an
answer it will be interesting to see how
many of you all will get this right
so guys leave your answers to this
question in the comment section Below in
a week's time we will be announcing the
right answer and you all can check it
out
so moving ahead we will discuss about
the pointers maintained in the case of
both these data structures
for stack data structure our ADI only
remembers one location that is the
address of the topmost element
this tracking of a topmost element is
achieved using one pointer which we name
as a top for our convenience
whereas in the case of Q we maintain two
pointers named front and rare the rare
pointer points to the last inserted
element in the queue and the front
pointer points to the first inserted
element in the queue
we use and maintain these two pointers
to execute different operations at both
the front and rear ends
the last parameter that we have for
differentiating stack and queues is when
to use which data structure
start data structure is mainly used to
solve problems that are recursive in
nature for example memory management and
programming environments the resource
allocation and execution of the programs
is a repetitive process based on the
invocation of different function calls
and stack is the basic memory management
architecture for any modern Computing
environment a stack is at the heart of
the runtime environment for Java C C
plus plus Ada Fortran and other
languages which is independent of their
native codes like x86 sun or wax
the stack memory management unit is
compatible with old and new operating
systems including Windows nt10 Solaris
and Linux runtime environments
the next applications of the stack on
all list are expression handling and
backtracking algorithms
the expression handling algorithms
evaluates the output for arithmetic
operation closed inside the parenthesis
the stack data structure is also used to
perform expression conversions as infix
to postfix in fixed prefix postfix to
infix or prefix to infix
furthermore the backtracking algorithm
is also implemented using a stack this
algorithm moves backwards and perform
steps to evaluate a more Adept solution
now let's discuss about Venture use Q
data structure
the queue data structures work on
sequential processing of data hence
whenever your application needs a
sequential processing a queue data
structure can be implemented
for example
Q is used in messaging applications
you are probably aware that we all rely
on messaging apps like WhatsApp Facebook
messenger and Instagram chat to interact
with our friends and family
and you must have noticed that the
person you are attempting to communicate
receives a messages in the same sequence
as you have sent them irrespective of
whether he is online or offline
actually the queue is implemented in
messaging applications at the user's end
containing the messages to be delivered
to the user
so when the user connects to the network
all the text messages in the queue gets
delivered and once the messages are
delivered mtqs get deleted
the next application of Q is its use in
operating systems
multi-user multi-programming and time
sharing environments are common in
today's computers
in this OS setting a system handles
multiple jobs at once and the concept of
a queue is employed to manage these
activities
so remember guys you can Implement stack
data structure to solve recursive
problems and Q data structure to solve
problems that need sequential data
processing
so what exactly is a 3D data structure
the tree is a non-linear data structure
that consists of nodes and is connected
by edges I know it's a little difficult
to understand just by the definition so
let me show you the pictorial
representation as you can see we have
the elements that is 10 20 30 40 50 60
and 70 and all these are stored in the
tree data structure they are stored in a
non-linear structure if we had used
arrays it would have been in a linear
consecutive way where 10 starts first
and 70 ends at the last position
now in the next section we will discuss
why we had made to a switch to the three
data structure when we already had a
linear data structure that is array
now the next topic that is why we need
3D structure
so there are many reasons why we have
switched into three data structure and
one of the reason is a linear data
structure always stores the elements in
a sequential form that is one after the
other and in operations to be performed
in linear data structure that time
complexity increases as the data size
increases you can see here that as
discussed before the elements are stored
in a linear form that is 10 at the first
place and 70 at the last place imagine
you wanted to access the element 70 then
using the traversal you had to start
from the first position that is 10 20 30
40 and slowly at the end is 70. so
accessing that particular element is
really time consuming we are facing this
just for 70 elements imagine if you had
700 elements right so that is exactly
why we had made a switch to three data
structure and using tree data structure
we have many advantages as the tree data
structure is completely non-linear and
it allows easier access and quicker
access of the data elements how is that
possible we will look into it into the
next segment where we will discuss about
the traversal of trees
now before we understand their traversal
of trees we should understand another
important topic that has the
terminologies of tree
so the first one is the node node is the
entity that contains the keys and
pointer towards child nodes
so here you can see that the elements a
b c d e f and g are the elements so each
and every element or the blue dot is
called as unknown and the blue dots here
are
one two three four five six and seven so
we have seven blue dots so we have seven
elements here so you can see the line
between each elements right so this
particular line is called H now we'll
discuss about the H in the next part
so the connecting links between any two
nodes are called as edges so we
discussed about the nodes right where
the element is stored the blue dots are
the nodes and the lines connecting
between the elements or notes is called
as the edge
so out of all the nodes this first node
that is the element a is called as the
root node in a tree data structure so
indirectly root node is also called as
the parent node of all the nodes now we
will understand what are parent nodes
and children nodes
so in a tree data structure the node
that is the node's predecessor is called
as parent node so here we have discussed
that a or the root node is the parent of
all nodes so for a b and c nodes are
children nodes and for B and C nodes a
happens to be the parent node similarly
D and E are the children nodes of B and
F and J are children nodes of c and the
notes d and e have b as a parent node
and the nodes f and g have C as the
parent node now followed by that
we will understand The Descendant node
so as discussed before The Descendant
node is the node that comes after the
parent node here the B and C are the
descendants of a and d and a are
descendants of p and similarly f and g
are The Descendants or children of the
node C
so in a tree data structure the node
which does not have any child is called
as the leaf node now at the end we have
d e f and g so these particular nodes do
not have any children nodes like B and C
so these particular four nodes which do
not have any children are called as the
leaf nodes
in a tree data structure the node with
at least one child node is called as the
internal node
so here the internal nodes are p and C
which have at least one child
in a tree the total number of children
of a node are called as the degree of
that node so in this particular diagram
the degree of root node is 2 because it
has two child nodes and the degree of p
is2 as it has two child nodes similarly
the degree of CS2 because it has two
child nodes but when it comes to d e f
and g the degree is zero because they do
not have any child nodes
in a treated structure the root node is
said to be at level 0 and the children
of the root node are said to be at level
1 and the children nodes of the level 1
are at level 2. so to understand this
let's go through the diagram as you can
see this particular root node is called
as level 0. and followed by that we have
the children nodes of a that is PNC and
that level is called as level one and
followed by that we have level two and
if this tree goes forward the levels
also increase accordingly
now in a tree data structure the total
number of edges from a leaf node to the
particular node is the longest per and
this particular path is called as the
height of that node
now here we have our general tree data
structure and here you can see the
height of node a S2
and the height of node B and C together
is at 1 and the height of the last Leaf
nodes happens to be zero
next in the tree data structure the
total number of edges from the root node
to a particular node is called as the
depth of that node now in this
particular tree data structure the depth
of the root node is 0 and the depth of B
and C
number of edges
H the node a from B is just one and
similarly the number of edges connecting
the node C from a is just one so the
depth of both b and c is 1. now if we
consider the last Leaf nodes then the
depth is two because if you see G is
connected to a using two different edges
similarly f is connected to a using two
different edges and E and D also have
two nodes to connect to a so the depth
is 2. now in the next segment we will
understand the tree node
so the tree data structure has data part
and references towards left and right
child node in the three data structure
so here you can see this is the node and
the node has three segments that is data
element and the references towards left
child and the references to its right
child
now there are four different types of
trees the first one is the binary tree
followed by that we have the binary
search tree then we have AVL tree and
finally we have the Petri let us discuss
H1 of 10. the first one is the binary
tree a binary tree is a tree data
structure in which each parent node at
most has two children
so in this particular tree we'll have at
most two children that means it might
have one or more than one but not more
than two children per node
moving ahead we have the binary search
tree so a binary search tree or a BST is
a tree data structure in which each node
has a maximum of two children all nodes
of the left subtree are less than the
right node all nodes on the right
subtree are more than the root node so
here you can see the image or the GIF
which represents the image of a binary
search tree so here all the nodes of the
left subtree are less than the root node
and all the nodes of the right subtree
are more than the root node
the next type of the tree is the AVL
tree the AVL tree got its name after
inventory Georgie Adelson welsky and
Landis
avl3 is the self-balancing tree in which
each node maintains a balanced factor
most value is either 1 0 or -1
balance factor is equals to height of
the left subtree minus height of the
right subtree or height of the right
subtree minus height of the left subtree
so in this particular image you can
identify it as an AVL tree and now the
last type of tree that is the B tree B
tree is a special kind of self-balancing
search tree in which each node can
contain more than one key and can have
more than two children B3 is also known
as the height balanced m-ray tree now in
this particular GIF we can see how a
battery looks like now followed by this
we will discuss the tree traversal
so traversing a tree helps to visit
required node in the tree to perform
specific operations tree traversal can
be performed in three different ways the
first one is the pre-order traversal
where we visit the node
and visit all the node from the left
side then visit all the nodes from the
right side so this particular GIF is an
example for pre-order traversal where we
visit all the left side nodes first then
we visit the right side nodes now we
will move ahead into the next type of
traversal
that is the in order traversal first we
visit all the nodes from the left side
then we visit the root node and then
represent all the nodes from the right
side so this particular GIF will be an
example for the in order traversal where
we visit all the left side nodes then we
visit the root node and followed by that
we will visit the right side in nodes
and the last type of traversal is the
post order traversal web a visit all the
nodes from the left side first then we
visit all the nodes from the right side
and finally visit the root node so this
particular image on the right side is an
example for post order traversal now
before we get into learning the
applications of trees we will try to
execute one example based on the post
order pre-order and in order traversals
entry data structure
so you can see that we have an example
on my screen right now so here we have
the node structure then we have the in
order travel cell function followed by
that we have the pre-order traversal
function and finally we have the post
order traversal function now let's
quickly run this program and see the
output and don't worry about the code
this particular code document will be
attached in the description box below
and you can have access to it
now we have the Run option over here and
the program got successfully executed uh
you can ignore this warning and here we
have the in order traversal of the tree
and the first output then we have the
pre-order traversal of the tree and
finally we have the post order traversal
of the tree now let's discuss the last
part where we will learn the application
of trees
so the application of trees are as
follows binary search trees are used to
quickly check whether an element is
present in the set or not then we have
the most popular database usage of B3
which is a variant of tree data
structure then we have the modified
version of trees called as Trice which
is used in the router to store routing
information and finally the compiler
uses a syntax tree to validate the
syntax of every program you write
so it is a treated structure in which
each node can have at most two child
nodes these nodes are referred to as
left child in node and right child node
next let's discuss about some terms
related to binary tree
first up unknown a node consists of data
and a link towards both child nodes next
the root load root node is the first
node of the tree next Leaf nodes
these are the notes which has no child
next parent node apart from the root
node any node which has at least one
child is called as parent to that child
node next up a child node any node with
a parent is called as a child node next
up is the internal note any note with a
child and a parent has called as an
internal node next up is the height of
the binary tree the longest path from
the root to any Leaf node is called as
the height of the binary tree next up is
the depth of the binary tree the depth
of the node is the total number of edges
from the root node to the Target node or
the last child node
now let's try to implement the binary
tree in the code editor
as you can see now we are on the code
editor and the code on my screen is an
example for binary tree now here you can
see that we have created a structure for
node followed by that we have a function
where we will print the tree
and this is our main function
now don't worry about the code this
particular code segment will be
available in our description box below
and you can always have access to it and
try to edit and run this code on your
own local system to have a better
learning experience now without further
Ado let's try to run this program
quickly and see the output
foreign
so there you go the code got
successfully executed and here you can
see the output of this particular binary
tree now let's get back to the theory
part so as discussed before followed by
the implementation part we will learn
about the properties of a binary tree
now let us the properties of the binary
trees first up maximum number of nodes
at a level L is 2 to the power l
next up maximum number of nodes in a
binary tree of height H is equals to 2
to the power of H minus 1. next up
minimum possible height in a binary tree
with two nodes is equals to log of L
plus 1 base 2.
next up the minimum possible level in a
binary tree with n nodes is equals to
log of L plus 1 base 2. finally a binary
tree with L lease has at least log l
base 2 plus 1 levels
now let's discuss about the different
types of binary trees
first up we have the full binary tree
followed by that we have the complete
binary tree then we have the perfect
binary tree followed by that we have the
balanced binary tree and lastly the
degenerate binary tree let's discuss
about these in detail first Up full
binary tree
full binary tree is a unique tree data
structure in which a node can have
either two children or no child next a
complete binary tree
so a complete binary tree is another
specific binary tree where each node on
all levels except the last level must
have two children and at the lowest
level all leaves should reside possibly
on the left side
the next one is the perfect binary tree
a binary tree is perfect if every node
must have two children and every leaf is
on the same level
the next one is called as the balanced
binary tree a binary tree is balanced if
for each node the height of the left
subtree and the height of the right
subtree varies at most by just one
at last we have the degenerate binary
tree
a binary tree is said to be degenerate
if every internal node has only one
child
we have now discussed the binary tree
some terms and properties related to
Binary trees and types of binary trees
now we will look into the operations
that needs to be performed on the binary
tree so there are basically three types
of operations that can be performed on
binary tree which are traversal
insertion and deletion
so first we'll look into the traversal
operations
there are three different types of
traversal operations possible on binary
tree which are pre-order traversal in
order traversal and finally the post
order traversal now let's get back into
the text editor mode and try to execute
our example
foreign
so right now we are on the text editor
and this particular code is for the
traversal operations on our binary tree
and here you can see we have the
structure for node and we have also the
in order function free order function
and post order function don't worry
about the code this particular code will
be available in the description box
below and after you have written the
code we have some standard input over
here you can see that we are giving the
number of edges as 4 and the left
subtree elements are 2 and 1 and the
right subtree elements are 2 and 3 and
another left subtree elements are
3 and 5 and lastly we have 5 and 6 for
another left subtree now let's try to
execute this code
now we have already executed the code
and we also have the output over here
and here you can see we have entered the
number of edges as 4 and the traversal
is in order traversal which is one two
six five and three and the pre-order
traversal output is 2 1 3 5 6 and the
post order traversal is one six five
three and two now let's get back to the
PPT now we have the insertion operation
foreign
text editor and try to see an example
for insertion operation as well
so on my screen you can see an example
for insertion operation
so here we have the insert function as I
said this particular code will be
available in the description box below
now let's provide the standard input
so the standard input will be four edges
and we have 2 and 1 as the left subtree
and 2 and 3 as right subtree three and
five as left sub free again and 5 and 6
as the left subtree now let's quickly
run this code
and there you go the program got
successfully executed and here we have
the output
the nodes got inserted and it has
provided an in order traversal that is
one two six five and three
now let's get back to the presentation
and the last type of operation is the
deletion operation let's quickly execute
an example based on deletion operation
as well
now as you can see we are on the text
editor again now here the example is for
deletion operation we have the delete
function over here
now for this particular program we don't
need any standard inputs so just let's
run the program
so there you go the program got
successfully executed and we have the
output over here and in order traversal
before deletion and in order traversal
after the deletion of an element
so the deleted element is element 11.
now with that let's get back to the
presentation mode again so that's how
the element got deleted now we have
reached to the last part of this session
that happens to be the final key
takeaways
so what are the final takeaways so
binary tree is faster at search
operations than other type of tree and
it is easier to find maximum and minimum
elements in the binary tree binary tree
does not allow duplicate values and
draft reversal is done using binary tree
it is used to convert the post-fixed
Expressions into the prefix Expressions
so these were the final takeaways
free traversal is a process of visiting
each and every node in a tree data
structure
so right here on my screen we have a
tree with different nodes that is a b c
d and e
so here we will be visiting all the
notes one after the other using the
three traversal methods
now that we have a brief understanding
of what exactly is a tree traversal
process let's get into the next topic of
our discussion for today that is the
data structure used for free traversal
in a tree data structure there are
primarily two data structures utilized
for tree traversal the first one is the
start data structure and the second one
is the Q data structure a stack is a
linear data structure that operates on
the last end first out lifo principle
there is only one pointer in the stack
that is the top pointer which points to
the Stack's topmost element only the top
of the stack is used for insertion and
deletion now the next one is the queue a
q unlike Stacks as open on both the ends
the one end is always open and used only
for input and the other is only used for
deletion or elimination the principle
followed in Q is first in first out or
fifo approach
followed by that we will look into the
different types of free traversals in
data structure
free traversal can be done in the
following ways the first one is breath
first search and the second one is the
death first search
first let us have a look at the breadth
first search algorithm or breadth first
search traversal we follow level order
traversal in breadth first search
breadth first search traverses notes by
level instead of subfreeze first we
visit the root node followed by the root
node we visit the left subtree of the
tree Then followed by the left subtree
we finish the right subtree of the
entire tree
after that we go until the leaf nodes of
the entire tree is found the second one
is the depth first search in depth first
search we Traverse three data structure
in three ways that is pre-order
traversal in order traversal and post
order traversal
let us take a look at how these
traverses are carried out
first let us discuss the pre-order
traversal we Traverse the root node
first in the pre-order traversal then we
Traverse through the left subtree and
finally we travel through the right
subtree
then there is in order traversal in
order traversal involves traversing of
the left subtree first followed by that
we enter the root node then we visit the
right subtree lastly we have the post
order traversal so post order traversal
involves traversing of left subtree
first then the right subtree and finally
we visit the root node
now next we will have a look at some of
the important applications of free
traversal in data structure
so we use tree traversal in data
structures to build a prefix expression
or polish notation from expression trees
then utilize the pre-order traversal and
then Traverse the expression Tree in a
pre-orderly manner
a binary trees post-fix representation
or reverse polish notation can be
generated using post order traversal
because it returns values from the
underlying set in order according to the
comparator setting up the binary search
tree in order traversal is often
employed on binary search trees
a complete binary tree can be deleted or
released when deleting or phrasing nodes
and values in the post order traversal
now next we will see an example based on
tree traversal in data structures
so on my screen we have an example for
tree traversal in data structure to
begin we have included the enum or
user-specified data type traversal it
mostly used to give integral constant
names which make a programmer easier to
comprehend and maintain
we defined three variables in the enum
data type that is free order in order
and post order traversal we can Define
the type that can take one of the two
values by using the type Def and enum
keywords we have a traversal data type
with trap variable and a node data type
with node variable then we Define the
node using the data structure type as
struct node vericular one variable X and
two nodes as a left and a right notes
respectively in this node section we
then attempted to create node using the
create node function passing the root
node as an argument in this code we use
a malloc function to create a node
assign data to X and null to both the
right and left notes before returning to
the root node
if node T is not equal to null we simply
return it otherwise we will use the
release tree function to release the
left and right nodes and if neither is a
root node then we will use the free
function to release the node T which
would behave as the root node then we
Define the display tree function which
takes the Trap variable and the root
node as parameters
there is a condition in this function
that is if the root node is not null we
will return the root node then using the
switch case scenario we attempted to
Traverse the tree using all three types
of traversals we utilize a Trav variable
in the switch function so if any of the
in order pre-order or post order
variables match the Trap variable the
traversal will be executed then we
created a tree using the create tree
function which takes a data variable as
input in the create tree function we
used a malloc function to create the
root node and we first assigned a null
to the left and right nodes as well as
the data to the variable X before
returning to the root node
we first Traverse the root node then the
left subtree and finally the right
subtree in the pre-order traversal case
in order traversal case we first
Traverse the left subtree then the root
node and finally the right subtree and
in the post order traversal case we
Traverse the left subtree then the right
sub tree and finally Traverse through
the root node and finally we exit the
display tree function and moved on to
the main function we assign the values 5
as the root node then 10 20 and 30 as
the left notes and similarly 15 25 and
35 as the right nodes and then we call
the three three traversals that is
pre-order in order and post order to
Traverse the tree and finally we release
the root mode now let us try to execute
this program and see the output
so there you go the program got
successfully executed and you can see
that the output has been displayed on my
screen so the pre-order traversal is 5
10 20 25 15 30 and 35.
followed by the pre-order traversal we
have the in order traversal that is 20
10 25 5 30 15 and 35 and finally we have
the post order traversal that is 20 25
10 30 35 15 and 5.
so without any further Ado let's get
started with introduction to binary
search tree
finance history is a set of nodes
organized in such a manner that they all
have the same binary search tree
characteristics
key and a value is assigned to each node
the requested key is compared to the
Keys in binary search tree
so during search if the key is found
then the corresponding value will be
retrieved
next up
properties of binary search tree
first up the left subtree of a node
contains only nodes with keys lesser
than the parent node
next up the right subtree of a node
contains only nodes that are greater
than the parent node
the left and the right subtree each must
also be a binary search tree
next let's discuss what are the
operations we can perform on a binary
search tree
first up insertion
last deletion
let's discuss them in detail
first up insertion
we can insert a node in a such a way so
that we obey binary search tree rules
that is the new node should be either
less than the parent node if it's a it's
on the left subtree or if it's on the
right subtree it should be greater than
the parent node let's execute this in
the code editor
we will start by creating a class for
the binary search tree so class
PST
int data
and bsp pointers
yeah
comma
right
next we will Define some functions
publicly
public
first default Constructor
and a parameterized Constructor
a function to insert the value
and a function to Traverse the node
now let's write default constructor's
definition
from EST
now let's write the parameterized
constructor's definition
BST
and
value
data
is equals to value
and left is equals to null
and
right
equals to null
now let's write the definition for the
insert function
so BST
start PST
star
root
comma
and value
now we will check if the tree is empty
or not
so if
root
then we will insert the first node
so we will return
you
EST
value
otherwise we will insert the data so if
the value
is greater than
root data
and
then we have to insert it
in the right subtree
so root
right
is equals to
insert
root
right
comma value
else
helps with the value should be inserted
in the left
side
so root
left
is equals to insert
root
left
comma value
and then we will return
root
now let's write the Traverse function
so void
PST
drivers
PST
star root
if
root
and we will return
otherwise we will First Traverse
left side
then we will print the root data
and then we will Traverse
the right side
root
right
now let's write the main block
so we will start with an empty tree so
BSD
B
comma
star root
is equals to null
the root
is equals to
B dot insert
root comma
50.
e dot insert
equals to
root comma 10.
B dot insert
gonna be root comma
30
e dot insert
gonna be fruit
comma 50.
sorry we already use 50 so we will use
60
a DOT insert
root
comma let's use 20.
let's try to Traverse this
so B Dot
Traverse
root
let's execute this
as you can see we have successfully
created and traversed our first binary
search tree
let's get back to slides
at last deletion
we will delete a node following the
binary search tree rules that is the
value of the left subtree should be less
than the parent node and the value of
the right subtree should be greater than
the parent node
let's try this in a coordinator
let's start by creating a node
this time we will use structure so
struct
Ure
hint
key
product
node
start left
comma
are right
now we would create a utility function
to create a new binary search tree node
substruct
node
star
new node
and
item
code
star
and
equals to
product
code
star
malloc
size of
product
no
next
attempt
it will be assigned the key is equals to
item
left
equals to null
and
damn
right
is equals to
no
now let's write a function to Traverse
the tree
Traverse
node
star
root
so if
root
is equals to null
Traverse
root left
Co
root
e
covers
root
right
now let's write a utility function to
insert the new node with the given key
in the binary search tree substruct
code
insert
node
star
node
comma
and key
so if
node
is equals to null
then we will return
new node
key
otherwise
we will recover down the tree so if
he
is less than
unload key
then we will insert in the left subtree
so node
left
is equals to insert
code
left
comma
key
else
node right
could be inserting
e
now let's return the node
foreign
Ty binary search tree so we have to
return the node with the minimum key
value found in that tree
so we will start
men
value node
star mode
node
star
current
is equals to node
so we will look down to find the left
most leaves
so
while
current
and
parents left
is not equals to null
so current
should be equals to
current
return
current
node star
Elite
node
star
root comma and key
f
root
equals to null
return
root
now if the key to be related is smaller
than the roots key then it lies in the
left subtree so we will check if
he
less than
root key
then root
left
it will be equals to
delete node
root left key
comma key
foreign
root
right
is equals to
delete
node
root
right
comma k
else
if
Roots dot left
equals to null
and
root
dot right
is equals to know
then return
else
if
root
that
equals to null
construct
node
star
is equals to
root
right
and free
root
return
temp
L if
roots
right
is equals to null
then strapped
out star
jump
is equal to root
3
root
return
temp
now node with the two children get the
in order successor smallest in the right
subtree
so struct
note star
temp
is equals to
Min value
node
root
right
now we will copy the inorder successors
content to this node so root
is equals to temp
now we will delete the in order
successor so root
right
equals to
delete
code
right
comma temp
e
now we will return
root
now let's write the main block
we will start with an empty tree
accept
note star
root
is equals to
null
now root is equals to
insert
root comma
2.
root
is equals to insert
comma five
root is equals to insert
root
comma
three
root is equals to insert
root
comma four
root
is equals to
insert
root comma
seven
and root
equals to insert
root comma
six
let's try to Traverse this so C out
traversal
of the given
me
hours
root
now first we will delete a value so see
out
foreign
to
a root is equals to
delete
node
root comma
to
C out
traversal
after
deleting
travels
root
foreign
as you can see we have successfully
deleted two and Traverse the tree again
let's get back to our slides
at last let's sum up what we have
learned from this session
first off left side notes are always
lesser than the parents know and the
right side note are always more than the
parent node
next it is easier to search and sort
elements in a binary search tree
finally a binary search tree offers
faster insertion and deletion operations
so let's get started with introduction
to avial trees
an able tree is a high balanced binary
search tree for each node we have to
make sure that the height of the left
subtree and the right substrate can
differ by at most one we can calculate
this balance Factor by subtracting the
height of the left subtree from the
height of the right subtree now let's
discuss various rotations we can perform
on avial trees first up LL rotation next
are our rotations next LR rotation at
last RL rotation let's discuss them in
detail first up LL rotation it is a
clockwise rotation when a node is
inserted on the left subtree of the left
subtree of a node then we apply this
rotation to balance the tree it is
applied on the Node below the balance
Factor 2 node that is we will apply
right rotation on the green node next
are our rotation when a node is inserted
into a right subtree of the right sub
tree of a node then we perform RR
rotation it is an anti-clockwise
rotation which is applied on the Node
below a node having balance Vector minus
2 that is we will apply it on the green
node
next up LR rotation
when a node is inserted into right
subtree of the left subtree of a node
then we perform alerts rotation
it is a combination of R and LL rotation
first we will apply error rotation on
green and yellow node
after this red node is still unbalanced
so we will perform LL rotation on the
yellow node
finally
RL rotation
when a node is inserted into the left
subtree of right subtree of a node then
we perform RL rotation
it is a combination of LL and RR
rotation
first we will apply LL rotation on green
and yellow nodes
with this the red node is still
unbalanced so we will perform error
rotation on the yellow node now let's
discuss complexity of AVL trees
first up space complexity is a bigger of
n
next up av3 offers a complexity of
bigger of log n for searching
next up
AV trees offer a complexity of bigger of
log n for insertion
finally AVL tree offers a complexity of
bigger of log n of for deletion
we have now introduced an AVL tree and
rotations on it now let's discuss some
of the operations we can perform on
avial trees
first up insertion
and deletion
let's discuss them in detail
first up insertion
we will insert a node following binary
search tree rules then we will check if
the nodes are balanced or not if they
are not then we will balance it by using
suitable rotations now let's try these
operations in a code editor let's start
by creating a node to create a node we
need a class node
we will create its member as public
and key
dot star left
Star right
end height
now let's write a function to get
maximum of two integers
so and Max
a
comma and B
now let's declare a utility function to
get maximum of 20 integers so end
Max
a comma and V
now let's write a function to get the
height of the tree
and height
node
star
and
now if n is null
then we will return 0.
else we will return
and calls
hi
now let's write that function to get
maximum of two integers
hint Max
int a
comma
ENT B
we will return
if
a is greater than b
then we will return a else we will
return B
now let's write a helper function that
allocates a new node with a given key
and null left and right pointers
foreign
star
new node
End Key
word
star node
equals to new
node
so node
key
will be equals to key
node
left
will be equals to
left
node left
will be equals to null
and node
right
will be equals to null
and node
you know right
will be equals to
1.
1
and return
node
here we have kept height as 1 because at
the new node is initially added at Leaf
so by default it will always be at 1.
now let's write a utility function to
write rotate subtree rooted with y
node
star
right
about star y
foreign
is equals to Y is left
and
node
star
E2 is equals to
X
right
now we will perform rotation so X right
will become by
and Y is left
will become T2
now we will update the heights so why
height
is equals to Max
of
height
of Y left
comma
hi
of
y
site
plus one
now
X
height
equals to maximum of
height
X
left
comma
height
of
X
right
plus one
now return
X
now let's write a utility function to
left rotate sub tree rooted with x
so node
or left rotate
about star X
node star y
will be equals to
access right
and node
star T2
will be equals to excess
sorry
twice as
now we will perform rotation so why
left
will be equals to X
and
X
right
will be equals to T2
now let's update Heights so X
height
is equals to
maximum of
height
of X is left
comma height
of
X is right
and
y height
equals to maximum of
height
of
of
Y is left
comma
tight
of
wise right
return
y
now let's write a function to get
balanced Vector of node n
so in
that
balance
argument as node pointer and
if
n is n is equals to null
then we will return
0.
otherwise
we will return
height
of
ends
left
minus
height of
hence right
now let's write a recursive function to
insert the key in the sub tree rooted
with node and Returns the new root of
the subtree
so
node
star
insert
notes
star
node
comma int key
now we'll perform the normal BST
insertion so if
node is equals to null
then we will return
new
node
key
now if
this key
is less than
nodes key
then load
left
will equals to
insert
node
left
comma key
or else
we will insert that in the right node
right
is equals to
insert
node
right
comma key
now we will return node
this if else will make sure that we will
reach to the leaf node and then we will
insert the key
now we will update the height of the
sensor node
so node
right
is equals to 1 plus
Max
height
of
left
all right
comma
height
of node
right
now we will get the balance factor for
this ancestor now to check whether this
node became unbalanced so int balance
is equals to get
balance
now if this node becomes unbalanced then
there are four cases
so if
balance
is greater than 1.
and E
is less than
about
left
key
then we will return
right
rotate
note
this if statement for the left left case
so or allele case
now let's write it for the right IDs or
RR keys so if
balance
is less than -1
foreign
is greater than
node
right
key
then
we will return
left
rotate
node
now write for the left right case or LR
case so if
balance
is greater than 1.
and
key
is greater than node
left
key
the node
left
is equals to
that rotate
node
left
out return
right
rotate
now let's write the right left case or
RL case
so if
balance
is less than -1
and
key is less than node
to the right
key
and node
right
will be equals to
write
rotate
node
to the right
and we will return
left
now we will return this node
now let's write a function to print
pre-order traversal of this tree
so avoid
pre-order
code
star root
so now if
root is not null
then
C out
root
key
and now three
order
root
and pre-order
now let's write the code for the main
block
we will start with an empty tree a load
star root is equals to null
now we will try to construct tree
yeah root
is equals to
insert
root comma 10
root
is equals to insert
root comma 5.
root
is equals to insert
root
comma
2
root is equals to insert
root
comma 3
2 is equals to insert
root comma seven
and root is equals to insert
.com
comma
9.
now let's try to print this tree
so C out
area
3
is equals to
three
and
three order
three order
root
let's execute this
as you can see we have successfully
created our first Avia tree let's get
back to slides
at last deletion
we will delete a node following a binary
search tree rules then we will check if
all the nodes are balanced or not if
they are not then we will balance it by
using suitable rotations
now let's try these operations in a
coordinator
let's start by creating a node to create
a node we need a class
node
we will Define its members as public
and key
node star left
node star write
end height
now
let's write a utility function to get
height of the tree so end
height
node
star n
f
n is equals to null
then in that case we will return 0
otherwise we will return
hence height
now let's write a utility function to
get maximum of two integer
and
Max
and a comma ENT B
so we will return
if a is greater than b
then a
else
B
now let's write a helper function that
allocates a new node with a given key
and null left and right pointers
so node
star
new node
end
key
so node
star
new node
is equals to new
node parenthesis
Now new node
will get key
as
key
new node
left
is equals to null
and new node
right
is equals to null
and new nodes height
is equals to 1. because new node is
initially added as leaf that's why it is
always be given as 1.
now we will return this node return
node
now let's write a utility function to
write rotate a sub tray rooted with y
so node
are
right rotate
mode
star y
dot star X
is equals to
y left
node
dot T2
is equals to
X
right
now we will perform rotation so X
right
is equals to y
y
left
is equals to T2
now we will update Heights
so why
equals to maximum of
height
of
Y is left
comma
height
of
wise
right
plus one
and
x height
is equals to
maximum of
height
of
X is left
foreign
plus one
now we will return this new route so
return
X
now we will write
node
star left rotate
load star
X
root star y
will be equals to X is right
and
dot star T2
will be equals to Y is left
now we will perform rotation so why
left
equals to X
and X
right
is equals to T2
now we will update these Heights so X
height
is equals to maximum of
height
of X that
comma height
of X right
plus one
and
Wise height
is equals to Max of height
of
twice left
comma height
of
wise right
plus one
now we will return this y
now we will write a function to get
balance factor of node n
so int
capital
get balance
node star n
so if
n is equals to null
foreign
otherwise we will return
height
of
ants left
minus
height
of
ends like
now let's write a function to insert a
node so node
start insert
it's a node
star node
comma
and
key
now we will perform normal BST rotation
so if
node
is equals to null
and we will return
new node
key
so now
if
key
is less than node key
then
node
left
will be equals to insert
node
left
comma key
now if
e
is greater than node key
then node
right
is equals to
insert
node
right
comma key
else
we will return
node because like equal keys are not
allowed
now we will update the height of the
ancestral node so node
height
Plus 2.
1 plus
Max
height
of node
left
comma height
of node
right
now we will get the balance factor of
this ancestral node to check whether
this node becomes unbalanced
so if
end
balance
equals to
get
balance
of this node
now if this node becomes unbalanced then
there are four cases that could be
possible bus stop LL case
so if
balance
is greater than
one
and
key
is less than
node
left
e
return
right
rotate
node
now let's write write that case
so if
balance
is less than -1
and
key is
greater than node
right
key
then we will return
left
rotate
node
now let's write left right case
so if
balance
is greater than 1.
and
e
is greater than node
left
key
and
node
left
will be equals to
left rotate
node
and we will return
right
58
now let's write the case for right left
case
if
balance
is less than minus 1
and
e
is less than node
right
so node
right
is equals to
write rotate
node
right
now we will return
left rotate
note
now let's return the unchanged node
pointer
on return
node
now let's write a function to find
minimum value node
so node star
men
value
dot star node
so node
star
current
equals to node
so while
current
left
is not equals to null
current
is equals to current
at left
now we will return current
now we will write a recursive function
to delete a node with the given key from
subtree with the given root
so node
star
delete node
its arguments are not pointer root
comma
ENT key
for starters we will perform standard
BST delete so if
root is equals to null
then we will return
root
now if the key to be deleted is smaller
than the root key then it lies in the
left subtree so
if
e is less than root
e
then root
left
will be equals to
delete
node
root to the left
comma key
now if key to deleted is greater than
the root key then it lies in the right
subtree so else
if
e is greater than root
e
then
root right
equals to
delete
node
root
site
comma key
now if the key is same as the root key
then this is the node to be deleted so
else
if
root
left
equals to null
uh
root
to the right
is equals to null
then node
star
temp
is equals to root
left
now f
temp
is equals total
the temp
will be equals to root
and root
will equals to null
else
root
will be equals to start temp
and three
temp
lates
node
start time
is equals to
main value node
root
right
now we will copy the in order successors
data to this node
so root
e
is equals to temp
e
now we will delete this in order
successor so root
right
is equals to
delete
node
root
comma
temp
key
of if
root
is equals to null
then we will return
root
now we will update the height of the
current node
so root
right
is equals to 1 plus
Max
of height
of roots
left
comma
height
of
comma height
of root
height
now we will get the balance factor of
this node
so
and
balance
is equals to
get
balance
root
if this node becomes unbalanced then
there are four cases
first up LL case
so if
balance
is greater than one
and
that balance
of
roots
left
is greater than equals to zero
then we will return
right rotate
now if
balance
is greater than 1.
and
get balance
of root
left
Less Than Zero
then
root
left
will equals to let rotate
root
that
now we will return
right
rotate
put
now let's write write that case so if
balance
less than minus 1.
and
get balance
is less than equals to zero
then we will return
left rotate
now we will write right left case so if
balance
is less than -1
and
get balance
of root
right
is greater than zero
then
root
right
is equals to
write rotate
root
right
now we will return
left rotate
and we will return this route
now let's write a function to print
pre-order traversal of this tree
so void
free order
code
star root
so if
root
not equals to null
and C out
root
a
a pre-order
root
duct
and pre-order
root
right
now let's write a code for the main
block
we will start with an empty tree so node
root
is equals to
null
now root
is equals to insert
2 comma
2
.
root is equals to insert
yeah
root comma
10.
root is equals to insert
root comma 9
root
is equals to insert
root comma seven
root is equals to insert
root comma 5.
is equals to insert
2 comma 3.
now let's try and print this of evil
tree
so C out
created
AVL
pre-order
simply order
so
now we will delete a node so root
is equals to
delete
node
fruit
comma
10
.
now let's again try and print this
so C out
modified
AVL
tree
free order
after
deletion
of 10
layout
handle
pray order
root
it
now let's execute this
as you can see our deletion function is
working perfectly so with this we have
come to the end of the session on the
data structures full course I hope the
session was informative and interesting
if you have any queries regarding any of
the topics covering this session or if
you require the resources like PPD code
documents or anything then please feel
free to let us know in the comment
section below and a team of experts will
be more than happy to resolve all the
queries at the earliest until next time
thank you stay safe and keep learning
hi there if you like this video
subscribe to the simply learned YouTube
channel and click here to watch similar
videos turn it up and get certified
click here