with the largest developer Community a
variety of tools integrated development
Enterprises robust ecosystem for
software development almost an infinite
pool of resources and repositories
javasil continues being probably the
most in-demand programming language in
2023 software development is one of the
most sought after careers according to
the current trends an average software
developer with Java expertise can earn
minimum salary of 12 lakh in India and
in about 100 000 in the US if you are
watching this video I believe you are
one of those aspiring Java programmers
dreaming to build a secure career with
strong fundamentals and a powerful
portfolio to crack that dream job
opportunity we from Simply learn bring
you this complete Java full course we
will cover the fundamentals of java that
includes the core Java programming
Concepts like data types variables
conditional statements looping
statements object oriented programming
Lambda functions Java Collections and
much more not just that this full course
will also dive into the most crucial
program in paradigms that involves
Advanced Java programming exceptional
handing jdbc spring API programming
hibernate and much more to make things
interesting we are also covering the
most brain teasing pattern programs core
Java projects Advanced Java projects
projects ideas for your portfolio and
some important and frequently asked
questions in Java developer interview so
sit tight you are watching simply learn
and if these are the type of videos
you'd like to watch then hit the
Subscribe button and press the Bell icon
to never miss any upcoming videos from
us
in today's era the internet and
smartphones have become an integral part
of our Lives we use our phones for
almost all of our day-to-day tasks
earlier we used to shop at malls queue
up in front of Banks and make our travel
bookings at travel agencies but now we
can do all this in the comfort of our
homes using smartphones all of this is
possible because of a high level
programming language called Java hi guys
welcome to this video that will tell you
everything you need to know about the
class-based object-oriented programming
language Java Java is an object-oriented
programming language that is used in a
distributed environment on the internet
it is a high level language that is easy
to read and understand Java is popularly
used in console graphical user interface
web and mobile applications game
development and also to make embedded
systems apart from these Java is also
used to develop software for devices
is used not only in computers and
mobiles but even in electronic devices
like televisions washing machines air
conditioners and so on online forms
Banking and shopping are possible
because of java Java is a computer-based
programming language invented by James
Gosling and Sun Microsystems in 1991. he
had a single motor while creating the
language it was right once run anywhere
this meant that the code would have to
be written only once but it could be
used anywhere they named this language
Oak because of the oak tree outside
Gosling's Office later it was named to
Green then to Java Coffee which was
named after the coffee from Indonesia
and finally to Java in 1995
there are three editions of java each
programmer can learn any of these
editions based on the application they
want to make firstly we have Java
standard edition this Edition contains
core libraries like java.lank java.tutil
Etc secondly we have Java Enterprise
Edition this Edition has apis like JMS
ejb JSP servlets Etc and lastly we have
Java micro Edition which
program Java in cell phones setup boxes
handhelds and so on Java is an object
oriented programming language based on C
and C plus plus however it is improved
and simplified to solve the errors in
programming Java files are converted to
bit code format using a compiler and
then executed by the Java interpreter
the whole Java code is run on the Java
virtual machine which provides a runtime
environment now the main Concepts in
Java are its methods and classes a
method is a block of code that performs
a task only when it is called consider
this example while watching TV you use
the TV remote to change channels each
button on the remote performs a
different task methods in Java are the
same we can have methods to add two
numbers or email a person or to convert
kilometers to meters a group of methods
make a class classes are used to
organize code just like how fruits
vegetables and clinical products are
divided into different sections in a
super the market there are a lot of
features in Java let's start by looking
at them one by one it has a simple
syntax and is very easy to understand
and learn Java language is robust it
eliminates errors that occur in the C
and C plus plus languages Java also has
features like garbage collectors and
exception handling this makes Java very
unique the most popular feature of java
is that it is platform independent here
compilation happens in byte code and
because of this Java can run on any
machine it is a very secure language as
it contains no virus Java has a feature
of multi-threading the feature of
multi-threading helps Java do
multitasking Java is a portable language
as it can run on any platform and data
type sizes are set permanently so Java
program has a fixed size of the code the
last of all Java is not as fast as C and
C plus plus but provides higher
performance than any other language now
let's see oops Concepts in Java Java has
four Concepts abstraction encapsulation
inheritance and polymorphism in Java we
use objects and classes related to the
real world that makes the code easier to
make and understand abstraction means
showing the relevant information that is
needed for a task encapsulation makes
the Java code secure data is stored
within the classes and it is not easy to
access the data the next feature is
inheritance as the name suggests the
attributes and characteristics of one
class can be inherited by another class
because of this coders take less time to
create the code lastly we have
polymorphism which means using the same
method for different tasks in Java we
can use the same object or variable in
two different places where their tasks
will differ
our first question who is a Java
developer
so Java developer basically is a
professional computer software developer
who uses Java programming language to
build the software
now Java developer mainly uses Java to
build software for desktops mobile
phones and also develop software for
similar electronic devices such as a
smartphone tablet Etc now to become a
Java developer we need to have at least
a bachelor's degree in relevant stream
preferably computer science later you
might want to join an internship or a
training exercise that involves a
project or some highly recognized
certification like Oracle certified Java
developer then your dream job in your
dream company so this was a simple
walkthrough or roadmap to become a Java
developer now moving ahead we have a
main topic for today's discussion that
is the skills required to become a Java
developer
now we shall categorize this into two
stages one is the beginner and the other
is a professional we shall discuss each
one of them separately so first we will
start with the beginner so these will be
the basic skills that any interviewer
will be expecting out from a PR beginner
so in the beginners section the first
skill that we will be discussing is
related to the object-oriented
programming Concepts in Java so for a
beginner the concepts of object oriented
programming in Java play a very
important and vital role for an
interview
so he or she should be having a strong
grip over the object oriented
programming Concepts in Java so followed
by object oriented programming Concepts
in Java we have the next important
Concept in Java which is the file input
and output operations and serialization
so serialization is another way of
executing your code from a different
place for example if you write a code
and you wanted to execute the same code
in a different place in a different
computer all you can do is just
serialize your code to that particular
system and there the same code will be
executed so followed by the second point
the third important skill we need to
have is the good understanding of data
structures in Java
data structures or Java Collections are
the most crucial parts of programming so
for a beginner it's really important
that you have a good grip over all the
Java Collections so followed by that the
next important skill you require is
to learn how to handle exceptions
so exception handling plays a vital role
in real time programming so you better
have that next after exception handling
we have the good understanding of jvm
and memory management
so jvm basically is the Java virtual
machine so what happens in Java is you
write a code and that particular code is
compiled and converted into bytecode so
this bytecode will be transferred to jvm
and then jvm executes your byte code and
results in an output so you need to have
the good understanding of jvm and the
memory management Concepts in Java for a
beginner level so followed by that the
next important thing is multi-threading
and synchronization in Java so all those
were the basic and important crucial
skills required by a beginner if you're
attending for an interview because these
are the basic skills that every
interviewer will be looking out in a
beginner so let's have a quick overview
of the skill set again so for a beginner
level the major skill sets that you
require are to have a good understanding
of object-oriented Concepts in Java next
the file input and operations and
serialization Concepts in Java good
understanding of data structures or
collections in Java exception handling
jvm or Java virtual machine and memory
management and finally multi-threading
and synchronization so these were the
major skills that are required by a
beginner now followed by the skill set
we will have another slide that depicts
about the IDS that you must be
comfortable with so for a beginner these
are the basic Ides that you should be
comfortable with which are IntelliJ
eclipse and netbeans and also these are
the mainly used IDs in real-time
programming as well so if you are
comfortable with these three Ides then
it will be an added way to your resume
so followed by the beginner we enter
into the next level which is the
experience level so this is really
important so we have multiple skills
required by an experienced level
candidate so the first one amongst the
important skills required by an
experience level candidate are a good
knowledge of big data and artificial
intelligence Yes you heard me right
artificial intelligence there is a major
misconception that R and python are the
only languages that are built for
artificial intelligence and data science
but in reality even Java can perform the
artificial intelligence data science and
machine learning jobs using the new
libraries which are dedicatedly written
for the purpose now for an advanced or
experience level candidate the knowledge
of these libraries and the workflow is
really important so followed by that the
next important skill required by an
experience level candidate is a good
understanding of blockchain next after
the blockchain there are multiple Big
Data Frameworks out there which you need
to learn
next after that we have microservices
springboard and scripting languages such
as angularjs react.js and JavaScript so
let's have a quick overview of the skill
set required by an experience level
candidate so those are Ai and ml
libraries in Java good understanding of
blockchain Hadoop and Big Data
Frameworks spring Boot microservices and
finally Advanced scripting programming
languages like angularjs JavaScript and
react.js
now these skill sets might look big
complex complicated and hard to digest
but Java developers are categorized into
multiple streams of development just for
example we can see Java developers
working over web development Android
development First Act Big Data machine
learning artificial intelligence and
many more now let us consider three most
popular streams where we find Java
developers which are the web development
areas Android development areas and
finally the full stack development areas
so first we will discuss the skill set
required by a web developer
so for a web developer these are the
major skill sets required which are the
good knowledge of java servlet Pages or
GSP popular markup languages such as XML
HTML and next after that we have model
view controller so one should have a
good understanding of model view
controller our MVC architecture followed
by that we have good knowledge of web
Technologies like CSS and JavaScript and
finally Java applets so the important
Frameworks for a web developer to be
well burst with are Apache struts play
Google web toolkit and finally Grails so
these are the popular Frameworks that
are currently in Trend and used by Java
web developers so followed by the web
developer next we have is the Android
developer so an Android developer is a
software developer who specializes in
designing applications for Android
Marketplace the Android Marketplace is a
direct competitor to apps App Store this
means most of the Android developers job
revolves around creating apps that we
use on our smartphones and tablets now
the skill sets required by Android
developer are good grip over the Android
SDK or software development kit next the
Android testing followed by that a
better understanding of Android API and
database database connectors like jdbc
and Android security and finally get
Version Control now get Version Control
will be really helpful to keep your code
updated now followed by this case
required by an Android developer we will
go through some important Frameworks and
user interface development software
tools required by an Android developer
in real time first let us discuss the
user interface development tools like
flutter and react.js which are the most
popular ones amongst the others so
react.js is an open source front-end
JavaScript library for building user
interfaces or UI components it is
maintained by Facebook and a community
of individual developers and companies
react can be used as a base in the
development of single page or mobile
applications so next after react.js we
have the flat top flutter is an open
source user interface software
development kit created by Google it is
used to develop applications for Android
iOS Linux Mac Windows Google and many
more from a single code base
so next we have the solar 2D solar 2D is
a free and open source cross-platform
software development kit and then we
have the Android Studio that is another
popular development kit just for Android
now next in the docket is the Java full
stack developer a full stack web
developer is a person who can develop
both client and server software in
addition to mastering HTML and CSS he or
she also knows how to program a browser
like using JavaScript jQuery angular and
view so now the major skill sets
required by a full stack developer are
having a good understanding of software
design and architecture understanding of
devops knowledge of microservices apis
and libraries design patterns in Java
react and angular scripting languages
and finally should be capable to work on
front-end and back-end so these were the
major skills required by a full stack
developer so followed by this we shall
also discuss the major frame inverse
required by a full stack developer
so these are the major tools Frameworks
and scripting languages that are
supposed to be known by a full stack
developer we have the integration tools
such as Jenkins and devops related tools
like kubernetes and Docker and scripting
languages like angular and react and
Frameworks like spring and testing tools
like junit
so with this we will move ahead into our
next important topic that is the roles
and responsibilities of a Java developer
so first we will discuss the rules and
responsibilities of a Java developer at
beginner level
so the important roles and
responsibilities for a beginner are
to be able to define the objectives by
analyzing the requirements of the
clients followed by that to be capable
enough to complete the assigned job
before the deadlines designed and test
basic codes resolve the reported issues
in time and troubleshoot the code
improvise the existing code quality and
finally support the user with proper
documentation of the code so these were
the important responsibilities of a Java
developer at beginner level now let us
advance to the next level where we will
discuss the rules and responsibilities
of experience level candidates
so the roles and responsibilities of an
advanced level or experience level
candidate are
all the basic responsibilities of a
beginner so followed by the basic
responsibilities an advanced level Java
programmer should be having a thorough
knowledge of system functionality and
features followed by that the experience
level Java programmer should be able to
design and develop user interface
enhance the repetition of the company
recommend updates based on the
performance ensure the best possible
responsiveness and finally explore and
add value to the achievements of fellow
co-workers
so these were the important roles and
responsibilities of a Java developer
both at beginner level and experience
level now let us check out the companies
which are looking for Java developers
there are many companies that are
looking for Java developers in the
current IT industry some of the major
mncs looking out for Java developers in
the current IT industry are cognizant in
forces Oracle capgemini Dell Amazon web
Pro emphasis and Accenture now that we
have discussed the company's hiring Java
developers let us take a step further
and discuss the salary trends of the
Java developers in the current it
Industries
now let us discuss the salary trends of
Java developers in India first so the
salary trends for a Java developer who
is going through the beginner level or
an internship level start from 2 lakh to
4 lakh rupees per annum similarly for an
experience level Java developer the
salary Trends start from 5 lakh and go
up to 10 lakhs and above based on your
experience level and skill set now let
us go ahead and discuss the next country
which is the United States of America so
for a Java developer at beginner level
America offers 55 000 to 80 000 for
annum similarly for an experienced level
candidate America offers 85 000 US
dollars to 1 lakh 25 000 US dollars per
annum based on the experience and skill
set now finally we have the United
Kingdom the United Kingdom offers 45 000
pounds to sixty thousand pounds for a
Java developer at a beginner level and
similarly for an experience level Java
developer United Kingdom offers 65 000
pounds to 85 000 pounds per annum so
these were the salary trends of Java
developers in multiple countries so if
you wish to join the right training
exercise that covers the complete skill
set according to the standards of top
mnc's curated and explained in a
detailed manner by real-time industry
experts then simply learn would be the
right choice if you visit the simply
learn official website for Java related
training then you can find the simply
learn has beautifully organized all the
major topics of java in a
result-oriented manner that will be
helpful for both beginners and
professionals
so the key features of java training
offered by simply learn will have 70
hours of Blended training Hands-On
coding and implementation of two
web-based projects it also includes
hibernate and spring Frameworks 35
coding related exercises on core Java
and lifetime access of self-paced
training and finally the flexibility to
choose your own classes so the benefits
of java certification training offered
by simply learn will have the following
you can achieve your designation of
becoming a Java architect Java developer
database administrator or web developer
with a certification from Simply learn
on Java so the average salaries for a
Java developer with certification will
be varying from 16 lakhs as minimum and
will also reach up to the maximum of 27
lakhs per annum the Java certification
from Simply learn has been recognized by
multiple multinational companies and
some of the major MNC companies that are
hiring Java developers with the
certification of java are Wells Fargo
Oracle Accenture Citibank and many more
now we have the three varieties of
training options which are self-based
learning online boot camp and corporate
training
so what is Java it is a fast reliable
and secure programming language that can
be used in several websites and
applications it can be used to create
applications in a single computer or one
that could be distributed across several
servers and clients Java can be used in
several scenarios independent of the
system that it is used on
so let's look into what Java development
kit means
all the Java applications and applets
are developed using the Java development
kit that is jdk now the jdk consists of
the Java runtime environment an
interpreter a compiler an archiver and a
document generator and a few more tools
that go into developing a Java program
so now let us have a look at the
components of jdk
Java runtime environment JRE primarily
is a part of jdk and it can also be
termed as Java RTE
the jdk provides the minimal amount of
requirements needed to write and compile
a Java program
JRE consists of the jvm supporting files
and the core classes the jvm is key to
both jdk and the JRE because it is
embedded into them now whichever Java
program is being run the jvm is that
component of java that executes a
program line by line thus giving itself
the work of an interpreter we are now in
a position to Deep dive into the process
with which jdk JRE and jvm work
let's take a source file and save it
with the extension.java
this file is compiled and converted into
a set of byte code which changes the
file extension into dot class this is
done specifically by the jdk now here
are the steps that follow class loader
it makes sure that all the necessary
classes are loaded in the time of the
execution of a program next byte code
verifier that is jvm the byte code
verifier checks the code for errors or
irregularities based on access rights on
objects or implementation of pointers it
makes sure that the code fulfills the
specifications of jvm and does not break
the system integrity and finally
interpreter which is jvm now while
running the program The Interpreter
loads checks and runs the code the
implementation is made by the JRE which
is a final process
the latest release is jdk9 and it was
released in October 2017 but it was in
jdk 8 that a new feature called the Java
Lambda expression was introduced that
changed the face of java now Java Lambda
expression is a kind of function which
does not need any class to be created
it has been included in the latest
version of GDK as it provides a clear
concise way to pass functions around
this also replaces earlier bulky
Anonymous classes and reduces code
verbosity that is the length of the code
the Syntax for the Lambda expression is
this
argument list Arrow token body
now the syntax consists of three
components which are argument list
this can be empty or non-empty next the
arrow token now this is used to link
argument to body and finally body this
contains the statement that works with
the function
let us now just see an example of using
Lambda expression and contrasting it
with how code would have been written
with Anonymous classes
this is the old method
and this is the new method with Lambda
expression
just have a look at how Lambda
expression syntax has been used over
here the jdk 9 has been released
recently and it seems promising with
respect to new features and abilities
here are some of the features
the first one is Java platform module
system
this module allows strong encapsulation
and declare explicit dependencies
next J shell
with the help of J shell one can
directly start writing the code on the
console and execute them
improve Java dock
Java docs have got the search right in
the API documentation and as an added
bonus the output is also compliant to
HTML5
next stream API
the stream API also introduced in Java 8
allows programmers to easily paralyze
code for improved concurrency and
introduces functional programming
abilities to the language the stream API
in conjunction with Lambda Expressions
also comes in handy while iterating
filtering and extracting large amount of
data the release of multi-jar makes it
possible for codes to be done on the
newer versions of GDK to be released
so now let's download Java let's go to
Google and search for Java download
we'll go to the link we see here
oracle.com so now here we have the web
page here we can see Java se13 so this
is version 13 but this isn't the one we
are going to download we're going to
download the eighth version version 8.
which is here now we're doing this
because 8 is one of the more commonly
used versions of java so let's click
this and here we'll go down we need to
accept the license agreement before we
can download it
now we have two versions here x86 and
x64. now you can download it depending
on what version your operating system is
now if you do have a Windows 10
operating system it's highly likely you
have a 64-bit version of Windows now if
you do have a 32-bit version of Windows
you can take the x86 so let's download
this
so we've actually already logged in so
we just need to run the installer file
now let's go to downloads
another file
so here we have the installer we go to
the next step
we'll select this to next here we can
see where the file is being installed to
we'll go to next
now if you want to change where you want
to install Java we can press the Change
option I'm just going to keep it here
we'll press next and let's commence with
installation
and there we go the installation is now
complete so we don't need any tutorials
or API documentation so we'll just
finish off and go to close
now to see if Java is installed in your
system we can go to command prompt
and type the term Java C
which refers to the Java compiler
now as you can see here this shows a
number of different options you can
choose from this also indicates that
Java has been successfully installed in
your system now if the installation was
not successful you'll see something like
Java C is not recognized as an internal
or external command operable program or
batch file but since we've done it
successfully this is what will be shown
now
and now we're going to set an
environment variable now what exactly is
an environment variable now assume you
have a file which has a DOT Java
extension this environment variable
tells the computer that the Java program
needs to be called to run this
particular file
so to set the environment variable we'll
need to go to control panel
here go into system and security
go to system and select Advanced system
settings and then this shows up now
before we go into environment variables
we'll need to go to where the Java file
was installed so let's go to this PC C
drive
program files and here let's go to Java
so let's go to jdk which is the Java
development kit let's go to bin here
and copy this path
we'll go back to environment variables
select path here
and then press on new
paste this and okay now we'll go back
and go to JRE to the path of GRE which
is Java runtime environment you click on
this pin again
and copy this path
select this one
new
and paste that
and there we go the environment
variables are now set
now let's talk about running that simple
program I told you about now this is
possible with the help of an IDE an IDE
or integrated development environment
will give us a platform to code Java we
will be using eclipse and IntelliJ as
they are popular and commonly used that
being said there are several other Ides
that are available in the market so now
let's work with Eclipse let's go to
Google and search for eclipse
we'll go to this link
press download and then this shows up
let's click on download
now we've already downloaded the
software so I'm just going to directly
go into the install phase
downloads and select Eclipse with this
you can see that there are multiple
options for you to choose from so we're
going to select Eclipse IDE for Java
developers now you have other options
like for CNC plus plus JavaScript PHP
and so on let's go to the first one and
here you have the details you can change
them if you want but I'm just going to
go ahead with installation now
you press accept now
here we remember accepted licenses and
press accept
and then here as well we'll remember
accepted certificates select this one
and accept selected
and there you go the installation is now
complete let's click on launch now
so here we are setting up a directory as
a workspace uh I'm not changing it here
so I'm just going to go with launch
here we have the eclipse workspace now
let's close this first and here we have
the package Explorer now in case this
doesn't show up you can go to window
Show view
and select on package Explorer
so now let's go to file
new and Java project we need to set up a
project name I'm going to call it my
project
one
click next we'll go to source so this is
where the source code for your program
is going to be stored then let's finish
and now we'll click on my project one
quarter source I click new and create a
class we'll explain I'll name the class
of my class
and create it and here we have it so now
let's write a simple program to multiply
two numbers
so now let's write the main function
open
the bracket
now we're going to initialize the first
number
the second one
and finally the output
and finally the variable that will store
the output
now we'll just give them a simple print
statement
now let's run The Code by clicking this
option here
using myclass.java and there we have it
here the product is shown to be 100
indicating that the program is running
successfully now we're done with Eclipse
now let's move on to the other idea I
was talking about which is IntelliJ so
for that again we'll have to go back to
Google so that we can download it
search for IntelliJ download go to this
link here so here you can see that we
have two options the ultimate edition
and the community version now here the
ultimate version has way more options as
you can see here but it's a paid version
and only has a free trial now the
community version is free so that's what
we're going to take so we'll click on
download here so I've already downloaded
the software so I don't need to do it
again
so I'm going to go downloads and say
here we go let's just click on next
select the location where you want to
install it press next now we will add a
64-bit launcher shortcut on the desktop
and create Association so basically this
means that these are the different file
extensions that this will support so dot
java.gui and now let's go to the next
step we'll install now and we'll wait
and there we go the installation is now
complete let's not import any settings
we'll accept the privacy policy we'll
set defaults
now let's create a new project so here
make sure your project SDK is set to the
version of java you've installed make
sure this isn't blank we'll go to next
here you need to select this option
which is the create project from
template and we are now going to create
a command line application
press next
name the project which I'm going to call
my Approach to
you can change the location if you want
I'm just going to keep it the way it is
and then click on finish
so now we're going to create a simple
program through which based on the
user's input we can determine whether a
number is even or odd first we're going
to import the package scanner
through which we can take the user's
input
so let's go inside here let's create the
available reader
now let's ask for the user's input
foreign
so this is with which we'll be taking in
the value from the user
so we're going to set up a condition to
determine whether the number is even or
not so if the number
and when divided by 2 provides the
remainder 0 it indicates that it's an
even number
we'll show them then
for the else case
foreign
or in this case odd
there we go
we're done so let's run this program
so let's enter 12
foreign
and there we go we have a successful
output this indicates that the program
is running successfully let's begin with
the fundamentals so the first one in the
fundamentals is the data types so every
programming language has a data type so
what exactly is a data type so whatever
the input you provide in your program is
a data type for example if you provide
numbers so in that particular numbers we
have a different variety of numbers if
you are giving just one two three so on
without a decimal number then that
particular type of input which is a
number will be considered as integer
type if you provide the same number with
a decimal point then that will be
considered as float and if you have the
range greater than float it will be
considered as double and so on so this
is how we have multiple data types in
every programming language so the most
frequently used data types in Java
programming languages are as follows at
first we have the byte followed by that
we have short end long next float then
double Boolean and finally care apart
from this we also have few other data
types but these are the most frequently
used ones for all the basic programmings
so this is made for beginners basically
so you can take a quick screenshot of
this particular slide so that you can
have a quick overview or reference to
all the data types in Java programming
language so I hope you have taken a
screenshot of this now let's begin with
the next concept so in the next concept
we have the keywords and variables so
all the programming languages have
variables and keywords so variables are
used to store the values so for example
consider that you wanted to run some
automatic operation on two different
values that is 5 and 10. so in order to
do so you might want to create a
variable which stores them for example
you wanted to store the value of 10 in a
certain variable a and the 5 in a
certain variable B so if you apply the
arithmetic operation that is a is equals
to A plus b then the value of a which
was previously 10 will be updated to 15.
so here you can see the value is varying
and also it is storing the result so
this is why the variables are used in a
program in order to store a value and
this particular term variable is used
because the value can change at any
instance of time once after a certain
arithmetic or a logical operation is
performed on that particular variable so
similarly we have keywords unlike
variables keywords have a special
meaning no matter whatever you try you
cannot change the meaning of that
keyword for example consider main so you
cannot use the term main for normal
things because the part or the term mean
is dedicated for a different purpose so
whenever you try to execute your Java
program the control flow will start
executing the program right when it
reads the term Main so it has a special
meaning similarly you have other
keywords such as end so that is
dedicated for integer type of values and
float for float type of values that is
the decimal values and byte for byte
care for character type data string for
string so every keyword or every term
with special meaning which is predefined
and cannot be changed is called as a
keyword now let's see the most
frequently used keywords in Java
programming language so similar to the
previous one we have a table here so in
this particular table we have the most
frequently used keywords in Java so you
can see we have Boolean final byte
native and we have void switch so switch
is a conditional statement so we have if
if it is also a conditional statement we
will go through this conditional
statements as we proceed in our tutorial
and you can also see the protected so
this term which is protected public so
this is basically the access modifier
even this particular keyword have
special meaning this public this
protected keywords provide the
information to the compiler or The
Interpreter about the accessibility of
that particular data member or data
manipulating method so if it is
protected from your accessibility or is
it available for you it's provided by
these keywords so we will deal with
access modifiers in the upcoming Parts
don't worry about that and as you can
see we have implements extends so
extends this term comes in inheritance
so inheritance is one of the crucial
concepts of object-oriented programming
can also see abstraction so this we will
be dealing in the next upcoming part
where we will understand the object
oriented programming Concepts next we
have interface return and so on you can
also see some keywords like through so
throw welcome in exception handling so
we will also learn about exception
handling in the upcoming part so these
are the most frequently used keywords in
Java so now we will move ahead into our
next concept so the next concept is the
operators in Java so to understand
operators let's go through a table so on
my screen you can see a table which has
some arithmetic operators which are most
commonly used that is the Plus for
addition minuses attraction similarly we
have star forward slash double plus
double minus so double plus and double
minus say they are increment and
decrement operators respectively as you
can see we have a plus plus here which
means the post increment so the first
value will be read after that the value
will be updated next we have the
pre-increment the value will be
incremented first then the updated value
will be stored so that's that's how the
increment and decrement operators work
so we have the modulus over here so to
understand the operators that we use in
Java in a much better way let's try to
execute a sample program so on my screen
you can see a program which is based on
operators so we are currently on the
Eclipse IDE don't worry about the Ides
and Java etc etc so I will drop a link
in the description box below which will
explain you in a very detailed way about
how to install Java into your local
system and how to install Eclipse IDE in
your local system and also how to create
your first project how to create your
package how to create a new new class
how to write your program and how to run
that how to see the output and a
complete overview of the Eclipse IDE how
that works so everything will be linked
in the description box but you don't
have to worry about that so right now to
save time I have created the text
document which has all the programs that
we will be executing today so I will
also drop a link for that particular
file so that you can have complete
access to that file so that you can run
the programs in your personal PCS or
laptops and also understand the programs
in a much better way so now let's begin
with the program so this particular
program is basically designed for
automatic operations so you can see we
have the operators that is the addition
subtraction multiplication division
modulus and exit so basically we will be
taking input from mu so the input will
be taken by the user that is where we
are using scanner class here so scanner
class takes the input from user and that
particular input will be compared here
so we are using the switch case here so
if you provide the option as one then
addition operation will be run similarly
second for subtraction third
multiplication fourth for division fifth
for modulus and sixth to exit so this is
how the loop or the program works for
automatic operations now let's quickly
run this program and see the output so
you can see the program got successfully
executed and we have the console asking
for the first input let's provide some
random number now let's provide the
second number so there you go we have
our options over here now let's choose
division operation for that we need to
provide the number four so there you go
we have the result over here which is 4.
now the loop has started once again now
it's in the starting stage again it's
asking for numbers now let's provide a
25 and 5. now let's choose some
operation that is addition so for that
you need to provide one so we have the
result again that is 30. now let's again
choose some number ten five so basically
that's how the program works so we have
the brief idea how the program is
running now so now let's quickly
continue with our next topic now to
terminate this Loop you can provide the
option number six so we have terminated
it so I hope you understood how the
program flow is running so if you did
not understand don't worry I have linked
the document in the description box
below you can take the access of that
particular document and you can check
the program and run in your local system
and also you can make some modifications
to it as you can see we don't have a
default case over here I've just placed
the case one two six and I'm seeing the
default because you can see that the
options are from one to six what if the
user provides the number as seven right
so the program might crash over here so
for that purpose you can write in
another case that would be the default
case so the default case will check if
the number is anything above or out of
the range of 1 to 6 then it should be
providing you with an output saying a
wrong input has been given or check your
input or something similar so that's how
you can make some modifications to it
you're free to modify the code as well
don't worry about that so now let's
quickly begin with our next concept so
in the next concept we have the
conditional statements so what are the
conditional statements or the control
statements so basically these are some
yeah these are conditions so what
happens is just imagine that you wanted
to do something or if you wanted to
drive a vehicle or if you wanted to
drive a bike so the condition you will
apply on your mind is if I know driving
then I will do it if not I'll not do it
so that's what you do right so basically
you apply a condition on your mind and
you do it if it is capable of doing or
if you are capable of doing it so in the
same way the conditional statements play
a major role in Computer Logic so before
writing a code or before you start your
program you provide the condition
perform this particular operation if the
provided condition is satisfied so
similarly you have these three
conditional statements in Java which are
if if else and nested if so we use these
conditional statements in Java to
implement our logic so we will
understand the conditional statements
particularly if if else and nested if in
a much more detailed Way by practically
running some programs based on these
three types of conditional statements so
now you can see that we are back on the
eclipse right now so this particular
code segment is based on the if
condition I hope the program is visible
let's try to increase the font size so I
think it's better now so basically we
have an input so we have the is your
type of input that is num and we have
the number as minus hundred so it is a
negative number and after that we have
the if condition so this is where the
conditional statement is provided so the
condition is if the number is greater
than zero if the provided number is
greater than 0 then the control should
enter the loop which is this particular
segment and execute the statements
present inside that particular Loop so
here we have one single statement that
is a print statement that says the
number is positive in case the condition
fails imagine that the condition fails
then what happens is that instead of
entering this particular code segment
this particular code segment the control
will Skip and execute the next statement
that is another print statement which we
have over here which says the if
condition is terminated control is
outside the condition block now since we
have provided a negative number the
second option should go ahead now let's
try to run this and see the output so
there you go as expected the program got
executed and we have only one statement
that is if condition is terminated
control is outside the block now let's
write otherwise let's just eliminate the
negative number and now check it again
there you go now you can see the program
got executed and now we have two print
statements you can see that the
condition here was true so the control
entered into the statement or the code
block and this particular statement got
executed successfully once the
statements are executed and there is
nothing else to do then the control will
automatically exit this particular
statement and it will enter into the
next statement which is another printer
statement and we have the same output
over there so this is how now the single
if statement works so you can also
modify this with an else so that's the
next program that we are going to see we
are going to execute some similar kind
of example for our next kind of
conditional statement that is if else so
here only we had one if condition so in
case if this particular condition fails
then we will be having another condition
over here which will be the else block
so as you can see we have another
program so this particular program is
based on if else condition so here you
can see that we have our first if
condition which states number should be
greater than or equals to zero if this
particular condition is true then this
statement should be executed which says
the number is positive else else if this
condition fails then what you must do
the control should avoid entering this
particular segment and it should
directly hit the next segment where we
have the else block which has another
statement which says the number is
negative so this is how the program
works so here we will be doing a little
modification over there instead of
taking an input which is previously
defined as it was in the previous
example where we had given minus 100
previously we are going to do it a
little differently this time we'll be
taking or reading the input directly
from the user so for that we are going
to use this scanner class so this is the
particular library that we will be using
so we have imported
java.util.scanner so this particular
code segment will ask you for the input
and you will press some random number
and it will read it as its input now
let's try to quickly run this program
and see the output and there you go the
program got successfully executed and
now it is asking for an input from the
user now let's try to provide a negative
number
so there you go the program would
successfully executed and you can see
that since we had given a negative
number the control did not enter this
particular code segment at all it
directly avoided to enter this code
segment and entered into the else block
and executed the statements present in
that particular else block which was a
simple print statement that had the
statement which read as the number is
negative now let's try to execute the
same program again and see what would be
the output so there you go now it's
asking for the input again now this time
let's provide a positive number so there
you go since we provided the number as a
positive number this condition was true
and this particular statement got
executed since one of the statements
executed there was no need for the else
block to be executed again so you can
see this particular code segment runs in
this way so once the condition is
checked so if the condition is true then
the true statement will be executed in
case if the condition's result is false
then the false statements will be
executed so you will be provided with
two options so one option for True
validity and another option for false
validity so this is how the if else
block works I hope you understood this
now with this let's continue with the
next type of conditional statement that
is the elsef ladder so on my screen you
can see there is a change of program we
have stepped into the next type of
conditional statement that is the lsf
ladder so basically everything will be
seen we will be provided with only one
condition so we will be checking the
validity of that particular condition so
if the provided condition is true then
the first one will be executed if it is
not then the second one will be executed
if the condition fails for the first two
the third one will be executed if the
first three failed and the fourth and if
all the four Fields then we will have
one last else which will print the last
segment or statement so this is how the
else ladder works so basically it's
completely similar to if else but the
only difference is instead of one else
block we have multiple else blocks
that's the only difference now let's
quickly execute this program and say the
output so basically we are going to take
an input from the user so we will be
entering one for noodles two for
milkshake three for fruits four for
coffee so something like that and if we
provide anything else then one two three
four then we will be having an else
statement which says it's an invalid
input so the flow of this particular
relative statement is similar to the
switch statement having said that we
will also discuss something about a
switch statement as well basically we'll
try to execute a program based on switch
statement and we will also understand
the control flow of that don't worry
about it now let's quickly execute this
particular program for
so there you go the program got
successfully executed now it's asking
for an input uh let's select noodles
that's how it works we have the output
noodles so the choice is equals to is
equals to one so the first one was true
so it executed the first code segment
and everything else got suspended
because uh this was not necessary to be
executed because the condition was true
over here and according to that only
this particular statement was supposed
to be executed so that's how it works
now let's switch into the next
conditional statement which is the
switch so you can see that we have a
program on my screen which is based on
switch case so uh you can see that there
is some similarity between this
particular program on the first program
we dealt with that is based on operators
so we also have the default code segment
over here so this was what I was talking
about you can add a default code segment
in that particular program which is a
operators program and do some
modifications so this is what the
suggestion I gave over there now
basically what happens in this
particular code segment is so we have
Monday as the day one of a week Tuesday
as the day two of the week and so on so
uh to select one particular day of a
week you need to provide an input so
it's based on one two three four and so
on to seven and if you provide anything
else than one two seven you will be
provided with a message which says
invalid input so now let's try to run
this program and see the output so there
you go the program got successfully
executed now let's select the weekend
day so which would be something between
six and seven so six is Saturday and
seven is Sunday let's go with seven so
there you go Sunday now let's try to
execute this program once again and give
a wrong input and see if it works or not
let's provide it there you go the
program identified it as a wrong input
so it gave us a message invalid input so
that's the use of default code segment
and switch case so you can implement
this in that operators program and check
out how it works can be considered as a
homework though not a problem so first
of all understand why do we need Loop
statements so generally whenever you are
dealing with some data structures in
Java which can store multiple elements
for example we saw array which can store
multiple elements string is also
basically technically a character array
which is storing multiple characters so
whenever you have these kind of data
structures where you have multiple
elements being stored in the same then
in that case you would like to have a
way to iterate or access all of the
elements in a seamless fashion one of
the ways is to access them individually
one by one but that's too much of work
that's too much of code there has to be
a simpler way of accessing all the
elements one by one if I want to and
that's where the majority of the use
cases for using looks coming to picture
now Java provides multiple constructs to
write Loops in Java there is a while
loop there is a do while loop there is a
for Loop there is also an enhanced for
Loop and in the previous versions of
java a use case of iterator was also
very popular so there are multiple ways
in which you can actually iterate over a
collection and access all the elements
of the collection one by one and you can
use it to multiple useful cases for
example if you have a huge eye of
employee salary and you want to give
bonus to each of the employees and add
the bonus to the salary then you need to
do this Edition for all the employees it
would be nice to have to return a while
loop and the while loop can
automatically access all the employee
salary one by one and keep adding the
bonus to the salary this would be an
easier way to do this rather than
individually updating each employee
salary and the first Loop statement we
are going to understand is is a while
loop so the syntax of while loop is very
straightforward you write the Y keyword
you enter the actual condition which
will be evaluating to a Boolean true or
false so you write the expression which
will be a Boolean expression exactly
similar to the conditions which you use
to write in your if statements so you
write your condition which will evaluate
to either true or false and then you
write your statement and these
statements will keep executing till the
time this particular expression
evaluates to true so generally the way
it works is that it will enter the while
block it will evaluate the expression if
the expression becomes true then the
statements inside this particular while
block will be executed and after the
execution of the statement it will again
go back again evaluate the expression we
call the steps basically so it will go
to the next step again evaluate the
expression if this again if this still
holds true it will again go inside
execute the statement move on to the
next step it will again go to the
evaluation so this this Loop will
continue to go till the time this
condition will hold true if it still
doesn't make sense for you don't worry
we will have a demo of it to make you
understand how to use the while loops
and maybe it's a good idea to switch to
the IDE and look at an example of it so
I have already created while demo for it
here it is it looks very small and
simple but it will get to the point
where we can understand how and why will
we will be using the while Loops so I've
created a while demo class I have added
a public static void main method here
which is the entry point I have declared
a variable which is int count equal to
one so the count value is one right now
and then I'm writing a condition here
I'm saying while count is less than 10
do this so it will print the current
value of count and after that I'm using
the post increment unary operator if you
remember we covered this in the previous
sessions what is the meaning of this it
basically will increase mean the value
of count by 1 this expression is e is
equivalent to if I write it in this way
if I write count equal to count plus 1
this is exactly the same as this no
difference so this will have the same
impact I will just remove this line
because we already have the count plus
plus here so if we try to understand
this we are basically incrementing the
count and then checking the condition
again so at first time it will be 1 less
than 10 yes that is true it will go
inside and print the count value the
current count value which will be 1 and
then it does count plus plus so now the
count value becomes 2 it will again go
back here again check the condition
saying is 2 less than 10 yes that is
true so the while condition again
becomes true it will again go inside
this print the current value of count
which is 2 then do count plus plus so it
will again increment the value of count
so the now the count value becomes 3
again go back here at condition and
saying is 3 less than 10 yes that is
still true again come here print the
three again go here make count as four
four less than 10 prints four again
count plus plus count becomes 5 and so
on so forth it will keep doing that till
the value becomes ten so at a step when
count plus plus results in the count
value being updated to 10 it will go
here and say is 10 less than 10 now that
is not true because 10 is equal to 10
but 10 is not less than 10 so this
condition will become false and it will
exit of this while loop and it will come
here and it will execute if there's if
there was anything written after the
while loop that will be executed so
that's the idea that you want to do
something till a particular condition
holds true then you can use the while
loop Define your condition and execute
the statements and try to do something
which changes the state of this
condition here I am changing the count
so that every time a new evaluation
happens if I comment this this will
result in an infinite Loop because one
will always be less than 10 I will not
be incrementing the count here and it
will keep running forever it will never
stop it will just keep printing one one
every time till your computer program
runs out of the memory so always
remember not to end up into an infinite
Loop that's probably one of the biggest
mistakes any beginner programmer does so
please try to be aware of that
particular loophole not try to run an
infinite Loop always try to write
something in the code block which can
change the state of the condition and
also make sure that that state condition
sometimes sometimes should become false
you should also make sure that that all
that always becomes false because if I
do this if I do this then this condition
will always remain true because it is
already 1 then it will become 0 then it
will become minus one minus 2 minus 3 so
on so forth but that value of count will
forever be less than 10 and again you
will never be able to exit this Loop
your program will be stuck in this Loop
till your program runs out of the memory
so always remember to write a statement
or a statement of execution in your in
your code block which can change the
state of the condition which results in
some eventual time when this condition
becomes false this condition has to
become false eventually otherwise you
will never come out of the loop always
remember that so if we run this program
now let's observe the output so we can
see here this particular statement is
printed for one two three four five six
seven eight nine and that's it after 9
the moment the count plus plus resulted
into the count value becoming 10 it
checked that condition and then it just
came out of the loop because 10 is not
less than 10 and the condition became
false so always do something inside your
code block which results at least of one
scenario where this condition becomes
false and that is how you can use the
while loop now you can see this is a
pretty generic code and you can write
any kind of condition here write any a
code you want to execute here and then
do something to change the state of the
condition as well in a positive way in a
way which results this particular
condition to be false at some point of
time and then your while loop will run
fine so this is all I wanted to cover in
terms of the while loop hello guys let's
get started with today's topic which is
about how to use do while Loops so let's
understand when do we need that and how
do you actually use that let me switch
to the Java documentation and if I can
find some syntax of it as well yep so as
you can see here if I just highlight
this portion this is how you actually
write a do while statement block so you
write do you start a code block you
write some executable statements and
then after the code block ends you write
a while expression and end it with
semicolon this is the syntax basically
it starts with do or curly braces some
executable statements a while block or a
while statement basically with an
expression ending with a semicolon let's
understand this with the help of a
program to understand the structure
better so for this I have created a
sample program here which is called do
while demo again having a public static
void main method and it has a variable
which is count and it is initialized as
one then I write do I write this code
block or the curly braces and then I am
just printing the value of count then I
am incrementing the value of count and
then I am writing a condition which says
while count is less than 10 and
semicolon if you compare this with the
previous demo we ran if I just put them
side by side we had while condition
statement and and the state change
condition here we have do statement
condition change statement and then we
check the condition at the end so the
idea is that if you have a use case
where before you even evaluate the
condition you want to print something
even before you evaluate the condition
if you want to do something in that case
you will use the do while loop even
before the while actual while loop
starts if you want to execute a
statement you will use do while loop for
example if you want to print the initial
value of the count even before the
condition checks then you can use do
while loop if that is not your use case
you can use a simple while loop which is
described here in this program so coming
back to the do while so I say do and
then I am saying print this particular
statement without checking anything this
condition will be executed for the first
time without any condition check at all
this will just work as is like a normal
Java statement after that I am
incrementing the value of the count and
then I am checking the condition so
remember when this particular condition
is being checked the first increment has
already happened but in the wild case we
did the comparison before even the first
implement the first comparison happened
with the original value of count but
here the first comparison is happening
with the incremented value of the count
hope you get the difference in a better
context now that you will use this when
you want to do some write some
initialization code before you actually
hit the condition so this condition will
be evaluated with 2 less than 10 and
then the value will be printed let's
print this example and we'll also try to
play around with this example a bit more
to bring to build our understanding
better if I run this program there is no
difference in output if you compare this
with the previous program we ran for the
while so it prints the count value so
this is coming here then it increments
the value then it checks the condition
saying is 2 less than 10 yes that holds
true if that holds true it will go back
to statement number nine again print
this again do an increment on the count
and again check the condition with the
updated value of the count which will
say 3 less than 10 now similarly print
the value increment check this will
continue to happen till this particular
condition becomes false and once this
condition is false it will exit out of
this whole do while loop and it will go
to the line number 12 and if you have
any statement written there you can that
statement will be executed in this case
so let's try to change some values here
and let's see if if we can make sense of
this program if we change the value
let's see if I put 11 here what will
happen now let's run this program you
will say the now you will see that this
particular output is displayed which
says count is 11. so what happened here
that count was 11 it entered the do
while block it went to this particular
statement which said count is 11 then it
incremented the value so the value
became 12 and obviously it 12 is not
less than 10 so it did not print it
again it only printed once even if the
first time the condition was checked the
first condition execution itself
resulted in false still line number nine
got successfully printed and that's the
whole that's the whole idea behind using
the do while what if I change this value
to 10 let's see what happens and after
that we'll run one more combination to
just make it more interesting This Time
Again count is 10 line number 10 will be
printed as count is 10 then at line
number 10 the count is incremented to 11
and 11 is not less than 10 so in this
case the loop ends and it will move out
now what happens if I do this if I say
less than equal to here let's run this
program and interpret the output now
again only one statement is printed
because in this case the count is 10 10
is printed here and we are saying 10
plus 1 11 11 is still not less than
equal to 10 and that's why the loop just
exits let's make it 9 and see what
happens now you see two values so count
is nine it enters the do while loop goes
to statement number line prints the
current value of count which is 9 then
increments the value to 10 then at line
number 11 this while statement is
executed and the condition is checked is
10 less than equal to 10 yes 10 is not
less than but 10 is equal to 10 so this
condition will hold true it will go back
here print count is 10 May count 11
again check the condition is 11 less
than equal to 10 no it's not and then
the condition will return to false and
loop will be exited so hope this will
give you a better understanding now
since we ran different permutations and
combinations of the values and we saw
when this will be executed and when this
will not be executed but the bottom line
is very straightforward that whenever
you want to write some pre-processing
logic even before checking the very
first condition of your Loop then in
that case you will be using a do while
loop otherwise a normal while loop or a
for Loop are absolutely worked fine
hello guys let's get started with
today's topic which is about for Loops
in Java so so far we covered about while
loops and do while loops and we also saw
different examples of using different
types of data structures like arrays but
one of the core requirements whenever
you are working with any kind of
collection is to iterate over it exactly
similar to what I explained in the do
while and why lectures that you would
often require to iterate over a
collection or a data structure and for
that one of the most sophisticated and
easiest way to do that is using for
Loops so let's understand the syntax of
for Loop first and then we will also
look at an example of it in the in the
Eclipse IDE so I have just opened the
official Java docs here so if you see
this is basically the syntax of a for
Loop statement so let's understand it
and let's talk also try to compare it
with a while loop so that we can
understand how it Compares with the
while loop so if we see the syntax we
first see the term initialization then
we see the term termination and then we
see the term called increment now if I
try to compare it with a while loop
there also you basically did these three
things you first initialized a variable
outside the while loop which is called
initialization and then you wrote a
condition which is your termination
condition you wrote a condition saying
let's say while I is greater than 10 or
while I is less than tan so that is the
condition which is also the termination
statement the loop will continue to
execute till that condition evaluates to
false and that's when the loop
terminates that's why we call it as
termination and then the third piece of
it is the increment the I plus plus
which we used to do in the Y Loops so
these three portions together make or
constitute any kind of loop in any kind
of programming language and for Loop if
you see the the kind of code which you
use to write in a while loop in multiple
lines where you first initialize a
variable then you write a condition in
the while block and then inside the
while block you use to increment the
variable all of that can be done in a
single line in the for Loop and that's
why I said it is the most sophisticated
and easiest way to write Loops in Java
so you write all of these three things
the initialization the condition and the
increment or decrement values in the
single line and then you start with the
curly braces and you write the code
which you want to keep executing till
the condition evaluates to false that's
the basic syntax of it so let us try to
understand this with the help of an
example so here I have opened a class
which is called for demo and this is a
class which will demonstrate the use
usage of a for Loop so again we have a
public static void main method which you
can see here which is the entry point
and then I use the keyword for I put
standard braces for the brackets and
then I do the initialization so this
part is the initialization part you
initialize the variable so I just say in
TI equal to 1 initialization done you
end it with a semicolon so that it is a
single statement understood by Java and
then you write this condition which is
your evaluation slash termination
condition so this condition is basically
the the deciding factor of how long your
Loop should run it's exactly similar to
what you used to write in the while
block if I just show you the example
this is what we used to do so we did the
initialization at line number seven then
we wrote this termination condition
inside the while syntax or the construct
and then we did the increment here so we
are doing all of these three steps what
we are doing in a single line so this is
the condition and then we write our
increment or decrement values which are
going to change the evaluation condition
every time at every step so we are
saying I plus plus so technically what I
am saying here is that start with i
equal to 1 and then check the condition
I less than 10 so the in the in the
first step it will be checking if 1 is
less than 10 if the condition holds true
go inside the for Loop execute the
statement at line number seven and then
go back to this particular statement so
we'll do y plus plus so I becomes 2 and
then you again go back to the condition
and again you check if 2 is less than 10
yes it is so again you go inside inside
the for Loop and do whatever is written
there there can be multiple statements
here for now I have just written one
system dot out dot println so that
happens and once all the execution is
finished inside the block it will again
go back to the increment thus then
increment so 2 plus 1 becomes 3 again
does the evaluation exec and if the if
the condition holds true it will again
go inside so this will continue this
condition checking execution and
increment will continue till the time
this condition holds true the moment
this condition becomes false the control
will come out at line number nine so
that's the basic anatomy and control
flow it's very important to understand
the control flow of a for Loop otherwise
you might end up into a program which is
forever running and which will just heat
up all the memory available in your jvm
so be very sure of what you write in
your for Loop be very sure of specially
these two parts the condition and the
increment or decrement so this is very
important piece the initialization
happens only once and then this
condition evaluates if the condition
holds to True some code executes goes
back to the changing statement which can
be an increment decrement whatever and
again compares the updated value with
the condition so this will keep
happening let's run this code to
interpret the output
so I will right click go to run as Java
application and if I interpret the
output here I can see that it started
with count is 1 2 3 4 5 6 7 8 and 9. it
stopped at nine so what happened there
let's try to evaluate the termination
condition so let's say I has become 9
and 9 is less than 10 so it goes inside
and it prints count as 9 which is I then
it goes here and it says 9 plus 1 I plus
plus means 9 plus 1 the current value of
I plus 1 it becomes ten and then it
again compares the condition so now 10
is not less than 10 10 is equal to 10
but it is not less than 10 so the
condition becomes false and count is 10
is never printed because this condition
has become false it will jump out so
let's say if I do this if I put an equal
to here and if I now execute the same
program
this time I will see 10 here and because
I have said that okay check the
condition if 10 is equal less than equal
to 10 that will become true it will
print count is 10 then it will increment
and the count will become 11. the I will
become 11 and then it will check 11 is
less than equal to 10 no it is not so
condition becomes false and the control
comes out of the loop so that's how you
should always try to interpret the loops
you can also run some infinite Loops for
example if I say I equal to 1 I leave it
that and I say I minus minus so what
happens I equal to 1 1 is less than 10
yes it goes here prints the value and
then I decrement the value I don't
increment the value I decrement the
value so whatever value comes out will
always be less than 10 and this Loop
will run forever for fun let's try to
run this and I will I will have to kill
this program manually but just to show
you what happens and what you should not
do in your in your Java program so you
see it will continuously keep printing
the values till the program runs out of
memory till it eats up all the available
memory it is cut it is forever running
it will never stop because the condition
will never remain never never evaluate
to false this condition will forever be
true so the loop will run forever so I'm
just gonna kill the program but this is
something which you should avoid
whenever you are writing Java code and
this happens quite often with beginner
programmers hello guys and let's get
started with enhanced for Loops in Java
we generally use the enhanced for Loops
for scenarios whenever we have to
iterate over a collection of items or an
array of items those are the most
popular and common use cases of using
enhanced for Loop and this for Loop is
even simpler like I said it's even
simpler than writing a classic for Loop
and the syntax is simply like this you
again start with 4 put the standard
brackets and then let's start from the
right most because then I will be able
to explain it better you specify the
collection in the rightmost side of the
bracket The Collection can be an array
it can be a list can be a map so
whatever different kind of collections
which are available in Java and we are
going to cover collections in detail so
don't worry if you don't understand what
are lists and what are maps and what are
sets we will go into detail of each of
these one by one in the upcoming
sessions but the idea is that you put
the collection to the right most then
you put a colon and then you put a
representation of the member of this
collection so for example here this
numbers is basically an INT array so
this int array means that this array Can
Only Hold integer numbers and that's why
we write int here because this array is
only having integers then we put any
placeholder variable name this can be
anything you can even write it as I if
you want to you can write it as anything
any variable name which you want to
write this this is a temporary variable
so now this code is going to execute in
a manner that it is going to iterate
over this array one by one starting from
the first element going till the last
element you don't need to write any
initialization code you don't need to
write any termination condition code and
you don't need to write any increment or
decrement code also and how these threes
how these three values are actually
taken care of let's understand that as
well so when we talk about the
initialization as I have put an array
here a data structure here the automatic
initialization index is going to be the
first index so when we do the iteration
when this for Loop is going to execute
it is automatically going to initialize
a temporary variable with the value at
the first index which is the index 0 as
you know that array is a zero index
based structure then comes the condition
part so the condition evaluation is
going to be again based on the size of
the array or the size of the data
structure which you are using it is
going to start from the first index
which is the index 0 and it is going to
iterate till the arrays last element is
reached so technically start from the
index 0 and go till the last element
that's your evaluation condition and
then comes the increment part so at each
step after it has successfully accessed
the first element automatically the
index is going to be updated to pointing
to the next element so if it starts from
here once the first step iteration is
complete I is automatically going to be
incremented to index 1 and then it will
basically this I will be holding 2 then
in the next iteration the same I is
going to be holding 3. similarly I will
keep holding the new value of the
collection item one by one till the
collection items last element is reached
so this is the basic premise that you
can write a collection variable here and
keep iterating over it and this whatever
variable you write here will hold the
current items value one by one so in the
first step this I is going to hold 1 in
the Second Step this I is going to hold
2 in the third step this I is going to
hold 3 and so on so forth that's the
basic idea so now let's run this program
to see what kind of output do we get so
you can see we basically are able to
print all the elements of the array and
that's probably one of the most popular
usage as well that if you want to just
print all the elements or access all the
elements of array or a collection one by
one then just use enhanced for Loop so
you can see at each step it is printing
the value of I and the value of I is
basically the subsequent elements of the
array that's the whole idea with
enhanced for Loop under the hoods if you
talk about how does it work under the
hood it is actually using the classic
for Loop construct itself but for
developers it is making it easier
because it knows that if you are
iterating over a collection you will
start with the first element and you
will go till the last element so it
knows the initialization value the
termination condition and it also knows
the increment condition and that's the
reason you will use enhanced for Loops
in Java for iterating over collections
hello guys let's get started with nested
for Loops in Java so in front of you you
can see an example which I have prepared
for nested for loops and in this
particular example I have created a two
dimensional array as you can see on the
line number six I have created an
integer array and I have put two square
brackets here which are basically
symbolizing that this is a two
dimensional array so this two
dimensional array is going to hold
technically a 2d Matrix and we are going
to use the concept of nested for Loops
to print this 2D array in a 2d Matrix
style where you will be able to see the
rows and columns clearly let's first try
to interpret this particular 2D array so
we have a curly braces outside and then
we have these three Inner Elements which
symbolizes three rows basically so this
is the first row this is the second row
and this is the third row and then each
of the rows have three elements each
which symbolizes the column values or
the item values so it's basically a 3
into 3 2D array which has three rows and
three columns so so we can say that this
is basically a 3 into 3 array which has
three dimensions on the row side and
three dimensions on the call column side
or just a three by three Matrix or three
by three 2D array so as we know that in
case of arrays everything starts from 0
so technically if we talk about the
indexes it would be the index 0 index 1
and index 2 on the row side and
similarly index 0 index 1 and index 2 on
the column side so that's that's
something which you should remember
because we are going to use this
particular concept when we write the for
Loop so let's try to write the for Loop
now if you look at line number eight we
put this keyword called for and then we
write the initialization so we say int I
equal to 0 then we are writing the
termination condition and we are saying
run this particular Loop run this whole
Loop which ends at line 13 till I is
less than 3 and keep incrementing I at
every step that's what I'm doing in the
line number eight then inside the for
loop I am writing another for Loop which
which has another different variable
called J it can be anything you can name
it anything you want and this also
starts with 0 and this also has a
similar condition which is which says
run this particular Loop the line 10
basically or this Loop which is
signified by this curly braces run this
particular Loop till the time the value
of J is less than 3 and keep
incrementing J at every step and at line
number 10 print the element of array
which has the current value of I and the
current value of J these are basically
the positions these are not the elements
the element would be represented by this
whole but print the element which is at
current I and J's position values that's
what this code means so let's try to do
a dry run on this particular code to
understand how this is going to work so
at first we have I equal to 0 0 is less
than 3 and it goes inside it initialize
is J as well with 0 and J is 0 is also
Less Than 3 so this condition went true
that's why we went to line number nine
and line number nine condition also went
to true so we went to line number 10.
remember that in this particular case at
line number 10 the values of I and J are
0 and 0 respectively and we are saying
print the array of 0 and 0 so 0th rows
zeroeth column element should be printed
so this is the zeroth row because this
is the first uh first sub log and this
is the first element so in this case in
line number 10 2 should get printed then
it goes here and it increments the J to
1 so 0 plus 1 becomes one it again
checks the condition is 1 less than
three so yes 1 is less than 3 it goes
here remember it did not go up at line
number eight it just came back from line
number nine so when it comes here I is
still 0 but J has from 0 to 1 so now we
are trying to access the element which
is at zeroth row First Column which is
going to be 7 so 7 is going to get
printed similarly on the next iteration
J is going to get incremented from 1 to
2 and again the condition will be
evaluated so 2 is less than 3 all good
it will again come back to line number
10 and now it will say print the value
of 0 Row third or the second column or
the third element so 0th Row Third
element which is the 9 so 9 will get
printed then again J will be incremented
and J will become 3 2 plus 1 3 and now
the condition will be evaluated is 3
Less Than 3 no it is not less than 3 the
condition becomes false so it breaks out
of the loop goes to line number 12
prints an empty line because we are not
writing anything here so it will just
print a blank line and now it will go
back to line number Eight's condition
and it will do an increment of I and now
I will move from 0 to 1 and now the
evaluation will happen is 1 Less Than 3
yes 1 is less than 3 so it will again go
to line number nine again initialize J
with a flash 0. the previous J got
destroyed the moment you came out of the
loop so this is a new J so this J again
gets initialized to 0 0 is less than 3
it goes here remember I was 1 in this
time so now it will print the value of
this 2D array which is sitting at 1
comma 0 basically second row first
element so second row first element
which is three again J is going going to
get incremented and it will become from
0 to 1 so 1 is less than 3 yes it will
again come here and it will print the
value of the array which is sitting at
array of 1 comma 1 for a row equal to 1
and column equal to 1 which will be 6.
similarly J will get incremented again
again 2 is less than 3 come back here
we'll print one then again we'll
increment J J will become 3 3 is less
than 3 no it's false that condition is
false so it jumps out of the loop goes
to line number 12 prints a blank line
again goes back to eight line number
eight increments I and I now becomes 2 2
is less than 3 yes it will again go here
initialize J again with 0 and again does
the same thing for the Row 2 and column
0 1 2 and again it will come out of the
loop this time again when it will go
here the value will become from 2 to 3
and 3 is not less than 3 so then it will
break out of the outer loop so the idea
is execute the inner loop for every
value of the outer loop remember this
line because that is how you will be
applying your knowledge of nested for
Loops to be used in certain condition so
whenever you have a scenario where where
you have to iterate over a collection
based on a certain value of another
collection then you can use nested for
Loops or you have a scenario where you
have to iterate over 2D or 3D arrays for
example if we were dealing with 3D
arrays then you would have seen three
nested for Loops here and where it will
apply the same logic that iterate over
all the collections all the values of
the inner loop on a particular value of
the outer loop then increment the value
of the outer loop and do the same thing
again I trade over all the values of the
inner loop based on a fixed value of the
outer loop so let's run this program and
let's see what kind of output do we get
so like I said our our motive our Target
was to print this in in a matrix style
and you can see that it is printing in
it in a sort of a matrix representation
so the first row gets printed here then
the second row gets printed here and
then the third row gets printed here if
you try to decipher it it will work
exactly the same way as I explained so I
equal to 0 0 Less Than 3 condition
becomes true comes here J equal to 0 J
Less Than 3 condition becomes true comes
here prints the array of 0 comma zero
which is 2 then prints the array of 0
comma 1 which is 7 0 comma two which is
9 then J becomes 3 it breaks out of the
loop goes up here I becomes from 0 to 1
1 is less than 3 Yes again comes here re
initializes a fresh for loop with a new
J setting to zero and it will it will
print the array of 1 0 1 1 1 2 then
similarly array of two zero two one two
two so that's basically what we are
doing we are iterating we are taking the
first row and iterating all elements of
it picking the second row iterating all
all elements over it and so on so forth
you can do this for any n dimensional
kind of array or a collection so as I
described earlier that array is
basically a container which can store
value use or a sequence of values or
sequence of numbers or sequence of
characters into itself you can think of
it as a box which can store all the
values in a continuous fashion as you
can see here this is just a pictorial
representation and this is coming from
the official Java docs and you can see
that we if we create an array of size 10
then we have these 10 blocks created
here you can see 1 to 10 so the whole
length of boxes the number of boxes here
are 10 but the way arrays are designed
is that the index index is basically
used to access the element in this
particular box the index of the boxes
start from 0 so it goes from 0 to 9 so
remember the array length is 10 it array
in the array can contain 10 elements but
the index of the array starts with 0 and
will always end at length minus 1 which
is 10 minus 1 one in this case which
comes as 9 so it will always be length
minus one it could always the index will
always start from 0 and go till length
minus one length can be anything in this
case the length is 10 so the index ends
at 9 if the length was 20 the last index
will be 19 but in total you have these
10 memory locations we also call them as
continuous memory locations because they
are continuously placed and array
basically blocks 10 memory locations and
creates a container over it so this is
how an array basically looks like inside
the memory and whenever you want to
access the elements of the array you
will say array of 0 or array of 1 or
array of 2 you basically need to specify
the index to access the element at index
for example if you want to access the
element which is sitting in this box you
need to say array of index 8 and we'll
see how we can do that but this is the
basic uh understand understanding and
idea of the concept of arrays so let's
try to understand this with the help of
an example I will switch back to Eclipse
IDE and I've created a very simple
program here to demonstrate the
functionality of arrays here so we
already covered in the previous lecture
of what is package and what is public
and what is class how do we give the
class name and what is the meaning of
this particular method so I'm not going
to cover that again we'll start directly
from here so here the first thing which
I'm doing is I'm declaring an array of
integer this is a variable name the
identifier basically it can be anything
and this is the data type it's an
integer array and as we as we covered
this as well that whenever you put
square bracket in front of a data type
it becomes an array data type so this is
an integer array representation now we
just declared an array but we still
haven't allocated a size to it so you
can do that with this particular syntax
so you can put the variable name of the
array and say new int and put the right
size here this size can be anything and
once you do this now array will actually
allocate those memory boxes which we
covered here but the moment you do new
into 10 this box these boxes continuous
boxes will be placed in the memory and
the memory is allocated to this array we
call this memory allocation this is how
you allocate memory to the array so we
allocated memory to this array for
storing 10 integers the next thing is
now we can start storing elements in
those boxes so like I said that the
array index always starts with 0 so if
you have to store the first element you
actually have to store it at index 0
location so you give the array name you
provide these square brackets and you
put the index value within the square
brackets that is how you basically point
to a particular element inside the array
so we say an array of 0 and we put the
value 100 then we initialize is the
second element which will be index 1
then will be the third element which
will be index 2 fourth element index 3
Fifth Element index four Sixth Element
index 5 and so on and till we store till
the last element so this is the tenth
element which is accessible as index 9
and the value is a thousand basically so
from 100 to thousand we stored 10 values
in this array and we stored them by
accessing the index and this is actually
the only way you can store values in the
array by pointing to the indexes so we
go from 0 to 9 and we stored all the
values 0 being the first element and
array of 9 being the last and the tenth
element remember the length minus one
concept okay so now we will try to print
all the elements one by one that's
pretty much what we are doing now so as
we covered in the previous lecture that
we use system dot out dot println to
print anything and we understood the
whole meaning of this so I'm not going
to repeat that now we want to print the
first element the first element is
sitting at index 0 and we can access
that element with this syntax by
providing the variable name and the
actual index value so I'm just writing a
random string here which says a limited
index 0 and then I'm putting this plus
here and putting the variable name this
plus is basically used to concatenate
the output of a static string with a
random variable or basically you can
print anything with using plus plus is
used for concatenation so I'm just
trying to print this whole value but
here this is a string value which is a
static string and then I have a value
coming from the array so whenever you
have to print some value from a
particular data type or variable or
collection then you can use this plus
syntax to concatenate a string static
string with your actual value so that's
what I've done here by saying plus and
array 0 and similar only for index 1 I'm
printing the the first index then for 2
3 so far and so on so forth till the
index 9. so basically I'm just printing
the all the values of the array starting
from index 0 to index 9. so that's all
which which is written in this program
now let's try to run this program so I
will right click go to run as and go to
Java application and hit on this and now
if I just expand this console you can
see all the system.out.printellent
statements have been executed and they
printed this so this is the static
screen string part in fact including the
colon this is the static string part
element and index 0 printing exactly as
is and then dynamically the zeroth index
element of an array is printed here
similarly we have printed the index 1
location element index 2 location
element index three location element and
so on so forth till the index 9 location
element so in total these are the 10
elements but the index always works from
0 to length minus 1 in this case it will
be going from 0 to 9. so this is
basically all which I wanted to cover in
this lecture the whole idea was to give
you more understanding of arrays and
remember this is just an integer array
you can similarly create a character
array you can also create a string array
for uh for you as well so it it's
completely uh it's completely related to
the data type you are using if you
create a care array then you can only
store characters into it if you create a
string array then you can only store
strings into it and now you can probably
relate back to this particular thing
which I explained in the previous
lecture that we create the string array
for the reason that when you run this
particular program and if you want to
provide any command line values command
line arguments to the program those
arguments will automatically be stored
in this args and then you can access
this as ARG of 0 here GS of 1 Etc in
your program that's the whole concept
let's get started with understanding
arrays in detail we have been talking
about arrays throughout this course of
java in the previous sessions as well
and we have covered some basic
understanding of how to create arrays
how to declare them how to fill values
in the array and how do we print the
array with positions as well as the
array as whole but whatever examples
which we took previously were one
dimensional arrays because arrays can
have more than one Dimensions as well
you can create a one dimensional array
you can create a two dimensional array
you can create even a three dimensional
array and you can go up to as many
dimensions as you can handle in your
Java program so it depends upon the kind
of complexity you want to have in your
program and the kind of values the kind
of structure you are going to store in
your arrays and based on that need you
can choose whether you want to use a 1D
array or one dimensional array or a 2d
array or a 3D array and so on in these
sessions we are going to talk about 1D
arrays 2D arrays and 3D arrays and after
that we'll leave up to you to try out
more dimensionals if you want to we have
already covered the basic array
structures which were one dimensional
arrays so I will just give you a quick
walkthrough of how we actually handled
one-dimensional arrays so this is a
sample program to demonstrate one
dimensional arrays if you remember this
is how we use to create arrays we write
the data type of the array and then we
write the square boxes which denote that
this is an integer array data type we
assign a variable to this and then we
initialize the array with the size 4. so
new is the keyword which is used to
initialize anything in Java and we are
going to use this heavily when we talk
about classes and objects and even
collections literally any object which
you want to create in Java requires a
new keyword so here I'm writing new and
then and int 4 which means create an
array of size 4 and then I'm filling the
value of the four positions which I have
created as part of this array and if you
remember when we create these kind of
arrays we store them in a zero index
based position the first value gets
stored at 0th index position and then so
on so forth so it will always start from
0 and never start from one remember that
and after that we just print all the
values of individual positions of the
elements in the array and if I just run
this program all of the elements of this
particular array should be printed one
by one so if I just show the full
console of the output we can see that
element and index 0 was 10 element and
index 1 was 20 element at index 2 was 30
and element at index 3 was 40. so this
was just a quick refresher of how one
dimensional arrays can be written and
whenever you declare a very Sim
simplistic array it will generally be a
one dimensional array now let's look at
the two dimensional arrays and how do we
write them when do we need them for that
I have created another example which is
says two dimensional array I just
created a class and it has a public
static void main method and I've created
a two dimensional array this time so
let's understand this two dimensional
array in a bit detail and when do we
need that generally you would need to
use two dimensional arrays whenever you
are trying to do any Matrix calculations
if you if you understand what do you
mean by matrix it's basically a two by
two structure which stores the values in
the form of rows and columns so imagine
a table of two rows and two columns then
it will be a two by two Matrix so if you
want to store that particular table in a
Java program you would need to store
that as a matrix as a two-dimensional
Matrix rows being the one dimensional
and column being the other dimension and
that's what we are doing here and if you
want to store that 2D metrics in a Java
program the approach and the procedure
for that is pretty similar to how you
create a one-dimensional array with
slight changes the first change is
instead of a single square bracket you
are going to write two square brackets
because it is a two dimensional array so
remember the number of square brackets
you are going to put while initializing
and declaring the array is the number of
Dimensions which your array is going to
have since this is a two dimensional
array example that's why you see two
brackets here if this was a three
dimensional array example you will see
three array three square brackets here
and so on so forth so that's the first
part of it second part to understand is
to how to store the data remember I told
you always imagine the structure of rows
and columns whenever you are trying to
store a two dimensional array in Java so
what are rows and what are values and
how do you represent them while you
declare and initialize a two-dimensional
array so you start with the curly braces
as the normal 1D array but inside the
curly braces you create nested curly
braces blocks you can see three blocks
here they start with their own curly
brace and end with their own then this
curly brush starts here and ends here
and then this curly brush starts here
and ends here idea is that you provide
this outer curly braces to define the
overall structure and then inside each
of the curly brushes is going to
represent a row in your two dimensional
array so each of these values these
blocks is going to represent a row so I
can say that this is the first row this
is the second row and this is the third
row and if I try to visualize it in
terms of columns then this is the first
row First Column first row second column
First Row Third column similarly second
row First Column second in row second
column second row third column and third
row First Column third row second column
and third row third column so individual
values are going to be represented as
columns and the whole curly braces is
going to be represented as arrays that's
the basic mental idea or mental image
you should have while declaring a two
dimensional arrays remember to declare
the rows inside the nested curly braces
and whatever elements you have will
automatically be indexed as columns one
other thing to remember that since this
is an array data structure everything
starts from 0 and nothing starts from
one so this will be row 0 this will be
Row 1 and this will be row two I'm
talking about the position we can still
call it as first row second row and
third row but the position of this
particular row element is 0 the position
of this particular row element is 1 and
this particular row element is 2.
similarly for columns as well this is
column 0 column 1 and column 2 similarly
column 0 column 1 and column two and so
on so forth once you understand this
data structure well and you have defined
it correctly then everything should fall
in place if you want to do a matrix
addition or if you want to do a matrix
multiplication or a DOT product all of
the kind of calculations can be
performed using the 2D array concept
here in this program what I'm doing is I
am printing the values of this
particular 2D array into a matrix style
and you see some strange code here which
is for ETC don't worry about this I am
going to cover in detail what this 4
means and how do you write this for now
what we can understand that we just want
to print this you might not need to
print this in your Java programs when
you write a production grade application
but you might want to do manipulations
on these arrays as metrics maybe you
want to create a transpose of a matrix
or you want to do a DOT product or
addition or subtraction or whatever be
your use case in this case just for
demonstration purpose I am printing the
values as rows and columns nothing else
so this all of this code from line 8 to
line 14 or in fact line 13 is just
showing how to print the values you can
see some system dot out and you can see
some construct here and like I said
don't worry about this I will cover this
in detail let's run this program and see
if my Java array is stored correctly and
how can I represent this so you can see
I have represented it in a style of a 2d
Matrix where this is the first row this
is the second row and this is the third
row similarly this is the First Column
containing the value 237 so column 0
will have value 2 and column 1 will have
this value 3 and column 2 will have this
value 7 for row 0. let me also do
something here which can help you
understand this concept better let me do
a
system.out.println and let's print an
individual value because like I said the
for Loop can be confusing here to
understand so let's say I want to print
ARR of 0th row First Column and see what
kind of values do we get let me comment
this code comment is control backslash
and this code will be commented and this
code will not be executed and now only
line 15 will be executed instead of the
four block so if I run this I get the
value 7 so row 0 and First Column row 0
First Column is 7. let's try with one
one I want to print the row at zero one
position remember not the first row but
the one position row which is basically
technically the second row so second row
second column and see what kind of
values value do I get in this case I get
6 so second row second column similarly
if you change this value to 2 then third
row second column which should point to
4 yes we get 4. similarly you can write
a value here as 0 and you can write a
value here as let's say 2 this will
print the 0th row and the second column
so similarly whatever kind of value you
want to write you or you want to access
you can access it in this fashion and
remember the column and row indexes will
always start from 0. so this is a simple
demonstration of how you can use two
dimensional arrays and in this session
we also did a refresher of one
dimensional array let's get started with
how to create and use a
three-dimensional array or how to go
about using multi-dimensional arrays in
Java so as you can see from this image
we talked about 1D array which is having
just one axis then we talked about 2D
arrays in the last session where we had
rows and columns basically an x-axis and
a y axis and then we can also have a 3D
array which will have three axises which
will have an x-axis a y-axis and also a
z-axis think of a simple box which every
box in this world will always have at
least three dimensions and from from
here you can go even build more complex
arrays which can have four dimensions or
five Dimensions or as many dimensions as
you want it to have and today we are
going to look at an example of how can
we build a 3D array and how do we access
those elements but this picture is just
to show you the mental model of when you
will be creating a 3D array so for
example generally an image data is
stored in in three dimensions so you can
you might want to store the image data
into a 3D array and there can be many
other use cases in the mathematical and
research computational use cases where
you might want to use a 3D array so but
remember there's an x-axis there's a
y-axis and then there is a third axis
which is called the z-axis so let us
look at a Java a program to understand
how we can build a three-dimensional
array and for that I have created this
class which is called multi-dimensional
array it has a entry point method which
is the public static Point main method
and then I have created an integer array
and this time instead of one or two
square brackets I have three square
brackets and if you remember I mentioned
this in the previous session as well the
number of square brackets which you're
going to put while initializing the
array is the number of dimensions of the
array and since in this particular
program I am going to demonstrate a
three-dimensional array that's why you
see three square blocks boxes let me
just minimize this yep so we have three
square boxes here and we have created
the variable name as ARR or short form
as array then we start with the outer
post curly braces as is then we put
another curly braces which starts from
here and it ends here then then another
set of curly brace which starts from
here and and here so this is the this is
the First Dimension this is the second
dimensions and these are the third
dimensions that's how you are going to
define the different dimensions remember
this is the First Dimension when the
first curly brace starts then you have
the second dimension which covers this
hole and this hole and then you have
third dimension which are these so
that's how you are going to visualize
and and put the three dimensions in use
while declaring a three-dimensional
array and the values work in the same
fashion it's it's a zero index based
position so since we do not have an
official name for the third dimension so
I'm just gonna use x axis y axis and Z
axis to refer to the three axises so
this would be X of 0 this would be y of
0 and this would be Z of zero similarly
X of 1 y of 1 and Z of 1 and and so on
so forth so now if I try to access the
value which is at zeroth X position
first y position and second Z position
what's the value do we get here let's
run this program and understand and
interpret the output okay so when we ran
this program we got the output as 11. so
let's understand this output so when we
say the zeroth position on X the first
position on Y and the second position on
Z so this is the zeroth position on X
and this is the first position on Y and
then this element is 0 1 2 is the second
position on the z-axis so to to describe
it in a nutshell this defines the x-axis
so we have two elements on the x axis
here this one and this one then we have
2 elements on the y-axis on each x-axis
so this is one this is 2 on the first x
axis and this is one and this is 2 on
the second y second x axis so 2X and 2y
and then on the Z axis I have three
elements each so hope this helps you
understand and visualize this so x axis
and this one is other x axis and then Y
axis y axis and then in elements inside
this are Z axis so I'm saying 0 with x
axis in this block first on the y axis
which is this block and then second
element or the Z or second position
element on this particular ax in this
particular block which is 11 and that's
why we get 11. if I print 0 let's say I
change this particular value as 1. so
now the output should be coming from
this side so second X position because
it's one second y position so this will
go here and then the two position which
is the third element of the Z axis which
is 13. so let's see if we get 13 yes we
get 13 here so this is just to show you
how you can interpret this this
particular array and always be mindful
of how you are structuring this array if
your structure has gone wrong then your
program will become useless and it will
give you lot of unpredictable outputs
which might not make sense and which may
introduce errors in your program so be
very careful how you define the
structure of the elements here that's
the key and after that you just need to
understand the x-axis the y-axis and the
z-axis always remember all the accesses
start from 0 so when I say 2 I'm
basically referring to the third element
and not the second element so this is
all I wanted to cover in this particular
session where we describe how we can use
a three-dimensional array and from here
you can go to any lens like I said you
can add more square brackets here and go
to four dimension or five dimension or
six Dimension but remember the more
Dimensions you add the more complexity
of the program will be having the
program will become more and more
difficult to debug and understand so
always try to take a wise call as to how
many dimensions you want to use in your
array get started let's see what strings
are and how we can use strings in Java
Java strings are objects that contains
groups of characters like arrays strings
are immutable as well immutable means
one string is created they cannot be
changed or manipulated if we use a
string hello they are stored in a memory
location like this 0 1 2 3 4 are the
addresses of the locations where each
character of the string is stored now
let's move on to creating strings there
are two methods of creating string
string literal method and using new
operator this is the syntax of string on
the screen first string type then
variable name is equal to sequence of
characters in double quotes this is
called as string little method for new
operator method we use new operator and
value of string is given in the brackets
now let's see a simple program to
understand the use of strings with Java
code let's create a new project file new
project next tick the box next I'm gonna
name it as strings and for the base
package I'm going to name it as string
as well because all the programs I'm
going to do in this package for Strings
we have our main program right here the
main class now before importing the
strings we need to import some
preprocessive directives so for this for
this I'm gonna import Java dot IO input
output dot star star star means
everything inside the directive and I'm
gonna import
java.lang dot star this means I can do
all the operations that is needed for
Strings so there are two ways to declare
string this is the first one string s is
equal to Simply learn now we have a
string s and it contains the value
simply learn now I'm gonna print this
system.out.println
plus s or I'm gonna name it as string
I'll print string first is equal to and
then I'm gonna print this so double
quotes string is equal to and plus s so
let's run this program
and there we go we have string is equal
to Simply learn so it took the value of
s and printed that
so let's see the next type of string how
we can declare the string
Str is equal to new string simply learn
so this is the second method how we can
declare string or assign the values to
string so to print it
I'm going to use string 2 is equal to
and then plus Str so let's execute this
as well
and as you can see we have string 2 is
equal to Simply learn as well so this
means both the methods are to declare
strings or to assign values to the
strings so you can use any of them I
prefer using first so it's easy that's
why you don't need to write new and
string so let's move on to the new topic
classes in strings we all know that
strings are immutable now what if we
want to change something inside the
string then we use these methods to
manipulate strings in Java first one is
string Builder the string builder in
Java represents a mutable sequence of
characters it is an alternative to
string class as it creates a mutable
sequence of characters next is string
buffer string represents fixed length
immutable characters of sequences while
string buffer represents growable and
writable character sequences it will
automatically grow to make room for
additions like appending inserting and
deleting next we have string tokenizer
as ring tokenizer object internally
maintains a current position within the
string to be tokenized some operations
Advance this current position past the
characters processed string tokenizer
class in Java is used to break a string
into tokens a token is returned by
taking a substring of the string that
was used to create the string tokenizer
object now let's say different methods
for functions that can be done on
strings in Java we have lot of methods
or functions in strings these are few of
the methods that are used by programmers
frequently and we will be using in this
series of our Java tutorial next let's
have a look at a program where we are
going to reverse a string and compare to
string this is going to be an
interesting program and you will be able
to understand string a lot better so
let's get started so first we'll see how
to compare two strings and then we'll
see how to reverse a string so let's
create a new project file new project
let's click on next
tick the box next I'm gonna rename it as
compare and reverse because I'm going to
do both the programs in the same program
and we have our main function here to
use some classes or to use some methods
we need to import some of the strings
from java so I'm going to import strings
dot compare compare dot string compare
so let's write our code here so I'm
gonna use four strings first string S1
is equal to then I'm going to use new
string and I'm inside it I'm going to
name the string as simply learn
as capital and for the next string
string S2 is equal to new string
let's give it as practice for the third
string S3 new string let's give it a
study and for the first fourth string we
are going to match the third string to
show all the outputs that's possible
study now we are going to display some
output using the function equals so what
equals does is it it compare two strings
so first I'm gonna use it make it as
user friendly by writing comparing
string 1 and then comparing string two
and then semicolon so that everything
will be separated you can easily find
out what the result will be and then
this is the main part S1 dot equals and
in the bracket S2 because we are
comparing S1 and S2 so S1 dot equals S2
so this function automatically checks
whether S1 is equal to S2
now same thing we are going to do with
string S3 and string S4 again this user
friendly S3 and S4
semicolon S3 dot equals S4 we know that
S1 is not equal to S2 but S3 is
definitely equal to S4 so let's try it
with one more sentence so that we can
compare one more string so I'm gonna
compare S1 and S4 so I'll copy paste it
and instead of S3 I'll write S1 and same
I'll do with S1 dot equals S4 so let's
run this program so before running we
have a error here so I'm going to delete
that import because we have not used it
so now let's run the program and yes we
have a result comparing simply learn and
practice is false this definitely false
study and study both strings are
matching so it's true and simply learn
and study they don't match that's why
it's calls so let's get started with our
second program that's reversing a string
so I'm going to delete everything from
here and I'm gonna write same code here
only so first I need to assign a
variable of string
string input equals and limit as simply
learn and this is the main part guys we
use string Builder because the string is
immutable and as we discussed earlier
string Builder allows us to do
manipulation so I'll use one more
variable input 1 and new string Builder
so in input 1 we can do any manipulation
that we require so first I'm gonna do
input1 dot dot append so that I can do
operations that I want on it either
reversing or deleting or concat so I'll
take append of input and lastly input 1
is equal to input 1 dot reverse this
function reverse the string that is
there in input 1.
now to print the value of the reverse
string
the reverse string is and then input 1.
so here's the catch guys we have to use
string Builder so that we can do
manipulations inside the string if we
don't use string builder then we will
get an error that unable to manipulate
the string or unable to reverse the
string so string Builder is the main
thing here so that we can do all the
operations that we want either reversing
or concat or deleting anything from the
string or deleting an element or adding
anything to the string so all that
happens because of string Builder so now
let's run this program
and there we go we have a result the
reverse string is the reverse of Simply
learn now let's try it with something
that is palindrome so we have our
language Malayalam if we reverse this
we'll get Malayalam so this is kind of
palindrome string and see the result the
reversing is also Malayalam so this is
how you reverse a string so this brings
us to the end of this video we learned
about strings the functions for Strings
and the methods we use in strings and
lastly we learn how to compare two
strings and how to reverse two strings
welcome to this tutorial on objects and
classes in Java this is a part of our
Java tutorial Series where we will be
covering everything you need to know to
master Java let us look at what we will
cover today first we will talk about
objects and we will Implement two
programs on IntelliJ to learn about
objects then we will move on to classes
in Java where we will see an advanced
program to learn classes more in depth
so what are objects an object is an
instance of a class let's have a look at
an example in this example animal is a
class and dog is its object the object
dog has States and behaviors we can have
dogs with different breeds sizes and
colors these are considered as the
states of object dog on Behavior side
dog has Behavior like barking eating and
wagging tail so an object has its own
States and behaviors now let's look at
an example using Java code there are
many platforms to run Java program so
for this video I'll be using IntelliJ so
let's create a new project let's name it
as project 1 and finish there we go we
have a new project with we have a class
with Main and we have a main function so
the code that we write should always be
written in the main function so let's
create a new class to understand how the
object is used let's name it as student
we need variables so that we can access
the variables of this class so I am
going to use student ID with the integer
type student name
and students age
there we go now we have these three
variables that we can use so let's go to
our main program and start our coding so
we have a class named student now let's
see how to create a object of a class
this is the syntax to create object now
the object here is s i created an object
s of class student now let's assign
values to the variables for this we use
the object s and use the dot operator
and we have options from which we can
choose from that we declared in the
class student so for this I'll use ID
and give a value similarly I'll give age
and give a value and finally let's give
a name
now we'll print its value
now we are going to run this program
let's see what output we'll get
and there it is we have name that's
simple learn we have age and we have ID
now let us see an example how we can use
multiple objects for a single class so
let's get started let's create a new
project and and I'm gonna name it as
Vehicles because I'm gonna use cars and
bikes in this program so I'm going to
use Vehicles as a combined form and yes
here we have a class mail and a function
main now I need two classes for this
program so I'm gonna create two classes
first I'm gonna name it as bikes and the
second class I'm gonna name it as cars
so let's create variables for these
classes so in cars first I need string
name and I need the cost of the car so
cost can be integer as well because I'm
gonna use dollar sign in that so I'm
gonna use string because of that so same
thing I'm going to do with bikes
now that our classes are created let's
create objects for this class so the
process is same but we are going to use
different names for the object first the
car class and I'm gonna name as car one
and yes we have created the first object
not to create the second object
similarly I'm gonna create five objects
of the Class Cars
and I'm gonna change the name for them
so I created five objects of the same
class so I'm gonna create five objects
of the bikes class as well so bike one
will be a bit longer so I'm gonna use B1
till B5
and I'm gonna name them two from B1 to
B5 so now I'm gonna assign values to the
variables that I created in classes bike
and cars so first I'm going to go with
cars and let's name it as Lamborghini
similarly Car 2 Ferrari
so I'm gonna use names of the cars that
are very famous and costly so that
anyone over the world can understand
this so let's name car 3
I'm gonna name it as Bugatti
similarly car 4
Pagani and Ka 5.
now I'm gonna give names for bikes
I hope everyone will understand the
names that I give
to be four
and B5 last one Yamaha
now let's assign the cost for bikes and
cars as well so the procedure is same so
let's do it 130 000. same B2 so B1 goes
for Harley Davidson B2 for Ducati B3 for
Suzuki B for for E cos and B5 for Yamaha
I am going to assign values for these
values accordingly for Ducati to thirty
two thousand
dollars
for Suzuki 200 000
300 000.
and the last one Yamaha 500 000.
now similarly I'm gonna assign values
for carbon.cost till card 5 dot cost
three thousand dollars for
Lambo I think I can copy paste these as
well so let's copy paste it a lot faster
and easier to do
car two car three car four and car five
we don't need this uh as per car 2 let's
take it as 252
000 and let's make it it's 3 million
uh let's put this let's keep it as 1
million
four hundred thousand and lastly uh
let's take us 293. now that we have
assigned all the values for all this now
let's print it and get the value I'm
going to create a very simple program
but a very user friendly program so it's
gonna be interesting for you guys so we
are going to ask the users what do they
like either bikes or cars so we need to
give them the options and our next
program will be based on the options
that the users select not the options we
give as the command so let's do it
let's give the options one
bikes
and two cars I need to take the value
that user gives for this I'm gonna write
this command
so I have not used scanner yet so let's
import scanner
and let's create a object for scanner
and yes let's get back so the data type
of choice variable is integer that's why
I'm using next int if the data type was
string then I would have used next line
so now that we have Choice from the user
let's use this value
if the user chooses the first value that
means bikes so the next thing we display
is we have models and we are going to
give five models for bikes to the user
here I am giving options to the user so
that they can choose easily from number
one to five
now we can show these options to the
users so that they can choose from one
of these value so let's use one more if
statement so that we can find out
whether they have this value or not
before that I am going to ask which one
would you like to choose
to enter the choice I'm gonna use one
more variable let's say n so I'm gonna
store n
f n is equal to equal to 1 that means
Harley Davidson then I'm gonna show the
cost of Harley Davidson
this is the syntax to print the value
for the cost or any of the variable that
we use in class
what if the user says second or third or
fourth or fifth so for that we are going
to use else if statements
if n is 2 that means Ducati so we have
to show the rate of Ducati or the cost
of Ducati to the user
now similarly I'm gonna do for n is
equal to 3 n is equal to 4 and N is
equal to 5.
now I'm gonna do for n is equal to 4
and lastly n is equal to 5 that is our
last bike Yamaha
what if the users put a number that is
not between one to five so for that I'm
going to use else statement and put a
message that please enter the value from
1 and 5.
so now we have code for bikes and the
same thing whatever the user selects
that he wants to find the car so for
that we have this the choice is equal to
is equal to one so the same thing we are
going to do for choice is equal to is
equal to 2
and the same thing we are going to tell
to user that we have five models
the same names that I gave to variables
I'm going to give this to here
second one Ferrari
third book RT
fourth ecos
and the last one
posh
now we are going to ask the users the
choice that which number do they want to
choose
now we need one more value so that we
can have it as a variable which can
store the choice of the user so for this
I'm going to use C
now if C is equal to equal to 1 that
means if the user who wants to see the
cost of Lamborghini that he puts the
choice as one so we're going to display
this message the cost of Lamborghini
and we are going to use else if Loop to
enter the next values for C from 1 to 5
if C is equal to is equal to 2 that
means the user wants to know the rate of
Ferrari then we are going to show the
cost of the Ferrari
same thing if the user enters 3 as the
choice
if user enters 4 as the choice then we
go for ecos
and the last one if user enters the
Choice as 5
then we have to display the cost of posh
now what if the user enters none of the
values from 1 to 5 then we have to
display a message
showing that
please enter the value
between one to five now remember the
first choice that you wanted from user
to enter either bikes or cars so what if
the user do not enter either one or two
so for that we need one more else
function to tell the user that either
enter 1 or 2.
and with this we have completed our code
so now let's run this program for this
we need to go to run and then run main
there's a shortcut for it that is shift
plus F10 so let's run the program
and yes we have successfully executed
the program Let's test this program now
so enter your choice I'm going to enter
one and yeah we have five models Harley
Davidson Ducati Suzuki Pagani and Yamaha
so enter your choice I'm gonna enter one
and yeah we have a result the cost of
Harley Davidson is 130 000 so with this
we have completed our code and please
feel free to type this code in your own
computer and try out all the permutation
and combinations that you can with this
program so with this let's move on to
classes and understand the classes and
their concept then we'll have a new
program on classes now let's see what is
a Class A Class is a blueprint from
which objects are created a class
describes state or behavior of an object
in this example dog is a class the
variables in this class are breed and
color the functions or methods of the
class dog are barking hungry and
sleeping we use objects of a class to
use variables and functions of the class
with this let's understand classes with
a simple Java code let's create a new
project
next tick the box and let's name it as
automobiles
let the base package be student and yes
we have a class main now let's create
some classes to do code on
I'll create a new Java class as cars
and then I'll create one more class with
the name bikes
and then one more class automobiles
so I'm gonna connect cars and bikes with
automobiles so that we can use that
program in Main and see what can we do
with the classes that we create in
automobiles I need some variables
I'll take private double and let's say
Fuel and then same thing private double
and then year and let's take one more
private string and brand now let's have
Getters and Setters for this so these
are used to get the value and set the
value for the variables inside the class
there we go we have the Getters and
Setters for it now let's go to class
cars so public Class Cars extends
automobiles
so in it I'm gonna create one more class
or a Constructor
and I'm gonna print a message say a new
car has been created car has been
created
now the same thing I'm gonna do with
Bikes let's go to bikes and I'm gonna
use the same thing extends automobiles
this is because I can inherit all the
variables from the automobiles class so
I created a Constructor and I'm gonna
print a message a new bike has been
created
so I have created Class Cars bikes and
Automobiles so let's go to main program
so this is where we should write our
code so I'm going to start with the code
now it's a very simple code I'm gonna
first I'm gonna create the variables or
the objects of the class with private
bikes bike so one is car and one is bike
both are objects for the classes so I'm
going to use this objects
bikes bike is equal to new bike
this is so that my object can function
really well and now I'm gonna run it it
will take some time to run
and yes there we go our program has
executed and the things that I typed a
new car has been created a new bike has
been created are done now let's try
something else using the classes
so I'm going to bikes so I'm going to
create a new method or a new function
public void kick for bike so I'm gonna
print message the bike has been started
with kick bike has been started with Kik
now the same thing I'm gonna do with
cars now how does a car start with the
key so I'm gonna make a function public
key and inside it I'm going to print the
same message car has been started with
key so I should write void there to give
the return value as wide so let's print
the message car has been started with
key rotation let's write that as well so
in the main program I'm gonna use
objects to use those functions and let's
see what changes they will do to our
program
Pike dot cake and car dot cake let's run
this
and there we go first we used to have
this two messages but now these two
messages are also there as well because
we invoked those functions and methods
that are there in class cars and bikes
so if I write bike dot key or car dot
kick this won't work this is because key
is not a method of bike or kick is not a
method of car so that's why I gave
private static for the functions so if I
execute it these are the error messages
that I'll get cannot find the symbol
method kick or method key import is an
abstract class
the answer is abstraction is one of the
keys to achieving an object oriented
programming approach and designing a
software
here the programmer tries to hide the
complicated implementation of the code
which makes the software run smoothly
most of the time the user isn't
interested to know how the code is being
implemented so through abstraction we
can just hide it
to do so we use an abstract loss or
sometimes an interface based on the
requirement
so abstract class in Java is considered
as a template of methods and variables
which are used in a program remember
abstract classes cannot be instantiated
directly now moving ahead we will next
learn the important features of abstract
classes
so the first one is template the main
reason programmers prefer to use
abstract methods is because they act as
a predefined template for any future
specific class that you might use
next loose coupling is a procedure where
an internal object gets the necessary
method or a different object from the
external world that is other than the
current working project the use of
abstract classes makes this process
possible
after that we have the code reusability
implementation of the abstract classes
provides the developers with one of the
greatest features that saves time which
is none other than the code reusability
followed by code reusability we have
abstraction as discussed earlier data
abstraction is the process of hiding
certain details and showing only
essential information to the user
abstraction can be achieved with either
abstract classes or interfaces
last but not the least
Dynamic method resolution
the abstract classes enable us with
Dynamic method resolution or the dynamic
method dispatch process
the dynamic method resolution is a
mechanism by which a call to an
overwritten method is resolved at
runtime this is how Java implements
runtime polymorphism when an overwritten
method is called by reference Java
determines which version of that method
to execute based on the type of object
it refers to
now these were the few important
features of abstract classes next in the
docket is the crucial rules to be
followed to use abstract classes
all right let us go through the rules
one by one as mentioned below
the first one is the keyword abstract is
mandatory to declare an abstract class
followed by that the next rule says that
abstract classes cannot be instantiated
directly
the third one is an abstract class must
have at least one abstract method
next to that we have another rule which
says an abstract class includes final
methods next an abstract class may also
include known abstract methods
it's not mandatory that an abstract
class should only include abstract
methods so the last rule says that an
abstract class can include Constructors
and static methods
so these were some crucial rules to be
followed to use abstract classes in Java
so far we have discussed the definition
of abstract classes its features and the
rules to use abstract classes in Java
now we will learn how to achieve
abstraction in Java
so basically there are two different
ways to achieve abstraction in Java the
first way is by using abstract classes
and the next one is by using an
interface
now this brings us to our next topic
that is the syntax to be followed to use
an abstract class and an abstract method
to declare an abstract class we use the
keyword called abstract followed by that
we use the keyword called class then
after that we declare the name of our
class the name of the class is up to the
user's choice for example I have named
my class as simply learn as shown here
followed by the abstract class we have
the abstract method to declare an
abstract method we use the keyword
called abstract then the written type of
the method as of now I have used void
then later we have the name of the
method that is based on the user's
Choice as you can see I have used simply
learn as the name of the method
so this was by using abstract class
method the next one is by using an
interface method
now what exactly is an interface
so interface can be defined as a
boundary between the method and the
class implementing it in Java we use
interface to achieve abstraction
in other words we can also consider
interface as a container which saves the
signages of the methods used in a
program
now we will move ahead and understand
the syntax to use an interface to
achieve abstraction in Java
to declare an interface we use the
keyword called interface followed by
that we declare the name of a class
the class name is up to the user's
choice for example I have named my class
as simply learn as shown below
as discussed earlier interface acts just
as a container that stores only the
signatures of the method we cannot have
a complete method defined inside it all
we can do is just declare an interface
now that we have a detailed explanation
about the abstract class and the
interface
let us look into some example programs
based on abstract classes
now we have successfully booted the
Eclipse IDE now let's create a new
project
so to create a new project just click on
create a project
and this should give you a dialog box
wherein you have to select Java project
click next
now let us give a name to our project
so simply learn will be the name of my
project here now let me click on finish
to finish this process
as you can see the project has been
successfully created and inside the
project simply learn we have the source
file and right clicking the source file
will give us a Dropbox where you can
just select new and inside new you can
select a new package
now let's name the package as
abstraction and click on finish to
create the package
moving further let's right click on the
package and select new and from new
select a class to create a new class
so the name of my class will be employee
let's click on finish to create the
class
now we have our employee class ready
now let's right click on the package and
select new and inside that
let us select another class
and the name of this particular class
will be person which will act as our
abstract loss
so as you can see we have declared this
particular class with the keyword
abstract and the name of the class is
person
so our first example which is based on
employees where we will have an abstract
class called person and this person
class will be inherited by the employee
class and gets executed to generate
employee details
now let us try to execute this program
and see the output
to execute the program just right click
on the package and go to the Run option
and select the first one that is Java
application
now you can see we have the employee
name pavitra and the gender is female
and the employee has logged in
successfully so these are the details
which we were expecting to be presented
on the output console now moving ahead
we shall execute our next example which
will be based on students
so here the class student is the
abstract class and three different
student classes namely Raju pranita and
punat will inherit the student class and
generate the output that displays their
particular ranks
so you can see our abstract class that a
student has been declared using the
keyword abstract and inside that we have
an abstract method which is get rank
and these classes that are Raju pranita
and Punit will inherit the abstract
class student and display their ranks
now let us try to execute this program
and see the output
as you can see the three classes have
successfully inherited the abstract
class and displayed their ranks on the
output console
now let us move ahead and try to execute
one last example
based on abstract classes
so the third and last example is based
on interest rates provided by different
banks
here we have an abstract loss named loan
and all the banks described in the
program will inherit the loan abstract
class to calculate the rate of interest
on the loans provided by them
as you can see we have the abstract
class that is loan and inside that we
have the abstract method which is
interest so we have the classes Andhra
Bank bank of Baroda idbc Bank State Bank
of India which are inheriting the
abstract class called loan and the
method interest to display their rates
of Interest now let us try to execute
this program and see the output
as you can see the program got
successfully executed and the rate of
interest for loans from different banks
is been displayed in the output console
so with this we have entered into our
next topic where we understand the
differences between an abstract class
and an interface
so the first difference between the both
is the keyword while we declare an
interface we use the keyword called
interface on the other hand when we
declare an abstract class we use the
keyword abstract
followed by that the second difference
is when you use an interface the
subclasses basically Implement an
interface
while on the other hand when you use
abstract classes the subclasses extend
an abstract class and inherit the
properties of the abstract class
followed by that the third difference is
multiple interfaces can be implemented
but on the other hand only one abstract
class can be extended at one particular
instance
and the final difference between the
both s interface is capable to support
multiple inheritance whereas on the
other hand abstract classes are not
capable to support multiple inheritances
multiple inheritance is none other than
the diamond problem which is not
supported in Java
now that we have understood the
differences between the both let us
understand the major advantages and
disadvantages of using an abstract class
now first we will discuss the advantages
so the advantages of using an abstract
class in Java are the abstract classes
are highly beneficial in writing shorter
codes the abstract classes avoid code
duplication they enable code reusability
which is a major advantage and finally
the last Advantage is changes to the
internal code implementation can be done
without affecting the classes
so these were few of the major
advantages of using an abstract class
now moving ahead we shall discuss the
disadvantages of using abstract classes
few of the disadvantages of using an
abstract class in Java are abstraction
is expensive as sometimes you need to
handle cases and situations which are
not necessary
followed by that the second disadvantage
is object relational impedance must
match in the case of rdbms and the last
disadvantage is object relational
mapping in case of Frameworks like
hibernate so these are the few important
disadvantages of using abstract classes
in Java that you need to consider before
using them into your project
let's see the definition of
encapsulation encapsulation is like a
capsule the whole code and data is
bounded together into a single unit
another way to think about encapsulation
is it is a protective shield that
prevents the data from being accessed by
the code outside this Shield as you can
see variables and methods are defined
inside one class like a capsule now the
question is why do we need encapsulation
the main reasons are first better
control of class attributes and methods
second class attributes can be made read
only or write only third it makes Java
code very flexible this means the
programmer can change one part of the
code without affecting other parts apart
from these encapsulation is mainly used
to protect data and increase security of
the code as you can see to protect the
data variables must be private and they
can only be accessed through methods now
let's see Java code for encapsulation to
understand the concept accept better so
now let's create a new project
next
and I'm gonna name it as
NCAP one
so here we have our main class we can
write the code here so before writing
the code let me create a new class
right click new Java class
and I'm gonna name it as employee
so in this program we are going to use a
classic example of employee using
employee Name ID and salary so in this
class let me create variables
first string name
then
integer ID
and then in salary
so I can easily use these variables in a
main program by creating object of the
class so let me just create the object
employee e is equal to new employee
now I can use e dot ID name or salary
anything I need to but this program is
about encapsulation so this is an easy
program we can do but in order to secure
our programs when we have a large number
of program and large number of lines in
a program so we need encapsulation at
that time so that data can be secured so
for that I'm gonna name it as private
now all three variables are private so I
can't use them see we can't see them
anymore if I write ID
we'll get a red color here so if we go
on it we can see ID has private access
so that means we can't use it directly
because of this we need Getters and
Setters that are normally methods that
are used for these so right click
generate and here you can see Getters
and Setters so just select all of them
and ok so now we can use these methods
instead of direct using the variables so
we can get in the starting then set then
get and again set so likewise it goes
like this so now we have set here so if
I want to declare variable and if I want
to put some value inside my variable so
how can I do that
here you can see get ID or get salary so
if I go for get ID sorry if I go for E
dot set ID and I set it as 6 so this
shows no error this means we can use
methods to access variables so let's
complete our program now first I'm gonna
set everything
and lastly e dot set salary let's get it
as thirty thousand maybe in dollars or
maybe in rupees let's just set it as 30
000 for now
so how I'm gonna print it for this I'm
gonna go to a print statement and then
name
and E dot not set name but this time I'm
gonna go with get name get name is to
return the value of the name that I have
given so in this case that's simply
learn
and next will be ID
and E dot get ID
and lastly salary
e dot get salary
so this is a simple program that is used
to Define encapsulation if we don't use
private variables that becomes a normal
program so when we use encapsulation we
are going to use private every time
whenever we declare variables so that
it's secure and no one can access the
variables directly
so now let's run the program
and there we go we have our result we
have executed the program successfully
and as you can see name simply learn ID
6 and salary is 30 000. so I hope you
understood the concept of encapsulation
so the main concept of encapsulation is
all the variables can be accessed
through methods so for this we use
Getters and Setters that are inbuilt
functions for IntelliJ or netbeans or
Eclipse so with this let's move on to
our next program to understand it better
and how we can manipulate these
variables or methods using program so
again let's create a new project
and this time I'm gonna name it as
encapsulation 2 because it's the second
program for encapsulation
and here we have our main program now
this time I'm gonna use an example of
cars so let me just create a new class
and I'm going to name it as cars
so in this again I'm gonna create three
variables that are private
so first I'm gonna get string name
then private string price that means
price of the car
and third one
top speed of the car
so we can create the program that we did
before as it is but I'm gonna explain
you more in depth how we can manipulate
these variables or classes so I'm gonna
create a Constructor for the class cars
and inside I'm gonna give it as
arguments as string name
then string price
and string top speed
and I'm gonna give it as this dot name
is equal to name this is so that the
class can identify that we are going to
give arguments related to that and the
class can return the values of it
so similarly I'm gonna give it as this
dot price
is equal to price
and lastly
this top speed is equal to
top speed
so with this we have completed our
Constructor for it now let's have
Getters and Setters for the same thing
for these three variables
so generate getter and setter
select all and ok
this is a great feature that we have in
Java Getters and Setters otherwise we'll
have to type the whole code so with this
let's move on to our main program
we'll write the code here first I'll
create object of the Class Cars
and inside this I'm gonna give arguments
or inside this I'm gonna give values
that I use in Constructor to assign the
values without using any c dot get name
or C dot get price
so my first was name so let me just name
it as BMW
the second thing was price so I'm gonna
give it as thirty thousand dollars
and the third one was top speed so top
speed I'm gonna give it as 200 kilometer
per hour so we have assigned all the
values to the variables and we have
created object as well all in the same
line so this is another way of creating
objects or another way of assigning
values to the variables that are private
so if I try to print these they can be
easily printed
so in the starting name
and C dot so this time I'm gonna give
get name so it automatically gets the
value that I assigned to the variables
through Getters and setters
after that price
C dot price get price
and in the end
top speed
C dot get top speed so if I print this
let's execute it
and there we go we have name BMW price
and even the top speed now if I give
spaces between them
it will look neatly
so let me execute it once more
and here you go name BMW price thirty
thousand dollars and top speed 200
kilometer per hour so this is one of our
ways how we can declare variables or
assign values to the variables without
using any Getters or Setters so in this
method we used only Getters to print the
value that we have for variables now how
can we manipulate the variables if we
want to change value of them now for
this again I can do set top speed or set
price let the name be as it is
so C dot set price
so price I'm gonna set it as
fifty thousand dollars
and C dot set top speed let me increase
it to 250 kilometer per hour
so before printing that I'm so that we
can differentiate which one is new and
which one is old I'm gonna print one
more line
stats after
updation
so now if I print these values I'm just
gonna copy paste it
so now if I print it let's execute it
and here you go
first we have name price and top speed
then stats after updations that means
after we set the value the value gets
overwritten on the variables and now we
have a new price and top speed and all
the details so this is how you can
manipulate variables or
what is inheritance
there are two other key terms which are
not going to be in this agenda but you
should also when you get to them make
sure you bundle them together as you're
understanding these structures and
that's the abstract class and the
polymorphism so what is inheritance
inheritance is an act through which a
new class gets created by acquiring the
variables and methods defined in the
previous parent class
so we look at what is inheritance we can
take an example of say food we have
veggies noodles fruits where food is the
parent and your veggies your noodles and
fruits are all subclasses of that
they're all kind of children of food
why do we need inheritance
we Implement inheritance for a multiple
of reasons like creating a possibility
to add or remove features
to reduce the code length as we reuse
the code more comfortable to develop and
maintain the project
and so if we start looking at let's say
we have a cell phone we make calls we
have our SMS texting our communication
on our phone we have our media we also
had a browser on there because now we
have a smartphone
and we look at that we have our phone
set up and then we have our full
smartphone media call SMS and browser
and we start to kind of Link these
instead of making them separate we can
have the call and the text and then we
can have them inherit we can actually
create a media that inherits their
quality so now you can text your media
now you can use the browser as part of
your call scenario
and I would even add one more example in
here and that is that all programming
languages that are object based are
built on inheritance Java python C plus
plus so this concept of building an
object and then that object then is
inherited by everything underneath of it
is important to understand even in these
most even as we're looking at more
specific cases
so we'll take a look at the components
of inheritance
and the most important two components in
inheritance the two major components
that are mentioned are parent class or
the superclass in the child class or the
subclass
and to see this let's go ahead and jump
into eclipse and take a look at what the
actual code looks like
so the first thing I want to do is go
ahead and add in a new package
and we're going to go ahead and call
this package
inheritance because that's what we're
working with
oops
give me a default Java tutorial in there
inheritance finish and I started off
with the Java tutorials just a um
went in and created a new project and
made sure it was Java based
so we have our package inheritance right
here we're going to go ahead and add in
a new class
and we'll go ahead and call this class
machine
now one of the standards when you're
creating classes to capitalize the first
letter so always remember to do that in
some places people like to have the
whole word capitalized it really depends
on who you're working with but it is
kind of if it starts with a capital
letter it's probably a class
and so once we have our inheritance we
have our public class machine
let's go ahead and give it a little bit
underneath there to do something and
we'll start with
um
uh protected
string brand
and so whatever machine we're working
with these particular machines are going
to be we'll call them it'll be a Samsung
free
they get some free vocab free marketing
right there for Samsung
so Samsung machines
and then we wanted to do something so
let's go ahead and put a procedure in
there I'll make it public
Voyage it's not going to return anything
and we'll call this uh wash I guess
they're all washed machines
there we go there's our brackets a
little trouble finding the bracket on
there and let's just have it uh during
this we'll just have it do a Quick Print
line
and we'll say um
initiating
cycle
there and then of course our semicolon
on the end
all right so now we have a public class
machine and we're going to get into
where we start working with the actual
inheritance you can create an object
with this machine we haven't done
anything special to it it's like any
other class you might create in the Java
language and we've added in public void
wash a procedure with no return that's
what the void means and it's going to
print out and so let's go ahead and
create another class in here new class
and this one's going to be washing
machine
washing
machine
and uh
we'll go ahead and hit finish on here
and we come into our washing machine
it's opened up a nice new tab for us
might have a private string model name
and we'll change this to model type
model type equals
so the type of machine is is a top load
washing machine
so we have a Samsung as a main type of
machines we're looking at we have top
loader or top loading washing machine
and then we're going to add up here
extends
machine
and so this is the the key code we're
going to look for because we want this
to have the properties of the machine
so this comes in and says whatever is in
machine we now also have in our washing
machine
and then of course if you're going to do
all this we need to actually be able to
run it and if we're going to do that we
want to go ahead and add in the public
static
void main reserved keywords there and
this is just your standard main startup
you have your string of arguments
and of course our bracket and then in
here
we're going to take and create a washing
machine object
and so here's our wash machine
let's of course the type washing machine
and it's going to equal a new
washing machine so we're initiating a
new object in here there we go
and then we want to do something
and if we're going to have it do
something we wanted to go ahead let's
see what happens we have wash remember
our keyword up there was washing machine
Dot wash
and where did that come from well if we
go back into machine
here it is public void wash there's the
procedure and it's coming into the
washing machine and this is inherited
that way we don't have to retype that
every time we have a washing machine
this could be washing machine
uh maybe the next one is I don't know
different kind of washing machines I'm
not an expert on washing machines
we have to do a wash
and then specific to the washing machine
in here
we also had uh the type and so we can
come back up here or brand
so we can come up down here we can go
system
dot print line
wash machine Dot
brand
Plus
I'll put a little Dash in there
Plus
and then we're going to go ahead and we
have our wash
machine
dot model type
that model type we put in there so the
brand where does the brand come from the
Brand's coming from our machine we have
our protected string which is going to
be Samsung
and then we have our washing machine
which has the model type which is a top
load machine and if we go ahead and run
this
after of course we make sure we have
that semicolon in on the end there
we come up there we'll see initiating
cycle initiating cycle is printed out
from machine and then the Samsung top
load washing machine is the second
printout line here
and so when we have our wash print out
here also the wash machine wash this
initiating cycle and then we have that's
where that printout comes from we can go
back up here to machine you can see
right here initiating cycle
and then we flip back over to the
washing machine we print out wash
machine.brand which is the machine class
and then wash machine dot model type
which is underneath the washing machine
so let's go over all that let's take a
look and see what we're talking about
here
so we saw in the code the extends
keyword the term extends is a pretty
defined keyword in Java that allows you
to create a new child class by deriving
the variables and methods from the
parent class to reduce code length and
improve the performance
and we see that right up here in our
public class washing machine extends
machine
so the next key thing to talk about is
access modifiers
and I kind of breezed over them when I
put together the code but we'll dig in
there a little deeper we talk about axis
modifiers there's four different words
you really need to know and that's
default
public protected and private
and I'm going to tell you right now
default equals public
so what is default default access
modifier is set implicitly whenever you
declare a class without a specific
access modifier by default the axis of a
class or method when declared without a
specific access modifier becomes
available to any other method or class
within the same package
and in Java the default is public so
public a certain class can be declared
as public by using the keyword public
any class or method when declared as
public becomes available to any class or
method declared in the same package but
if a different method or class needs it
it should be imported
and then we have protected certain
classes declared protected by using the
keyword protected this provides access
to the methods and variables of the
protected class only to the rightful
subclasses and protects the data from
any other classes which are not related
and then private a certain class is
declared protected by using the keyword
private this provides the ultimate
protection to the data members and the
methods of the private class this
procedure is implemented by class to
encapsulate the method and members
foreign so uh we'll take a a little
we're actually going to do a different
example in here but I do like this
underneath the washing machine
you can see right here we have put in
private a private string
what this means is that only washing
machine can access that private string
where if you have protected the children
can access it so protective screen if
you're underneath a machine up here we
have protected
so that when I create the washing
machine and extend machine I can still
access it but if I create a sub class of
washing machine in a market as private
that subclass is not going to be able to
access it and so it has to do with what
layers of accessing
think of this as a big team project you
create something do you really want that
to Cascade down to the next class or who
do you want to have access to that
let's go a little deeper to really bring
this home because it's really important
to understand these terminology let's go
ahead and start a new class here we're
just going to call this particular class
summation
and go ahead and create that finish
and so our summation class it's going to
be pretty simple in here we'll go ahead
and do uh
public
so anything but he can access it just
remember here's our public on there and
then we'll just do a integer because
that's what's going to return as an
integer we're going to call it add and
we're going to put integer X comma
integer y
and
then we'll just return X Plus y so real
simple we're just adding two numbers
here's our two inputs so both have to be
integers and we're going to return an
integer and it'll be the summation of
the two so real simple class right there
and if we're going to have a summation
and let's go ahead and create a new
class and we'll call this one child
and in our new child class
we're going to go ahead and keep this
simple and we're just going to have our
public static main we're going to have
our summation a equals new summation and
then system out print line a DOT add 100
plus 200.
pretty straightforward everything's
public in here oops okay there's our
running and we see the answer is 300.
so this is public if you remember
correctly we're talking about public
and so when we use the public keyword
any class or method when declared as
public becomes available to any class or
method declared in the same package
but if in a different method or class
needs it it should be imported
so here we go it's that's our public
setup it's just open to everybody well
everybody that's under the package
inheritance so whoever's using that
package can now use the this particular
child
and let's go ahead and add a new class
in and this time we're going to do a
parent class
I'll just put that right in there
and we come in with our parent class you
can see right here the parent class
itself is public but we want to do
underneath the parent class is we want
to create a protected
void because we're not returning
anything and print so we're going to do
the print there and this protected print
let's go and put our brackets in there
and we'll do just a simple uh print line
hello world
and once we have that print hello world
we want to go ahead and add a child
class to this
and let's see we already well we had the
child class when it took it out a second
ago so we'll go ahead and put that back
in uh here's our child class
and before this childhood class we
wanted to go ahead and extend the parent
so inheritance there's our extend on
there oops let me retype that
all right extends parent so now the
chalk class is part of the parent class
and we'll go ahead and put our main in
there so that it will run it and execute
it and we'll create our child X
equals new
child class
go ahead and assign our variable X and
initiate it and then we'll do just the
print and see what happens here so
here's our print statement
and we'll go ahead and run this and
compile our child on there and when it
comes in there you see it says print
hello world and so the parent
has marked this as protected so it's
protected from objects that are not
inheriting it but the child can still
access that information and print it on
there
so here's protected this provides access
to methods and variables of the
protected class only to the rightful
subclasses and protects the data from
any other classes which are not related
and a lot of programming that's usually
where you end up is doing a lot of stuff
that is underneath your parent
that is protected you either make them
public or protected a lot of people are
sloppy and just make them public but
most of the stuff you want to make sure
it's uh protected and then we finally
have our private and I'm going to go
back here to our child and we're going
to run this
and it's going to come up and say
proceed with launch errors in setup and
then it's going to give us an exception
thread Main
compilation error the method print from
the type parent is not visible and
that's because unless you actually
initiate the parent you're not going to
see this code because it's private it's
only private to the public to the parent
class so even if I extend it in child
it will not be available and that again
protects it that means it's something
that you don't want to inherit and
Cascade down because maybe it is a piece
of code that is going to be changed and
so you don't want all the children to
crash every time you make a change to it
so with private this provides the
ultimate protection to the data members
and the methods of the private class
this procedure is implemented by class
to encapsulate the methods and members
so very important we have private and we
have protected and we have public the
more access you want other pieces of the
software code to have and other
programmers to have the more public you
want to make it and of course the
default is public
now one of the common workarounds for
this because you're going to have
protected data but you still want it to
be used by the subclasses is to create
what they call like a get or a and we'll
do it up here we'll go ahead and do a
private
integer x equals five
and then instead of on your inheritance
instead of having it uh call it from
the child we might have a get thing or a
get thing we might have a public
going to return an integer and we might
have it say get X
and this simply just return X
and what this means is that we have
something simple like this where it just
doesn't return X I can go back into my
child here
and instead of print X we'll do x dot
get X
and we'll go ahead and print this out
or you know something simple with that
we'll go ahead and do a
system print line on this
and when we run this
you'll see it come up it's going to
recompile and we get our five What's
Happening Here is now I've created
underneath the parent
private information you don't know
what's going on with it it's protected
you might have a procedure that's
protected in this case we had the print
procedure and then we access it from the
public and this could have easily have
been instead of maybe we'll just call it
public
void
public print
kind of a goofy way of doing the code
there we go and then it could go in here
and access our print
and so we can actually still access this
print variable up here by wrapping it in
kind of a git or a public function this
allows us to protect whatever code is
going on in the parent class so it can't
be messed up it can't be accessed
indirectly it has to go through the
right processes and so when we get to
the child on here the child can then
still has the public processes but all
the other information isn't is protected
and is private it's really important to
remember that private right there
this brings us to Super keyword
and we talk about the super keyword uh
super keyword eliminates the confusion
between parent class method and subclass
method
super keyword is implemented to access a
method or Constructor that is defined in
the parent class
so back in Eclipse we'll go under parent
and we'll take this we're going to take
the private out of there so now we have
an integer five
and we'll go ahead and just remove the
print because we're not going to do that
in the parent
whoops and the public
there we go
and so let's create a parent that just
has one piece of information it has an
integer x equals five
and then we're going to go to the child
and let's go ahead and add in here
integer x equals 10. and these are by
default they're public we haven't set
anything on here telling it what it is
and so what I'd like to do is we'd like
to go ahead and create a
oops one more thing there we go create a
procedure here
and we'll just call this void Capital
print this is going to be a system out
print line and this is what I want you
to notice is we're going to print out X
and Super X so we have the child class X
and we have the parent class Super X and
if we come down here
and we do X
Dot
print
don't forget my semicolon
add a couple spaces in here to make it
look nicer when we print it and we'll go
ahead and run this and you can see that
the child class prints 10 and the parent
class is five and so this way you can
actually store different information
depending on what it is you're working
on and what you're doing and that's
where this super comes in you can see
right here where the super
underneath the class and the print
module now you can't just put it in down
here under print
let me explore what that looks like if I
just take this and go ahead and
highlight it
and let's say I want to do just instead
of doing X print
it's going to come up right here right
off the bat you see the super dot X I
can do x dot super dot X and it's still
going to give me an error right here it
has to be underneath a procedure in the
actual class and not under the main
this brings us to types of inheritance
and there's four main types we have
single inheritance which we've already
pretty much looked at but we'll go back
over we have multi-level inheritance we
have hierarchical inheritance and Hybrid
inheritance
let's go ahead and just start with the
single inheritance single inheritance
consists of one parent class and one
child class here child class inherits
parent class methods and data members
and let's go ahead and create a new
class up here just to change it up and
keep an interesting new
class and we'll call this one student
and under the student
we'll have a simple setup we'll just do
an enrolled and it'll say enrolled in
simply learned there we go so there's
our class student and then we'll create
another class uh we'll do it as a
because we have our student our base
student and then we'll call this one
new
class
I will call this one uh computers there
we go so he's a rolled finish and for
computers let's go ahead and put in a
print line here and we'll put down
studying
computers
and we want to go ahead and do the
extends extends
student so it's a student studying
computer subclass computers and this
would all look familiar because we've
been doing this for you know a lot of
the other setups this is your basic
inheritance
um and we'll change that from enrolled
to studies
and then let's go ahead and put a main
in here so we can actually run it and we
have our P enrolled which comes from our
parent class and our P studies which
comes from the child or the one that
inheritance it the extends for student
and let's go ahead and run that there we
go run
and you can say enrolled in simply
learned studying computers
and then we can go on to the next setup
and this is where we look at multi-level
inheritance there's also apparent child
inheritance relation but the difference
is the child class is inherited by
another child class
this is the basic structure of most
programming languages right here you
have an object you have all the
different things under the object and it
gets all the way down to whether it's an
array you're working with whether even a
class is a sub-child that goes all the
way up to the object and we can simply
do that in our code in the eclipse
and we'll just go ahead and add a new
class in there we'll call this one uh
Java there we go
oops Java and under Java we want to go
ahead and
oh create some of the similar stuff and
then I want to go back to my student I
took out the main and student just
because I don't want it to run the main
in there
and in here we're going to have system
out
we have instead of studying computers
Focus
on Java which is what we're doing right
now
and maybe we'll call this classroom and
then we can come down here we have our P
equals new computers well instead of new
computers we want our Java
and it's going to be a Java object
and we need to put our extends in up
here
extends in this case we came from
computers
so there's our initial thing and then we
have our last print in here
and of course if we run this now we'll
see that it should if I did everything
correctly come up and say enrolled in
simply learn studying computers focus on
Java and we have the enrolled which is
the parent to computers and then we have
under computers well we have a student
in computers and then Java and so each
one of these classes just Cascades all
the way down and this is your
multi-level from your class A to class b
to class C
and if you can have multi-level
inheritance we can also have a higher
archaeal inheritance where your
parent-child relationship the only
difference is here are multiple child
classes inherit from one parent class
and that is pretty uh we'll do another
class here if you remember correctly we
had student computers maybe from student
we'll have a set of computers we'll have
project management
project
management so you're studying your idol
and all your other classes in there for
Cascade and for doing agile programming
and in here we can do that it's just the
same as we did before we just have a
second child coming in from here and so
this would go ahead and extend extends
extends
student
and of course whatever subcategory you
have one in here for running this
and so for here we'd have like our void
studies in this case instead of studying
computers we're studying project
management project
management one of the other wonderful
classes it is taught from the simply
learned team
and we'll go and run that and you can
see right here we have computers oops of
course uh
instead of computers I meant to do
project
management there we go and we have to
also initiate it as a new
and then when we run here we can see
this we're enrolled in simply learn and
we're studying project management
and then finally there is the um the
hybrid the name itself explains it to us
the Hybrid inheritance can be a
combination of any of the three types of
inheritance supported in Java and so
maybe we already saw that because we
have our a and our B
if we flip back on over to our
Eclipse we have our student our student
now has a computers project management
so there's our um hierarchical and then
they're mixed because we also have the
Java which is an extension of the
computer and so we have multiple layers
there
so one of the issues that comes up with
inheritance in classes is what they call
the diamond problem
and in the diamond problem the Java
programming language does not support
multiple inheritance as it ends up with
serious ambiguity
and that is where we have D which
inherits from both B and C which might
both inherit from a
uh this is the Daemon Factor because as
you start tracking your supers going up
which one are you actually looking at B
or C or a and that's why they call this
a diamond problem it comes up more than
you would think you get very complicated
structures and you realize oh I need to
have both sets of instructions come down
to whatever I'm working on and you can
see where that can become a problem
let us take a look at is a relation and
has a relation now these I mean they're
vocabulary but they're more of a concept
understanding how things fit together
and so we talk about is a relation when
a class inherits methods and members
from a different class then the
relationship is said to be is a relation
examples orange is a fruit
and oh let's just jump back on over here
and we'll make a
new
class and we'll call this class customer
so we're going to have our customers
oops
there we go if I can remember how to
type so we have a class customer and we
have gone ahead and our team in the back
went ahead and prepped this for us let's
just take a quick look though we got
public string names so it's accessed
publicly if you leave this out it'll
automatically be public because that's
the default and then we have our
customer and the string which is a name
and a string is a city and then when you
do a customer and you send it the name
of the city it will do this name equals
name and this city equals City we could
have easily done this private we have a
call into it to create it so it wouldn't
really matter too much whether we did it
private or public I would actually be
more likely to do it private
and for this example we'll go ahead and
create another class and we'll call this
store
we'll have our store class we have
customers and we have a store
and then we'll go ahead and
set up in here and this time we did do a
private we're going to create a list of
customer customers and then the store
list coming down and then this customer
customers and public list customers
a quick look at this is we did make this
one private which is nice because now it
can't be accessed externally except from
store and then the store has the public
list customers so we can send it a list
of customers and then it go ahead and
Returns the customers from that list and
then we add it to the store it sets the
customers in the store this customers
equals customers
one of the reasons we have the airlines
in here is I haven't compiled it so it
doesn't see the customers are part of
our package
and we'll get to that in just a moment
here
and then let's go ahead and create
another class we'll call this is a
relation
since that's what we're working on
and here's there is a relation setup
and we're just going to put this as the
main so you have your main in there and
then we went ahead and prepared a series
of customers
and we'll just call that customer C1
equals a new customer customer C2 equals
a new customer and we're just creating a
list here that's all we're doing
and if we're going to have a list then
we need to go ahead and create a list of
customers
and we'll just do that with a simple
list setup
and then we got to add those customers
into the list so let's go ahead and do
that
so breaking this down we have a customer
one which is reshu Bangalore Shiva
hyperbad Sachin Mumbai and so on and
then we just created a list of customers
a new array of lists and then we add in
each of those customers so now we have a
nice list of all our different customers
in here and then we want to go ahead and
create our store
and we'll put in store and it'll be a
fruit smoothies franchise I put down
fruit smoothies French
maybe that's not a good abbreviation
because you might think it's a French
instead of franchise there'll be a new
store and then we have our new store
which is
um in this case we're going to put in
that new store customers and if you
remember we went back here into store
let me just flip back on over there
it's going to take that list of
customers
and put that into this customer so now
the private list is going to equal that
list of customers
and then of course we can come in here
and we do public list it's going to
return that list of customers so we have
public assets here and this door you can
add public at the beginning
we'll go ahead and do that just to make
it clear is it public is what's going to
run on there and let's go back into our
is a relation
and I hope the back to store I'm going
to go ahead and just change this to
customer list so here's our list
customer list and it's going to return
the customers from this selection from
our private variable
uh so we come into here
we can come down here and we'll go ahead
and put that in there we'll do a loop on
this we'll have a list customer and
we're going to create a list of our
customers from our fruit smoothies
franchise and we'll get the customer
list from there and then for a customer
in the um in our four customer CST in
customer
we're going to go ahead and just print
that name out there
now at this point if you have an error
showing up here under list and also
underneath the arraylist depending on
how you did your install you may have to
go ahead and import those your arraylist
from your Java utility not a big deal
and then once we go ahead and we have
this all set up
you'll see here the compiler goes
through and then we have the name of the
customer City and then it just lists the
customers going down here
so when we talk about our relationship
of our fruit smoothies franchise and
customers the customers they are a
relationship directly to the French
smoothies franchise
now the second idea is it has a relation
and let's go ahead and take a look at
that and see how that differs
and we'll go ahead and create a um oh
let's see we had customers so let's do
um
and we'll call this one
um we're doing with smoothies so we'll
have
flavors our favorite we'll do favorite
flavors favorite
flavors for class very strange class
and the Sea and favorite flavors we'll
go ahead and give it a couple things to
look at we'll have a private
string and a name
and then we'll have a public
string
um
get flavor
there we go and that's just going to
return
we'll just have that return the name of
the flavor
there we go and then we want to go ahead
and create
one more class and this class will call
Hazard relation
and I'm hoping you're guessing where
we're going with this let's go and put
some code in here to make it work
and let's go back to our favorite
flavors and put in a Constructor so that
we can load the flavors and then I
return this name so we can return the
flavors we'll go back into hazard
relation
and let's just create a customer we'll
call it cust our new customers Toby
Marshall from Mumbai and our favorite
flavors are strawberry banana and peanut
butter I don't know it's a strange
concoction
and then we run a print line we're going
to print the customer name from
customers and the flavors get flavor
and so when we're looking at this what I
want you to be aware of is that neither
the flavors nor the customer are in the
same class they're not it's not an
actual relationship but they have a
relationship because we have Toby who
happens to like strawberry and peanut
butter
and if you remember just a quick note we
were looking at the diamond problem you
can create a class that then has these
two subclasses in and that's how you go
around the diamond problem is you don't
inherit but you create classes inside
the class you're working with
what is polymorphism according to
chemistry the term polymorphism can be
defined as the ability of any element or
compound to exist in multiple
crystalline forms this is called
polymorphism for example if you have the
carbon atom it can come out in different
forms in Coal graphite and diamond
what is polymorphism in Java similarly
in the terms of Java programming
language polymorphism is defined as the
ability of any object in class in a
class to perform a particular task in
multiple methods this is known as
polymorphism in Java we're going to open
up our Eclipse editor and we're going to
do some animal sounds with cows cats and
dogs just kind of a fun almost kids like
example of polymorphism and you can see
I already have my inheritance in here
let's go ahead and create a new
package and we'll call this polymorphism
just to keep it simple
and once we have our polymorphism in
there we're going to go ahead and add a
class in
and if you were doing
um an abstract class we could live with
those abstracts we're not going to
directly access it and we'll call it
animal sounds maybe we will we'll see
how we load the program up but we'll
call this animal sounds
and let's create a public it's not going
to return anything but we'll call it
sound
on here and we just want to go ahead and
have it do a system out print
with our system out print line we'll
just have it say animals make
different sounds
there we go
so yeah it's really simple and
straightforward we're just gonna have it
print something out
and if we're going to do that let's go
ahead and just a good thing I didn't
make it abstract let's go ahead and just
test it out and see what it looks like
and we'll do oh we'll call it animal
Main Animal Main
and in here let's go ahead and test out
what we just put together uh we'll do
our our static void main so it's going
to run on here and we'll create our
animal
sounds
we'll call it animal because we don't
know what kind of animal this is we'll
call it new animal
sounds
and we'll just take that animal and I
like to
put it in capitalize but usually like
this lowercase there we go
and we'll just have our
animal
uh Dot
sound
and let's go ahead and run this and see
what comes out
we can see here animals make different
sounds okay that's not too exciting uh
so let's jump in there and let's say we
have in this case we're going to add in
a couple of different animals We'll add
in a
oh let's start with a cow you know why
not a cow
so we'll have our cow in here we'll go
ahead and click ok
and now we have our cow class but a cow
doesn't just it makes different noises
but it actually
makes this you know a very clear noise
so we'll go ahead and give the cow a
sound
and we'll have the cow say moo moo and
the cow is going to
extend
there's our
and we'll put in our extends animal
sounds and then I want to go back here
to our animal Main
and now we have a class cow so in our
animal main we want to do a cow
equals new
cow
and once we've created the new cow we
also need to go ahead and have the cow
sounds
there we go and we run this
you can see it comes out here and it
says the cow says moo moo so if we go
back to Cal we're just going to do this
real quick and let's say we just take
this out of here the public void sound
and then we're going to go into our
animal Main and run that
recompiles animals make different sounds
because it doesn't know what sound a cow
makes
so this is really Central to
polymorphism is we're taking something
going on in the
in one setup that we've brought in and
extended from our animal sounds and
we've changed it to the cow says moo moo
and we can also add in multiple animals
in here we'll go ahead and just add in
one more animal we'll call this one
we'll do a dog why not
uh so here comes in our dog
and of course we want the dog to
actually say something
and we'll have the dog go Bow Wow and
then we'll go back to our animal main we
have to create a dog
and we'll say cow
simply dog dog uppercase for the class
lowercase for the actual object
and then of course we need the dog to
make a sound so we'll go down here and
go dog Dot
sound
and when we run this as you expect the
it's going to compile it there we go
animals make a different sounds a cow
says moo moo the dog says Bow Wow
characteristics of polymorphism the
functionality of a method behaves
differently in different situations the
behavior of a method is dependent on the
data polymorphism is mainly used to
implement inheritance as we saw we did
the extends with the animal sounds
polymorphism is mainly used to implement
inheritance it allows same name for a
member of method in a class with
different types which will cover briefly
in a minute polymorphism supports
implicit type conversion
types of polymorphism there are
basically two types of polymorphism that
can be occurred in Java programming
language they are mentioned as follows
compile time polymorphism runtime
polymorphism compile time polymorphism
gets executed during the compilation
stage here the overloading method gets
resolved in compilation stage so when
you saw me run those in eclipse and it
went through the compile time thus
looking at all the different changes we
made to those classes that's what we're
talking about here is during compile
time in method overloading in Java the
process of method overloading is
achieved when a class has two or more
methods with same name but the specific
method is selected based on the number
of parameters declared we'll now execute
a program based on the functionality of
additional operator in a different
situation and let's flip back on over to
our Eclipse so in here I'm going to go
back under the dog and let me just
highlight this
and we're going to do the same thing so
you see right here it says public void
sound so this is identical public void
sound but instead of sending uh nothing
we're going to send it a string we're
going to call it Angry now at this point
you should note that what if it's a
happy dot I would have to add an if then
if the string angry said happy then we'd
print happy or something else but we're
just keeping it simple so we've entered
another sound identical to the first but
we've added string angry to it and this
one's going to print out the dog says
growl growl now if we go back to our
animal Main
and here's our dog same dog same sound
but now we're going to add a string in
here
and we put that string in here we'll go
ahead and just call it Angry it doesn't
really matter what string you put in
here because we haven't sorted out what
the string means for now it just says
growl growl it's going to recompile it
so remember this is a polymorphism
during compile time and here we have it
the dog says growl growl so duck says
Bow Wow and then the angry dog says
growl growl so there's another thing
called Operator overloading Operator
overloading is not supported in Java
authors of java wanted to keep the
language less complicated explaining
operator overloading it basically is a
way of bundling operations into the call
statement and user procedures it's so
that it looks like a math on a paper you
have a plus add B plus C kind of thing
and it's all wrapped up in your call to
another statement this just gets
confusing it really isn't necessary so
the driver developers decided not to put
it in there so runtime polymorphism in
Java programming language runtime
polymorphism gets handled during the
program execution stage here the
overriding method gets resolved in
execution
so far we've talked about compile time
polymorphism as you saw in the program
we just wrote when it's compiling it
does the extend and figures out which
overload method to use on there
in runtime polymorphism method
overriding in Java the method overriding
is a procedure where trial class is
allowed to implement a specific class
that is already provided in the parent
class
for runtime compilation code or
polymorphism we need to go introduce the
super keyword now from inheritance you
should remember that we can look at
Super from before but we're going to use
it slightly different it's kind of doing
the same thing as when we did The
Inheritance but we're doing like what
they call an override during run time so
the term super is predefined keyword in
Java that is used to refer the immediate
parent class object or method defined in
the program in this procedure whenever
you create an instance of subclass then
automatically an instance a parent class
is also created that will be implicitly
referred by the super reference variable
so going back into our animal sounds
let's go in here to dog
and if we add a super Dot
sound
in here this is going to reference
whatever our extend is because we
extends the dog extends animal sounds
and so here's our super dot sound and if
we go ahead and apple run and compile
this
and you can see here that it comes down
and says the dog says growl growl
because that's what we had it system out
print line two and then the super
animals make different sounds and so if
we go back to our animal main this is
what it's calling right here it's going
back into sound under the animal Mains
and it's printing out or doing whatever
it does here at this point we usually
have it return something so you can look
up whatever the original class was using
so getting back to these two setups
whether you're using the super to use a
runtime polymorphism because that's
what's happening during run time versus
compile time polymorphism during compile
time polymorphism method call is handled
by the compiler itself so the program
maybe take a second more to compile but
it runs faster in the run time the
method call cannot be handled by
compiler in the execution stage so if
you have any errors it's not going to
show up either during the compile time
we have compile time polymorphism is
less flexible as it needs handle all
method calls in compile time so you
really in runtime polymorphism your it
exhibits higher flexibility as a method
call gets handled at runtime coming in
the execution period for compile time
polymorphism is less that's what I was
just talking about it compiles it so the
compiling takes maybe a little bit more
but if you're executing the same program
over and over and over again once it's
distributed it's going to run faster
then of course with the runtime
polymorphism the execution period for
runtime polymorphism takes longer it's
just a little bit more usually in most
programs you don't notice this but if
you're executing the same script A
Thousand Times suddenly that 0.01 second
is a lot more it suddenly is adding up a
second each time it goes through the
Thousand iterations uh then with the
compile time polymorphism integrating
the right method call with the right
method is done in compile time and of
course in runtime integrating the right
method call with the right method is
done in runtime again that's another
delay because it has to figure out what
it's doing it's not already pre-mapped
out and finally compile time
polymorphism occurs during method
overloading and operator overloading
where runtime polymorphism occurs during
the method overwriting advantages of
polymorphism programmers code can be
reused via polymorphism number one goal
of a programmer is to reuse the code as
much as possible so you're not
Reinventing the will over and over again
advantages of polymorphism supports
single variable name for multiple data
types reduces coupling between different
functionalities
and some of the disadvantages of
polymorphism that can come up is that
polymorphism ends up raising performance
issues in real time you can see whereas
you're loading all these different
things you might end up creating Loops
you didn't know you were doing
polymorphism reduces readability of the
code sometimes your actual code
everything you look at in Java is
polymorphism all based on a primary
object so you could have a very
complicated setup and then it actually
is very easy to read when you actually
put your final variable in there but
when you're going through lines and
lines of code it can be really hard to
figure out what's going on as you Loop
through all these different inherited
modules or classes programmers find
polymorphism difficult to implement just
depends the more you use it the easier
it is now let's quickly begin with our
session first of all
we will discuss the right angle triangle
pattern
so basically the right angle triangle
star pattern looks something like this
as it is shown on my screen
so to resolve this problem statement and
print the pattern we must assume that
this particular star Arrangement is made
in the form of a matrix where the first
row has single star and the second row
has two stars third row has three stars
and so on now to execute this particular
code we might need two for Loops so the
first for Loop will be for printing the
rows and the second one will be for
printing The Columns now let us execute
a practical program and see how does it
work don't worry about the codes that we
will be executing here because I have
formatted a draft about all the codes
that I will be executing today and that
particular file will be attached in the
description box below
on my screen you can see the particular
pattern which is a right angle triangle
star pattern so as discussed before we
will have the first outer for Loop which
will be for printing the rows so inside
the outer for Loop we have the second
for Loop which we will be using for
printing the columns you can see I have
defined the row value as 5 which means
we will be printing the star pattern for
five rows
and we have used a counter variable
which is I which is assigned the value
of 1 and the comparator operator is used
here which is I should be less than or
equal to the number of rows declared and
followed by that we have a pre-increment
operator and once the condition is true
the control will be entered into the
second for Loop where we have the next
counter variable which is J so we have
assigned J is equals to 1 and the
comparator operator which is J should be
less than or equal to I which is the
value here which is in the outer for
Loop and followed by that we have the
pre-increment operator once the
condition is true the control will enter
into the inside for Loop and will print
a star
so here just let us assume that the
value of I is 1 and the statement is
true so the control will enter into the
second for Loop and it will see the
conditional operator here so J is less
than or equal to I so value of 1 is less
than or equal to 1 and the star will be
printed after that we have the free
increment operator so here the J value
will be incremented to 2. now if you
compare the values 2 is not less than or
not equal to 1 so the condition fails
here so it will not print a star again
it will come out of the inner for Loop
and it will see the next statement which
says it should print in the next line
whereas in the inside for Loop you can
see we just used print not print in the
new line
so it will come to the new line and go
back to the for loop again and the
increment of I will be taken place and
the same runs again now let us try to
execute this program and see the output
so you can see that the program got
successfully executed and the right
angle triangle star pattern is print
successfully now let us go into the next
type of program
so the next type of program is the
inverted right angle triangle star
pattern so similarly according to the
previous example we also consider this
one in the form of a matrix so you can
see that in the first row we have 5
stars in the second row we have four
stars similarly so on now let us try to
check out the code and learn how does it
work and how to print the star pattern
on our screen
we are back in the Practical mode again
so the kind of pattern that we wanted to
print as this one which is a little bit
similar to the previous one but only
thing it is inverted so the code is
pretty much the same but the only
changes that we need to do are related
to the comparator operator in the
previous example we chose that I should
be less than or equal to 1 and in the
next stage we used free increment
operator in here we are using a
different one which is pretty decrement
and inside the for Loop we have the J
comparator operator in the same way so
here we have declared the row value as 5
and inside the for Loop we will equate
the counter variable equals to rows
which is 5 and followed by that the
comparator operator Compares if the
value of Phi is greater than or equal to
1 and followed by that we will use the
predecrement operator once the condition
is true the control will enter into the
inside follow and here the counter
variable J is assigned to the value 1
and the condition is J should be less
than or equal to I and followed by that
we have the pre-increment operator which
is plus plus J so once the condition is
true it will print the value of a star
and followed by that it will again
continue the loop so here the follow
will work in the following way and I is
equals to 5 I is greater than or equal
to 1 which is true and predecrement so
the condition is true so the control
will enter into the inside for Loop
where it will again compare with value
of J J is equals to 1 and J is less than
or equal to 5 and followed by that we
have the post increment so the control
will enter inside the for Loop and print
a star and followed by that in the next
instance the value of J will be
incremented to 2 so 2 is less than or
equal to I followed by that pre
increment and in the next iteration it
will print as star again so this will
continue until the condition is true
once the condition fails the control
will exit the for Loop and Print in the
next line you can see that we have print
in the new line here which is unlike the
print function which is inside the
volume so this will continue until the
statements are true now let us try to
execute this program and see if the
desired pattern will be printing or not
that you can see that the program got
successfully executed and the pattern
which we decide for is printed on the
screen
now let us move ahead into the next type
of pattern
so the next type of pattern is the arrow
shaped pattern and this almost looks
familiar to the previous two programs
the only difference is we have combined
them together to form an arrow pattern
now let us try to combine the previous
two programs and print this
so now you can see on my screen we have
our desired pattern which looks like an
arrow so as discussed before we are
trying to combine the two programs that
we executed before so the first half of
the program is designed for the first
half of the pattern which is completely
similar to our first program so the
second half of the pattern is from our
second program but the only difference
here is we have considered the value of
rows is rho minus 1 because we don't
want another extra row to be printing
here in this way so you can see if we
used I value is equals to rows then the
pattern would be something like this we
will not have a pointed Edge so to get a
pointed Edge we will use rho minus 1 to
get this pattern what we desired for
now let us try to execute this program
and print the output
now let us enter the number of rows we
want let's enter 5.
so there you go let me expand my output
screen yeah there you go we have the
pattern which we desired for
and don't forget that we need to use row
minus 1 in the next stage which is the
second half of the program
so this is how the arrow pattern is
printed now let us move further and see
the next type of pattern in our list so
in the next pattern we have the right
angle triangle which is completely
similar to the first one but the
hypotenuse is on the other side
as you can see this is the difference
between the first program and this
program so in the first program we had
the hypotenuse in this direction and now
we have the hypotenuse in the opposite
direction now similarly to the first
program we shall consider this one as
well in the form of a matrix so you can
see if we consider this pattern in the
form of a matrix we have four spaces
followed by a star similarly in the
second row we have three spaces followed
by two stars in the third one we have
two spaces and three stars and so on so
the main point that we need to consider
here is first we need to print the
spaces followed by that we need to print
the Stars to get this pattern now let us
execute a practical program and see the
output so back in the Practical mode you
can see on my screen the desired pattern
what we are looking for is this
so here the only difference is
we have to print the spaces first
so for printing the spaces we will be
using this for loop with the condition J
is equals to 2 into n minus I and J
should be greater than or equals to 0
and J decrement which is a post
decrement operator so what is the value
of n n is nothing but the value of rows
so the value of n is declared in the
main function and N is equals to 5 after
that we will be calling the print Stars
function which is over here and the
value of n will be carried over here and
then the counter variables I and J will
take care of the for Loops now let us
try to execute this program and see the
output
so you can see that the program has
successfully executed and the desired
pattern is printed successfully so this
for Loop will be run until the condition
is true once this follow fails we will
enter into the next for Loop which is
particularly designed to print the Stars
now after this let us move ahead into
our next type of pattern
so the next type of pattern is an
inverted right angle triangle pattern
which is opposite to the second type of
program that we dealt with
now similarly let us consider this in
the same way as we considered all the
other programs that is in the form of a
matrix so here we have five stars in the
first row four stars in the next one and
one space followed by that we have two
spaces followed by that we have the
three stars and three spaces two stars
and so on now let us see a practical
program and try to print this particular
pattern
so we are back in the Practical mode so
you can see that the desired star
pattern is this and it is completely
similar to our previous pattern
so the only difference is we try to
print spaces first in the earlier
pattern and here we are trying to print
the Stars first so that's the only
difference
and we have the same for Loops so the
first for Loop is for rows and it will
print spaces and the second for Loop is
for stars which will print the stars as
you can see we have the row values and
the column values here as the comparator
operator and we have the comparator
operator which finds if J is greater
than I in the first case
the loop will fail because the value of
J and I are completely similar because
we have declared I is equals to rows in
the first outer for Loop and same J is
equals to rows in the second inner for
Loop so obviously the condition has to
fail and it will not print any space
here it will directly enter into the
next for Loop and will print the star
pattern and followed by that we will
enter into the next line so this
follow-up will print the number of stars
in the first row according to the row
number for example if we give 5 as the
row number then it will print 5 stars in
the first row and it will exit the for
Loop and it will enter into the next
line and the same pattern will be
continued now let us try to execute this
program and see the output
now let us give 5 as the number of rows
needed
so there you go you can see the star
pattern here
so this is how this particular star
pattern will be generated
now let us move further and check out
the next type of pattern program in our
list so the next type of pattern program
in our list is Arrow
so this arrow is completely similar to
the previous one the only difference is
it is in the inverted way which is it is
pointed towards the left side now let us
check out the Practical program and
learn how to execute this
back onto Eclipse IDE so you can find
some similarities between the previous
two programs and this particular program
in the previous two programs we tried to
print the first half of the pattern and
followed by that we have printed the
second half of the pattern now we are
going to just combine both the programs
and print this particular Arrow pattern
so here the first half of this
particular program is concerned with the
top portion of this pattern which is the
right angle triangle followed by that
the second half of the program where we
have the conditions placed
so this particular segment of the code
takes care about the second half of the
program which is the inverted rectangle
triangle now let us try to execute this
program and see the output
so let us specify the number of rows as
five completely similar to the previous
two programs now let's press enter now
there you go let me expand my console
so there you go you can see the arrow
pattern
so this is how you print an arrow
pattern pointing towards the left side
we have also discussed an arrow pattern
where the arrow will be pointing towards
the right side as the program number
three
again don't worry about the codes all
the programs that I'm going to execute
in this session are drafted in the form
of a text document and that is linked in
the description box below you can take
that source file and practice the
programs for yourself don't worry
now let's move ahead and check out the
next type of program
so the next type of pattern that we have
in our list is the pyramid we also call
this an acute angled triangle star
pattern
now let us understand the logic for this
now you can see without the Matrix
format this looks completely similar to
our first program but only the
difference is we have a space which is
obvious but there is a small difference
let us check out what's the difference
is
if we look this program in the form of a
matrix you can see there are variations
in spaces in the first row we have two
spaces one star followed by that again
two spaces in the next row we have
alternate space and star space and star
and similarly in the third row we have a
star space star and space so this is how
the Matrix continues according to the
number of rows provided so let us
understand how the logic exactly works
for this program
okay so you can see the pattern that we
desired is in the form of an acute angle
triangle or pyramid now we have two
counter variables which is I is equals
to 0 in the outer for Loop and J is
equals to n minus 1 which is inside the
for Loop so the value of n is equals to
Phi which is the total number of rows
that we needed in our particular pattern
now you can see in the outer for Loop we
have the condition which is I should be
less than n so I should be less than the
number of rows which is equals to 5
followed by that we have the post
increment operator I plus plus so the
condition will be true because 0 is less
than 5 and it will enter into the inside
for Loop where we have J which is equals
to 5 minus 0.
followed by that we have the condition
so
5 is greater than 1. so the resultant of
this particular statement is 5 so 5
which is now the value of J is greater
than 1. followed by that we have the
post decrement operator which will
decrease the value of J in every
iteration so once the statement is true
it will try to print a space
so it will print the spaces until the
condition is true
so once the first for Loop fails the
control will enter into the next
following for Loop where we have J is
equals to 0 and J should be less than or
equal to the value of I which is
currently equals to 0
and followed by the conditional
statement we have the post increment
operator which is J plus plus so this
particular for Loop is used for printing
two things which is the first one star
followed by that we have a space so once
this follow gets executed the control
will exit it and will print in the new
line so this is how the program works
now let us try to execute this program
and see the odd
there you go the program got
successfully executed and the required
spaces and the stars have been printed
here so as you can see we have spaces
followed by that we have a star
similarly
space
is on to the left a star and the second
star
so followed by the previous program we
have the next program which is also
considered to be like a pyramid but the
only difference is it is in an inverted
format now let us check out the logic
behind this program and try to execute a
practical program so logic wise it's
completely similar to the previous one
we have star followed by that we have a
space and again a star space and a star
next row we have alternate space and
stuff and finally we have two spaces
star and two spaces so the number of
spaces and stars is based upon the
number of rows we provide now let us try
to execute a program and see the output
don't worry this is completely similar
to the previous one but the only
difference is it is printed in the
inverted fashion so there will be minor
changes to the code let's try to look on
those changes so here we are back in
Eclipse so the desired pattern is here
which is an inverted pyramid and the
premium program was a regular pyramid
so here is the logic and we have the
following for Loops so the first for
Loop is dedicated for printing the
number of spaces we require so inside
the exterior for Loop we have the
counter variable I is equals to 0 and I
should be less than or equals to the
number of rows minus 1 and followed by
that we have the post increment operator
I plus plus
so let us assume that we have provided
the number of rows to be 5 and according
to the logic I is equals to 0 and
followed by that 0 is less than or
equals to 5 minus 1 which is 4 and
followed by that we have the post
increment operator which will increment
the value of I to 1 once after the for
Loop first iteration is finished so once
the exterior follow condition is true
the control will enter into the second
for Loop which is the internal follow
and we have the second counter variable
which is J is equals to 0 followed by
that the comparator operator which says
J should be either less than or equal to
the value of I followed by that we have
the post increment operator on J so this
particular code segment or the first
part of the program takes care about the
number of spaces we require in our
pattern followed by that we have the
second for Loop which will take care of
the number of stars we print and the
number of spaces we require after the
star pattern
now let us try to execute this program
and see the output
now let us provide the number of rows we
need let's provide the value as 5. now
there you go according to the logic
provided in the program the star
patterns are successfully generated
followed by this basis
now moving ahead we have the next type
of pattern which is the combination of
first and second pyramids now let us
understand the logic and print this
pattern now you can see the desired
pattern is the combination of the first
pyramid and the second pyramid so the
first half of the program is derived
from the first pyramid pattern and the
second part of the program is derived
from the second pyramid pattern now we
have combined them together and now we
are trying to print the rhombus pattern
now let's try to execute this program
and see there
always provide the number of rows as
five
and there you go
so here you can see the desired star
pattern has been successfully executed
so according to the input we have the
first five rows and followed by that we
have the inverted star pattern where we
avoided the first row and printed the
following four rows
so that we have a proper Rubik's pattern
now moving ahead we shall see the next
type of pattern in our list so followed
by the previous pattern we have the next
type of pattern which looks completely
similar to the previous one but the only
difference is we have printed the second
type of pyramid first and then the first
type of pyramid which makes it look like
an hourglass now let us understand the
logic and print this pattern
so here is the desired pattern what we
are looking for and this was the
previous pattern what we printed
now followed by the first segment we
have the second segment which is
dedicated to print the second half of
the pattern which happens to be the
first type of pyramid which is a regular
pyramid but the only difference is
inside the first for Loop we are using
the rows minus one command because we
don't want
an extra star so if we add in an extra
star this pattern will look a little
abnormal so let us try so this is what
it looks like if we had an extra star
there so let us remove it
so this is how our pattern should look
like so that's the reason why we are
using row minus 1 here now let us try to
execute this program and see the output
now let us enter the number of rows we
want let us input 5.
and so there you go you can see the
program got successfully executed and
the desired star pattern has been
printed on the console now let us move
further and have a look on the next type
of pattern in our list so followed by
The Hourglass pattern we have the next
pattern where we need to print a
diagonal star pattern
now if we look at the logic it's just a
single line which is placed in the form
of a diagonal now let us check the logic
behind it
so you can see
we have printed stars in the form of a
diagonal of a matrix now we have the
first four spaces followed by that we
have a star and similarly three spaces
provided by a star then a space and so
on now to print this pattern what's the
logic let's go back to eclipse and try
to print this program
so this is our desired pattern now let
us go into our program
now inside the program we have two
counter variables which are one I two is
J so the first for Loop is I is equals
to 1 I is less than or is equals to 5
which is the row number then I post
increment
so when the logic is true which is 1 is
less than or equal to the row number
five the control will enter into the
second for Loop so once the control
enters into the outer for Loop we have
the second for Loop where we have our
second counter variable which is J J is
equals to 0 and J is less than 5 minus I
which is 5 minus 1 which is the current
value of I which is 4 so 0 is the value
of J currently so 0 is less than 4
followed by that we have the post
increment on J counter variable so once
the condition is true the control will
enter into the second inner for Loop and
will print space
so this Loop will run until the
condition is true once the condition
fails it will come out of the inner for
Loop and will print a star in the new
line
followed by that it will continue to
start the outer for loop again so this
is how the flow goes ahead now let's run
the program and see the output
so you can see the program got
successfully executed and the desired
pattern is printed now let's move ahead
and understand the next type of pattern
in our program
so the next type of pattern is a little
bit similar to the previous one so in
the previous pattern we had one diagonal
right now we have two diagonals which
have formed the shape of X so we can
consider this as an x pattern now let us
check out the logic and next after that
let's execute the program so according
to the logic when we consider this
particular pattern in a form of a matrix
we have the Stars printed in the first
row followed by that we have three
spaces and then again a star so this is
continue in the same way with alternate
spaces and in the third row we have a
single intersection point with one star
so this is how the pattern should look
like once the program gets executed now
let's check out the program and see the
output
so you can see on my output console this
was our previous pattern now what we are
going to do is make a similar pattern in
the opposite direction and make sure
they intersect each other now you can
see our program has two segments the
first segment and the second segment
they both look a little similar because
the first segment will print the upper
part of the pattern that is the first to
be and then the second segment will
print the lower part of the pattern
which is the inverted V now let us check
out the condition
we have the first outer loop which has
the first counter variable which is I is
equals to n n is nothing but the number
of rows that we want in our pattern then
I should be greater than or equal to 1
followed by that we have the post
decrement operator where we will
decrease the value of I
then if the condition is true then the
control will enter into the next
statement where we have the inner for
loop with second counter variable that
is J is equals to I then the condition
is J should be less than the value of
rows provided then post increment of J
and if the condition statement is true
then it will enter into the inner for
Loop and it will print a space similarly
for printing the star we have the next
segment inside the next segment the
condition is a little trickier because
we don't want to print any stars in The
Space Between the x pattern we provide
this condition where J is equals to 1
and J should be less than or equals to 2
times the value of I which is the outer
follow minus 1. if this condition is
true the control will enter inside the
for Loop where we have if else condition
if J is equal to is equals to 1 or J is
equals to is equals to 2 into I minus 1
then we should print a star else we
should print a space so this will print
the upper part of the pattern and
similarly we have another segment which
will print the lower part of the pattern
which is the inverted V pattern now
let's execute this program and see the
output
as you can see the program got executed
now let us provide the value of n let us
provide Phi and there you go you can see
that the program printed the desired
pattern so this is the first half of the
pattern which is the proper V then this
is the second half of the program which
is the inverted V so this is what the
flow of the program is now let us move
further and check out the next pattern
in our list
so the next part in our list is the
inverted V pattern
now let us check out the logic behind it
if you see this in the form of a matrix
then you can recognize this we had
already discussed similar program which
was the third one where we had printed
the pyramid shape but the only
difference is we have missed out the
star in between
which makes it look like a inverted V
now let us go back to eclipse and
execute a program based on this to print
this pattern as you can see we have our
desired pattern on my screen which is an
inverted V so if we check out the logic
we have outside Loop and inside loop so
we have two for Loops so the first outer
for Loop has out is equals to one out
should be less than or equals to the
number of row size then
post increment of outside variable
if the condition is true we enter into
the inner for Loop where we have inner
loop is equals to 1 inner loop should be
less than or equals to the row size into
2 then we have increment operator which
is a post increment so if this
particular condition is true then we
enter into another statement where we
have the if else statement so if in
value is equal to is equals to control X
or n is equals to print control y
then we should print stuff else we
should print a space now let us try to
execute this program and see the output
now let us provide the row size which is
5 so as you can see we have got our
desired pattern
now let us move ahead and execute the
next type of pattern which is the V
pattern now let us understand the logic
behind it
it is completely similar to the previous
program but the difference is the
pattern is in inverted position to the
previous one which is in the proper V
format so now let us try to check out
the code and execute the program and
print the pattern so on my screen you
can see the desired pattern what we are
looking for which is V now the previous
program was to print an inverted me so
the complete program is same but only
there is a minor change in the logic
where we have replaced I as greater than
or equals to 0.
and there is some change in the second
segment as well now let us try to
execute this program and see the output
so you can see the program got
successfully executed and the desired
pattern is printed here the value of n
or row size is equals to 5 which we have
declared here in the main part now let
us get back and check out the next
pattern to be executed in our list
so the next pattern is the combination
of both an inverted V and a normal V
which will result in the form of a
rhombus
now as you can see this is our previous
program now we have two segments in our
code where we have the first segment to
print the starting or the top position
which is an inverted view format and the
second segment of the code is designed
to print the second half of the pattern
which is the normal V pattern so we will
combine these two and print the rhombus
shape
now let me provide the number of rows
which is 5 so there you go you can see
the desired pattern now let us move
ahead and check out our next pattern so
the next pattern is completely similar
to one of the previous ones which is a
pyramid pattern but the difference is
this pyramid is hollow or in other words
this looks like an acute angle triangle
now let us understand the logic behind
it so if you look at this Matrix then
you can find that we are going to print
the stars in the form of a side of the
triangle which is we'll print the stars
in This shape of a triangle and nothing
inside the Matrix now let us understand
the program and print this pattern so as
you can see the desired pattern has been
located here which is a triangular
pattern now inside this we have three
particular for Loops so the first for
Loop is the outer for Loop and the rest
two for Loops are the internal for Loops
so the first internal for Loop is
dedicated to print spaces where we don't
require Stars and the second internal
for Loop is dedicated to print Stars
where we require them also we have NFL's
condition which decides where to print a
star and where not to now if we look at
the condition I should be less than or
equal to the number of rows provided and
if the condition is true then we enter
into the internal follow
and in the internal for Loop if J is
less than the number of rows given then
in that particular location we need to
print a space once the condition in the
first for Loop is failed the control
will enter into the next follow where we
have the next counter variable that is K
is equals to 1 and K should be less than
or equals to 2 into I minus 1 where the
value of I is 1 at the current stage
and followed by that we have the post
increment of the value of K if K is
equal to equal to 1 or I is equal to
equal to the number of nodes or k is
equal to equal to 2 Star I minus 1 then
we should print a star so this will give
the location in The Matrix where we
should print star to make it as a
triangle pattern
if location is anything else then the
condition provided then we should be
printing space there
now let us try to execute this program
and see the output
let us provide the number of rows as
file
so there you go we have printed the
desired pattern
so the next pattern after the triangle
pattern is the Box pattern so this
particular program will be completely
similar to the previous program the only
difference is we need to find the
locations where we need to print Stars
so that the resultant pattern looks like
a box so for that we will make some
changes in our program and those changes
will be related to the rows and columns
now let us understand the logic so as
discussed before we need to look at this
pattern in the form for Matrix and check
out the number of rows and columns so
where the number of row and column are
equal
we need to print a star so let us now
check out the program and execute the
program to print this particular pattern
so as you can see on my screen we have
the same program that we use to print
the triangle but now here we have rows
and columns so n is nothing but 0 and M
is nothing but the column so if the
value of the external for Loop that is I
is equals to equals to 1 and I is equals
to equals to the number of rows provided
similarly J is equals to is equal to 1
which is the internal for Loop counter
variable value and if J is equal to
equals to M that is the column value
then we should print a star in that
particular location and wherever the
location does not match we should
provide a space now let us try to
execute this program and see the output
so there you go we have our desired
pattern which is the Box pattern
now let us move ahead and check out the
next type of pattern in our list so you
can see the next pattern is completely
similar to our first pattern the first
pattern was our right angled triangle
now we have the same right angle
triangle but the only difference is we
have used numbers here now we will use
the numbers from our for loops and we
will print the same values in our
pattern so that it looks like a right
angle triangle
now let us understand the logic so we
will see this pattern in the form of a
matrix now we will print the numbers
where we require them where we don't
require the numbers we will print spaces
now let us check out the program and
execute it to print the following
pattern
now you can see we have got back to our
same program but the only difference is
here we are using the values of the
inner for Loop which is j instead of
Asta previously we used star symbol here
and we are now replacing it with the
inner for Loop value let us try to
execute this program and see the output
now let us enter the number of rows as 5
and there you go we have the values of
the internal for Loop making the pattern
look like a right angle triangle pattern
now let us move further and check out on
our next type of pattern in the list
so here is another right angle triangle
in our list but the difference is we are
using the numbers in a continuous manner
which is 1 2 3 4 5 6 to 15. this type of
triangle is also called as fluid
strangle now let us understand the logic
so similar to the previous one we will
consider this in the form of a matrix
and we will print the numbers only way
we require them that is to form a right
angle triangle where we don't need the
numbers we will try to print a space
there now let us check out the program
and execute it and print this pattern
now you can see we have got back to
eclipse and don't get scared about the
pattern it's completely similar to the
previous one only thing is we will be
using one extra counter variable which
is K so we have provided the value of K
is equals to 1 and where we are supposed
to print Stars we will add the post
increment operator to the counter
variable K so whenever the for Loop gets
executed we will be printing the values
of K which is 1 2 3 4 5 and so on now
let us try to execute this program and
see the output
so there you go the values of K one two
three four five six seven until fifteen
so this is how the fluids triangle work
now let's get back and check out the
next pattern in our list so the next
pattern in our list is similar to the
previous one which is Pyramid so this
type of pyramid is also called as
Pascal's triangle now let us check out
the logic the logic is completely
similar to the pyramids logic but
instead of star we are going to use
numbers so this type of triangle is
called as Pascal's triangle and the
logic is also a little bit different
from the regular pyramid let's
understand the logic through the code
so now you can see the program on my
screen so the logic and the for Loops
used are completely similar to that of
the pyramid but only the difference is
we are going to print the value of
number
so the number is firstly initialized as
1 followed by that we have a formula for
that which is number is equals to number
into I minus J divided by J plus 1 which
are the values of the counter variables
of
outer for Loop and in the follow
respectively now let's try to execute
this program and see the path
so you can see the program got
successfully executed and the Floyd's
triangle has been successfully
constructed here
now let us move ahead and check out the
next pattern in our list so the next
pattern in our list is a box which is
made up of binary numbers now let us
understand the logic for it first so if
we look at this in the form of a matrix
we have binary numbers 1 and 0 which
forms the pattern of a box now let us
check out the program and execute the
program to print this particular pattern
so you can see on my screen we have the
program to print that particular box
type of pattern using the binary numbers
so we have the external for Loop for
rows and the counter variable I is
equals to 1 and I should be less than or
equal to the number of rows provided
once the condition is true we enter into
the external for Loop where we have the
number and where we have the condition I
modulus 2 is equals to is equals to 0
and the number is equals to 0. and
inside that we have a logic to print the
binary numbers
now let us try to execute this program
and see the odd
now let me place the number of rows as
five and there you go we have our box
pattern using binary numbers now let us
get back and check the next pattern in
our list so the next pattern is the Ruby
pattern
this is completely similar to our
program where we printed the Ruby
pattern using the stars now we will use
the numbers and print that particular
pattern now the logic for this is
completely same that of the Ruby pattern
we used but the only difference is
instead of a star we'll be placing the
value of the counter variables now let
us try to execute this program and see
the output
so there you go the program got
successfully executed and instead of
stars we have printed the Ruby pattern
using the numbers now moving ahead we
have our next pattern so here the next
pattern is completely similar to the
first one which is the right angle the
triangle pattern but here instead of
numbers or Stars we will be using
alphabets so for alphabets we will be
using the ASCII values in the program
let us check out that program soon now
first let's understand the logic the
logic is also completely similar to the
right angle triangle which we followed
for stars and numbers
now let's check out the program
so as you can see the desired pattern is
the right angle triangle made out of
alphabets so the logic is completely
true but the only difference is we are
going to print characters using ASCII
values and alphabet function
now let us try to execute this program
and see the output
so the desired pattern is the right
angle triangle printed using the
alphabets now the logic is completely
similar to the right angle triangle
pattern but the only difference is we
are going to use the ASCII values so we
have declared an integer type variable
alphabet with the ASCII value 65 which
should start the alphabets from capital
A because the ASCII value of capital A
is 65.
now let us run the program and see the
output
so there you go the program got
successfully executed and we have the
right angle triangle printed using the
capital alphabets now let's get back and
check out our next pattern
so our next pattern is a pyramid again
so instead of numbers and stars we are
going to use the alphabetical values
now let's check out the logic even here
you can see the logic is similar to The
Pyramid logic now let's check out the
code and execute the code and see the
pattern now you can even see the logic
is also similar to The Pyramid logic but
here the only difference is we are going
to use the ASCII value that is 65 which
is equivalent to Capital a now in the
print statement instead of a star we are
going to print the alphabets and this
particular for Loop is for spaces now
let's quickly execute this program and
see the output
so there you go the pyramid pattern has
been successfully printed or
so in this session we are going to focus
on a particular project
and the project we are going to focus is
is about an ATM application
so you might have interacted with
different ATM Stores in your cities
where you go in you insert your card you
enter your PIN and then you can view the
balance you can withdraw some amount you
can also deposit some amount from the
ATM so we will try to look at it from
that perspective and and we will see
what kind of different uh Java and oops
Concepts we can use to build such ATM
application this is not a super
versatile application but this is just
to give you the idea of how to use those
oops Concepts to build a simple or a
complex Java application so let's start
from the options menu class because that
will give us the understanding of what
kind of functionality I'm using and here
you will use that I am using different
concepts which I have taught you so far
in this particular series
so for example we are using the io
exception we are using the hashmap class
we are also using a scanner class which
is used to take input from the command
line
so this option menu class is extending
the account class and I will come to the
account class in a while but let's see
what this option menu class is doing
this particular class has uh it is using
a decimal format money format class
which is to denote what kind of format
of money you have
then we have a hash map which is storing
the couple of records of account number
to pin mapping so we create a map and
inside the get login method we add
couple of entries to the map here the
first entry the first integer is
pointing to the customer number
and the second integer is pointing to
the pin of the account of this
particular customer number
so if we call the get login method this
method will insert the data
after that it will ask the customer to
enter the customer number which has to
be one of these two if you provide any
other value then there should be a logic
in the application to reject the input
so whatever in a customer number the
customer inputs we pass that inside this
particular method called set customer
number again I will come back to that
and once we have provided a valid
customer number then this method is
going to ask you to enter a PIN number
and remember I told you this is the
customer number to the pin number
mapping so whatever customer number you
select from here you will be providing
the corresponding pin number and again
if you provide an invalid pin number you
will get an error
so that will all happen inside this try
block and if you enter any invalid
characters in the pin number or of the
ATM uh customer number then you will get
an exception which I am writing inside
the catch block
this is all what we have seen so far
after the successful enter of the
customer number and the pin number I
fetch those values from these two
methods again I will talk about what
these methods are doing and again I'm
doing some basic validation checks but
things get interesting in this method
so what we covered so far was the get
login method let me close this method
here
so we covered the get login method the
second method which is defined in this
particular class is the account type so
here the we will ask the once the
customer has provided the customer
number and the pin number we will ask
the customer to provide the account type
this application supports two different
account types which are checking account
or a savings account so whatever so the
customer has to choose one of them again
we will be taking the input from the
command line using the scanner class
and then I'm using a switch case if the
customer entered one then I will execute
some code for the checking account which
is defined here in the case one and if
the customer entered two then the case 2
will be executed
and if the if it enters three then I
will exit the application by just
printing assist out
so here I'm using the switch case
construct to provide different options
to the customer
there's also a default case specified
here which says invalid choice
so this is what is happening in the get
account type method
the next method is if the customer has
used the option one
then we call the get checking method
so let's go to the get checking method
which is the next method which is
defined in this particular class so if
the customer has selected a checking
account then we provide the following
functionality to the customer
which is the customer can view the
balance customer can withdraw the funds
customer can deposit the funds to the
checking account or they can just exit
the application
and again I'm using a switch case here
based on the customer types one two
three or four the corresponding case
block will be executed for example if
the customer wants to view the balance
then this block will get executed and I
call the get account type method
if the customer selects the
2 as the withdraw fund then get
checkings with withdraw input method
gets called and then get account type
gets called
similarly if the customer enters 3 then
we deposit the fund and for that also I
have defined a method I will go to the
definition of these methods as we go
along but right now we are just building
the framework
so the get checking deposit input method
will be called to whenever the customer
selects the option three
and for option 4 we just exit the
application
so this is what is happening in the get
checking method
now if from the account selection if the
customer selected second option which
was savings account then we were calling
get saving method
so this is where the get saving method
is defined
and again it is following the exact same
format as we saw in the get checking
method
where we present the following options
like viewing balance withdrawing the
funds and depositing the funds in the
savings account
and I have some methods defined here for
example get saving withdraw input get
saving deposit input
so we Define the switch case here based
on the customer's choices here
and that is what is happening in the get
saving method so let me close this
method as well and that's all what is
defined inside the option menu class so
we ask the customer to enter the
customer number the pin number from this
get login method then based on that we
provide the customer the options to
choose the account type whether they can
choose the savings account or the
checking account
and based on that whatever account type
they use we call the get checking or get
saving method and inside this method we
provide the customer the other options
to either withdraw the money deposit the
money or view the balance that is what
is happening inside this option menu
class
now let's go to the account class and
all the methods which we saw here will
be provided a definition in the account
class
you also see this option menu is
extending the accounts class so an
inheritance concept is being used here
let's go to the account class now
so this is the account class where I
have defined some private member
variables like customer number so now
you will be familiar with the customer
number pin number which I just described
and also with the checking balance and
the savings balance
you can also divide this account class
into two child classes where you have a
savings account class and a checking
account class but for Simplicity I've
kept it to one class
I'm initializing a scanner input which
will be used at multiple places and then
I have the Setters and Getters for these
four
member variables so you see set customer
number get customer number if you
remember this set customer number was
called in the option menu class if I go
back to the get login
once we ask the customer to enter the
customer number we call the set customer
number which gets called here
similarly
we call the set PIN number
which gets called here
similarly once we have said that we then
we were fetching the values using the
get customer number and the get pin
number and that has that is also defined
here in terms of the Getters get pin
number and get customer number
similarly we also have the Getters for
the checking balance and the saving
balance member variables
we do not have the Setters for them
because they are not technically Setters
but we have to calculate the balance
it's not a simple setup where you can
just return the value
so now let's look at some of the
business functions of the account class
how do you deposit how do you view the
balance how do you withdraw the balance
Etc so you see these two methods
which are specifically when the customer
is trying to withdraw the money from
their account
and these methods are basically called
internally by other methods so we will
come to that let's just understand that
we have two methods for calculating the
withdrawal amount or executing the
withdraw transaction
for the checking account account and the
savings account
similarly I have two more methods here
which are calculating the depositing for
the checking account and calculating the
depositing for the savings account
and then we get the the bigger methods
which are using these calculation
methods so I Define four calculation
methods so far calc checking withdraw
calc saving withdrawal calc checking
deposit and calc saving deposit
basically withdrawing and deposit for
both of the classes
and then we have these business
functions called get checking withdraw
input and get saving withdraw input
get checking deposit input and get
saving deposit input so these getter
methods are something which were being
called from the option menu class if you
remember
if you go back to the option menu class
and if you chose the checking account
you get these options and let's say you
chose option two which was withdraw
funds or option 3 which was deposit
funds then the corresponding methods
which were being called were get
checking withdraw input
and get checking deposit input
and this is the exact same method get
checking withdraw input
and get checking deposit input
so if you see what is happening inside
this particular method is couple of
sellouts
then we take the scanner input amount
and which we convert that amount to the
double
after that we check if the amount which
the customer wants to withdraw is
smaller than the checking balance or not
and I'm running this condition to check
that
if the amount is smaller than the
checking balance then we call the calc
checking withdraw method which was
defined right here
remember I told you that these four calc
methods will be used and this is how
they are used so here I'm actually
subtracting the value so whatever amount
the customer wants to withdraw subtract
that from the main balance and then
return the new main balance
that's what you do right if you have
thousand rupees and if you want to
withdraw 500 you subtract 500 from
thousand and then you send back the
remaining balance
so that is what is happening when we
call this method and then we print the
new checking account balance
that is what is happening in the get
checking withdraw input method
similarly if you chose option 3 which
was
depositing funds to the checking account
then get checking deposit input gets
called
and it is defined right here get
checking deposit input and here instead
of subtraction we are doing the addition
so here I'm again doing a condition
check that the current balance plus the
new amount which has been supplied by
the customer from the command line
the total sum of it should be greater
than zero what if the customer entered
an amount minus 5000 I should not allow
that so that's the reason I'm putting
this condition in place and if the
current balance plus the new amount
which is supposed to be deposited to the
account the sum of it is greater than
zero then call the calc checking deposit
method
and this is where the calc checking
deposit method is present and we are
just doing present balance plus the new
amount and returning the new balance
that's all which is being done here
and you will see exactly similar logic
running for the savings account as well
if you look at the get saving withdraw
input which is used to withdraw money
from the savings account so I take the
input from the command line and I run a
condition check that the amount which
the customer wants to withdraw should be
less than the current saving accounts
balance if yes then call calc saving
withdraw method which is defined here
where I subtract the amount from the
current balance and I return the new
balance
and similarly you will see the exact
same functionality in the get saving
deposit where we add the money instead
of subtracting the money
and this is all what is defined in the
account class so we talked about the
option menu class
we talked about the account class and
now we have the ATM class which is the
entry point which basically initializes
the option menu class and calls the get
login method remember get login was the
first method which asked you to provide
the customer number and then get login
called the method to choose the account
type and the account type methods then
called the method to choose the option
to withdraw deposit or exit
so now we have built a fair
understanding of what is happening in
this application so let's run this
application
so I just ran this application and let
me bring the console here it's first
asking for a customer number so I will
go to the option menu class and I will
pick up one of the customer number which
I have hard coded here
so I will provide that customer number
and hit enter
then it asks me for the pin number
so remember you have to provide the
correct pin number corresponding to the
customer number
so I'm taking this pin number just
copying it and pasting it here
then this whole code got executed
and then it called the get account type
and the get account type method provided
you with these options which you see
here on the screen so based on what you
select the case block will get executed
and let's say I want to go for a
checking account so I press one and I
hit enter
once you select the checking account the
case one gets selected and it calls the
get checking method and the get checking
method again provides you with another
menu view withdraw or deposit or exit so
let's say I want to deposit funds so I
press three
and hit enter
it says the current balance is zero and
enter the amount you want to deposit
let's say I want to deposit 500.
and I hit enter
you get the message saying the new
checking account balance is 500 and you
have successfully deposited the money
and that is what I did for the checking
account
now let's try to withdraw something from
the checking account so you again get
back the same option because inside the
get checking method
we call the once we have successfully
done the business operation we again
call the account type method to display
the menu again to the user
so let's say again select the checking
account class
and this time I want to withdraw the
funds remember I've added 500 there
so let's say I want to withdraw so I
choose the option 2 as the choice
current balance is 500 and it's asking
me the amount you want to withdraw from
the checking account
so I enter let's say 100 and I hit enter
when I do that the new checking account
balance becomes 400 so the 100 got
subtracted from the 500 and the new
balance is shown to your screen
you can do exactly the same thing for
for the savings account as well and
let's also run a negative condition so I
again select the checking account
and I want to withdraw the funds I
choose the option to
current balance is 400 and I I would
like to withdraw 1000.
what happens
if you do that we get a message saying
balance cannot be negative and this is
coming from the calc checking method
which which is defined here so what is
happening that I wanted to withdraw the
funds from the checking account
and here get checking withdraw input dot
called
here
this condition was checked so the
checking balance was
400 and the amount I wanted to withdraw
was thousand so 400 minus 1000 is not
greater than equal to zero so it jumped
into the else block and it said balance
cannot be negative
so this is how you can also build some
error conditions in your code which are
mandatory and which should be built
otherwise your application will have lot
of bugs we can also exit the application
so if you just type free
and hit enter
you will exit from the application and
it will again call the login method
where it will again ask you to enter the
customer number
so this is how you can run this
application and this is this was a
simple use case for you to show how you
can use the different object oriented
Concepts like classes objects methods
Setters Getters switch case
Etc to build the application with the
correct business logic
and this is all I want to cover in this
particular session
and in the next session we are going to
have a look at another interesting core
Java project just to build our
understanding more better about the core
Java concept choose from over 300
in-demand skills and get access to 1 000
Plus hours of video content for free
visit skillup by simply learn click on
the link in the description to know more
let's get started with walking through a
code Java project using all the
different oops concept we have learned
so far
so in this example we are going to have
a look at a calculator application and
this calculator application supports
primarily four different operations like
addition subtraction multiplication and
division
so let's see how do we build that app
so in front of me right now is open the
main class
so I have a main app class here which
has a public static void main method and
the first thing we see is a read input
class which is calling a read method
so if you go to the read input class
it has a simple static method here which
is the read method and it is using the
scanner class if you remember I talked
about the scanner class which is used to
take inputs from the command line from
the user so we initialize the scanner
class and we start taking the inputs and
whatever the user inputs in terms of the
expression let's say the user entered
four plus five or whatever that whole
expression gets sent back into this
input line as a string and that comes
back here in the input expression
once we have captured the input
expression the next thing we do is
divide the input expression in the
numbers and The Operators basically an
expression would be either something
like
4 plus 5
into 3
divided by 2 let's say
let's say the user entered this
expression so this has either numbers
or operators
so that's what we are doing here we are
using the split method of the string API
the string class basically and this
split method is going to split the
numbers and operators into two different
string arrays and here I am providing
the split expression that split at every
time you encounter one of these symbols
so this when you execute this particular
statement it is going to return a
numbers array
which will be created based on this
expression so you will get an array with
4 5 3 and 2. and similarly in the
operator array you are going to split or
pick out the elements every time you
receive a number so this operator array
is going to hold this plus sign this
multiply sign and this divide sign
hope you get the understanding that we
are just splitting the whole expression
into two different arrays
where first array is holding only the
numbers and no mathematical expressions
and second array is just holding the
mathematical operators and no numbers
and we'll see why we need to do that in
the upcoming lines
once I've created the string array I
just want to store or convert these
string arrays into a queue so I convert
this array into a list by calling the
array dot as list so this expression is
going to return a list and then I'm
going to convert this normal list into a
linked list
and then going to store this linked list
into the queue of numbers
and I'm going to do exactly the same
thing for the operator array as well
converting this into a generic list
converting that generic list into a
linked list
and then storing this linked list as a
queue
so I have an operator's queue and I have
a numbers queue both of them have been
stored into a queue now
and then I am using the pole method if
you remember the pole method of the
queue is used when you want to fetch the
first front element the head element of
the queue so whichever element is
sitting at the head of the queue will be
taken out the moment you call the whole
method so I fetched the first number
from the numbers queue so in this case 4
will be fetched here
in this variable and after that I run a
loop on the numbers queue and I'm going
to run this particular Loop till this
particular queue is not empty if you see
there is a negation here so I'm going to
pick up numbers one by one from this
numbers queue till the number Q becomes
empty
and inside the loop I do this exact same
pole operation for the operations queue
so this operations queue is holding all
these mathematical operations like plus
star and divide
so I'm going to pick the head of it so
in this case plus will be picked up and
will be stored in this variable called
opr
and then I am going to run a switch case
on this opr basically as I told you in
this particular calculator application
we are supporting four operations which
are addition
subtraction multiplication and division
so I Define a case for each of the
mathematical expression
so you see there are four different
cases here and for each case I am
initializing a class if it's a plus sign
then I'm initializing the add class
if it's a minus sign then I'm
initializing the subtractors for
multiplication I have a class called
multiply and for division I have a class
called divide
let's have a look at what these classes
are containing
so if I go to the add class first of all
it is implementing an interface called
operate
and this operate interface has just a
single method called get results
which is accepting a variable argument
array if you remember I told you that
you can also use a where ARG array this
is called a where ARG expression this
means that this numbers will be an array
of arbitrary length it can be a one
element array it can be a two element
array it can be a Four Element array or
whatever you supply but it is still
going to be a fixed length array but the
length is going to be dependent upon how
much argument you supply to this
particular method
so that is what this interface operate
is doing it's it just has one method
declared which is called get result
which is accepting an array of numbers
so if the add class is implementing the
operate interface then it has to
override the get result method and here
it is just doing a summation of all the
numbers which have been supplied so if
you supply four numbers it is just going
to add up those four numbers and return
the sum
and the exact same kind of logic or
similar logic will be seen in other
operate classes so if I go to the
subtract class
it runs the exact same operation but it
subtracts the values
if I go to the multiply class it is also
implementing the operate interface and
in the get result it is just multiplying
all the values
similarly in the Divide class
it is also implementing the operator
interface and it is dividing all the
numbers one by one so it's doing pretty
much the same thing in terms of the
expression and the logic
the only difference is whether you are
using an ad operation or a subtract or
multiply or a divide
so we have checked all these classes and
the operator interface as well and let's
go back to the main app now
now you also see that I've defined a
reference of copyright here and each of
the switch case block I am assigning the
object type to this interface reference
so I'm using the concept of dynamic
binding which we talked about when we
talked about interfaces that we can also
do Dynamic binding where we can assign
an object
to an interface type and the object type
will depend upon the expression
so once we have filled that based on the
case
while filtering out this expression and
picking up plus star and divide
sequentially then we go to the next line
outside the switch case block which is
to pick the next number from the queue
remember we already did one pole here
so as per this example 4 was here in
this race
and now when we do this number dot pull
again
5 will be picked up because that will be
the next head of the queue so we pick up
5 here and then we call operate dot get
result now this get result will be
called based on the expression which was
encountered first in the queue
again looking at the example the first
expression encountered will be plus
so the expression was plus so the
operator type object is of add type
and when you call operate dot get result
the get result method of add class is
going to get invoked and it is going to
Sum 4 and 5. this rest is holding 4
right now based on what I described here
numbers dot Pole and this num is holding
the the second operand basically
basically 5 here so 4 plus 5 gets
evaluated here in this case and then it
again goes back here and it checks if
the number Q is now empty no it is still
not empty because we still have 3 and 2
left there so again it does the
operations dot pole and it picks up
multiply sign here
then it again runs the switch case since
it's a multiply sign it will go here and
it will initialize the operate interface
reference as the object of multiply
class
then coming here it will do a numbers
dot pole and this time the numbers dot
pole is going to pick up three
so three will be picked up here and then
the current value of result which is
already 9 4 plus 5 was 9 the current
value of result will be updated here so
rest will be 9 here and num will be 3
here and when you call operate dot get
result the multiply classes get result
will get called and it will say 9 into
3. which will become 27
it will again go back here to this
particular line and it will check again
if the numbers queue is now empty no it
is still not empty because we still have
one element left
then it pulls uh the queue of the
operations where the expression divide
is present there which is the only
element left in this particular
operations Q
and since we have the opr value as
divide this case block gets called and
the New Divide class gets initialized
the Divide class basically gets
initialized and we come here and we do
numbers dot Pole now the last number
which is available in this queue is 2
which gets picked up here
and then we again call operate dot get
result this times is the operate object
refer object uh operate reference type
was of divide class type so when we call
operate dot get result The Divide
operation or the get result method of
the Divide class basically this method
will get invoked and it will divide the
current value of result which was 4 plus
5 9 into 3 which was 27 so it is going
to divide 27 by 2 which was the last
value of the numbers dot pole which is
going to execute 27 by 2 and whatever
value it gets it is going to store a
value back into the rest variable and
then it is again going to go back here
and again going to check the condition
if the numbers Q is not empty but now
the numbers queue is empty because 2 was
the last element so it is going to come
out of the loop and it is going to print
the final result
that is how this whole program is
working
now let's try to see this in action and
we'll try to execute the exact same
expression
so if I right click and go to run as and
run this as Java application
and I Supply an expression saying 4 plus
5 Star 3 divide 2.
and if I now hit enter
I get the value as 13.5 which is exactly
what we ran through because 4 plus 5
will be evaluated first which will
result into 9 then 9 into 3 will be 27
and 27 divided by 2 will be 13.5 exactly
so this is how this whole program is
running where we first take the inputs
and then we divide the input into
numbers and operation arrays or in fact
queues and once we have those queues
built up then we pick up the first
number and we keep running this Loop
till the numbers Q is not empty inside
the while loop at each step we pick up
the first expression or the operator we
check what is the operator whether it is
an addition subtraction multiplication
or division operator and whatever kind
of operator we have we initialize the
corresponding class of it and then we
fetch the next value in the numbers
queue and then we call the get result
based on the expression and whatever
result we get from the get result we
store it back into the rest variable so
we keep updating the rest variable at
every step that's the reason the result
of 4 plus 5 gets stored in the rest and
next time you are calling the get result
for a multiply operation here the rest
value is 9 now and it says 9 into 3
again in the next time the rest value
will be updated to 27 because we are
storing the result back into the result
variable
so this is all I want to cover in this
particular session where we looked at an
example of a calculator application
purely from the console standpoint
obviously there can be lots more stuff
which we can do into this particular
application make it more error free and
cover a lot of corner cases like
validating the inputs
Etc also looking at putting some
conditions around the exception handling
handling the divide by zero scenario Etc
which is not here but this is just to
show you the basic idea of how you can
build simple to complex CLI applications
using the core Java Concepts topic what
exactly is a Java collection a Java
collection can be generally defined as a
collective unit of objects in the form
of a group for example a group of
numbers of integer data type Etc moving
forward we enter into our next topic
where we Face the Java Collections
framework this will help us understand
Java Collections in a little more
detailed way
a Java collection framework represents a
unified architecture for storing and
manipulating a group of objects its
architecture includes the following
an interface a class and the Java
Collections API to understand these in a
much better way we shall now go through
the Java Collections hierarchy the
utility package java.utl contains all
the classes and interfaces that are
required by a collection framework The
Collection framework contains an
interface named as an iterable interface
which provides the iterator to iterate
through all the collections
this interface can be extended by the
main collection interface which acts as
the route for the collection framework
all the collections extend this
collection interface they by extending
the properties of the iterator and the
methods of this interface the following
figure illustrates the hierarchy of
collection framework out of the
complexities we have the interface and
the classes as the major part of the
collections now let us understand each
one of them at one step at a time as you
can see on the screen we have the
iterable class which is implemented by
The Collection class and this particular
collection class is further implemented
by list q and set and moving ahead we
have the following classes which have
implemented the list queue and set
classes in the list we have arraylist
linked list Vector stack and on the
other hand on the Queue we have priority
queue DQ and array DQ and finally on the
set we have the hash set lint hash set
sorted set reset Etc now moving further
we will enter our first Java collection
which is none other than the interface
so the first one is an interface an
interface can have methods and variables
but the methods declared in an interface
are by default abstract that is only the
method signature is available not the
body
interfaces specify what a class must do
and not how it must do it is a blueprint
of a class now a Java collection is a
foundation to the Java Collections
framework note that all the collection
interfaces are generic for example
public interface collection is the
Syntax for the generics and when we
declare the collection we should use it
to specify the type of object which it
can contain it helps in reducing runtime
Errors By type checking the objects at
compile time to keep the number of core
collections interface manageable the
Java platform doesn't provide separate
interfaces for each variant of each
collection type if an unsupported
operation is invoked a collection
implementation throws an unsupported
operation exception now under the
collection interface we have many
interfaces that we should use for data
manipulation a few of the major ones are
set interface list interface DQ
interface queue interface map interface
sorted set interface sorted map
interface don't worry those are a lot of
interfaces but we will discuss each one
of them in a detailed way along with a
practical example for a better
understanding
so the first one in the docket is the
set interface a set is a collection that
cannot contain any duplicate elements
this interface model is the mathematical
set abstraction and is used to represent
sets such as a deck of cards
the Java platform contains three general
purpose set implementations the hash set
tree set and linked hash set the set
interface does not allow random access
to an element in the collection you can
use an iterator for each Loop to
Traverse elements of a set now for a
better understanding let us go through a
practical example I have prepared a code
document for all the programs that I am
going to explain to just save time you
can always have access to it all you
need to do is just ask for it in the
comment section below so you can see on
my screen we have an example for set
interface in this particular example we
are going to store the elements 21 23 43
53 22 and 65. so let's try to execute
this program and see the output
so you can see the elements stored in
the set interface are 65 2153 22 and 23
43 so the sorted set is here which is a
21 22 23 43 53 and 65 and the first
element being 21 and the last element
being 65. so this is how the set
interface practically works now let's
move ahead into our next type of
interface which is none other than the
list interface so what exactly is a list
interface the list interface is an
ordered collection that can contain
duplicate elements you can access any
element from its index the list is more
likely an array with Dynamic limb the
list is one of the most used collection
types an arraylist and linked list are
the implementation classes or the list
interface
the list interface provides useful
methods to add an element at a specific
index to remove and replace elements
based on the index and to get a sub list
using the index for a better
understanding let's check out an example
so this particular program is based on
list interface so we are going to add in
three names which are David John and
Stacy into our list and also we have a
fourth edition which is Stacy again
just to check if the statement is true
which says list interface also allows
duplicate elements unlike the set
interface
so let's try to run this program and see
the output so you can see the program
got successfully executed and the names
David John and Stacy are added into the
list now let's come back to our program
and remove this comment and try to run
again and check if the fourth element
which is the duplicate of the third
Stacy will be added into the list or not
so as you can see the program was
successfully executed and the fourth
element which is Stacy the duplication
of the first one got successfully
inserted into the list so this is how
the list interface works now let's move
ahead into our next type of interface
which is the queue interface so what
exactly is a queue interface Q is a
collection used to hold multiple
elements prior to processing besides
basic collection operations a queue
provides additional insertion extraction
and inspection operations
cues typically but do not necessarily
order elements in the fifo OR first in
First Art manner among the exceptions
are priority cues which order elements
according to a supplied comparator or
the elements in natural ordering
whatever the ordering used the head of
the queue is the element that would be
removed by a call to remove or pole in a
first and first out queue all new
elements are inserted at the tail of the
cube now for a better understanding
let's go through a practical example so
as you can see the program on my screen
is an example for queue interface so in
this particular queue we are going to
store the names of fruits apple mango
grapes and banana and apple being the
head of the queue and banana being the
tail of the queue now let's try to
execute this program and see the output
so we are also going to count the size
of the queue which is 4 basically in the
first after that we are going to remove
the element grapes from the queue so the
command is Q dot remove the element name
so after that the graves element has
been removed from our queue we have the
latest size of the queue as three now
after that we are also going to check if
the element apple is included in the
queue or not so for that statement yes
the element apple is included in the
queue and the result is true so this is
how the queues work and let's move
further and in the next phase we have
the DQ interface so what exactly is a DQ
interface
so a linear collection that supports
element insertion and removal at both
the ends is called as a DQ interface the
name DQ is short for double ended queue
and is usually pronounced as deck most
DQ implementations place no fixed limits
on the number of elements they may
contain but this interface supports
capacity restricted dqs as well as those
with no fixed size limit this interface
defines methods to access the elements
at both the ends of the DQ
methods are provided to insert remove
and examine the element for a better
understanding let's check out an example
so you can see on my screen we have a
program for DQ interface so here we are
going to add in some elements into our
DQ and then also try to remove the first
element and print the updated DQ now
let's try to execute this program and
see the output
so as you can see the program got
successfully executed and the elements
which we try to push into the DQ are 50
to 10 and 21 52 is being the first
element and the 21 as being the last
element so we try to remove the first
element which is the 52 so after that
the updated DQ is having two elements
which are 10 and 21. so this is how the
keys work now let's move ahead and learn
our next type of interface which is the
map interface so what exactly is a map
interface a Java map is an object that
Maps Keys along with its values a map
cannot contain duplicate Keys each key
can map to at most one value
the Java platform contains three general
purpose map implementations which are
the hashmap stream map and linked hash
map
the basic operations of a map are
contains key contains value size and is
empty for a better understanding let us
check out an example so this particular
example on my screen is an example for
map interface here we are going to add
three elements and map them as one as
Cricut 2s hockey and 3 as archery
now let us execute this program and see
the output
so you can see the program got
successfully executed and the elements
are mapped with their keys and the
element Cricket is mapped with the key
one and similarly hockey with key 2 and
rcd with G3 so this is how the map
interfaces work now let's move further
into our next type of interface which is
the sorted set interface so what exactly
is a sorted set interface so a sorted
set is a set that maintains its elements
in ascending order
several additional operations are
provided to take advantage of the
ordering sorted sets are usually used
for naturally ordered sets such as
wordless and membership roles
for a better understanding let's check
out an example based on sorted set
interface
so you can see the program on my screen
is an example for sorted set interface
so here we are going to add in Bob Sean
and Jennifer into our set and we are
going to print the same let's try to
execute this program and see the output
so you can see the program was
successfully executed and we have our
elements printed in the sorted set and
you can see the names have been arranged
in the form of ascending order according
to the alphabets which have started in
the first position so this is exactly
how the set interface works
so the last one in the interfaces is the
sorted map interface a map that
maintains its mapping and an ascending
key order
this is the map analog of assorted set
the sorted maps are used for naturally
ordered collections of key value pairs
such as dictionaries and telephone
directories now for a better
understanding let's check out an example
based on map interface or sorted map
interface so you can see the program on
my screen is an example for sorted map
interface so here we are going to add in
the elements John moly Aaron and Daisy
into the map interface now along with
the names we also have their aggregate
switches 76.5 for John 87.3 for Mali and
78.2 for Aaron and for Daisy we have
73.4 now finally we are going to fetch
the data of Molly which is the aggregate
of Molly now let's try to execute this
program and see the output
so you can see the program got
successfully executed and Molly's
aggregate is 87.3 so this is how the map
interfaces work now let's move ahead
into our next topic which is the Java
collection classes so now that we have
finished the Java collection interfaces
let us have a quick understanding of
java interface methods so the first
method is the add method the add method
is used to add an object to the
collection and next is the ease anti
method this method returns to true if
the collection contains no elements
followed by that we have the clear
method and this method is used to remove
all the elements from The Collection
followed by that we have the remove
method this method is used to remove the
given object from the collection if
there are duplicate values then this
method removes the first occurrence of
the object next to the remove method we
have the size method so the size method
is used to return the number of elements
in the collection so after the size
method we have the stream method the
stream method is used to return a
sequential stream with this collection
as its source so the next method we have
is the two array method so the two array
method is used to return an array
containing all the elements in this
collection
followed by that we have the hash code
method this method is used to return the
hash code value for this collection next
the equals method the equals method is
used to compare the specified object
with the remaining elements in the
collection followed by that we have the
iterator method so the iterator method
is used as an iterator over the elements
of the particular collection and finally
we have the contains method so the
contains method returns true if a
specified element is existing in the
collection and false if it is not
present so with this we finish the
collection interface and collection
interface methods now we will move ahead
into our next topic which is none other
than the Java collection classes so what
exactly is a class A Class is a
user-defined blueprint or prototype from
which objects are created it represents
a set of properties or methods that are
common to all the objects of one type
now start up with the first one which is
the hash set class so the Java hash set
is a basic implementation of the set
interface that is backed up by the hash
map it makes no guarantee for the
iteration order of the set and permits
null elements as well
so this class office constant Time
Performance for basic operations such as
ADD remove contains and size assuming
the hash function disperses the elements
properly among the buckets we can set
the initial capacity and load factor for
this collection the load factor is a
measure of how full the hash map is
allowed to get before its capacity is
automatically increased for a better
understanding let's go through an
example so on my screen you can see a
program which is an example for hash set
classes so inside this we are going to
store some names which are the names of
the manufacturers of bikes along with
null values so we have added in two null
values to just check if it allows two
null values at once so basically it only
should allow one null value so let's
check out how does it perform
so you can see the program was
successfully executed and the null value
is stored only once that too in the
first location
so this is how the hash set classes work
moving further we will deal with the
next type of class which is the three
set class
so a tree set class is a navigable set
implementation based on a tree map the
elements are ordered using their natural
ordering or by comparator provided at
set creation time depending on which
Constructor is being used this
implementation provides guaranteed log
time cost for the basic operations such
as ADD remove and contains note that the
ordering maintained by a set whether or
not an explicit comparator is provided
must be consistent with equals if it is
to correctly implement this set
interface now to understand in a much
better way let us go through an example
now we are going to add in some numbers
into the tree set using the add method
now let's execute this code and see the
output
so you can see the numbers are added
into the tree set and the numbers are
ordered in ascending order which is 0 18
88 748
983 8476.
now let's move further into our next
type of class which is the arraylist
class
so add a list in Java is a resizable
array that is an implementation of list
interface that allows null elements so
in this class we have three types of
arrays which are one-dimensional arrays
two dimensional arrays and three
dimensional arrays now let's check out
the one dimensional array
so a one-dimensional array looks similar
to this where we have the array index
and the element present in the array so
here our indexes are a0123 and 4 and the
elements which are shown here to
understand one dimensional arrays in a
much better way let's go through a
sample program
so you can see the program written on my
screen is an example for one dimensional
array and we are going to store the
elements 10 20 and 30 into my array a
so you can see the program has been
successfully executed and the elements
have been added into my one-dimensional
array moving further we will discuss the
two dimensional arrays the two
dimensional arrays are completely
similar to one-dimensional array but the
only difference is the index numbers
earlier we had index number but now we
have index numbers now using these index
numbers we can represent the elements in
a matrix form
so to understand this in a much better
way let's go through a sample code
so you can see this particular program
in my screen is an example for
two-dimensional arrays so here we are
going to add in elements 1 2 3 and 4 in
The Matrix form and we are going to use
two for Loops to print that now let's
execute this program and see the output
so you can see we have the elements one
two three and four and the elements are
printed in The Matrix form add the array
index location 0 0 we have 1 0 1 we have
2 and 1 0 we have three and one one we
have four so this is how the two
dimensional arrays work and finally
let's deal with the third type of array
which is the multi-dimensional or three
dimensional array so you can see the
three-dimensional area is completely
similar or a little bit similar to the
two-dimensional array but the only
difference is we have a third Vector
here so next up we have the linked list
linked lists also come under Java
collection classes
there are three types of linked lists
which are single linkless doubly linked
list and circular linked list now let's
check out each one of those so the first
one is the single linked list so you can
see in a singly linked list each memory
segment is divided into two parts so the
first half of the memory location is
given for the element and the second
half of the memory location is dedicated
for the address so this particular
address is used to point to the next
element or the next memory allocation
which stores the second element
similarly the third so this is how the
singly linked list works so the last
memory allocation is called as the tail
and the last address will not store
nothing but null which indicates the end
of the single linked list now to
understand singly linked list in a much
better way let's try to execute a sample
program
so you can see the program on my screen
is an example for singly Linked list now
we are going to add in the elements one
two three and four in the form of a
singly linked list now let's try to
execute this program and see the output
so you can see in the program got
successfully executed and the elements
are one two three and four now let's
move further and try to learn the next
type of linked list which is the doubly
linked list
so the W linked list is completely
similar to that of the singly linked
list but the only difference is we have
two address locations so the first
address location of the head stores null
and the last address location of the
tail stores null which indicate the
start and end of the doubly linked list
respectively so here in the second
memory location you have two addresses
so the first address points to the
previous element and the next address
points to the next element so to
understand doubly linked list in a much
better way let's try to execute a sample
program
so as you can see the program on my
screen is an example for w linked list
and we have the node which has the data
and previous address next address now
let's try to execute this program and
see the output and the elements that we
are going to store in this particular
doubly linked list are one two three
four and five
so as you can see the program got
successfully executed and the nodes are
one two three and four and five so this
is how the doubly link list work and now
let's check out the third type of linked
list which is the circular linked list
so there are similarities between the
previous linked list and the circular
linked list so the circular linked list
makes it circular based on the last
address location so this particular
address location points to the first
element back again so this is how it
becomes a circular linked list so to
understand this in a much better way
let's check out an example for it
so you can see the program on my screen
is an example for circular linked list
now let's try to execute this and see
the output so you can see we have
successfully included one two three four
five six and seven and eight into our
circular linked list and they are
printed on the screen so this is how the
circular link list work so moving
further we will try to understand the
next type of classes in Java Collections
which is the hashmap class so hash table
is based on the implementation of map
interface this implementation provides
all the optional map operations and
permits null values and the null key
hashmap class is roughly equivalent to
Hash table except that it has
unsynchronized and permits null this
class makes no guarantee for the order
of the map now for a better
understanding let's go through a sample
program so this particular program on my
screen is an example for hashmap class
so here we are trying to load the data
which is the name of the manufacturer
and their bike so let's execute this
program and see the output so you can
see the program got successfully
executed and we have the manufacturer
and their made bikes now moving further
we will deal with the next type of class
in Java collection which is the tree map
class so the tree map is based on
navigable map implementation the map is
sorted according to the Natural ordering
of its case or by a comparator provided
at creation time depending on the
Constructor used now let's check out an
example for better understanding
so you can see the program written on my
screen is an example for train map class
so we have the roll numbers and the
names of students here now let's try to
execute this program and see the output
so the program got successfully executed
and the result has been printed on the
output console so we have the role
numbers of the students and their names
Amber
James Violet and Reynolds along with
their respective IDs so now with this we
complete the Java Collections classes
Now we move into our next topic which is
the collection API algorithms so the
first one is sorting sorting does the
job of ascending at descending numbers
based on the algorithm written by the
user for a simple example we shall
consider the bubble sort algorithm for
this one so you can see on my screen we
have an example for bubble sort
algorithm so we have the elements 289 39
48 6 28 1 2 and 33 which are ordered in
a unorderly manner let's try to execute
this program and order them
so you can see array before bubble sort
is 289 38 48 similarly 33 and after the
bubble sort we have the sorted array
which is 1 2 6 28 33 39 48 and 289 so
this is how the bubble sort works now
let's move further and understand the
next type of API which is the shuffling
algorithm so the shuffling algorithms
are designed to destroy the current
Arrangements they are employed on
creating Randomness in the list so for a
better understanding let's check out an
example so you can see the program
written on my screen is an example for
Shuffle algorithm so we have an array
which has the elements completely sorted
in ascending order which is 10 to 100.
now when we run the shuffle algorithm
these elements will be completely
shuffled according to a random order now
let's try to execute this program and
see the output so you can see the
elements which were in an ascending
order are now completely in Disorder so
this is how the shuffling algorithm
works now let's move further and
understand the next type of algorithm
which is the searching algorithm
searching algorithm is employed to
search an element in the list or array
based on the type of searching mechanism
used now for example let's use the
binary search now you can see a program
on my screen which is an example for
binary search so we have the elements
one two three four and five in our array
now what we are going to do is search
for the element or the key element to in
our array using the binary search
algorithm now let's execute this program
and see the output now you can see the
program got successfully executed and
the output says the element which you
are looking for is found in the index
location 1. so this is how the binary
search algorithm works now let's move
further and understand the next type of
algorithm which is the composition
algorithm so the definition says the
frequency and distance algorithms test
some aspect of composition of one or
more collections so the frequency counts
the number of times the specified
element occurs in this certified
collection so the disjoint determines
whether two collections are disjoint
that is whether they contain no element
in common or not now to understand it in
a much better way let's go through an
example so you can see on my screen
there is an example for composition now
let's run this program and say the
output
so you can see the program was
successfully executed and
the elements are completely disjoint now
moving further we will enter into our
next topic which is based on the
benefits of Java Collections so there
are various benefits of Java Collections
out of those the major benefits are
software or code reusability so the Java
Collections enable code reusability to
save time followed by that the ease of
Designing apis so the next two ease of
Designing apis we have the Simplicity in
learning and using apis and finally
increased speed in programming so these
were the major benefits of Java
Collections that is what is an exception
so an exception is defined as an event
that arises due to an unexpected input
or logical failure in the program this
may not be considered merely as an error
but it surely does impact the normal
functioning of the program segment now
these types of exceptions are resolved
by the most efficient mechanism called
exception handling exception handling is
not any rocket science but a simple
mechanism that drives the compiler to
the next statement by making the
compiler understand that the input
obtained or the malfunction that arise
is just an unexpected or an unnecessary
event which can be ignored by sending
the user with a relevant message about
the exception errors
for a better understanding let us go
through a small example
so as you can see on our screen we have
typed in a program so according to this
program we are going to access a file
called data.txt from the C drive so this
particular data.txt is not really
existing in the C drive so when we run
this program we will face an exception
that says file is not found so let's try
to run this program and see
so as expected so when we run this
program we get that this particular file
what you're looking for which is
data.txt is not found or in other words
it is not present in the specified
location so this is how the exceptions
work in Java now followed by this we
will move ahead into our next topic
where we will understand the meaning of
an error
so what exactly is an error
so here we are trying to learn about the
error just to eliminate the ambiguity
between an exception and an error also
further we will discuss the major
differences between them but now let us
go through the term error first unlike
an exception an error poses a serious
Potential Threat to the program or
sometimes it is even capable enough to
collapse an entire software
so basically an error is occurred due to
syntax error or some logical error while
coding so we have a sound understanding
of an exception and an error now let us
move further and learn the differences
between the both
error versus exception
so some of the major differences between
an error and an exception are
an error is classified under unchecked
type whereas on the other hand an
exception is classified under both
checked and unchecked
the next difference is if a program
encounters an error then it turns out to
be completely irrecoverable until the
error is resolved whereas in the case of
an exception if the program encounters
an exception then the program is easily
recoverable
followed by that the third difference is
an error belongs to the package called
java.lang dot error on the other hand an
exception belongs to the class Java dot
Lang dot exception
the fourth difference says that an error
can be encountered only during the
program's runtime whereas on the other
hand an exception can be expected both
during the runtime as well as the
compile time
finally we will mention an example for
both an error and an exception
we can consider the input and output
error as an example for error and on the
other hand we can consider divide by
zero exception as an example for
exception
so when the difference is discussed we
will now move ahead and have a look at
the exception hierarchy in Java
the hierarchy of errors and exceptions
is really simple
there is one root class called the
throwable now the throwable class is
basically inherited from object which
comes from the superior root called
java.lank now the throwable class is
inherited by two chart classes which are
none other than the error and an
exception further an error is inherited
by different types of Errors for example
jvm or Java virtual machine error memory
error and also in some cases some of the
errors are caused by the incompatibility
of the IDE or the framework which are
you are using
next up is the exception now the
exception is inherited by few more
exceptions which are mentioned as below
the exceptions can be input output
exception SQL exception class note found
exception runtime exception and many
more further the runtime exception is
inherited by some more which are the
automatic exception number format
exception Etc
now that we have a good understanding of
the exception hierarchy let us move
ahead and check the differences between
checked and unchecked exceptions
so the first one which is the checked
except
ion these are really simple exceptions
and can be defined as follows an
exception that pops up during the
compile time is called as the check
exception it is not serious and is
completely ignorable
followed by the checked exceptions we
have the unchecked exceptions on the
other hand the unchecked exceptions are
defined as an exception that pops up
during the runtime is called as the
Uncharted section
it is considered as serious and is
caused by logical errors
so to understand checked exceptions in a
much better way we shall go through an
example
so this particular example is based on
checked exceptions
so basically we have a text document
called data.txt in the location
documents username users C drive
so this particular data file has five
lines so we are going to access the
starting three lines of this particular
file and basically when we try to run
this program we will face some of the
major exceptions which are unhandled
exception type input output
and again the same exception and here
file not sound exception so these
exceptions are errors
so to understand checked exceptions in a
much better way we shall go through an
exam
so this particular code segment here is
trying to read a document from C drive
which is data.txt
so this particular data.txt has five
lines of text so what we are going to do
here is try to type in a for Loop and
try to read the first three lines of
this particular document so basically
when we run this program
we will face some of the exceptions
called file notes on exception input
output exception and another input
output exception
so we can resolve this particular
program with small modifications to the
program and then if you run this program
then we can find our lines
so the lines in the data.pxt file were
hello welcome present later on we are an
e-learning company our certification is
recognized by Major mncs enroll and
upscale
so this particular example was for
checked exceptions
now we will also go through an example
for unchecked exceptions to learn it in
a much better way
so this particular example is based on
unchecked exceptions this particular
program is really simple we have an
integer type array and insight that we
have 10 Elements which are 1 2 3 4 5 6 7
8 9 and 10. so what we are going to do
is we're going to access the 11th
element of the array which is not really
present so this should throw an
exception
so array index out of bond exception is
one of the example for unchecked
exception
so with this we will move ahead into our
next topic
now we know what exactly are checked and
unchecked exceptions moving further we
will slowly dive into the process of
exception handling in the process of
exception handling we have five major
keywords
so we will learn each one of them as
follows
so the first one is try keyword
the try keyword is used to specify the
exception block
in a program when you specifically type
the exception that you might expect to
face in your program then you describe
it using the keyword try
followed by that the solution for that
exception will be defined in the cash
flow so the cash block is used to
specify the solution
finally the finally is a keyword which
has the executable code which is
completely mandatory for a program to
execute followed by finally we have a
throw keyword the throw keyword
basically throws the exception when it
is found during the runtime
followed by that we have the throws the
throws keyword is used to dictionary the
exception so basically this is where you
declare the kind of exception you are
going to expect a new program sometimes
you might try to type in your user
defined exception or sometimes you might
type in the exception that is default in
its way
or in other words it might be system
defined
now that we have a good understanding of
the implement ation of the exception
handling a Java let us move further
some of the most frequently faced
exceptions in Java
so with this we enter into our seventh
topic which is common exceptions faced
in Java
so the first one is the array index out
of bound
so if you try to store a value in an
array or try to access an element in an
array which has an address exceeding the
address maximum location value then this
particular exception is thrown so to
understand this particular exception let
us go through a practical example
so as you can see on our screen we have
an array of integer data type so we are
going to store the values 10 20 30 40
and 50 in five different locations of
the array which is 0 1 2 3 and 4. now we
are going to provide the address of the
required element so during that process
we are going to specify one location
which is more than the maximum location
of the array so here the maximum
location of the array is 4 and if we try
to provide the location file then this
program should throw us an exception so
let's try to run this program and see
the output
so as you can see we have our Arrow here
now the program is requesting us to
provide the address of the element
required so what if we provide a file
so now it should throw an exception
so this exception is the array indexed
out of bound exception now let us try to
run this program again and specify the
proper address so for this time let's
provide 4 and see if we get the output
so as you can see at the address
location we have The Element 50 as we
have defined here
now our program is running perfectly all
right
now let's move ahead into the next type
of exception which is none other than
a null pointer exception
if you try to perform an operation on a
null value this particular exception is
thrown so might be a little ambiguous to
understand this particular exception in
a perfect way let us go through a
practical example
so here on your screen you can see that
we have a program and inside the program
we have a string called Str which stores
a text called simply
followed by that we have another string
type which stores a null value which is
ABC as you can see ABC is equal to
number now here we are going to access
the value of ABC so here the string ABC
has a null value and we are trying to
access it so this particular code
segment should throw an exception called
null pointer exception now let's try to
execute this code
as you can see it has thrown an
exception called the null Contra
exception so whenever in Java if you try
to access the null values then the null
counter exception is strong
followed by this we have the next type
of the common exception which is the
number format
if you try to store a value with wrong
formatting then this particular
exception is thrown
not to understand this in a much better
way let us try to execute a sample
program
so here on the screen we have a sample
program where we are trying to cast a
string into integer so this kind of
operation should throw an exception
so as you can see the program has been
successfully compiled and we have our
exception here which says number format
exception
followed by this we have another most
commonly faced exception which is the
automatic expression
if you try to divide a number by zero
this particular exception is strong now
let us go through a practical exam
now you can see we have a sample program
on a screen where we have two particular
numbers and one is equals to zero and N2
is equals to 100. so here what we are
trying to do is we are going to divide
the number 100 by 0 which is practically
not possible so when we try to execute
this particular program then we should
be getting an exception that says you
cannot divide a number by saying
so there you have your personalized
message which says the divider cannot be
zero try a different number so this is
how the automatic exceptions work
so with this we have come to our last
topic which is the best practices to be
followed while working with exceptions
in Java
so the first one is use exceptions
conservated
so exceptions have proven that they can
be costly if used recklessly or
unnecessary so it's better to use
Boolean values to indicate successful
implementation of smaller operations for
example if you specify a particular
operation and it successfully gets
executed then you can just notify the
user by specifying a Boolean value which
can be one or in the case of failure you
can just specify the number zero
next after that we have the customized
exceptions
it is a very good practice of
customizing your exceptions in the
design time rather than planning them on
the go
so in other words we can consider this
as if you're planning to design a
software then in that particular stage
itself you must also evaluate the kind
of exceptions you might face on the
process of Designing so tomorrow if you
completely design a software and
suddenly an exception is popped in your
head then designing or including that
particular exception in your finished
software might be difficult so it's
better you start planning your
exceptions
followed by that we have exception login
keep track of the exceptions and this
process comes handy as the user
user why exactly a particular exception
has supported
followed by that we have early through
and early the next section should be
shown as early as possible and should be
resolved in the same pace
and then we have the closing resources
since exceptions hard the complete
program we must make sure that the
system resources are shut so as to save
the resources
tell us what exactly is multi-processing
so what is multi-processing
so multi-processing is a procedure where
you utilize your processor to the
maximum
it's basically dividing the instruction
you give to your CPU into multiple parts
and each segment is assigned a separate
thread to execute that particular task
now moving forward we will discuss about
the types of multi-processing
so basically there are two different
types of multiprocessing the first one
is process based multi-processing and
the second one is the thread based
multi-processing so our point of
discussion is the thread based
multi-processing
now we will understand what exactly is a
threat so a thread is an individual
lightweight and the smallest unit of a
given process there are multiple threats
in a single process and each stroke is
independent of each other
so basically whenever you assign an
instruction to your processor it divides
the instructions into segments and all
these segments are assigned with a
single thread and the best part of using
threats is in case if one of your
threads is not operational or it is dead
then the rest of the threads will not be
affected your process will not be hurted
so that's the major advantage of
multi-threading we'll discuss all the
advantages in the upcoming parts now
after the definition we will understand
a little more about the thread
so basically threats are interdependent
sometimes you may have to switch between
one process to another process or you
might have to switch between one thread
and another thread so as shown in the
above figure the thread is executed
inside the process and there is context
switching between the threads there can
be multiple processes inside the
operating system and one process can
have multiple threads as well now moving
forward we will understand more about
the thread life cycle
so basically a threat life cycle is
decided in five different stages
so the first stage is the new next is
runnable after that running and followed
by running you either have to wait or
you can also send your thread into with
that state based on the requirements of
your process now we will discuss each
one of them in a bit more detail first
we will discuss about the new stage the
first stage in a thread is always called
the new stage in this stage the brand
new thread is created and is kept on
hold no process is allocated to it or it
will not start executing until a process
has been assigned to it after the
creation of the new thread the next
stage is the runnable stage it is where
a thread gets assigned to the process
and the threat is engaged it is ready to
get executed the next stage is where the
osr the process scheduler Begins the
execution of the process using the
thread and that stage is called as the
running stage once the process is
running it can continue in that stage
until the process gets finished or
sometimes it has to wait because of the
response that it needs from another
process that stage is called as waiting
and in case if the threat has finished
executing the process it can directly
enter into the dead State now we will
discuss what is waiting stage so as
discussed the waiting stage is where the
current thread is in the weight
situation as it needs a response from
another thread
there are two ways one it might have to
wait for the response from the other
thread and going to wait or it might
finish the execution stage and directly
enter into the test state so the death
state is the last stage where the thread
gets killed after the process execution
after the termination stage the thread
enters Into the Dead condition
now that we have understood the thread
and what is its life cycle let us
execute a simple program based on
multithreading as you can see on my
screen we have a simple program for
multi-threading here my class is
multi-thread and we are extending the
thread class to create threads into our
program now we are going to create three
simple threads that are thread a thread
B and thread C and all those threads
will be executing one single message
that is printing the thread is
operational message onto the print
console now let's directly execute this
program and see the output
so as you can see the program got
successfully executed and all these
three threads are activated and they are
executing the job of printing a simple
message
now let us move ahead and discuss the
advantages of using multi-threading in
Java
so following are the advantages of using
multi-threading in Java they are threats
can perform multiple operations at the
same instance and this will save a lot
of time multi-threading offers improved
throughput and multi-threading minimizes
the system resources and program
structure is really simplified and it
offers Superior application
responsiveness and finally it improvises
the communications between the different
processes in the project action
what is jdbc
jdbc is a tool or an application
programming interface that establishes a
connection between standard database and
Java application that intends to use
that database
need for jdbc
establishing database connectivity to
execute MySQL or SQL queries in ddl DML
commands View and modify data records
and one of the most important things to
look at when we're talking about a jdbc
and probably the most confusing part
where the devil's in the details is data
types in a jdbc
so when we start looking at the data
types and you're setting up your data
you have your SQL which is your VAR
character and your Java equivalent
java.language.string and you have your
bit in SQL in Java it's Boolean in SQL
is numeric
java.math.big decimal integer int real
float float float so there's no real
difference in job between a real number
and a float number your double is double
your binary is a byte data Java SQL date
so your date in java.sql date
and there's also your SQL timestamp
java.sql timestamp array java.sql array
reference
javasql.reference structure java.sql
structure character
java.language.string big integer long
and Java variable binary it's a byte a
club
and that's character large object and
then equivalent is
java.sql.club and then you have your
blob and SQL
which is a collection of binary data
stored as a single entity and the
equivalent in Java is going to be your
Java sql.blob
now if you're doing a lot of programming
I would suggest having a cheat sheet
there and then once you're up and
running you'll start to remember most of
these just because out of use
with the jdbc architecture
we're looking at the application then it
goes into the jdbc API so you have your
application your writing your Java
database connector API then that has a
manager underneath of it and then you
have your Java database connection
drivers and the drivers are the ones
that are transferring that whether it's
an SQL Server MySQL server the Oracle
database or different sources that use a
jdebc connection
jdbc environment setup
so when we talk about the environment
setup we have Java and your
environmental setup underneath of that
and setting up a job environment you
have to download the latest jdk set Java
to home and set your Java path so if
you're just using eclipse for the first
time or whatever IDE you're using to
program you want to make sure you have
that all set up and you have the current
jdk in there the Java development
package
and then with mySQL
setting up MySQL environment download
the latest MySQL workbench extract the
file run the setup file and that will
get you set up with your own MySQL on
your computer and MySQL registers with
your operating system so it's kind of
like a global variable when you start
accessing it and it's designed that way
because normally when you're using an
SQL or mySQL database it's installed on
a server so it makes sense that you want
it registered with the operating system
so it's accessed globally
steps to connect your jdbc
Step One Import your packages this
procedure is followed to make sure that
the relevant packages are readily
available for the API
step two load and register your driver
the imported drivers needed to be loaded
and registered for establishing a
connection between application and
database and if you remember in this
case we're doing the MySQL so we make
sure our MySQL driver is installed
and step 3 connecting database after the
first two steps the next stage is to
connect the database this can be done by
a git connection
step four writing a query
so now we're actually starting to get
into your scripting here we write in the
SQL command or query that we need to
execute if you're not familiar with SQL
it's good to have an SQL cheat sheet set
up once you start understanding how it's
put together you'll find that it goes
really quick and it's pretty fast to
learn but it is its own query language
and you do need to learn a number of the
main settings in poll language so you
know what you're doing
step five executing query now the query
from the API is executed using execute
query and we'll actually load that up
just as a string variable when we look
at that you'll see how that fits
together
step six processing result after step
five the system basically does two
things it processes an output and
retrieves the values from your query
and then step 7 closing statement the
result set and statement needs to be
closed explicitly and you'll find
there's two closing statements there is
your result set which is still pulling
from the database
and then step eight
which is we need to actually close
Closing Connection so the last stage is
to disconnect ourselves or the API from
the database so we no longer have that
open connection using resources
so we're going to jump into our Java
database connection example
and we're going to do that with what we
call the University database
let's start with a basic overview of
MySQL and you can go to
dev.mysql.com and you'll see here we can
look up more information they have the
download of the newest version
this is a full SQL database package and
some of these you can actually go in
there and if you're doing a database
management they can spread across up to
usually don't want to go more than five
servers but it is designed to go up to
five servers kind of set up with
terabytes of data in there
for a developer on the programming side
we usually want to install something
like MySQL locally so on my setup it
says no network connections it doesn't
auto start on the boot up of the
computer
and I have it locked down that way if I
use some kind of simple password or
something like that for one of my demos
it doesn't go anywhere no one can access
it
now another option to mySQL is also the
SQL Lite
uh and you can go to the
sqllight.org read more about it and
download it it has a couple limitations
that you're not going to see in your
regular your full scale MySQL Oracle or
SQL but most of it will transfer over
and so for a small project you can
actually use it as a backend for storing
your data you can also integrate it or
upgrade it into my SQL because most of
the SQL commands are the same
and when you go into the Mayas kill
which is a significant download versus
SQL Lite you can certainly go down to
downloads and then there's also the
connectors so Dev mysql.com download
slash connector slash J
and I bring this up because it depends
on how you set up eclipse
for your interface and your IDE and it
depends on what you need and how exactly
on your setup as far as the connectors
we'll look at that a little bit more
closer
in the MySQL it is an oracle based so
you'll have to set up an account if you
don't have one you have to log in it's
all free as long as you're not doing
like the Enterprise with all the support
and help on it you don't have to pay for
it it's an open source
now once you've installed
MySQL and if you do sqlite you're not
going to have these interfaces it'll all
be done from java code but once you've
installed MySQL it's going to add in a
terminal window and then also
the workbench which is just a nice gooey
interface for MySQL server
and we're not going to do anything with
the workbench you can play with it
certainly because a lot of times you
don't have the workbench installed on
your computer especially if the MySQL is
set up on a different server and you're
remote accessing it especially like if
you're in the classroom or something
like that they probably have sent you
your login information so you can get
into the shell quick note though is if
you do your own MySQL just note that I
kept this as a local host you can
actually see it down here root localhost
no outward connections and that's just
to protect my computer once you start
opening those you have to be aware of
your passwords and since I'm doing demos
I want to keep my passwords really
simple so that's not the focus of the
programming
I had to log out and relug back in So
once you've gone in there you should
have this a lot of times your interface
might be web-based if it's a remote
MySQL connection you're working with and
I'll prompt you for your username and
password in this case mine is on my
computer it automatically has me log in
as admin so I have full admin rights
and then we always like to start by at
least I do is show databases and these
are the current databases on here
um they have some different information
on them that is part of the basic setup
and some examples like sakila and world
are both example databases that
automatically load with mySQL
for this example we're going to create a
database
and it's going to be University we'll do
Capital there University
don't forget our semicolon
and time you can see how long it took
0.69 seconds and of course if we go show
databases you'll see now that there is a
university in there
and we want to go ahead and use the
University
that means that whatever we do any
commands that we have in here for tables
or whatever are now going to be going
into the university database
so now our database has changed
let's go ahead and zoom in let's see
here we go set okay a little bit more so
we get the nice big print so you can see
what I'm doing a little bit better
there we go all right so we're going to
go ahead and create our table
and this has all been prepared so I
don't have to go through and and redo it
all the time you'll see here we're going
to do create a table engineering student
and then we have student ID is an
integer not null Department variable
character 25 long first name last name
pass out year university rank primary
key
in creating this note a couple things
first we created a table engineering
students and we've gone ahead and
created the fields as part of the crate
setup here and the things I want you to
note is that we have our integer so our
student ID is an integer our department
is a variable character and it's 25 long
and the reason I say that that is really
important is when we flip back on over
here if you remember from our
there we go if you remember from our
data types here's our variable character
and in Java language that's a string a
string doesn't say hey it's only 25 long
and so you got to be a little careful
when you're pushing and pulling this
data especially when you're writing the
data from java into the SQL that you
check for that length of that string
and then the integer is of course an
integer and of course the other data
types you can see how they follow suit
but with variable character be very
aware of that that is a designated 25
characters long
and we're going to go ahead and insert
some data in here
we go we'll go ahead and insert into
engineering students values and this is
going to be the student ID and it's also
the primary key so keep in mind that
that is a unique value in there and then
we have CSE computer science engineering
Quran akaria 2018 1272 so there's our
pass out year 2018
and ranked I guess number
1272 I'm not sure where the um oh that's
the university ranking there we go
and then we have some prepared data
which I just went ahead and pasted in so
we have a whole bunch of individuals in
our database now
and we'll I mean it's the same line over
and over again insert into engineering
students values and then you have your
list of values
and we can see that by doing a simple
select
uh we'll do what's a star so it's going
to select everything one of our hot
characters if you're not familiar with
SQL get a set up on there and look it
over and you can also download a cheat
sheet from somewhere with all the
different commands in there
um I myself do a lot of Consulting and
so I'm always jumping around from one
platform to another if you're doing that
kind of work it's more important to
understand the limitations and the
advantages of different systems and then
you have your cheat sheets for putting
together stuff really quickly when you
need it
and you can see here the data we just
put in there there's our student IDs
Department first name last name pass out
year and University rank
we'll go ahead and do one query in here
real quick we're gonna we already did
one query we're gonna do two queries we
did select star from engineering and
then we're going to go ahead and select
student ID Department first name last
name so you can actually choose what you
select instead of doing the asterisks
um where student ID equals 10202
and when we go ahead and execute that in
here
oops
there we go you'll see that it Returns
the one individual with that student ID
here
so let's take this back into our Eclipse
because we're still doing the setup so
you have your MySQL server set up or you
did SQL Lite with a little bit different
setup going on there and let's flip on
over and see what's going on with
eclipse
so in Eclipse we're going to go in new
we'll start a new project
we'll call this jdbc
it's our jdbc project whoops
select a wizard I forgot where I was
going on there it's a Java wizard we're
looking for this project Java project
there we go and we're going to call this
there now we're in the right spot uh
jdbc package that way everything will be
bundled in there in the same package and
finish it
create all right so you can see right
here we have our new jdbc package we're
working with
now at this point there's a lot going on
as far as your options
if you set this up for doing database
management which I did not and I'm going
to show you the two different ways you
can go under windows and under
preferences
and in this list you'll see database
management and then you can just go in
there and set it up this way and it'll
pull in that information for your SQL
connections
now if you did not and you downloaded
the MySQL it does have an option to
download the Java connects which would
put it into wherever you installed that
at which is default under your C drive
program files
now on mine I didn't I downloaded the
connection separately and there's two
different ways we can go under project
and under the build project
give that a moment to come up
oops I mean properties here we go the
project properties and the Java build
path
this same window can be accessed by
right-clicking on your package we're
working on and then we can go down to
properties and you'll see the same
window opens up
and we're going to go under Java build
path
we're going under Library so these are
libraries we want to include in our
setup and then I click on our module
path and at this point you'll see add
external jars here now again if you
haven't already pre-set up any Clips you
can just add jars and it'll be in the
jar Library so there's different
possibilities there but I did a download
so I'm going to go add external jars
and I happen to keep mine on my D volume
under my SQL
and you'll see my SQL connector Java and
this is MySQL 8.0
and I just go in here oops there we go I
just go ahead and open this up and
you'll see right here it has my
connector Java once I set that in it's
now added those packages and there's
hundreds of actual sub-files in there
and it's all set to go and I can apply
and close this window and now I'm ready
to go ahead and start writing my script
and start building a program in here
and let's go ahead and go under Source
new and we'll go and put in a new class
in here and we'll just go call it jdbc
same as the package I'm going to finish
that
and we're set up with a new class in
here
and once we've got this set the first
thing we want to do is we want to go
ahead and import all of our Java setup
in here so we have the Java connection
and now we want to go ahead and import
it
and when we look at this we can see we
have our connection and remember two of
these have to be closed explicitly and
that's your connection and when you
create the statement
you have your driver manager so when it
goes in there that's the piece that
connects to actually does the connection
to the database the drivers that convert
everything and the code in there so you
have your connection to the database you
have the code that converts it you have
your result so you're going to get a
result off of your query then you have
your exception so if you have an error
throws or something like that that's
where that's going and of course the
actual statement that you're going to
send to the SQL Server
and of course we want our Java to be
able to actually run so we'll put our
main in there public static void Main
and it's going to throw the SQL
exception uh so you'll see right here
that's what we're working with and
there's our Java SQL SQL exception on
there
so the first thing we're going to need
on our setup let's put that in here is
going to be our connection information
we need to know the username and we're
just going to call it string you name
equals in this case I created a user
Richard underscore simply learn
and then I created a password my
password remember this is a local host
so you probably don't want to have a
simple password like that but Mike this
whole database is locked down on just
this computer there's no outside network
access or anything like that to get in
here and then of course this is a
separate user so it's not even my admin
or root user and then we go ahead and
put a query right here in this case
we'll start with our most basic query if
you remember we already did that on our
at the very beginning select star from
engineering students and we're going to
use that query in our code to start off
with
and then another really common thing
when you're setting this up
is that we also want to test it and see
hey did we import our package correctly
is it set up correctly so remember we
came in and we imported our my SQL
connector jar file
in the code we would just want to make
sure it's it's working correctly and
that's what this is it says try class
fourname and then it has our
com.mysql.cj.jdbc driver saying hey do
we have the driver for this that's all
that's doing
and if not then it's going to print an
error so we can find out why it doesn't
have that driver
and then next we want to actually start
getting into our actual code and in here
we're going to do a try because whenever
you do any kind of major connection you
want to make sure
that uh
you're looking for your errors you're
not going to miss on anything and we're
going to do a catch
and so we're looking for any kind of SQL
exception error
and for this demo we'll just do you know
print it out so oops wrong spot
uh it goes into the catch section there
we go uh so we'll print it out over down
here as far as the error on there and
it's an xql exception so still looking
for the code which we haven't put in
here yet
and this is really where the the magic
really starts to happen because we have
our um connection
and
there we go
and you'll see that the connection is
that's all this is right here here's our
connection up here
and we pop it down here we have a
connection we'll just call it Con
do one end so keep it uniform there we
go
and this is going to go to the driver so
in other words right here we're going to
go ahead and need a
the driver manager and that's where we
imported here it says git connection
because that's part of the driver
manager and we have our URL
let's see and we of course forgot to put
the URL in up above so let's go ahead
and go back there and put that in
and the URL comes out as a jdbc MySQL
that is registered with my computer so
my computer has when it's running the
MySQL this is the local host in this
case we call it University that's where
this comes from
and that's all part of your MySQL setup
if you're working with a remote database
you want to get this information from
the remote whoever set the database up
so that you have this particular line of
where to call
and so we go back down here we have our
connection it's all set up on here the
next thing we want to do is we want to
go ahead and create our statement
and this initializes it so we have a
statement called statement but this
statement is going to be based on our
driver manager which is then connected
to the connection so these are all
connected to each other and this
generates the format it needs for when
we actually send our inquiry remember
here's our query right here so we're
going to send select star from
engineering students for right now
um we haven't put that part in we're
just creating the class or initiating
the instance so that we can do that
and then once we've initiated the
instance here oops go down here
we need to go ahead and generate a
result and so we have our result set
again that comes up here from what we
brought in we're storing the data coming
in or storing the pipeline to bring it
in
we're just going to call that result and
then we have this is generated from our
statement here's our statement so this
is all like linked together here's our
execute query which is part of the
statement and here's the actual query
which is coming that we put together the
select star from engineering students
and then finally we want to actually do
something with our information so we'll
do is we'll just Loop through it while
and here's our result set that we just
generated so wall result
dot next
and this just generates a Boolean so it
says hey there's still another result
coming in so we need to go ahead and get
that next result
and we'll go ahead and create a
and we'll take that string University
data and then
we're going to Loop through the
different results
there we go integer and then here we go
University
data
and we want to tag on the end of it
result.getstring I
so what's going on here there we just
did a bunch of things uh we are going
through each row
result.next each row of data that comes
off of the database until this returns
null there's no next result coming in
there and then we come in there we look
at the result the one we're looking at
is the current one so it goes through I
forget how many we put in there about 20
those you know row 20 0 Row one row two
Row three row four and then on each of
these rows
we have a string it's an array of
strings
and we're going to get that string and
it returns I so this is get string of
column I
so we have row and column
and really important it is programming
to really understand rows and columns
because it's so Central to most of the
data processing going on
and then finally we want to go ahead and
see our results so let's print them out
we'll put in our nice print statement
system out print line University data so
this is going to print each row as it
goes through it and then I'll reset the
row again to an empty string and then
I'll add each of the columns to that Row
from our result and then we'll print the
next row out
and now that we have a complete code
let's go ahead and go up here hit the
Run button
it's going to compile it runs it out and
we can see down here let me just get my
double Mouse we can get a better View
here's our different uh your ID comes up
with their I forget what the actual
setup was but the CSE the name the date
the ranking all that prints out one row
at a time and that's what we're doing
here of course if you're processing the
data differently it might be loading
this into a user interface this might be
generating other information you may be
doing statistics with it but you can see
how it's set up in here as far as
pulling the data into the Java format
and then running it from there
just so we can get a quick glimpse of
where this goes let's go back up here
and we're going to flip back and forth
between a couple different screens so
let me do that
and here if you remember we did select
star from engineering students and
there's the same thing up here that we
got down here this is our MySQL server
interface and this is the interface we
built in Java
and from here we also did this
particular selection selects student ID
Department first name last name pass out
year university rank from engineering
students where student ID is
and we got the single row on here
and this is kind of interesting because
I switched something in the code here
where this could cause a problem it
won't on this one
let me go ahead and paste this in here
and we'll run and compile this one
and you see it comes out with the single
user
so the danger of this particular code
is that I went ahead and hard coded in a
loop for I equals one to six
and so this one we pulled it just
happened to be that we did selected six
different columns in here so you got to
be a little careful when you're coding
in here what are you pulling and where
is it going you can see if I take out oh
let's do we'll just remove the student
ID
and we're going to run that without the
student ID
you compile it there we go and it gives
us a bunch of Errors because it doesn't
see the we're short a column down here
so when it gets down to this code down
here
under the while statement
and it goes Hey where's number six well
there's no number six and so we get a
lot of errors on that
and you can see where queries let me
just go back up here and paste another
query in
there we go and we'll run this one and
we're looking at is we're going to go
ahead and do the same columns and
we'll just leave this as a star to make
it easy so we're going to select all
columns
from engineering students where the pass
out year is 2018.
just do a copy of that one
and we'll run that
recompiles
and you can see here's all the 2018 on
here if you look at the dates so they're
all 2018 and that's the same as our
query directly into the SQL Server if I
do the same thing on here you'll see
they're exactly the same
and just because we're having fun let's
flip this back over here and we'll do
one more SQL Server
and let's do in this one
let's see let's just take this whole
thing out here
and in this one we're going to pull in
all the Departments but I want the
minimal university ranking as the
highest from engineering students that
way we can get an order of the rankings
on here and we'll go ahead and run this
and there we go there's our minimal one
so this one hit the lowest ranking on
there or closest to number one
and we can do that in here and get the
same result uh there's Karen Karen is
awesome uh ranking Number 96 and you
sell these other people that are ranked
way below Quran so that's this guy must
be super smart
so that concludes our jdbc example
University database where we took a
quick look at MySQL server or you can do
SQL light in some basic queries you can
put in there and how that works
what exactly is Zam
well Zam as a One-Stop open source
cross-platform solution for multiple
needs in general it is considered as a
bundle of software utilities that
include an Apache server mySQL database
support for PHP and support for Pearl
this simple and lightweight solution
works on Windows Linux and Mac hence the
cross-platform part
now that we have a quick briefing about
zamp let us get started with the
installation procedure
so installing xamp is really simple all
you need to do is just Google download
samp and you'll see the first link and
just click onto it which will redirect
you into the Apache website here you can
see multiple varieties of Sam the first
one is for Windows second is for Linux
and the third one is from Mac now we
will select the windows version so here
we have the 7.2 version 7.3 and 7.4 so I
would suggest you to go with the latest
version that is a 7.4 you just need to
click on the download button and there
you go
you can see on the bottom left corner
that your software is getting downloaded
now this might take a while so I have
downloaded it on my local system
previously so let's get back to that and
start our installation procedure just to
save time
so I might want to cancel this
so let's get back to the download
section and there you go you can see the
zamp software which is downloaded here
so all you need to do is just run it
so just provide the permission yes
ignore this warning and just select ok
you can start the visit by clicking next
so here you can see multiple options for
Server programming languages Etc so you
have the varieties of servers such as
Apache MySQL Faisal Etc can't get you
never know which one you might need in
the future so I would suggest you to
just select all and same goes for the
programming languages
just select next so now you can see the
next dialog box where you're asked to
select the location for your software so
it would be better if you select the
default location that is C drive
just select next
and here you're asked to select the
different languages for your control
panel so let us select English
is a default option here now let's click
next
again and next
and now your software is ready to get
installed don't worry about this new
webpage which is popped up in your
screen
now let's get back to our setup file
now let's just select next to start with
the installation
and there you go you can see that zamp
is getting installed into your local
system
now this might take up a little while
all we need to do is just wait
anytime now the installation will be
finished
so there you go the installation is
completely finished now you can just
click on the Finish button and the
process will be finished
and there you go you can see your samp
control panel on your screen let's
maximize this for a better View
yeah that's good now you can see the
modules on your control panel which are
the Apache server mySQL database
filezilla server Mercury server Tomcat
server you can start any one of these
let's get started with Apache first to
start that all you need to do is just
select the start button
and you can see the Apache has just got
started and you can see the first one
was attempting the Apache app to get
started and then you can see the Apache
app state is changed to running now you
can see the process IDs of Apache server
as well as the port number which is 80.
now you have an option of configuring
your port numbers because what if in
future you may need to start tomcat and
Apache server parallely but in different
port numbers so to make sure that they
don't interfere with each other you can
configure them on different port numbers
to do so all you need to do is just open
config
and inside config choose the first
option that is Apache httpd.com
just scroll to the bottom
and now you can see the port number here
so just let us change it to 3000.
similarly here
and now select the file option and save
it
now let's try to restart our Apache
server stop it and then again restart it
and there you go you can see the change
of the boat number to 3000 and the
process IDs which are 9620 and 9868. so
this is how you install Zam server and
this is the complete procedure to
install xam server into your Windows
operating system
now Lambda Expressions were not there
along with Java since the beginning
there were an update to Java since its
eighth version Lambda expressions are
basically an advanced method of writing
methods to be simple
these Lambda Expressions can be used
inside a previously written method this
approach reduces the code length and
improvises performance to a greater
extent so we can Define it as follows a
Lambda expression is a short block of
code that takes in parameters and
returns a value Lambda expressions are
similar to methods but they do not need
a name and they can be implemented right
inside the body of any method now your
very first question is we had methods
then why do we need a Lambda expression
that could replace the conventional
method
so that's exactly where we understand
the need for Lambda expressions
now Lambda expressions are having some
impeccable features they are capable of
converting huge block of code into a
tiny argument now how cool is that now
coming back into methods when we need to
create a method we need to make sure
that it belongs to a certain class no
matter that we can create a method
without having to belong to any class
but that would be just access clients of
course lying in your project but when it
comes to Lambda Expressions a Lambda
function can be created without
belonging to any class
and finally
Lambda Expressions can be passed around
as if it was an object and can be
executed on demand
now how do they work and what is the
functional interface these will be the
next questions before that we shall
understand the syntax of Lambda
Expressions then slowly we will move
ahead into the functional interface
so followed by the need of Lambda
Expressions we enter the syntax of
Lambda expressions
now the syntax of Lambda Expressions is
something which is shown on the screen
right now now you might be wondering if
Lambda Expressions have three difference
in taxes no it's actually based on the
number of parameters we use
so the first syntax belongs to the first
type where we have absolutely zero
parameters
the second one is preferred when we had
one single parameter and the last one is
preferred when we had multiple
parameters
now do not worry about the number of
parameters used we shall execute
examples based on each and every type of
them to have a better understanding of
each type
now we enter the most important topic of
today's discussion which is the
functional interface
in Lambda Expressions functional
interface serves as a data type for the
Lambda expressions
it is represented by The annotation
called functional interface it mainly
consists of an unimplemented abstract
method
and when an interface is represented
using functional interface annotation or
basically a functional interface can
never have more than one unimplemented
abstract method inside it if you try to
declare more than one then automatically
we will face a compiler error so the
functional interface can be defined as
follows a functional interface in Java
is an interface that contains only a
single unimplemented abstract method a
functional interface can contain default
and static methods which do not have an
implementation in addition to a single
unimplemented method now that we have a
theoretical understanding of a
functional interface let's get into the
Practical mode where we will try to
execute some different examples based on
functional interfaces and Lambda
Expressions I hope so far everything is
clear now let's begin with the Practical
session
now we are in the Practical mode and we
are on Eclipse now let's quickly create
a project
let's name our project as Lambda
just finish it
and done
now we are having a Lambda project over
here and this is our source file now
let's quickly create a new package
so by default the name of the package is
same as the name of
project Lambda so it's okay not a
problem let's just finish it
now let's create a new class
so we have our class here now let's
quickly execute the code
as you can see this particular program
on my screen is an example for a button
click operation so what exactly this
program will do is it will create a
button on my screen and when I press
that particular button I'll be
displaying a message called hello world
welcome to Simply learn on my console so
this particular line on my screen is an
example for Lambda expression where we
are trying to execute a printer
statement using the Lambda expression
syntax now let's quickly try to execute
this program and see the output
so you can see that I've got the button
over here on my top left corner of the
screen if I just try to press this
button called click me I'll be printing
a message on my console which is Hello
World welcome to Simply learn
let's try that again
yeah that's how it works
now let's stop this button let's stop
this program and continue with the next
example
so this particular example is based on
both functional interface and also the
Lambda expression
so you can see this particular code
segment is represented using The
annotation called functional interface
so this is what I was talking about the
functional interface annotation which
represents a code segment that has only
one unimplemented abstract method
now let's try to quickly execute this
program so this particular code or
program is nothing complicated it's just
trying to print the area of a circle we
already have a pi value and we'll just
calculate the value of the area of the
given circle with a certain radius so
the radius will be taken as an input
from this particular code segment here
now let's quickly try to execute this
so you can see the program got executed
and the console is asking for an input
for radius now let's type in some random
input
let's input 15 as the radius now we
should be getting the area of
the circle with radius 15.
so which is around
706.83 units
I did not mention the
units here let's consider that as
centimeters so this is the square
centimeter area of the particular circle
with radius 15. and let's continue with
the next type of program now let us try
to execute the next example which is
based on the both function interface and
a Lambda expression that has zero
parameters so we discussed this before
Lambda expressions are three types with
zero parameters single parameter and
multiple parameters so this example is
based on zero parameters it doesn't have
any parameters it's just printing one
single message that is Hello World
welcome to Simply learn that's all
nothing more than that now after this
we'll try to execute another example
which is based on single parameter now
let's quickly run this program and see
the message
so there you go on the console we have
the message hello world welcome to
Centrelink now let's move ahead and try
to execute the next type which is the
single parameter one
so now you can see on my screen we have
another program which is based on single
parameter
so what we're trying to do is here just
we are sending a string of data which is
the name of a city and we are just
running through urgex and then we'll
find if the data given is valid or not
so the city name that we are passing
here is New York now let's just quickly
execute this program
and there you go we have the output the
value returned from Lambda is true so
the function that is info dot matches
worked perfectly now let's quickly get
into the next type of example where we
have multiple parameters
so as you can see on my screen we have a
small and simple example for multiple
parameters Lambda expression so the
multiple parameters that we will be
passing here are the values of X and Y
and these X and Y will be multiplicated
with each other so that will be getting
a product of these two numbers now we
have the functional interface which has
one unimplemented method which is the
float multiplication now let's quickly
try to execute this and see the output
so the value is passed by 100 200 and 25
so the respective product of those two
or those four numbers is been given here
so the product of 2 and 5 is 10 and the
product of 10200 is 2. 20 000
so that's how the program for multiple
parameters in a Lambda expression work
now let's try to continue with our next
example where we will try to print
multiple elements present in a list or
an array using for each Loop
as you can see on my screen we have a
small little simple program which is a
list and inside the list we have a set
of names of fruits and we're just going
to print these names of the fruits using
the forage Loop and inside the forage
Loop the control will run through a
Lambda expression which is simple print
statement now let's try to quickly run
this program and see the output
so you can see the program could
successfully execute it and the names of
the roots have been printed here now
let's try to execute one last program
based on Lambda Expressions where we
will try to use filter operation over a
collection
so as you can see we have our last
program on my screen so in this
particular program we have three
variables which is the ID of the bike
and the manufacturer name and on-road
price of that particular bike so what
we're going to do is we have three
particular variables here which is
Yamaha Bajaj and hero and the cost of
all the three bikes are different so
what we're going to do is apply the
filter operation and filter out the
bytes with on dot cost which is greater
than 80 000 so this is how it should
work now let's try to quickly run this
program
so you can see the program got
successfully executed and the bikes
having price greater than 80 000 up and
printed on my output console here so
with this let's continue with our next
topic so let us move ahead and learn the
major differences between the Lambda
expressions and the methods
so the first difference between the
Lambda expression on the method is the
Lambda expression doesn't specifically
need a name but whereas for a method
name is mandatory and the next
difference is Lambda Expressions may or
may not include parameters we have
already exceeded in an example based on
zero parameters and the third difference
is in a Lambda expression it does not
have to return a type but in the method
it specifically needs to have a return
type and the last difference between the
both is Lambda expression includes a
body as the main code segment whereas on
the other hand for a method code body is
just another code segment of the program
so these were the major differences
between a Lambda expression and a method
let us now enter into the next part
where we will understand the Lambda
expressions in the form of an object
so as discussed in the features before
Java Lambda expression is essentially an
object you can assign a Lambda
expression to a variable and pass it
around just as a normal object
moving ahead we have variable captures
a Java Lambda expression is capable of
accessing variable stick layer outside
the Lambda function under certain
circumstances Java lambdas can capture
the following variables they are the
local variables instance variables and
static variables each of these variable
captures will be explained as follows
first we will understand the local
variables
Java Lambda can capture the value of
local variable declared outside the
Lambda body now look at this Lambda
expression that implements Java Lambda
interface right now this Lambda
expression is only referencing to the
parameter value pass to it but we can
change it
as you can see the Lambda body now
references local variables Str which is
declined outside the Lambda body this is
possible if and only if the variable
being referenced is effectively final
meaning it does not change its value
after being assigned if the Str value
had its value change later then the
compiler would complain about the
reference to it from inside the Lambda
body moving ahead we have the instance
variable capture
a Lambda expression can also capture an
instance variable in the object that
creates the Lambda here is an example
for that
notice that the reference to this dot
val inside the Lambda body this captures
the name of the instance variable of the
enclosing Company ID object it is even
possible to change the value of the
instance variable after its capture and
the value will be reflected inside the
Lambda the semantics of this is actually
one of the areas where Java Landers
differ from Anonymous implementations of
interfaces an anonymous interface
implementation can have its own instance
variables that are referred via this
interface however a Lambda cannot have
its own instance variables so this
always points to the enclosing object
next we have the last type of variable
capture which is the static variable
capture
a Lambda expression can also capture the
static variables the static variables
are reachable from everywhere in Java
application provided the static variable
is accessible that is scoped as public
here is an example that creates a Lambda
which references the static variable
inside the Lambda body the value of a
static variable is also allowed to
change after the Lambda has captured it
again the above class design is spelled
nonsensical don't think too much about
that the class primarily serves to show
you that the Lambda can access static
variables followed by the variable
captures we have the method references
so method reference is used to refer
method of functional interface it has
Compact and easy form of land by
expression each time when you are using
Lambda Expressions just to refer a
method you can replace your Lambda
expression with a method reference
so there are three types of method
references available in Java Lambda
Expressions those are reference to a
static method reference to an instance
method reference to a Constructor
now with this we shall wind up our
session by Our Last topic which is the
best practices to be followed while
using a Lambda expression
so these are the few best practices to
be followed while using Lambda
Expressions the first one is prefer
using standard functional interfaces
functional interfaces which are gathered
in
java.util.function package satisfy most
developers needs in providing Target
types for Lambda expressions and each
method references each of these
interfaces is general and Abstract
making them easy to adapt to almost any
Lambda Expressions developers should
explore this package before creating a
new functional interface followed by
that we have use of functional interface
annotation annotate your functional
interface with functional interface
annotation at first this annotation
seems to be useless even without it your
interface will be treated as functional
as long as it has just one abstract
method but imagine a big project with
several interfaces it's hard to control
everything manually an interface which
was designed to be functional could
accidentally be changed by adding of
another abstract method rendering it
usable as a functional interface but by
using the functional interface
annotation the compiler will trigger an
error in response to any attempt to
break the predefined structure of
functional interface so it is also very
handy tool to make your application
architecture easier to understand for
other developers so followed by that the
next best practice that you can follow
is to not overuse default methods and
functional interfaces we can easily
default methods to the functional
interface this is acceptable to the
functional interface contract as long as
there is only one abstract method
declaration
so followed by that the next best
practice that you can follow is to
instantiate functional interfaces with
Lambda Expressions the compiler will
allow you to use an inner class to
instantiate a functional interface
however this can lead to very verbose
code so you should prefer using Lambda
expressions and the final best practice
that you could follow is avoid
overloading methods with functional
interfaces as parameters session so the
first question what exactly is a servlet
now imagine you're searching for some
information on the internet
you open your local browser and start
typing it this question from you to the
internet is called as request
so further this request is sent to the
cloud or in technical terms your browser
sends your request to the respective
server responsible for storing for that
particular information and helps you
with it when requested now the server
gets triggered with your request and in
written it helps you back with
information you have requested for this
answer from the server is called the
response so this is how the request and
response work in a server for this
process to happen so smoothly and
effectively we need a servlet digging a
little deep into the server we find the
component responsible for such an
effective job it is called the servlet
container that holds Java based web
application and a set of individual
components called as servlets now we are
close to our answer so this particular
Java based component takes care of web
request and response to sum it up with
the form of a definition we can Define
it as follows
a servlet is a Java program that runs on
the Java enabled web server or
application server they are used to
handle the request obtained from the web
server process the request produce the
response and then send a response back
to the web server now hoping that it was
a clear explanation can we move ahead
with the next topic
so the next topic we have is
so how does the servlet work in reality
or more practically or in depth what's
the life cycle of a servlet
so the life cycle of a servlet in real
time has the following stages
these stages are the ones that a Java
servlet actually follows in real life to
get our work done so the stages are in
IT service
and
the current operations which are the get
post put delete and finally destroy now
let us understand each one of them in a
bit more detail the first one is the
init process
the init method is called only once it
is called only when the servlet is
created and not for all the requests
afterwards so it is used for the one
time initializations just as with the
init method of applets the servlet is
normally created when a user first
invokes a URL corresponding to the
servlet but you can also specify the
servlet is loaded when the server first
started when a user invokes a servlet a
single instance of each servlet gets
created with each user request resulting
in a new thread that is handed over to
the do get or do post as appropriate the
init method simply creates or loads some
data that will be used throughout the
lifecycle of a servlet followed by the
init method we have the service method
so what is service method surface method
is the main method to perform the actual
task the servlet container that is the
web server calls the service method to
handle request from the client or the
browser and to write the formatted
response back to the client each time
the server receives a request from the
servlet the server spawns a new thread
and calls service
the service method checks the HTTP
service type and accordingly performs
the crud operations which are the get
post put delete Etc and calls do get do
Post do put do delete Etc methods as
appropriate
the service method is called by the
container and service method inbox do
get do Post do put and do delete Etc
methods as appropriate so you have
nothing to do with service method but
you override either with do get do post
and other types depending on what type
of request you receive from the client
so this is how the init and service
methods work now digging a little deeper
we have the do get do Post do delete and
do put methods so first we will discuss
about do get method so what exactly does
a do-get method do a get request results
from a normal request from a URL or an
HTML form that has no method specified
and it should be hardly by do get method
followed by do get we have do post a do
Post request results from a HTML form
that specifies list post as the method
and it should be handled by do Post
method similar to to get and do post the
do put and do delete options are usually
used to update and delete the data when
asked by the client so to some of these
do get do Post do put do delete we can
consider them as crud operations so do
get basically gets the information what
you're looking for do Post method
usually post the information or provides
you with the response from the server
and followed by that we have the do put
which is usually used to update the data
which is present on your server and
finally delete which is used to delete
an existing data on your server so this
can be considered as crud operations
finally we arrive at the last method
which is the destroying method the
destroy method is called only once at
the end of the life cycle of a servlet
this method gives your servlet a chance
to close database connections halt
background threads right Cookie list or
hit counts to the disk and performs
other such cleanup activities so with
this we finish up the life cycle of a
servlet now we shall understand its
architecture
basically the architecture of a servlet
can be understood by reverse engineering
the life cycle of a servlet so this is
how the server execution takes place
when a client or a browser makes a
request to the web browser
so the servlet architecture includes the
following first one servlet interface
to write a sublet we need to implement
the servlet interface servlet interface
can be implemented directly or
indirectly by extending generic servlet
or HTTP servlet class
followed by that the next part is
request handling methods as we have
discussed before there are mainly three
methods defined in servlet interface
which are init service and Destroy and
inside service we have do put do Post do
get and do delete methods the first time
a servlet is invoked the init method is
called it is called only once during the
life cycle of a servlet so we can put
all your initialization code here the
service method is used for handling the
client request as the client request
reaches the container it creates a
thread of sublet object and request and
response object are also created these
requests and response objects are then
passed as parameter to the service
method which then processes the client
request the service method in turn calls
the do get do Post methods if the user
has extended the class from HTTP servlet
and lastly the creation of instances
this is based on the load of the servlet
so with this we have finished the
architecture of serblet moving further
we shall quickly discuss the features of
servlets and then enter into the
Practical mode
so the following are the features of
java servlets the first feature is Java
servlets are portable in nature as I
have mentioned above the servlets use
Java as programming language since Java
is a platform independent programming
language the same holds true for
servlets for example you can create a
servlet on Windows operating system that
uses glassfish ASM web server and then
later run it on any operating system
like Unix Linux and Apache Tomcat web
server this feature makes tablet
portable and this is the main advantage
of servlet over CGI we shall discuss all
the differences of CGI versus servlet in
the next section for now we will discuss
the features followed by the first
feature we will now enter into the
second feature which says Java servlets
are efficient and scalable once a server
is deployed and loaded onto a web server
it can instantly start fulfilling the
request of the clients the web server
invokes servlet using lightweight thread
so multiple client requests can be
fulfilled by servlet at the same time
using the multi-threading feature of
java compared to CGI where the server
has to initiate a new process for every
client request the servlet is truly
efficient and scalable the next and the
final feature of java servlets is they
are robust and highly secure by
inheriting the top features of java such
as garbage collector exception handling
Java security manager Etc the servlet is
less prone to memory management issues
and memory leaks this makes the
development of web applications and
serverless secure and less error prone
so these were the important features of
java servlets now let us enter the
Practical mode
so we are in the Practical mode right
now there were two parts in the
Practical mode the first one was to set
up the environment for Java servlets and
the second one was to execute a basic
program
so this document has the following steps
to follow
that is the prerequisites before
executing a Java servlet program
so we have these prerequisites where we
have to set up Java home
and the Java path followed by that we
need to set up the home and path for JRE
which is the Java runtime environment
and finally Catalina home and path so
Catalina home and path is nothing but
the Tomcat server home and path now we
will set up these things by using the
environment variables now I'm using a
Windows operating system so I'll be
using the control panel to enter the
environment variables
there you go you have edit environment
variables
so inside that just select environment
variables and inside this you can see
that I have already set up the
environment variables for Catalina home
Java home and JRE home so now let us
just select Java home and edit it so
that we can see how did I set it
so you can see I have named the variable
name as Java home and inside the
variable value I have a location so this
location is nothing but the Java jdk
location in my local system
now followed by that we have JRE home so
similar to Java home we have set up the
JRE home as variable name is equals to
JRE home and the variable value is the
location of GRE folder in my local
system so I have my JRE folder in my
local system at C drive program files
Java JRE
and similarly the Catalina home which is
inside my program files Apache software
foundation and Tomcat 8.5
so similarly we'll also check up The
Path variables so inside system
variables you can see the path just
edited so then you can see the path
variable set for Java JRE and Tomcat
now just select ok
OK and finally another okay now your
prerequisites have been set up so this
is how you set them so in case if you
have doubts about the Tomcat version to
download then I'll help you with that
just open Google
and type in Tomcat download
so now you have entered Apache Tomcat
official site and since I'm using a
Windows operating system I'll be
selecting the 32-bit or 64-bit Windows
service installer version
and after this gets downloaded you need
to set up the home and path variables
for Catalina server
so once after the environment is set up
you need to follow four stages to create
a servlet program which are creating a
dynamic web project create a servlet add
servlet API jar file and run the servlet
so to create a dynamic web project you
need to select new and inside that you
have the option of other just select
other and inside that you will be
finding web
so select web and inside that you need
to select the dynamic web project and
select next
so you just need to name to your Dynamic
web project so I'll be naming a server
and then select next
and inside that you have a source folder
and now you can select finish
now there you go Java Eclipse will ask
you for opening this particular in Java
ee perspective then just select open
perspective
now basically Java will set up
everything you need here and there you
go you can see Server folder here which
has already set up everything you need
now what you need to do is set up a new
servlet so right click this and select
new
and inside that you can see the option
of solve it just select it
now you can see a new dialog box and
here you need to set up the class name
for now let's just type in hello and go
to next
now again next
and in here we have a lot of options so
for now we are just executing a basic
program so let's just select do get
method now let's just finish it
and there you go a servlet has been
ready so this is the basic template
created by eclipse for you now next we
need to add in the build path so for
that you need to right click the server
and then
select build path
and here configure build path
from here you can add the external
Library select the external libraries
option and you can see I have the Tomcat
libraries here just select all and open
and that's how you add all the required
libraries of Tomcat server now apply and
close
now the last step is to execute the
project now just to save time I have
already typed in the program
which is over here
now let's try to execute this
this program will just provide us a
simple output which is none other than
hello world
now the server I have choose the
stormcat server
let's finish it
so there you go the message has been
displayed successfully hello welcome to
Simply learn
now we'll move ahead with our next topic
now that we are done with the
environment setup and the basic example
let us now discuss the advantages and
disadvantages of using Java servers
so first we will discuss the advantages
the following are the advantages of
using servlets in Java servlet is
convenient and modifying regular HTML we
can write the servlet code into JSP
servlets include the feature of
multi-threading of java we can make use
of exception handling of java servlets
have a separate layer for business logic
in the application and finally it is
easy for developers to show and process
the information so these were the
advantages of using servlets in Java
moving ahead we will discuss the
disadvantages of using servlets so
following are the disadvantages of using
servlets in Java designing a servlet is
considered as a little complicated
so let's often slow down the application
business logic of servlet is difficult
to understand we need a GRE which is the
Java runtime environment on the server
to run a servlets and finally the data
connectivity is a little complicated so
these were the major disadvantages of
using servlets and Java moving ahead we
will understand CGI why are we learning
CGI because even CGI is similar to
serblets and it also does the web
interactive job similar to servlets so
thought you should know about some
basics of it so let's understand its
definition and architecture real quick
so the CGI or common Gateway interface
is a standard for writing programs that
can interact through a web server with a
client running on web browser these
programs allow a web developer to
deliver Dynamic information usually in
the form of an HTML via the browser a
CGI program can can be written in any
language including Java that can be
executed by your web server CGI programs
are commonly used to add search engines
guestbook applications database query
engines interactive use of forms and
other interactive applications to
websites in very basic terms a CGI
program must interpret the information
sent to it process the information in
the same way and generate response that
will be sent back to the client most of
the input of CGI program is passed into
through environment variables so with
this we will move ahead into the
architecture of common Gateway interface
so you can see the architecture of
common Gateway interface is completely
similar to serblet normally the request
is sent in the form of an HTTP request
so this particular HTTP request is
divided amongst the CGI shells and it
will be processed by the CGI shells
based on the program provided and the
response sent to the user now moving
ahead we shall understand the
differences between the common Gateway
interfaces and the servlet so the first
difference is the common Gateway
interface scripts are executable codes
written in Native operating system while
on the other hand the servlets are
written and run using the Java virtual
machine the next difference is the
common Gateway interface performance is
considered to be low compared to
servants on the other hand servers are
having high performance compared to cgis
the third difference is for a common
Gateway interface it is hard to switch
between different platforms that is the
operating system platforms when we come
into servlets the serverless are
considered to be completely platform
independent
followed by that the common Gateway
interface scripts are directly executed
so on the other hand servlets are
translated into byte code because the
servlets are executed using the Java
virtual machine and in Java virtual
machine whatever the code you transfer
it will be converted into bytecode first
then execute it and the last difference
is the common Gateway interface is not
portable and on the other hand we have
the Java servlets to be completely
portable so these are the major
differences between the common Gateway
interface and Java servlets now let us
understand the Java servlet's requests
and responses so first we will deal with
the request phase in request we have
various types the first one is being the
HTTP request the HTTP object is used to
represent the HTTP request to a browser
that the user sends to the web
application thus anything the browser
sends is accessible through the HTTP
request followed by the HTTP request we
have the request parameter the request
parameters are the parameters that are
sent from the web browser along with the
request the request parameters are
typically sent as a part of the URL or
as a part of the body of an HTTP request
followed by the request parameter we
have the request header the request
headers are the name value pairs sent by
the browser along with the HTTP request
the request headers contain the
information about the web browser
software being used what type of files
that the web browser can receive Etc
followed by the request header we have
the input string if the browser sends an
HTTP post request request parameters and
other potential data is sent to the
server in the HTTP request body it
doesn't have the request parameters that
is sent in HTTP request body it could be
pretty much as the data like file or
soap request the next one is the request
session the session object can hold
information about a given user between
the requests so if we have set an object
into the session object during one
request it will be available for you to
read during any subsequent request
within the same session time scope
followed by the request session we have
the servlet context the servlet context
contains the metadata related to the
application followed by sublet context
we will enter the response phase in the
response phase we will deal with the
first one which is the HTTP response the
satp response object is used to
represent the HTTP response to your
request a web application sends back a
response page to the user as a response
to the HTTP request from the browser
sent to your web application followed by
the HTTP response we have the right HTML
to initiate the process of sending the
HTML back to the browser you need to
retrieve the print writer from the HTTP
response object this can be done using
the right HTML followed by the write
HTML we have the the response header
similar to http request the HTTP
response includes headers as well these
are responsible for all the data written
in the response followed by response
header we have content type the content
type header is responsible to tell the
browser about the type of content you
are sending in the return
followed by content type we have the
content length the content length header
is responsible for telling youth about
the number of bytes your server is
sending you in return followed by
content length we have redirection
redirecting will help you to redirect
yourself to the different web page from
the current one so these were the HTTP
requests and responses in Java servlets
now we will enter the next part where we
will deal with the session tracking and
cookies so first we will understand
session tracking session simply means a
particular time of interval session
tracking is a way to maintain state or
data belonging to a user it is also
known as session Management in serblets
HTTP protocol is stateless so we need to
maintain State using session tracking
techniques each time the user requests
to the server the server reads the
request as a new request so we need to
maintain the state of a user to
recognize a particular user you can
understand this in a better way by
looking at the pick picture showed on
the presentation each time you send a
request you will be receiving a response
from the server as well as this
particular request will be recorded as a
state in order to recognize you as a
particular user now after session
tracking we will enter into cookies
cookie is a small piece of information
that is persisted between multiple
client requests a cookie has a name a
single value and optional attributes
such as comment path and domain
qualifiers a maximum age and a version
number by default each request is
considered as a new request in cookie
Technique we add a cookie with response
from the server so cookie is stored in
Cache of a browser after that if the
request is sent by the user the cookie
is added with a request by default thus
we recognize the user as an old user
there are two types of copies they are
non-persistent cookie and first Western
cooking let's understand non-persistent
cooking first a non-persistent cookie is
valid for a single session only it has
removed each time when the user closes
the browser now let us understand the
persistent copy the persistent copy is
valid for multiple sessions it has not
removed each time when the user closes
the browser it is only removed when the
user logs out or signs our front browser
so before we begin with what exactly is
a Java API we will understand what Java
is
so basically Java consists of two major
components that are Java runtime
environment and Java development kit so
when we get into Java's API we might
want to dig a little deep into Java's
development kit
so jdk consists of three more major
components that are the Javas compiler
Java virtual machine and apis now we
will learn each one of them in a bit
more detailed way so at first we have
the Javas compiler so Java compiler can
be defined as a software program that is
designed to convert the high level that
is the user return or user readable code
into the computer readable code that is
the Machine level or bytecode so this
particular byte code will be transferred
to the next state where we find the jvm
so what is jvm so jvm is an abbreviation
for Java's virtual machine so Java's
virtual machine is responsible for
processing all the bytecodes and
providing an output to the user
next we find our topic for today's
discussion that is the Java API so just
like Java's virtual machine and compiler
Java's apis are the integral software
packages that come with the gtk the
primary intention of API is to establish
Communications between different
applications
so on my screen you can see a pictorial
representation of java apis architecture
so at first we have the Javas program on
the topmost layer so this particular
segment will be having the user return
program and user language
followed by that we have The Interpreter
Javas API and the Javas virtual machine
which are responsible for reading and
compiling the Javas program so at the
last final level we have the application
Hardware which is responsible for
interacting to the Javas program so this
is how the Java apis architecture looks
like now followed by this let's dive
into the next topic
so in the next topic we find the types
of developers using various types of
apis for different jobs
so at first we have the open developers
next we have the internal developers and
at last we have the partner developers
don't worry we will understand each of
these developers in a bit more detail
and along with some examples for a
better understanding
so at first we have the open Developers
so open developers are used by top-end
companies so leading companies provide
access to their apis as open source
through authentication via a unique
secret key to keep track and ensure the
legal usage so basically what happens
here is there might be some big
companies like social media companies or
some other companies which provide the
APF they use for their applications as
open source to the developers so these
open developers get access to their apis
through getting Authentication
so they'll be creating a profile they'll
be providing the research details of
their application like what are they use
in that particular API for and other
reasons to use those apis then they get
the unique secret key from the owner of
that API and that's done just to keep
track that the API provided is not
misused so the open developers majorly
include the b2c teams and some of the
major companies that provide the apis
for open developers are Twitter and
telnex so one best example is the
Twitter where the Twitter provides
Twitter API for the Twitter developer
accounts for using that for any kind of
developing things or some data science
applications and much more so followed
by the open developers next we have
the internal Developers
so you can consider internal developers
as an organization so the internal
developers belong to a specific
organization and work in a close
environment these apis run with a high
security that can establish
communication between the application
and the application Hardware so only the
internal developers that is the
developers belonging to that particular
organization have the access to that
particular API so this particular type
of apis run on a high security level
so internal developers majorly include
b2c teams B2B teams a to a teams and b2e
teams
so some of the major companies that
provide the internal apis are Instagram
Google mail and Google Cloud virtual
machines
next we have the partner apis
partner developers are similar or like
internal developers but the only
difference is there is a collaboration
between two or multiple companies for
example consider yourself to be linked
with a different company and you both
wanted to create an application so only
you both can have access to that
particular API that you are using to
create your application
the partner developers majorly use the
b2c teams and the major companies
providing the partner apis are Microsoft
and finasterra so with this we finished
the first topic that was what is API and
who exactly uses it and for what
purposes now we'll dive into the next
segment where we learn the need for Java
apis
so why exactly we need Java apis now
Java apis are used for multiple reasons
but the three most important reasons for
which we use Java apis are to streamline
the operations improvise the businesses
and finally create some powerful
applications we will discuss each one of
them in a bit more detail
so the first one is to streamline
operating procedures we have multiple
social media applications like Twitter
Facebook WhatsApp Etc followed by that
we have multiple delivery applications
such as Amazon Flipkart then we have the
FNB such as zomato 3D Etc so all these
applications are running smooth and
hassle-free because of the significant
Improvement in the implementation of
java apis by using Javas apis users are
provided with multiple options on the
screen so this kind of approach makes
the functionality very simple and easy
to use
followed by this the next important
requirement is to improvise the business
introducing apis to the public leads
many companies to release private data
to generate new ideas fixing existing
bugs and receive new ways to improvise
operations the Twitter developer account
is an example for API that gives
programmers private API keys to access
Twitter data and develop applications
followed by that we have the third one
which is to create the powerful
applications online banking has changed
the industry forever and apis offer the
customer's ability to manage their
finances digitally with complete
simplicity so this is made possible only
by the use of apis now followed by this
we will dive into the next topic where
we understand the types of java apis
so basically there are four different
types of apis in Java
they are public private partner and
composite we will discuss each one of
these apis in a bit more detail at first
we will deal with the public API
so what are Public apis public means
open so public or open apis are Java's
apis that come with the jdk and they do
not have any strict restrictions about
how developers use them
so followed by the public apis we have
the private apis
so the private or internal apis are
developed for a specific organization
these particular apis will be accessible
through the authentication by only the
employees belonging to that particular
organization so followed by private apis
we have the partner apis
so similar to private apis even partner
apis are having some authentication
process to use so the only difference is
here instead of one organization we
might have two or multiple organizations
and the employees belonging to that
particular group of organizations will
be able to access the apis and Implement
them or use them
followed by partner apis we have the
last one which is the composite API
composite APS are microservices and
developers fill them by combining
several service apis now that we have
covered the different types of apis let
us now discuss the categorization of
java apis based on the services that
different varieties of apis in Java
provide
so data and API services are another way
to categorize Java apis other than the
previous type which is the public
private partner and composite if apis
are also classified based on their data
manipulation capabilities and the
variety of services they offer so this
type of categorization has four
different types which are the internal
API Services external API Services crud
operations and user interface Services
we will understand each one of them in a
bit more detail at first we will
understand internal API Services
internal API services are developed to
offer organizations Services specific to
that particular organizations
these Services include only complex data
operations and internal processes
followed by internal API we have the
external API external API are open
source apis that developers integrate
into existing application or website so
internal apis are something similar to
private apis and externals apis are
something similar to public apis next we
have the crud operations so cred apis
provide data manipulation operations
over various data storage units such as
software and service that is SAS and
relational database Management systems
such as rdbms using standard data
storage unit connecting tools like
database connectivity that is jdbc ETC
next we have the user interface Services
user interface service apis are open
source apis that allow developers to
build user interfaces for mobile devices
computers and electronics now let's
examine the rules and protocols that
Java apis must follow
so that brings us to API service
protocols
the rules and protocols guide the
different functionalities of java apis
so different apis have different service
protocols let's consider an example for
restful API service protocol as an
example so for a typical restful API
developers must follow the following
rules for a typical restful API
developers must follow these rules
stateless uniform interface client
server cache layer no worries we will
discuss each one of these protocols in
detail first we will discuss stateless
so what exactly is stateless
so since the restful API follows client
server architecture by default it is
recommended that restful API services to
be stateless all the client
next we have the uniform interface the
entities in a restful API are server and
clients applications that run on global
scale need uniform client and server
interface through hypertext transfer
protocol or HTTP and uniform resource
identifiers URI will allocate the
required resources next we have the
client server
the client server model used in the
restful API should be fault tolerant
both the client and server are expected
to operate independently the changes
made at the client and should not affect
the server and vice versa
next we have the Kish including a cache
memory allows the application to record
intermediate responses and run faster in
real time a restful API also includes
the cache memory and next we have the
layer
a restful API is built using layers
layers of API are Loosely coupled or
independent from each other each layer
contributes a different level of
hierarchy and also supports
encapsulation next we will go through
some frequently used apis
so this is the list of most frequently
used apis in real time so we have web
API Facebook 4G Twitter 4G Android API
Java Advanced Imaging Java data objects
and you can also see the acronyms for
them in the right column so some of them
have no acronyms and some of them have
acronyms for example we have Android API
as Google Java Advanced Imaging sjai
data objects as jdo Etc so moving into
the next slide we have a few more apis
so we have restful apis Java media
Frameworks Java persistent apis Javas
speech API Java 3D Java USB for Windows
Etc and similarly on the right column we
have their acronyms so for Java media
Frameworks we have jmf for SQL apis we
have nothing and Java 3D we have j3d
Java speech API as JS API and few others
so followed by this we will advance into
the next topic where we will discuss
about the advantages of using Java's
apis
Now using Java's apis will help you with
multiple advantages now we will discuss
the most important advantages of using
Javas apis
so the first one we have the extensive
SQL support apis in Java enable a wide
range of SQL Support Services in users
applications through a component based
interface
next we have applications apis and Java
provide effortless access to all of an
application's major software components
and easily deliver services
next we have efficiency
Java's apis are highly efficient because
they enable rapid application
development also the data that the
application generates is always
available online
next we have the automation API allows
computers to automatically upload a
download update and delete data
automatically without human interaction
followed by that we have integration
Java apis can integrate to any
application and website and provide a
fluidic experience with Dynamic data
delivery
followed by that we have scope Javas
apis make websites application and
information available to a wide range of
users and audience
followed by that we have customization
Java APS enable developers and
businesses to build applications that
personalize user interface and data and
finally we have the adaptability Java
apis are highly flexible and adaptable
because they can easily accept feature
updates and change to Frameworks and
operating systems what exactly is Java
Enterprise Edition
the Java ee stands for Java Enterprise
Edition which was earlier known as j2ee
and is currently known as jar kataka EE
the Java Enterprise Edition provides a
platform for developers with Enterprise
features such as distributed computing
and web services now let's move further
and understand why exactly we needed
Java Enterprise Edition we needed Java
Enterprise Edition for four major
reasons to have powerful API support to
reduce development time to reduce
application complexity and finally to
improve the application performance so
followed by the need for Java Enterprise
Edition we will move ahead and
understand the Java Enterprise
specifications so in the Java Enterprise
specifications we are going to discuss
the four major specifications used by
Enterprise developers so the first one
being the Enterprise specification
followed by that we have a web
specification then we have web server
specification and finally some other
miscellaneous specifications we shall
discuss each one of them in detail
firstly we will move ahead with
Enterprise specification so in
Enterprise specification we have the
first one to discuss that is the context
dependency injection the context
dependency injection provides a
container to inject dependencies as in
swing next we have Java Enterprise Java
Bean the Enterprise Java bin is a set of
lightweight apis that an object
container possesses in order to provide
transactions remote procedure calls and
concurrency control
followed by Java bin we have Java
persistent apis so the Java persistent
API are the specifications of object
relational mapping between relational
database tables and Java classes next we
have the Java transaction API it
consists of java interfaces and
annotations to establish interaction
between Java transaction support offered
by Java Enterprise Edition the apis in
the abstract from low level detail to
the interfaces are also considered as
low level followed by Java transaction
API we have the Java servlet the Java
servlet specifications Define how you
can manage HTTP request either in a
synchronous or asynchronous way
so followed by Java transaction API
which is one of the Enterprise
specifications we will move ahead into
the Java web specifications
so the first one in the Java web
specification is the Java servlet so
this specification defines how you can
manage the HTTP request either in
asynchronous or asynchronous way it is
low level and other specifications
completely depend on it so followed by
Java servlet we have the Java websocket
so the Java websocket is a computer
communication protocol and this API
provides a set of apis to facilitate
websocket connections
followed by websocket we have the Java
server faces so the Java server faces is
a service which helps in building
graphical user interface out of the
components so followed by Java server
faces we have the unified expression
language the unified expression language
is a simple language which was designed
to facilitate a web application
developers so followed by the web
specification now we will enter the web
service specification out of which we
have the first one which is the restful
web service so the Java restful API web
service provides services having
representational State transfer schema
next we have the Json processing
Java API for Json processing is a set of
specifications to manage the information
provided in a Json format followed by
Json processing we have Json binding so
the Java API for Json binding is a set
of specifications that provide for
binding or passing a Json file into Java
classes next we have the XML binding so
XML binding simply allows for binding of
XML into Java objects for example soap
is an XML based protocol to access web
services over HTTP this API allows you
to create soap web services so followed
by the web service specifications of
java Enterprise Edition May finally
enter into the other miscellaneous
specifications of java Enterprise
Edition sort of that the first one is
the validation so the validation package
consists of various interfaces and
annotations for declarative validation
support offered by Bean validation API
in Java followed by validation we have
the batch applications so the batch
applications provide the means to run
long-running background tasks which
involve large volume of data and which
need to be periodically executed
followed by batch applications we have
Java Enterprise connector architecture
so the Java Enterprise Edition connector
is a Java based technological solution
for connecting Java service to
Enterprise information system so with
this we will enter into our next step
where we will learn the system
requirements to install Java Enterprise
Edition so the basic requirements to
install Java Enterprise Edition into
your local system are you should be
having the Java virtual machine from the
standard 6 Edition or more followed by
that your local system should be having
at least 1GB of ram capacity next your
system should be having at least 250 GB
ROM space available and finally you
should be having the Java development
kit installed into your local system
now next we will understand how to
install Java Enterprise Edition into
your local system
so in short these are the steps you need
to follow to install Java Enterprise
Edition into your local system first you
need to browse into the Oracle official
Java site then go to Java standard
edition development kit followed by that
accept the license terms download the
jdk file run the jdk file as an
administrator in your local system then
set up the Java environment I know this
looks a little bit complex but don't
worry I will drop a link in the
description box below which will explain
you in a much detailed way how to
install Java into your local system
please check that to have a better
understanding of how to install and set
up Java in your local system so followed
by this we will learn the differences
between the Java standard edition and
Java Enterprise Edition
so the first difference between the
standard edition and the Enterprise
Edition is the standard edition provides
basic functionalities like defining
classes and objects whereas Java
Enterprise Edition mainly focuses on
high-end and corporate type of java
applications
the second difference between the both s
Java Standard Edition comes with only
the standard specifications which will
be used by a beginner and similarly on
the other hand Java Enterprise Edition
comes with some Advanced specifications
which support web applications and
servlets the third difference between
the both is the Java Standard Edition
comes with features like class libraries
and deployment environments whereas the
Java Enterprise Edition has structured
application with the clients business
and Enterprise layers the fourth
difference between the both s
the Java standard edition is used for
desktop and mobile application
developments whereas on the other hand
the Java Enterprise Edition is used
mainly for development of web
applications the fifth the difference
between the both is the Java standard
edition is preferred and used by
beginners and on the other hand the Java
Enterprise Edition is preferred and used
by experts in Java field
the sixth difference between the both is
the Java standard edition does not have
authentication whereas on the other hand
there are strict rules and regulations
to be followed when using Java
Enterprise Edition related to
authentication the problems in
Enterprise application development would
serve it in JSP serve it in code are not
usable web designing tools can be used
in case of servlet parallel development
is not possible to solve the problems
and Microsystems introduced a two design
patterns for developing Enterprise
applications model 1 paid Centric model
and model 2 MVC
so here we have a request coming in
to the JSP page the request is forwarded
to the Java bin so that the object can
be created it connects to the Enterprise
server or data source and then the
response is generated to the browser
request is sent by browser and received
by JSP Java Bean object is created and
business methods are called if required
it communicates with the databases to
get the required data GSP then displays
the process data to the end user
there is no clear separation of
responsibility JSP access both
controller and View and the business
logic is separated using Java beam
so now here you can see that the request
comes to the servlet which access the
controller the servlet can
actually connect to the model Java bin
which maps to the data source using some
orm like hibernate
that
content can directly be pushed into the
JSP as well in case there is no data and
it can then go to the model bin and
retrieve data from the database via the
JSP as well and finally the response is
sent to the browser
controller servlet receives requests
from browser and captures the input
controller invokes the business method
of model or Java pin model connects with
database and gets business data model
sends response to controller keeps the
process data in Heap memory request
session and servlet contacts and
controllers which is the control the
appropriate view of the application
the limitations of the MVC model clear
separation of responsibility code
reusability single point entry for
application and support for multiple
view Technologies
spring MVC is used to develop web
application that uses MVC design pattern
spring MBC is meant to make web
applications development faster cost
effective and flexible
contents of spring MBC we have the
dispatcher servlet we have the Handler
mapping the controller
mode and View and view resolver
the dispatcher servlet it is given by
auxbring framework.dispatcher servlet it
controls the front controller design
pattern and whatever URL comes from
client servlet intercepts the client
request before passing the request
object to controller in the web config
file write servlet mapping in such a way
that dispatcher servlet is invoked for
client request
then we have the Handler mapping it is
an interface implemented by objects to
Define mapping between request and
Handler objects when a request is made
to Springs dispatcher servlet it hands
over the request to Handler mapping
Handler mapping inspects the request
identifies the appropriate Handler
execution chain and it delivers it to
dispatcher servlet
handle mapping provided by string MBC
module can be implemented in many ways
Bean name URL Handler mapping which is
the default Handler mapping class that
Maps the URL request to the name of the
beans if URL pattern welcome.htm is
requested dispatcher servlet will
forward the request to welcome
controller
if street name.htm is requested it will
forward the request to street name
controller and if processcredit.htm is
requested it will forward the request to
process controller
the controller components that are
called by dispatcher servlet for any
kind of business logic all controllers
Implement controller interface the types
of controllers are abstract multi-action
and Abstract wizard form
there are components called view
resolver their job is to provide mapping
between logical view name and actual
physical location of the view resource
then we have the model and view it is
represented by class of dot
stringframework.web.servlet model and
View and is returned by the controller
object back to the dispatcher servlet
this class is just a container class for
holding the model in the view
information the model object represents
some piece of information that can be
used by the view to display the
information this gives abstraction in
the spring framework any kind of view
technology can be plugged into the
framework like Excel Jasper reports PDF
xslt free marker HTML tiles a supported
Frameworks
then we have the view resolver it is an
interface implemented by objects to
resolve views using name spring mvc's
module it encapsulates the module View
and the view object in a single entity
which is represented by the object of
class model and view to resolve the view
object dispatcher servlet view resolver
is used
internal resource views resolver it
resolves The Logical name of the view to
an internal resource by free fixing the
logical view name with the resource path
and suffixing it with the extension it
resolves a logical name of the view to
the B name which will render the output
to the user the beam should be defined
in Spring app context file this view
resolver is the same as being name view
resolver the only difference is that
instead of looking for the beans and
springs application context file it
looks for Pins defined in a separate XML
file
spring MVC framework
the spring MVC web framework provides
model view controller architecture that
can be used to develop flexible and
Loosely coupled web apps
so here we see the steps the request
comes to the servlet dispatcher it goes
to the Handler mapping
the Handler mapping sends back to the
respect dispatcher servlet that access
the controller we then call the Handler
request method on the controller
which calls the business methods on the
service
which in turn calls The Tao method which
talks to the database and gets the
response the response is sent to the
service
sent back to the controller
sent back to the servlet dispatcher
which forwards it to the view resolver
so the Right View can be returned to the
servlet dispatcher the serblet
dispatcher then picks up the model
attaches it to the view and generates
the response so client requests a
resource in the web application the
spring front controller dispatcher
servlet requests the Handler mapping to
identify the particular control of a
given URL Handler mapping identifies the
controller and sends it to the
dispatcher sublet dispatcher servlet
calls handle request method and passes
these two objects to the controller
controller calls the business method
service class calls the tower method for
business data now interacts with the
database to get the data database shares
the result Tau returns this result data
to service Dao data is processed
according to business requirement and
returns to controller controller returns
model and view object back to font
controller dispatcher resolves actual
view by Consulting The View resolver
object view resolver renders view to the
dispatcher dispatcher servlet consults
the view to the dispatcher servlet
View executes and returns HTML to the
dispatcher serverlet dispatcher servlet
sends output to the browser
the request processing workflow of
spring web MVC dispatcher subjected
tools is Illustrated in the following
diagram
the Handler mapping
going to the dispatcher servlet second
is the controller
data Exchange
with the dispatcher servlet then it
communicates with the view resolver
and finally The View and the response is
sent out
after receiving an HTTP request dispatch
a servlet consults the Handler mapping
to call the appropriate controller the
controller takes the request and calls
the appropriate service method based on
used gate or post method the service
method will set model data based on
defined business logic and return view
name to the dispatcher servlet the
dispatcher servlet will take help from
view resolver to pick up the defined
View for the request once view is
finalized the dispatcher servlet passes
the model data to the view that is
finally rendered on the browser
configurations required for spring MBC
map request that you want the dispatcher
server to handle using URL mapping in
web XML create servlet names servlet XML
file Define a controller create a view
so you map requests that you want the
dispatcher servlet to Handle by using
URL mapping in web XML file use the
following code declare the map hello web
dispatcher servlet the web.xml file will
be kept in web INF directory
then you create the servlet.xml file
framework will try to load the
application context from a file name
servlet XML located in the applications
web content directory the file name is
hello web.xml the servlet name XML file
will be used to create the defined beans
override the definitions of beans with
the same name in the global scope
the component scan tag will be used to
activate spring MBC annotation scanning
capability which allows you to make use
of annotations like controller and
request mapping and the internal
resource viewer resolver will have rules
defined to resolve the view names
we Define a controller the at the rate
controller annotation indicates that a
particular class serves the role of a
controller the at the rate request
mapping annotation is used to map a URL
to either an entire class or a
particular Handler method the request
mapping method is used to declare the
print hello method as the controller's
default service method to handle HTTP
get requests then we create a View
Spring MVC supports many types of views
for different presentation Technologies
these include JSP HTML PDF Excel
worksheet XML velocity template xslt
Json view in webangs choose from over
300 in-demand skills and get access to
1000 plus hours of video content for
free visit skillup by simply learn click
on the link in the description to know
more finally the spring MVC program
let's write a simple web-based
application using spring MVC to create a
spring MVC model to display hello world
so the request will come in here saying
hello.jsp we will use at the rate
request mapping then the dispatcher
sublet will communicate with the hello
controller then the internal resolver
View resolver and finally the East
hello.jsp which will generate the
response the hello world example uses
spring web MVC framework to follow the
model view controller architecture the
controller is responsible for processing
user requests and building an
appropriate model it then passes the
model to the view for rendering in this
example hello controller Java classes
controller the view is responsible for
entering the model data in general it
generates HTML output that the client's
browser can interpret in this example
hello.jsp is the view
we create a dynamic web project with the
name hello web we then add jar file to
web content web inflib then we create a
Java class hello controller under SRC
folder then we create spring
configuration file web XML and hello
servlet under the web content INF folder
then we create a subfolder with the name
JSP under web content then we create a
view file hello JSP under the subfolder
the final step is to create the content
of all the source and config files and
Export the application
here are the steps we create a dynamic
web project that we have already learned
we add the following jars servlet API
common logging spring aop spring beans
spring context Springport spring
expression spring web MVC and spring web
then we write the at the rate controller
and request mapping to slash hello we
write the controller with the request
method as get and we say model dot add
attribute message hello spring framework
then we create the spring config file
that Maps the dispatcher servlet object
and the hello web
then we map the spring framework
internal resource view resolver as well
and we put the webinf JSP property map
to that particular folder path
then we create the subfolder with a view
hello.jsp which simply returns hello
world and dollar of messages the
expression
to run the application we say localhost
Port hello web and hello
we'll write a simple web-based
application that makes use of HTML form
using spring MVC framework to submit the
data to the controller and display a
processed result
so the moment we say project name slash
employee it will go to the dispatch
dispatcher servlet which will talk to
the employee controller retrieve the
employee object move to the internal
resource review resolver which picks up
the result.jsp inemploy.jsp views and
send it out as a HTTP response
MVC architecture for form handling
example the form handling example uses
spring MVC framework it follows model
view control architecture the model
encapsulates the application data and
consists of pojo it creates employee
class containing ID name and each the
controller is responsible for processing
user request building an appropriate
model and passes it to the view for
rendering it creates an employee
controller.java class to call employee
class methods the view is responsible
for entering the model data and in
general it generates HTML output that
the client browser can interpret Java
JSP files result.jspin employ jspi used
to display employees information
steps to write a web-based application
using string MVC we create a dynamic web
project and add the required jar files
we then map the request that you want
the dispatcher server to Handle by using
URL mapping in web XML you then create
the Java class employee you then create
employee controller in SRC folder you
then create spring config web XML and
served at XML under web contact web INF
you then create a subfolder with the
name JSP and a webcontact INF you then
create viewfile employee.jsp you then
create second view file result.jsp and
the final step is to create the content
of all the source and config files and
Export the application now we create a
dynamic web project and add the required
jar files common logging or spring
framework ASM org spring framework pin
org spring framework context aux spring
framework core expression web servlet
web and springweb.jar
we then Define the spring web
configuration file web.xml where we set
up the dispatcher servlet we give the
servlet name as hello web
we then set up the employee class with
each name and ID
we then create the controller with a
request mapping of a URL slash employee
and map to a request.get method we then
return model and view with the employee
and command and the new employee object
we then do another mapping for the
request method.post this is from the
form data to be posted we provide the
add employee method and add attribute
mappings for name agent ID
next we create a spring config file web
XML and servlet XML which map the JSP
page
then we create a subfolder in a view
which maps The View information as a
employee.jsp file where we create a
simple table to print out the data
we create a second view called
result.jsp which has a separate table
that this gives us the name age and ID
of the employee
we create content for all the source and
config files and we run the application
let's look at a demo on Spring web MVC
let's start with a small demo
demonstrating the capability
of spring web MVC
so let's move to eclipse
so spring MVC is an end-to-end solution
for complete web app development
the servlet plays the role of the
controller and JSP plays the role of the
view it follows the fun controller
design pattern this means there will be
a servlet as a controller and the model
caters to collecting the data there is
complete sync between the model the view
is handled by the controller which is a
form of MVC design pattern
so spring MVC has a front controller
which is the dispatcher servlet
so we have created a dynamic web project
and we have added the libraries
so the reference libraries are all the
spring libraries in addition to that we
have added
the comments
logging
which is the other important library
that we have added
we have a views folder that has four
views home profile register trainee and
success
look at the
web.xml file
here we have the dispatcher servlet
configured with the name as my servlet
and here we are configuring my servlet
with a URL pattern of Slash indicating
that any
request that comes to the dispatcher
servlet which acts as a controller will
be catered to by the dispatcher servlet
so the moment you put a slash which is
the root URL in the address bar the
request will come and hit the dispatcher
servlet
foreign
servlet.xml file
so here we can actually see
that the sprigweb container is going to
look for this file it is going to look
for JSP Pages inside this path which is
web INF slash views and that is where we
have stored our JSP pages
it will search for the controllers in
the com.controllers package
and here in the source in the
com.controllers package we have set up
our controllers as you can see here
the internal resource view resolver will
find out which particular JSP page is to
be returned
so the prefix is the path where the JSP
are stored and the suffix is it's going
to post fix all the view names with a
DOT JSP extension
next we come to the
mycontroller.java file
we use The annotation controller we are
mapping to the root so if somebody gives
the URL the end user passes the URL as a
slash
we are going to print home in the
console and simply return
the home dot JSP page so the suffix will
be appended to this
we have another function
called say name
so in case
the request for this particular URL
route
we will get the first name parameter
from a form
we will map the attribute
of this particular value first name
and we will return the profile view
which is again present in the views
folder as we see here
we have a third route set up for the URL
login so if the URL is slash login we
will track the username and password
fields from the form
we will check if the username and
password equals Tom and Jerry we will
add the attribute and we will return the
profile page
if there is an error we will simply
return an error message
so that constitutes
the my controller
let's look at the home.jsp
e have the same name action method which
will post to the say name
request map that we saw in the
controller the method is post we have a
submit button with fname and we have a
login controller with username and
password and a submit button and this is
mapping to the action method login and
those are the two action methods we saw
we are mapping to say name or login
we'll come to the home
page
and we'll execute this
we'll go to the default route which is
just a slash which takes us to the home
page
and here
it simply gives us a welcome message as
of now which says hello
welcome to Spring
which we see is the default
welcome message that we are actually
getting
and we also have a c name function that
is actually getting mapped when we click
on this button
and we are going to route
to a success page so here let's print
first name
and we can see here
that we are actually going to map to the
first name function and if we go to the
controller
we have created an attribute first name
to which we are mapping this value
okay and we are
simply returning the user information so
in case
there is a success it will simply go
ahead
and route to that particular
URL so we'll just provide
or rather let me go here rather than the
success and we'll make that change so
we'll go to the profile because we are
navigating there and here we have a
first name
and now if you see here we are saying
that we are going to post this form to
say name first name is going to be the
attribute that we are going to trap and
we are going to return profile so the
first name attribute that we are going
to trap here
if we look at the home dot JSP
okay the user is going to enter a first
name which we will trap as an attribute
so here that value is going to get
trapped we then return the profile JSP
when I go to the profile JSP we are
simply outputting that attribute first
name
so this is my page execution I have just
entered a first name I'm going to click
on the submit button and it says welcome
that particular user right if I add
another user
it actually goes and traps that user ID
so again the flow is that in the
controller it's hitting this particular
request map
it then traps the F name
stores that value
into an attribute called first name
and forwards it to the profile page the
profile.jsp is returned by the
controller and simply prints the first
name
now we have another page here which is
registered trainee
we are posting to an add trainee method
okay we are posting to an ad Training
Method the command name is training
command
and we have here if you look at this we
have actually
included a custom or rather a system
defined tag Library which is
springframework.org tag slash form so
what we are using here is spring forms
rather than the system defined HTML5
forms
and here we are
in Colon which is the prefix for this
particular namespace that we have
imported on the top the action is AD
training and we have a trainee name we
have a marks code we have a contact
number and a submit button
okay
and now uh
we are already going and
setting path to com controllers so in
the com controller we've created a
register controller
here you see that we have a request map
for register and a request mat for ad
trainee and here you see the trainee
command
that is actually getting trapped so the
trainee information will automatically
be passed here and this is the model map
which acts as a scope which allows us to
pass data between the controller and the
view so this trainee object acts like
the model data so if we come to the
com.2 package you actually see the
trainee class which has trainee name
marks code and contact number it has a
parameterized Constructor it has an
overwritten two string default
Constructor and getter and Setter that's
all the trainee class actually has
the register controller as we saw has
two maps a register function that
returns register to any.jsp
maps to the attribute trainee command
and a ad trainee map that accepts the
training object along with the scope the
model map which passes data between the
controller and The View
we are adding attribute training and we
return success okay so if I go to the
success.jsp we are printing the trainee
object
if you look at the register training
here you see the command name that we
are trapping and trainee name marks code
contact number which map to the fields
that we have in the model class or the
entity class which is the trainee itself
so now if we actually look at uh
so let's close this
come back
we don't add any credentials we click on
login and it says invalid login
credentials okay so this is
the login that is getting called so you
see here it maps to the login
and here if we do not enter anything it
simply returns invalid login credential
so this is the login that's actually
getting hit when we click on that button
and if you look at the register training
we actually see the input type
over here equal to submit
and the moment we hit that particular
login URL it will simply throw this
message saying that you did not enter
the right
credentials
so that is the login screen for us
foreign
credentials so if I add the correct
credentials here
or let's say we enter the incorrect
credentials let's say omit and password
and we say login
it continues to say invalid login
credentials right so in the home.jsp you
actually see the login so this is the
login block which is giving us that
action equal to login username password
and it is displaying dollar of error
message right so the moment I click on
this input button
it looks for a JSP or rather it looks
for a controller which has a request map
so this JSP page looks for a controller
that has a request map of login
so inside the my controller I have a
request map of login it will go here it
traps the username password checks if
it's not Tom and Jerry it goes to error
message if it is Tom and Jerry it
displays profile right and if I look at
error message error message is being
printed in the same page below so in the
home.jsp we actually are
if you look at the home.jsp page dollar
of error message is being printed and
that's why you get the invalid
credentials out here okay and if it is a
success it will show you the success
page and print
uh that information
okay it will just display so if you look
at the my controller what we're doing is
we are displaying the profile page here
so if I go to the profile page it will
just display the first name okay so
let's try that
so here if I say Tom and Jerry it should
just display the first name successfully
saying Tom so when I log in it says
welcome Tom okay the URL continues to be
login
now I when I click on this register link
what happens so let's look at the home
JSP again href equal to register so when
I click on the register link I simply
have a registration which says click
here to register
okay and I already have
a registered trainee form
created and this is created using
springforms as we discussed by creating
you importing the tag library for
springforms right so that's the register
trading now I have a separate controller
that is managing that so here is the
register so moment I click on that link
it will hit this request map and it will
bring up the register trendy.jsp
okay and remember we had added the
suffixes here in this particular file so
when I say register trainee the dot JSP
suffix will already be automatically be
added so let me try that we'll click on
register and here you see the register
trainee springform has come up
so we enter the trainee name we enter
the marks code
and we enter the
contact number
right
now if you look at the register trainee
form
this is posting to ad training so if I
go to the register controller here is
where I have my ad trainee it accepts
the training object as a parameter maps
to training command and the scope which
allows us to pass information between
the controller and the model and here we
are mapping the trainee object and just
returning success.jsp and in success
your JSP we are simply printing the
training object so let's see when I
click on submit query
so let's try the register now
so when we click on register
we'll enter a name for the trainee
will enter the marks code and we'll
enter some contact number
and we'll click on submit query and
there you see the trainee object
actually getting displayed
so in the success page we were actually
displaying the trainee object on the
register trainee as we discussed we were
connecting to the add trainee action
in the register controller we had the
add trainee action we were passing the
training object along with the model map
and adding the trainee attribute to the
map and find the returning success and
on the success page we just went ahead
and printed the trainee object
so you saw how the spring MVC pattern
got the request to the dispatcher
servlet it forwarded it to the right
model picked up the model data and went
and displayed
successfully the required View
which was the final view that actually
got registered for us
and that is the success dot JSP page
that finally got displayed
let's start with the basics the
hibernate framework was created by Gavin
King in 2001 the latest version is 5 to
10.
let's start by discussing why we need
hibernate and why it was created
it is a framework that simplifies the
development of Java application to
interact with the database let's
understand
why we need it with the help of two
scenarios let's consider the scenario
where a user has a program with mySQL
database connectivity
now if you look at the illustration here
the user needs to write MySQL specific
code to create the database connection
now just in case the user shifts from a
my sequel to an Oracle database the user
has to repeat the process of writing
database connectivity code which is
Oracle specific so the connectivity code
is difficult to modify because it's in
the source code and we'll have to
recompile the application every time we
change the data storage mechanism
hibernate hence converts database
specific queries automatically based on
a dialect provided and it uses hql or
hybrid query language which is
independent of the database so it
prevents the user from changing the code
and queries to map to different data
source once you change a data store
let's say from MySQL to Oracle
let's consider a scenario of a user with
various billing records the user in the
billing records data needs to be stored
in a dbms for this the user class has to
be mapped to the user table and the
billing records has to be mapped to the
billing records table
so this is the class that we will
actually set up
when you create the class the schema for
the user and Builder billing records
classes will automatically be created
for you so this is the class
representation with the data members and
this is the equivalent SQL statement
that will be created to generate the
respective tables
now what could be the possible problems
with this
the association problem
we are talking about object relationship
mismatch problems in terms of the
association Java can use Association by
having another class variable as a
member in SQL no standard concept is
available to represent Association
navigating data it is different in Java
and SQL and cost mismatching due to
manual handling of object relational
mismatch
let's add two subclasses
credit card and debit card which are
subclasses of the billing record
now what could be the possible problems
here SQL does not support super table
and subtable relationship table is not a
type so it is difficult to create super
table subtable relationship and writing
SQL query for polymorphic relation is
difficult
in user table ID is the primary key this
is a foreign key for the billing record
table it is hence difficult to change
the ID we need to update not only the ID
column in user but also the foreign key
column in Billing record we also need to
add surrogate key in user and billing
record table the surrogate key isn't
presented to the user and is only used
for identification of data inside the
software system
user surrogate ID and account number ID
a system generated values it is
difficult to decide whether these
columns should be added to data model or
not different persistent Solutions have
different strategies and this can cause
confusion
what is the solution hibernate provides
an orm or object relationship mapping
which takes care of these issues
let's look at orm in its features orm
refers to automated and transparent
Persistence of objects in a Java
application to the tables in a relation
database using metadata it describes the
mapping between the objects and the
database so here once we create a Java
audio class or a plain old Java class in
your code and let's say we provide data
members like ID and name we will
automatically be mapping this to a table
in the database which the hibernate
framework will generate automatically
for us with the same set of columns and
mapped to the class structure that we
have and hence we said object
relationship mapper so the object
structure that you have will be mapped
to the database table structure
the advantages obviously it can
significantly reduce development time
less code better performance and you can
support different database Management
Systems by adopting this
by mapping logical business model and
physical storage model orm implements
domain model pattern it navigates the
object relationship transparency orm
provides one way to translate the query
to appropriate database syntax it also
provides concurrency support by multiple
users can access the database at the
same time it provides a host of services
that enable developers to focus on
business logic it also provides cache
management to reduce load on database
surrogate key identifier and other key
features can be automated in the Ora
so the Java application
will connect to the orm API which
facilitates create update delete
operations the orm engine will
facilitate the creation of the mapping
information for the Java class that you
create here to actual SQL statements
meant for the database and the jdbc
driver will connect the Java application
finely to the database so it is the orm
that is doing the mapping from to your
objects that you write in the Java
application to tables that are actually
updated and created in the database
let's look at hibernate as an orm
framework
from a architectural feature persistence
and API perspective
as an object rotational mapping
framework hibernate is concerned with
data persistence as it applies to
relational databases via jdbc dbms
specific details and mapping file
details are specified in a file called
hibernate.configuration.xml and
mappingfile.xml the hibernate engine
using the uses these files to generate
dbms specific syntax so the Java
application will have all the
configuration for your hibernate written
in the cfg.xml file you can also have a
mapping file if you want to map table
names to
column names in the XML file and finally
we connect to the database management
system
hibernate orm provides its own native
API in addition to full jpa which is the
Java persistence API it maps pojos of
java objects to relational databases it
provides a rich tool set it has better
performance for caching fetching and
enhancing code performance and it is
also passed of the JBoss Community this
is where we can go and download the
latest version of hibernate
the jpa provides a standard persistent
API as part of ejb 3.0 specification it
is supported by all major vendors of
java industry hybrid model implements
Java persistent object relationship API
and the hibernate persistence provider
can be used in any environment of java
platform be it the standard or the
Enterprise Edition
so here is the hibernate programming
model you create the
hibernate.gfcfg.configuration object you
load the metadata information you then
create a session Factory object you then
make a hibernate API call on a session
object you close the session and you
close the session Factory
so the Java application will create the
persistence object
the entire hibernate framework consists
of the session Factory a session a
transaction a transaction Factory and a
connection provider
and the internal API which is used by
hibernate is the JTA the jdbc and the
jnti
let's look at each of these components
of the architecture in detail the
session object is created within the
database layer in every Tau method or
data access object method it is known as
the persistence object it has three life
cycle States the transient state where
an object is transient if it has just
been instantiated using the new operator
and it is not associated with a
hibernate session it is in a persistent
state if it has a representation in the
database and an identifier value
it might have been saved or loaded
however it is by definition in the scope
of the session detached
is an object that has been persistent
but its session has been closed the
reference to the object is still valid
of course in the detached instance might
even be modified in this state
the hibernate core apis
start with the configuration
now you can see here the
orc.hibernate.cfg which gives two
services in the hibernate application it
loads the mapping file and configuration
file into memory and makes them
available to hibernate engine it also
acts as a factory to create the session
Factory
the session Factory which is part of
oct.hibernate.session factory
the hibernate engine implements the
session Factory interface
it is one per dbms mostly one per
application that you create it is thread
safe
it is not a Singleton which means it
creates a session object the session
Factory encapsulates second level cache
connection pool meta information cache
and pool of the session
the hibernate interface also contains
the session
the hibernate engine implements the
session interface session object acts as
a persistent manager it is a lightweight
object it encaps encapsulates connection
and first level cache
session object is not thread safe in
every Dao method session object is
created it is used for crtd operations
the hibernate engine also implements the
transaction interface when database
connection is created by hibernate
connection associated with session is in
autocommit disable mode whenever a
credit operation is performed the
changes will not be reflected in the
database unless connection is maintained
in autocommit enabled mode
all the generator classes implement the
identifier generator interface this
application
will help the programmer
and may create
own generator classes by implementing
this interface hibernate framework
provides many built-in generator classes
you have assigned the default value has
to be explicitly aligned to persistent
object before you persist it increment
it increments value by 1 it generates
short end or long identifiers native it
use identity sequence or below depending
on the database vendor
sequence it uses the sequence of the
database if there is no sequence defined
it creates a sequence automatically for
example in the case of an Oracle
database it creates a sequence name
hibernate underscore sequence
it is used in high and low algorithms to
generate the ID of type shot in and log
finally the identity it is used in PSI
base MySQL SQL server db2 and SQL to
support the ID column The Returned ID is
of type short into long side Auto
generates the ID which could be the
primary key in your table
how do you set up a project with
hibernate Step 1 you create a Java
project you add the required jars and
libraries from the hibernate downloads
you then add the jdbc driver or a
specific jar file to connect to your
respective data store create the pojo
class save it in the SRC folder of your
project you then create the hibernate
configuration file which is similar to
the web XML file and you specify which
dialect of SQL are you using depending
on the databases listed here MySQL db2
Oracle you then create the hpm.xml file
which is the mapping file
and finally you create the class that
retrieves or stores the persistent
object and saves it in the SRC folder
and then you go ahead and run the
application
so first you download the latest version
of hibernate you click on the right
click on the project click on build path
click on ADD external Jazz and you add
all the required hibernate charge that
you downloaded
then you download the seek MySQL
connector assuming you're connecting to
a SQL the mySQL database or equivalently
the driver for the Oracle database
you then create the pojo class that
needs to be persisted into the database
in terms of its object so here we have
role number and name
then you create the hibernate
configuration XML file here you see the
property mappings done you see the
connection URL to the database you see
the username password you see the driver
name
you see the auto
property set to create which indicates
every time you run the application it
will create the table if the table
exists it will drop it and create a new
table and here is the mapping to the
mapping file which Maps the column names
to attributes that you have in the class
foreign
you can actually see the mapping done
name student table student
table the ID and the name are being
mapped
then you create the configuration object
by creating an object of standard
service registry you then call configure
you pass the XML config file then you
create an object of metadata call the
build method and finally an object of
the session Factory by calling the build
method of the get session Factory window
you can use property names
as create update create drop to avoid
creating the student table manually so
every time you have a change and if you
set it to update automatically you will
see that the record has been updated in
the database Within You Without You
having to manually write the SQL
statement and this is the SQL that will
be generated in case you put the value
as create here instead of update which
means the existing student table if it
is already there in the database it will
be dropped in a new student table will
be created every time you execute the
application
let's talk about annotations in
hibernate
you have learned how hibernate uses XML
mapping file for the transformation of
data from pojo to database tables and
vice versa
hibernate annotations is the newest way
to define mappings without the use of
XML file you can use annotations in
addition to or as a replacement of XML
mapping metadata so if you're using
annotations you do not need to create a
separate XML mapper file which will map
the values or the attributes inside your
class to the fields in the database
so here you just need to specify at the
rate entity as an annotation on top of
your class at the rate table as well at
the rate ID if you're defining anything
as a primary key at the rate column if
you want to change the name of the
column from a database perspective and
simply save this file and provide a
mapping in the hibernate CFG XML that's
all you need to do so you save the
effort of creating a separate XML file
purely for doing a mapping of the class
attributes to the column names in the
database
so here you see we are creating a
configuration.configure then we are
configuring and loading that XML file
and creating a metadata object and
calling build on it and finally in
instantiating the session Factory if
getting your learning started is half
the battle what if you could do that for
free visit scale up by simply learn
click on the link in the description to
know more
let's talk about create update delete
operations the acronym cracked stands
for create read update and delete there
are four basic operations that any data
driven application performs which is
create read update delete now hibernate
supports these operations by means of a
session interface
now multiple persistence objects cannot
be retrieved and this is the limitation
of using session methods multiple delete
and update operations are not possible
in parallel the required criteria cannot
be expressed to perform some complex
credit operations to overcome the above
limitations we have hql which is
hibernate query language the criteria
API and Native SQL which is structured
query language
what is hql it gives query language
provided by hibernate it is the same as
SQL but it doesn't depend on the table
of the database it uses classes
the criteria API is one way of querying
the database in hibernate application it
can be used for dbml operations
criteria API is an object oriented after
native first hql to read data from
database and it supports compile time
checking for the query that we built
unlike hql
here is a create operation
we create a configuration object a
standard registry object we then load
the hibernate configuration file
we then create a session Factory open a
session object begin a transaction
create a new student object set the
values as role number and name and save
that into the session call a commit on
the transaction and close this will
create the table in the database and
insert the first record inside it if you
need to read the data this block of code
until the session Factory remains common
then you again open the session begin a
transaction get that particular student
class object by passing the primary key
and simply print the value
for an update operation
this remains constant
you then open the transaction you then
get that particular
record of the student or the student
object by passing the ID and simply to
an update
for a delete process Remains the Same
get the student details call delete on
the session
let's look at a demo on how to work with
hibernate the first thing we will need
is of course to install the hibernate
API
so the hibernate software is available
and you just need to go ahead and
download it from the hibernate website
you can Google for it and simply then go
ahead and unzip it okay
so
if I go to this is the hibernate folder
that we've downloaded and you just need
to unzip it and you will actually see
all the files and the jars inside it
that are already there
so this is the file that we need and you
have a set of jars that we will actually
need uh
so these are the set of jars that we
will need to import inside our
application so once you install the
hibernate API
you then need to just go and download
and install any database of your choice
in Us in this demo I have installed
MySQL the installation document for
MySQL and hibernate has been provided to
you in the LMS so you can access it and
complete the installation of MySQL and
hibernate in case you need support on
that
and eclipse of course will be our editor
and besides that
we will download the MySQL workbench so
the MySQL workbench installation
document has also been provided so you
can go ahead and download it and once
you download the MySQL workbench you
will see that the installation of the
instance of MySQL is available to you
you just need to click on that
it says opening in the editor
just ignore this and it is that's about
it
okay so that's all we need to do
uh
connect to the MySQL
instance
and
once you get the
MySQL workbench installation done and
the MySQL installation done you simply
start writing your SQL commands out here
which will start
generating your database names and then
we will go ahead with configuring our
Eclipse application to create a simple
Java audio class which will via
annotations as we saw we will map it to
the particular database that we create
here
let's start with creating
the new database
so we'll say create database
and let's say hibernate demo
we'll execute this and you can see the
database has got successfully created
let's come to our Eclipse now
here we'll create a new project
we'll select Java project
the name
hibernate demo
see a new project
Java project
oops
Java project next
here
hibernate demo
next
we'll click on libraries
add external charts
and we will add
our jdbc driver
so
let's go to
this is the hibernate folder so I'm
moving to the hibernate folder first
we'll go to our lib folder
and inside that required and we will
select all the files and open and say
finish
okay so it would have added all the
references as you can see here so the
libraries the correct
references have been added
now we'll need to also add
the MySQL
driver
so let's go
to
the web
open Firefox
and we'll just Google
okay and here let's say we want the
MySQL
Java
connector
or driver
that should take us to the MySQL website
okay and here you see
the driver available we'll pick the zip
file so we'll say download
start download
okay
and it has downloaded the driver so I'm
just going to pick it up
and put it into my folder that says jars
and we'll just extract it here
okay
now the moment that is done we'll come
to our eclipse
we'll again go to build path and
configure
add external jars
go back
let me go to my charts folder
and
okay doesn't figure out so let me check
again it is in this folder
so we'll go and go to the build path
configure
add external charge
keep the path here and pick up the MySQL
connector apply applying close so that
has been added
now let's create a new package
for our pojo class
and we'll say com Dot
transfer object
we'll create a new class within it
and let's name it clear for example
finish
let me add data members
start with a player ID
let's add
player name
let's add
team name
let's add h
uh
okay that's my Constructor
get rid of this
let's add from The Source the Getters
and setters
will also generate
or two string
a two string method and save this
and let's also go to the source and
generate a parameterized Constructor
now time to add the annotations for
Entity Framework
so we'll say at the rate entity
we'll pick it from the Java x dot
persistence dot entity
package
then
the clear class is going to be a table
so we'll add at the rate table as
another annotation
and we want the player ID to be a
primary key
so we will add at the rate ID above the
player ID
now let's browse
to
the hibernate folder
and within it we will search
for
hibernate dot CFG
dot XML and you will see that there are
couple of CFG XML files that come up and
these are the ready-made configuration
files that are there in the folder so we
could just pick one and use it
so uh I've just picked a typical a file
from that location
okay and I'm just going to use it uh
so I'm just copy pasted a CFG file after
searching for it randomly
so I'm just selecting that coming to
Eclipse again
clicking on the SRC and just pasting so
here's
the file that we pasted
so if you go to the file the first thing
that we have is a database connection
setting where we provide the driver name
the URL Etc
then next we have the connection pool
setting
to set the pool size we have the SQL
dialect depending on which database
you're connecting to we have the cache
if you want to turn it on or off
this is the line
that will spit out the
SQL that J uh hibernate framework will
automatically be creating for us
this will allow us to drop and create
the table it will create the table at
the first run and on every subsequent
run it will modify and recreate the
table
so it will drop the table and recreate
it now you see a mapping class here here
we will map it to com.2 dot clear
okay so that's the change we have made
then
let's come to class
and this will be com dot MySQL Dot
jdbc Dot driver
let's come to the connection string
jdbc colon MySQL
since we are connecting to a mySQL
database
localhost the port number for MySQL by
default is 3306 and the table name we
created or the database name we created
was
hibernate demo
the username
on installation I had provided as a root
and the password was also root so we'll
save that
next the SQL dialect
we will give it as my SQL
5
dialect
we'll add
one more value
name equal to
current underscore session
underscore
context
underscore class
and we'll set this to thread
so that
every session runs in a separate thread
and it's thread safe
so we are pretty much done with uh
the configuration of
I'll just validate the
so this is
hibernate demo and that's exactly the
same thing that we will provide here
now time to add a new package so let's
do that
com Dot
control
we'll add a new class
and call it
hibernate mean
add a public static white main to this
class
have it ready so that's going to be our
entry point
first thing we'll create the
configuration
so we have created the configuration
first
configuration
equal to new
oops
equal to new configuration
Dot
configure
foreign
get rid of this
let's get this from
hibernate package
and then we will say
configuration Dot
add
annotated class and our class name will
be com.2 Dot
player Dot
class
then next
we create standard
service
registry Builder
Builder
equal to new
standard service registry Builder
Dot
apply settings
and
configuration
dot get
properties
we'll put this onto the next line
so this will go ahead
and get us all the configuration that is
available
inside our configuration class that we
specified
so the first step we are creating an
object of
the configuration class
the second step
we are going ahead
and creating
an object of standard
service registry Builder
we are also adding our class that had
annotations with it
and that class
with the annotations
is nothing but the player class
so this line of code
will actually
allow us to apply the settings
of the configuration file that we have
set up
post that
we will create
a session Factory object
equal to
configuration Dot
build session Factory and we will pass
the Builder Dot build method
next we start creating the session
equal to
Factory Dot
Open Session
let's add
the hibernate namespace for session
then
we create a transaction
equal to
session Dot
begin transaction
then we create a player object equal to
new
player
and we pass some values
we import com.2 and also
the transaction package
should be the hibernate equivalent so
we'll get that one
we also need to give a fourth parameter
here which is the team name so we'll
specify that
then we use the session object
to save
the player object
post that
we say transaction dot commit so that it
persists the transaction
and then we do a session Dot close
okay so here we are setting up the
configuration we are then adding the
annotated class which is clear we're
creating the Builder object loading all
the configuration properties from the
XML file we created setting up the
session Factory
passing the Builder to it which is the
configuration information we're then
opening a session opening a transaction
creating a new record in terms of the
object and hence it's called object
relationship mapper because we just
create a new object use the session to
save it and commit the transaction and
it will automatically create a table
with the right name and insert that
record into the database
Okay so
now all we need to do is attempt to
execute it so we'll just check
the SQL connector is referenced we'll go
to our
hibernate config file
and we'll just validate so we had set
the dialect
and it is trying to reach the
trying to load the class which is the
information class or rather the driver
so
com.mysql.jdbc dot driver so let's run a
check on that
save this
let's change this
and use my SQL dialect
oops let's come back to the hibernate
okay
executed the incorrect file so let's run
it again
we delete the additional file that got
created come back to the hibernate file
attempt to run that
save all
so the update that we did to the code
firstly
uh we have just changed the driver
alphabet D to uppercase which is system
defined and case pen specific
and the next change that we will have to
do is
uh we'll have to add the entire
namespace to
the SQL dialect plus so we will say
Arc
Dot
hibernate so this is the
package name
dot dialect LCD
dot MySQL 5 dialect so we've said Aug
dot hibernate dot dialect dot MySQL
dialect
okay and MySQL 5 is the updated version
of the SQL dialect class that will
automatically convert and write the SQL
statements to insert the data into the
database
and also create the
updated table for me
right so the these are the two changes
that we have done and the code here
continues to remain the same we have a
player object that we are trying to
store into the database
so we'll execute this
and let's look at
the output whether it
Okay so
you can see here now because in the
config file we had actually given this
configuration which says show SQL true
it has actually generated the SQL
statements in the background so it says
drop table if player exists and that was
because we gave the auto mode here to
create
then it creates the new table and you
see the SQL that is written
automatically written for US based on
the
structure or the attributes in the class
and then it has attempted to insert a
new record of type player into the
database
okay but has it actually happened and
updated in the database so we'll go to
our SQL
okay here we will just validate whether
the update has really happened has it
created a table out here and are we able
to retrieve the data so we'll say select
star from
hibernate demo Dot
player
okay and you see the data that we
actually inserted has come up inside the
database
let's try with an additional
record
save this
come here
and let us add another player
change the age value
and we will also
so we've created a new player P2 and we
are saving it
into the database
and you see after we've executed it
drops the table creates the new table
and it inserts the data into the table
okay what I've also done is I've just
introduced a try catch block so in case
there are any errors where we have gone
wrong it would return the error messages
to us right else it's the code continues
to remain the same with just the new
record so let's check in the database
now
we'll execute this and here you see the
second record that we just inserted as
available in the database
now let's go back here
let's comment
the second record
and the save statement as well
and let's modify
the value of the first
record from Amit to Virat
now when we execute this let's see what
happens
so you see it's dropped the table
created the table again and then
inserted as individual Player record so
if we go
to the database
you can see that it's now the updated
value but it has recreated the entire
table and hence the second record is
gone
let's now if we need to preserve the
records and just do an update to an
individual record without updating the
entire table let's change this flag from
create to update and save this
and now when we come back here
we will uncomment
the second
record and comment
the first one since it's already there
so we'll comment this and uncomment the
second player and execute
it's now generated a single insert
command let's check in the database what
has happened so we had one record
you can see now it did not drop the
table it just updated it with the second
record
let's check what is that we'll need to
do if we want to retrieve a record
so to retrieve a record
let's say player P
equal to we'll use the session object
dot get
player.class we want
a object of type layer return to us and
let's say we want the first record so
we'll give the key as 10.
and we'll simply print
the details
plus p
so we have a two string that we have
overridden in the class
so that should do the job for us let's
execute this
and there you see the player details are
returned for the first player
now let's say I want to write some code
to probably update those player details
so we can say player dot set player name
and change it
to another player
and we'll say p dot set h
so we've set the name and the age
let's execute this
and it says update player so you see the
statement update statement being
generated here let's check in the
database the current value is Virat for
player ID 10 let's update
and you can see it has changed moment I
refresh
what if you want to delete a record we
said it's used for create read update
delete we have done create read update
let's try the delete
so here we will simply use the session
object Dot
delete and we will pass P1
or other p
which is the object that we have just
retrieved
now when we run this
delete form player web player ID is this
and you can see
when I come here let's refresh the table
and you can see the first record has got
deleted
now similarly we have multiple
annotations available
so let's assume that we want
to Auto increment
the player ID every time a new player
record is generated so for that
we'll say Source we'll create
a Constructor
with just player name team name and age
so we've created a parameterized
Constructor we do not need the ID to be
passed we want to Auto generate it
and we'll say generated value
strategy equal to
we'll use the enumeration generation
type dot identity
now this will Auto generate
the ID
every time we try to insert a record so
let's come here
and we will comment
the delete
code
let's now
add code
to try and insert a record
so we'll add two player objects
E1 and P2
give it 70 and oh we don't need these
values now so we'll get rid of it
so we just need
the names
so we've just given the names there
and we'll say
session dot save
P1
and session dot save P2
now we'll go back to
here and we will say create since we are
recreating the table since we have
changed the column configuration
and we'll come to our Java code and
execute it
let's go now
and refresh and you can see the player
ID 1 and 2 was Auto incremented with and
generated with the new values that we
just added
similarly if we want we can also update
the column name
so let's say that for player name we
want to provide a different name
for the column in the database so we
will say column
name equal to name
and
let's say we want a different name for
the table as well so here we'll say name
equal to
player underscore table
so we've changed the table name from the
database perspective that we want
created
and for the column
if you want to put a constraint where
you do not want null values to be stored
you can say nullable equal to false
now
let's come back
save the application and execute
let's come here
and select
from instead of saying
player we'll say player underscore table
which is the new table and you see the
new table got generated
and you see the name
actually the player name was converted
to name and that is the setting that we
had provided so this shows us how to
create insert read and update data using
the orm hibernate and how easy it is to
provide annotations in the object class
and automatically map The Entity model
to the database create the table and
insert records as such
now let's talk about what exactly is the
junit tool all about like what are the
different things we can Implement with
the help of this tool here so junit is
basically a kind of unit testing
framework which is there for the Java so
it's kind of a default offering for the
Java programming language that we can
use the J unit for the unit testing
framework for performing the unit
testing now the main benefit of the
junit is like it's using the same syntax
like a Java programming language so it
makes it very easy for a Java developer
to write and execute the test cases so
most of the times when the developers
are going to work on the Java
programming languages so they prefer
that junit as in a default unit testing
framework for them because they get the
language Advantage they get the easily
Integrations on the eclipse so those
benefits helps the developers to decide
J unit specifically for writing the test
cases and running the test cases there
now whenever these test cases are
actually being executed whenever you add
up a new piece of source code so all the
unit test cases will be executed will be
again executed there every time when you
run a new build so all the unit test
cases gets executed but you also need to
take care that if you are adding up a
new functionalities you also have to add
the corresponding test cases to that so
increasing more and more code will uh
will be done by the developers but at
the same time you have to sync or you
have to keep your test cases up to date
also and as part of every build each and
every test cases will be re-executed
every time you're doing the build five
times six times a day every time the all
unit test cases will be executed over
there and the response will be given
back
right now let's talk about what exactly
is a unit testing now unit testing
refers to the testing of these small
small modules or the small piece of
chunks or the codes here now it's
basically used to have the early
identification of the defects antibugs
because you cannot simply rely on the QA
team to perform the testing and then
provide the feedback whereas on the uh
with the help of this unit testing
framework we can immediately get the
feedback right away once we are running
the test cases immediately we will be
able to know like these are the
different test cases which we have got
over here now the developers don't even
have to spend more time on fixing the
bugs and issues because these test cases
will help them with the easy and the
fast feedback so according to that they
can fix the bugs and they can take the
decision whether the source code is
working fine as expected or there is any
kind of issues as such present with this
one so unit test casing is something
which is very important from the
developers perspective also because it
helps the developers to understand that
they whether they have written a
successful code or if there is any kind
of scope of issues or perks over here
also it the successful unit test cases
increases the overall confidence of the
developers because it increases the
overall performance and the quality of
the product also so by having the
successful executions of the unit test
cases developers can understand that yes
the source code is working fine as
expected and there is no scope of bugs
or any issues as such with this source
code here so that's the main benefit
which we get with unit testing that with
this fast feedback Channel we will be
able to take uh the decisions whether
the source code is ready for the
production environment deployment or not
so that's a main benefit which we get
with the
unit testing here now of course this can
be done in two ways manual testing and
automated testing now in case of manual
testing you have to do this thing
manually within a manual tester or a
manual testing approach and in this one
you will not be depending on any kind of
automated tool which can be scheduled or
which can be executed in non-interactive
manner on the other hand automatic test
case is something which is used to be
executed using the tool and it is
something which is being done so that
you will be able to get the complete
automation there is no manual efforts
which is required as such you are going
to have like complete a deployment and
automations being done as such in this
case so automated testing is something
in which you will be giving more focus
on the automated automation tools you
may be having one or couple of tools
which using which you can write the
automated test cases and you can perform
the complete Automation in case of
manual testing it's quite uh you know
less reliable because you are dependent
on the a particular tester which which
can have perform the testing according
to his efforts and it's quite a time
consuming also because you can only run
the test cases for probably eight to
nine hours per a day
whereas on the other hand the automated
test case is something which is quite
reliable because it does not depends on
a human so so requirement so it can be
done like 24 cross seven so anytime you
can run those test cases and that's the
reason why these test cases are quite
faster as compared to any other manual
testing approach here
so J unit test cases and the automated
test cases really helps the developers
and the QA professionals to test the
source code much faster as compared to
the manual testing now let's talk about
the genuine installation now as Part D
of the installation of J unit you don't
require to install any exe file or any
kind of program there there are a couple
of Jar files which is required which
needs to be there into the a class path
so that every time when you write some
junit test cases you should be able to
refer those jar files because without
having those jar files into your class
path of your project you will not be
able to run the change in test cases so
that's the only dependency you require
if you are running a maven build then
these dependencies will be added up into
the password XML file if you are
referring or doing the build from the
eclipse or doing the development from
the eclipse then you have to put up
these Char files into the class path of
the project so that these jar files can
be loaded up and DJ unit can be referred
over here so the installation is pretty
straightforward but let's see like what
are the different steps we need to
follow now as a prerequest of
understanding the demo about J unit the
first initial two things is like you
require a jdk to be installed now you
can download the jdk8 over here from
this Oracle website and uh this is
something which you can download for the
windows or whatever platform you have
you can pretty much install it for
whatever platform is there so for
Windows platform you can download for
32-bit and the 64-bit both option over
here and once it's installed so you
should be able to use the eclipse latest
tool now all you need to do is that you
need to go to eclipse.org and there you
can download the latest version of the
eclipse now these two main things which
you require because Eclipse will be
required for creating the change unit
test cases and of course how a kind of
ID where you can run some test cases
changing test cases and all and then
Oracle is something which is required as
a runtime for running the jdk also and
the J unit test cases also Eclipse here
so that's a pre-request which we got
over here at this one so I have already
got these two things installed into my
system and I have Eclipse there so let's
move on to the eclipse and see that how
it goes on there but before that you
also require the junit jar files because
in order to have a particular junit
framework loaded up we require some uh
particular files jar files over here in
this case so I can just search for junit
forward over here and when you search
for J unit 4 so what happens like this
particular page
will help you or give you all the
details about the J unit 4. now you can
go for the version notes of the
different different versions but uh if
you want to download all you need to do
is like you can say like download and
install and the moment you go there so
it will give you the details now there
are two jar files which is required J
unit dot jar file is required over here
hamcrest hyphen code.jar file these two
jar files are required here if you want
to download it into the test class path
if you feel that you want to uh use a
maven-based project then in that case
you have to specifically go for this
dependency into pom file and according
to that that particular version will be
downloaded and will be referred over
there so these are the ways that how you
can get the particular softwares the
required things into the place so I'm
going to put up these jar files into a
location so that I should be able to get
the particular details
uh stored and I can refer to them into
my Eclipse so I'm going to download this
one here from the maven Central
so I'm going to download this jar file
and then I'm going to go back
I'm Crest hyphen core so that also I
want to download
chart
so these two jar files I have uh
downloaded and I will be referring these
ones into my project because these are
the ones which is being required into my
project as such so let's go back to the
eclipse and uh let's place these jar
files into a location so that into my
class file I can refer the complete
folder with all these two jar files
inside that so let's go ahead with that
so let's create a particular new project
over here so we'll go for new
Java project
and here I can give it like a simple one
a simple project name I can provide here
and jdk I'm using like 1.8 so that's the
jdk version which I have utilized over
here
finish
so this is the project which I have got
like in the source directory now I'm
going to create a simple file over here
a new class file over here so I'll
create it like
J
unit class so I'm going to create a
class over here in this one and of
course I need to have a particular white
main also over here in this uh specific
class over here because this is the
initial class I'm trying to create over
here in this one I can create a custom
particular methods also over here but
let's see like if we can execute or we
can run some particular functions as
such over here now I'm going to quickly
clear a function over here public
so I'm just going to create a method
over here
I'm just going to run a particular
print
statement over here
executing
junit test
cases right now this is a kind of a
method which is there which of course I
can run into my uh public wide Main and
this function will be executed uh will
be called upon over here now the thing
is that uh right now uh since it's just
a normal function but the moment I
convert it like I have uh at the rate
test mentioned over here so what will
happen like this will be converted into
the form of a test cases now of course
like right now there is no Imports which
is available there as part of this one
so you can see that the uh the the time
I have added this annotation at the rate
test I will be able to see like yes add
junit 4 library to the build path is
something which is coming up over here
or it's saying like add junit five so
whatever the library you feel that you
want to add you can do that and that
particular Library will be added up over
here now let's go for the junit 4
Library here the moment I do that what
we will happen you will see some changes
first you will see the changes in the
top saying that import
orj.junit.test that's a first import and
second import will be like junit 4 you
will see like these two jar files is
automatically being picked up by the
eclipse now even if you don't download
these jar files this is the main benefit
of the eclipse that these are already a
part of the plugins you can see their
paths that these are already installed
in plugins directory so the moment you
use these uh particular methods that you
want to use the junit these will be
automatically imported over here into
your system now you can just simply call
this method into the main void Main and
then the uh specific method will be
executed as a form of test cases so this
is a mechanism that how you will be
setting up the project initially you got
the Imports you got the uh particular
annotations configured and with that the
uh specific jar files will be
automatically being added up into your
class path whatever the Java files we
added up we downloaded previously we can
also have that added up into the custom
class path we can modify this uh build
path of junit 4 which is coming up
automatically we can just simply say
right click
build path and configure so this JF unit
4 we can actually import we can remove
it from our system and we can add our
external jar files also into the uh
build path or the class path over here
so that depends upon you that how you
want to perform the customizations
around that part but yes the particular
main benefit of using the eclipse is
that it's already having the junit
plugin installed both four and five
version is installed whatever version
you feel that you want to include it
will be included and the plugins are
already installed so you don't even have
to download the jar files manually so
that's how you will be able to do a very
basic initial setup of J unit and how a
basic project can be created over here
in case of J unit in the upcoming demos
we'll see like how we can execute these
particular test cases and we'll get the
response we'll come to that point so
let's go back to the main content right
so that was the uh Json installation
demo which we saw and we saw like how we
can put up or load the jar files related
to J unit into a cloud pattern you can
resolve the basic uh you know features
about the change unit about the test
cases now let's talk about some of the
certain features of the J unit here now
there are a lot of features which we get
primary with the chair unit let's
discuss about that one by one so the
very first feature about J unit is that
it's an open source Network now it's
something which is available as an open
source to you we have also seen the
installation so you don't have to really
go for any kind of license or something
like that so you can do any number of
test cases with this particular tool and
this specific automation tool here you
can automate it into Jenkins no way you
require any kind of license around this
so um these can be easily integrated
these are already or part of most of the
latest Eclipse installation so you don't
even have to configure these manually
because it's already a part of your
system
right second is that it provides
annotations now main annotation we have
already seen in the previous case that
when we converted a normal function or a
normal method into the test method by
using an annotation called at the rate
test so it provides a mechanism to
identify that which particular method is
a test method and which method is a
normal method according to our classes
so these annotations really help us to
identify the methods also and it
provides us the flexibility that it
these uh particular methods are not the
normal methods we need to execute you
need to run it in the form of test cases
so that identification is something we
will be able to do with the help of
these annotations here also it provides
the excitations uh to identify like what
exactly the results are there because uh
definitely when we are running the test
cases changing the test cases we need to
assert that what should be the value so
using the asserter you know we can
acceptations we can actually compare
that okay this method is giving this
value Suppose there is an the addition
method which is available there which is
giving like a plus b is equal to C so C
is like 5 plus 15 is 20. so with the
help of assert I'm saying like uh
whatever the response I'm going to get
from the function when I give the values
A and B as 5 and 15 so that should be 20
value so in the assert I can hard code
like okay this is the value this is the
response which I should be getting and
once the function is executed I should
be able to get this particular output as
in 20 over here so that comparison when
you do you will be able to understand
easily that yes when we are doing the
asset I am getting the proper response I
am getting the proper output over here
so oscitation is something which is very
important to compare the things to
compare the inputs which we are getting
from the application source code
next it provides the test Runner so we
can basically run the test Runners over
here to execute the test cases so you
can configure this within the pipelines
you can configure it with eclipse and
various automations during the pale
automations also you can configure it so
that flexibility you will be able to get
with these test Runners here and it also
allows you to provide a better feedback
Channel because it acts like a very good
uh feedback provider because the moment
you are done with the development you
will be able to get an instant feedback
so the overall quality of the code is
going to be increased in this case and
that's definitely helpful for you
because with this uh approach with this
junit uh framework you will be able to
get a quite faster and a perfect code
writing tool or a Quality Tool which is
available there so definitely the
overall quality of the code is going to
improve with the help of this junit
framework
and it provides the automations also
because these generator test cases are
having the flexibility that you can
configure it within the pipelines you
can automate it with the help of this
framework that you can completely help
or you can have a complete automated
workflow with the help of this
particular framework and it provides you
an instant feedback the feedback channel
is quite instant in case of this J unit
now let's talk about the junit
annotations we have already seen like an
opinion benefit of The annotation is to
define or to provide the metadata about
the methods to the different ones so
annotations also refer to the
syntactical uh method data added to the
Java source code so having a particular
better of feasibility and identification
is also quite easy so also the overall
structure of the source code can be done
in a better way and the readability is
also good when we talk about the
annotations here the biggest main
difference between the junit and the
junit 3 was the in the introduction of
the junit annotations so uh earlier
before J2 net 3 we were not able to
identify like if this is in kind of a
test method or this is a kind of a
source method over here so that
identifications is quite easy after the
involvement or the introduction of the J
unit 4 framework over here
also like uh this is something which is
really helpful to us to see like how
exactly we can overall read the overall
source code because you have so many so
many source code there present to your
project so annotation should be able to
uh you know help you to identify the
that these are the main portions with
these are the components which is part
of the unit test cases not the actual
source code so at the rate test is
something which is uh uh you know going
to tell us that uh the the specific
method with the public wide uh
declaration can be a run or can be
executed as a test cases this is not a
simple method this is not an application
source code method this is a test method
over here now at the rate before
something which is uh used to run some
statement before each and every test
cases executes maybe having some uh
additional or initial connectivity is
something you can do with the help of at
the rate before
at the rate after is something which you
can do after the execution of the test
cases like some statements which you
want to execute after the test cases so
that's something you can do or you can
go with the help of at the rate after
and at the rate it knows is something
which you can configure if you feel like
during the test execution you feel to
ignore some statement so that's a way
you can use the add that it ignores
there so at the retic nodes at the rate
after at the rate before and at the rate
test these are the four annotations
which is being used most of the time
into your junit test cases
right let's talk about some bit more now
after it before is something which is
being used to execute the classes uh
some statement before even you know any
kind of test class executes so not only
uh you know before executing any method
this is something before even loading up
any kind of uh test classes so before at
the at the rate before class is being
used
similarly at the rate after we'll be
there to execute it after all the test
classes and uh if we have a timeout
configured so what we'll have that we
will be able to set up a timeout while
executing the test cases so timeout
value can be configured over here and
then uh if you feel like if you want to
handle some exceptions during the test
execution so that's where we can use
this custom annotations over here to
have the exceptions handled or
configured over here in this one so
these are some of the very important
annotations which is available there on
the chair unit perspective now let's
talk about some another demo on chair
unit testing in the Java like how we can
pretty much configure the test cases in
J unit for a programming language called
Java and how we can get a long or get
execute those things so now we are going
to see like how exactly we can you know
go for the execution of some Java files
onto our Command light and how we can
using the command line run some
execution of the test cases typically we
do it from the eclipse but uh from the
command line also we are going to see
like how exactly uh you know we are
performing the setup and the executions
over here now what we really need to do
is like we need to see like how we can
proceed further with the execution so
I'm going to open this uh particular jar
file over here so to get a better
understanding here so I'm going to use
the YJ dot unit junit uh class over here
in this case so we are having a couple
of imports these are the standard
Imports so you can do like orj dot CNET
junit dot star also if you don't want to
go for this specific Imports here now
here we are going to create a test unit
as in a sample class and in this one we
got the wide main over here which is the
main portion of any kind of class here
the only thing which we got over here is
that we have created a test method over
here called test print message so we are
assigning a value called message a
variable over here as in simply learn
now what happens like uh we will be able
to uh like you know do the third equals
over here that if the value of message
is like simply learn
so it will be able to help us with the
proper output and there will be no
errors as such over here so everything
will be smooth and that's what we are
trying to execute over here in this case
and we are running into the null void
that these are the test cases we want to
run or we want to execute over here now
all we need to do is like we need to
compile this one we really need to
compile this test cases over here this
file and then we have to run that one so
for that let me open the command prompt
so now in this case we will be using the
Java C command prompt here and we will
be copying the junit into the class path
so that we will not be able to get any
kind of class not found issues over here
so test unit J unit dot Java we are
going to run so if there is no
exceptions as such we will be able to
get no errors here now I'm going to run
the particular class file with the help
of java command because Java C is to
convert the dot Java file to the dot
class file the compile format and then
in order to run the dot class last file
we have to go for the Java command line
here now this means that there is no
issues as such with the test cases and
everything is working fine as expected
over here in this one so the assert
equals is going to help you to identify
that if the
execution is proper and let's say like
if we put up some content like some
different content over here in this
assert equals so I'm going to again
execute this one so that I will be able
to see like if you know what will happen
that if this message value and this
value does not matches like in normal
situations it will say like okay the
particular uh you know output is going
up and there is no errors as such right
so let's see like what exactly uh it
will happen that if we go for the
executions like if we save this file in
such a way that we are providing some
wrong inputs and what will happen to our
assert equal over here so I'm going to
again compile the file here so again a
new class file will be available and
this time I'm going to execute this
class file again over here in this case
and the moment you did it the assert
will give you the uh comparison over
here saying that there is a failure of
the comparison why there is a failure of
the comparison because according to the
code base it was expecting the value
called simply learn but it simply got
the value called simply learn one two
which means that your test cases over
here got failed down so this is the real
uh way that how you will be providing
the comparison like what you should be
putting up to the application and what
kind of response you should be getting
in in Return of that so that's where you
will be able to provide a proper and a
complete comparison here which will help
you to understand that what exactly
output you're going to get over here and
that's where the output will be a
completely available to you and you will
be able to get a proper output asset
here
right so this is the way that how the
comparison will be performed and how you
will be able to see like these two
comparisons being done here as such so
this is the way that how you're going to
run the test cases in the form of the uh
from the command line here so let's go
back to the main document right now the
next one which we got over here is the
change your test cases using the eclipse
because from the command line we saw
like using the command line we can do
but we got like so many test cases which
is available there so it's not easy for
us to run those one by one so we will be
doing it through the eclipse so that we
can see like how the execution can be
really done and we can get a hold of
those particular components so let's go
back to the eclipse and this time we are
going to run the test cases in the
eclipse here now let's create a new
project again here
J
unit
project
right and finish so a new J Project A J
unit project will be created now in this
one you can see like there is no uh
executables libraries for the junit but
you can include it now also but I'm
going to do it later on so I go for the
unit project class right so this is a
kind of a test class here so I'm not
going to put the null or the public wide
mean over here in this one so finish now
in this case what I'm going to do is
like I'm going to you know replace this
content over here so uh with this uh
particular ones and going to have some
basic code base added up over here so
I'm going to import some particular
junit libraries over here so over here
like watch.j unit I'm going to import
these ones and I got like this class
over here junit uh you know project so I
just have to rename it a little bit so
that it can be the name of the actual
class name here so that's fine so
everything is fine but the only thing is
that we are getting some failures and
problems over here because it's not able
to identify these uh specific uh unit
related executables like the functions
and the methods for this one again the
previous like previous case you have to
do the particular addition
library to the build path so that you
will be able to have like these
automatically resolved over here in this
one right so you can see now that they
have junet 4 started reflecting over
here in this case and you did not got
any kind of Errors now over here in this
one so you can simply save this and now
you can you are good to go for running
the executions over here so you can
simply say like right click over here
run s and J unit test
and when you do that on the left hand
side you will be able to get a little
bit different Viewpoint over here which
says like yes test underscore junit is
something which is executed perfectly
fine if for any reason let's say like I
change the value of string 1 here as in
string one just an typo error I'm trying
to do here so that I can show you that
how the test cases really fails so
assert equals is basically helping to
find out that if the comparison between
the two attributes is correct that means
that uh you know the inputs which we are
putting up and whatever the output we
are getting it's both the same here when
you do that you will say like there is
an failure over here to the test cases
now I'm seeing the failure Trace over
here so I'll just move this one to the
console view so it says like it should
be like string but I got like string one
over here which is causing the problem
here because of the typo error which I
did the whole execution of the test
cases got failed so I'm just going to
revert my changes back here and again
run the test cases
it will all be okay right now again over
here so that's the main reason that how
the execution really happens in the
overall mechanism and the system can be
implemented over here in this case so
that's how we basically go on and we
execute some junit test cases here now
in this one we are going to talk about
like how exactly we can use both
mosquito and junit here to go for the
unit testing but before even talking
about these two tools here let's focus
on to understand like what is exactly a
unit testing here now there are various
kind of testing which is actually
available into our particular industry
and into our software testing World
there but yes there is a very important
scope and a position of the unit testing
here so unit testing is something which
we also call is an kind of a component
uh testing is actually a software
testing technique in which single
component of a software is being tested
we are not talking about like how
exactly our application going to
interact with other applications and
it's going to interact with it's not a
complete full-fledged application
testing so in this case what we are
looking forward is like it this is
something in which we are focusing on
how exactly we can only validate and
test out a single component a single
component is what we are basically
talking about over here right and when
we say like how exactly uh we want to
perform we want to achieve the setup
here so this is the main mechanism or
this is the main kind of testing which
an individual developer performs at its
own end to see like whatever the piece
of source code he is writing whether
it's working fine as expected or not
so this is where we are able to see like
uh the exactly what we are trying to
achieve here and how a full-fledged or a
basic testing validation can be done now
the main objective of this unit testing
is to pick a unit a very basic small
small unit of the source code to verify
it so that it will be uh the moment the
developer develops the code base at that
moment of time only this thing will be
validated and will be fixed on so this
is something which we are looking
forward over here to achieve like how
the automation needs to be done and
needs to be achieved over here in this
case
next thing is what exactly is the
mocking here now we talked about like
junit here but next one is like what
exactly we are talking about as in a
particular mocking over here now when we
talk about mocking so we are basically
uh trying to understand like what
exactly uh we are performing for what
purpose we are going for the mocking
process here so mocking refers to the
development of objects which are mock or
clone of real objects they are not the
exact uh objects or we can say like
that's not the exact scenario which we
are going to implement but it's kind of
a duplicate or it's kind of a temporary
mocks which we are creating so that we
will be able to get it implemented so
mocking is something which is kind of a
reference or a kind of a clone of an
existing or a real object here
so in this technique what happens that
the mock objects are being used instead
of the actual real object so it's not
like we are directly or we are going to
access the exact real objects over here
so we are talking about like uh using or
going through the specific mock objects
over here in this one so that's where we
are putting up the main focus right and
mock objects actually give a particular
output uh for each and every input
whatever the inputs you are going to
provide you are going to get in
particular desired output so the mocking
is going to process all these inputs
give you the desired output and to
understand like how the implementations
and the setups can be done right so for
these kind of mocking process mocking a
framework is something which is quite
popular so mosquito is one of the
framework which is available there which
is designed for this kind of uh work or
this kind of approach only where we are
trying to see like how we want we want
to perform a mocking imitation over here
right so let's talk about the marketer
tool because that's a primary tool which
is there for the mocking activity and we
have already focused on like marketing
is a process in which we are trying to
uh process uh the mock objects rather
than the real object so that's kind of a
verification here so marketer is a kind
of a job is framework which has been
used for uh doing the unit testing on
the job application so if you have
written the source code in Java
programming language then marketer is a
kind of a framework for you so this is
something which is helpful for
validating the development of the kind
of application source code here so you
will be able to validate that how your
application is going to behave and it's
going to work so when we talk about mock
a market over here so it basically gives
you a variety of information like what
exactly approach you are looking forward
and what is the end result you are
trying to establish over here so that's
a main focus of the Marketo which we are
going to get and it's for the basic
approach over here
so Java Reflection API is basically used
internally to generate the mock objects
that's a core component you can say like
the backbone of this whole mocking
approach over here mochito is used to
simplify the test development by mocking
the external dependencies and using them
in the source code so it's kind of a
blending in the whole environment there
so that your application is going to get
the desired environment and uh being in
that environment it can start processing
the inputs and then give the desired
output accordingly so this is what we
are trying to uh you know Implement as
such over here to see like how exactly
this mocking can be done and mockito can
really help us in this approach here
right now what are the different
pre-requests which we require to learn
Marketo so we basically need two
important pre-request over here first of
all we need the hands-on experience in
Java programming language so Java
programming language is very important
because mochito is something which we
can write in the Java programming
language it uses the Java programming
language syntax so that's a very
important thing there to be considered
and second one is the junit framework
implementation so these two things we
basically require for performing a
complete full-fledged mosquito approach
or mocking testing over here so these
are the two important uh components or
you can say like the two core prerequis
which we need to process before going
for the mochito implementation
right so let's go to see understand like
how mochito framework can be configured
in Eclipse because eclipse is the prime
tool for creating the uh development
source code for the Java programming
language so we need to see like how we
can configure the mogito framework over
there because that's the one that's the
single IDE which will be utilized by the
developers there so let's go ahead in
that in this demo we are going to talk
about like how we can create a simple uh
junit and mochito related uh program
over here so that we can have a basic
project created and we can also have
some basic program created on that part
so let me open the eclipse here now in
this one what I'm going to do is like
first of all I'm going to create a maven
project once my Maven project is created
then I'm going to include mochito and J
unit related dependencies and after that
I'm going to write a very small source
code uh just to see like how exactly our
dependencies are getting resolved and my
source code which will come up as an
error earlier will come up as unhealthy
over there so all I have to do is I have
to just right click over here
here I need to go for project like I
want to go for a particular Maven
project here so I can expand the maven
over here and go for Maven project
here it will basically ask me certain
values uh I want to use the default
workspace location so I'll just say next
then I want to have it uh like I want to
go ahead with this overall process so
these are all projects like what exactly
uh you know archetype you architecture
type you want to go so I can just go for
the default whatever is selected I can
just go with that and here I will be
providing like what is a group ID so I
can provide a group ID called com dot a
simple learn or depending on your
organization you can actually provide it
so here I can provide Marketo and the
version will be like this and this is
the same way like how the project will
also be created the package will be
created in case of the project here so
then I'll just say finish and uh on the
left hand side I will be able to see
like my uh specific source code which is
available there so this is something
which is uh going to come up over here
so it's actually trying to uh resolve
some of the particular options like some
of the uh you know like uh the
components test executions those are
required over here so I'll just uh go
for this particular resolution later on
right so I'll just open this form.xml
file here
and this is the power maximum file right
so it's basically looking forward for
certain changes like this in jar file so
this jar file is not actually available
over here so uh once I ran the build and
uh you know those kind of setup can be
done then it will be able to download
those particular dependencies so if you
right click on this one you will be able
to see that a particular Maven build
option here so I can just run the maven
Builder you can just run the map and
clean here
so according to that the maven will be
downloading certain plugins and it's
just trying to do some uh particular
process over here so on the left hand
side the source main test
the same package which is available they
are the same packages is coming up there
so app test is available there so here
the test is being available here I can
see like some couple of junit related
test cases is already being there like I
created a kind of a sample project so in
here a basic Java and a basic class file
or a test suit is already being
available here so all I have to do is
like I have to just try to see like if I
can go ahead with this executions there
now it's using like junit uh 3.8.1 over
here so I can definitely go for a
version which is uh higher like around
just unit four or five there but let me
try to do a clean build over here Maven
build over here so uh to see like if it
really works on there so uh what are the
goals I need to do I need to go for the
goals called clean install so that's a
goal which we need to do here so uh mvn
will automatically be resolved there but
clean install is a goal which I want to
look forward over here so let's see like
what it really happens so it's going to
download some couple of games whatever
the plugins I'm trying to provide here
some dependent plugins will be
downloading so all that stuff will be
downloaded this is the first time we are
running there so that's why it may
download some little bit more jar files
than expected ones not you must have
seen like these are all jar files is not
like something we are using into our
project but these are kind of Jar files
which is being used by the plugins by
the maven itself so for that purpose
it's actually going to that particular
level but once these are cached up there
next time if you do the run if you do
any kind of press here you are not going
to see all these entries so let me rerun
the wheel here to show you like how
clean the output would be there
so I can just go for clean install again
say run
and this time the output bit will be a
little bit less there so in this case as
you can see
if I expand the output
so here first of all it ran like it
performed the clean activity then it
compiled my source code here it also
compiled my test cases here in this one
then my test cases got executed over
here so you can see like it's something
which got XX executable over here so
this is the test which is available I
can click on that and I can see that and
after that it went on and prepared the
final artifact here which also means
like it performs both the compilation
and the test cases execution and this is
what we are doing in any kind of Maven
project and on top of that I'm using a
junit related Frameworks so this is a
mechanism where we can have some
dependencies like I can go for junit
here I can increase the dependencies I
can try out the pair so all that stuff I
can do here right and one more
dependency which I can include is of the
mochito here so I can include the
Marketo related dependency also over
here so that we can see like how exactly
the response is coming up there so you
can see like it's uh you know when I go
for the resolution over here like clean
build
clean install so I can just go ahead
with this
so this time it's actually going for the
Mojito one so you can see like all the
steps has been executed and we have got
the end result so the build is
successful and I have got the test cases
also so this is a test file where I'm
actually loading up some J unit related
uh executables there so I can just go
with that and whatever the activity
assert we are using over here so uh
using which we can do the comparison so
this is a way like how a basic project
can be created in Maven and on top of
that how we can manage the dependencies
for mojito and for change unit here
right so that was a demo in which we
talked about like how exactly we can
configure mochito into our Eclipse here
now let's see like when exactly we uh
required the mosquito to be implemented
now in this case what happens like uh
when when exactly you feel like you need
to have a Mojito implementation or how
we can go for the mochito implementation
all together here so for example when a
component is to be tested or a single
unit needs to be tested so this unit or
component actually depends on some other
component which is uh kind of uh in in
development process or maybe some other
developer owns that component and you
are not exactly validating that
component you are validating your own
component but since it's actually
dependent on other component or some
other unit of the of the whole
application so that's the reason where
you may not be going you may not be able
to perform the end-to-end testing but
yes with the help of mojito you will be
able to get the mock objects so that you
can perform the testing there you don't
have to held up with that other
component dependency you can resolve all
these dependencies like that and you can
just proceed further with your
verification and your implementation so
this is the main benefit which you get
when you talk about the marketer so that
you can see that a full-fledged
understanding like how exactly these
different components are going to be
process here
right and when there is any kind of
concern like uh if if uh you know like
if you feel like there are some
infrastructure components which is
making the testing impossible so in that
case also we can use the marketer to
mock some infrastructure components so
that we can proceed further with the
validation and the testing here so all
the hindrances and all the problems
which we normally face when we talk
about the implementation all those
things can be really implemented with
the help of mochito here so that's a
main benefit which you get over here in
this one now let's talk about the next
concept so the next concept which we
have is what exactly is a stub very
important concept here so stub is a kind
of object which holds up a predefined
information a predefined data we cannot
do a kind of a dynamic verification in
case of unit testing because we have to
uh limit the scope of testing we are
putting up some inputs over here just to
see like how our application is going to
behave these predefined data will act
like inputs and the test cases are going
to process these inputs and give us the
desired output so these outputs we will
be then analyzing to understand that how
our application is going to behave or in
other terms like how application is
reacting to these inputs so that we can
get an end-to-end desired output as a GM
also it can be referred to as an object
that looks like exactly a carbon copy of
a real object of course it's not a real
object it's a kind of uh mock object
over here in this one but it will give
you the exact different details or you
can say like things that output as such
over here in this one so that's a main
benefit which we get with the stuff that
it helps us to get a mock object instead
of the real object so that we can get
ahead with the testing and we can get
all our environment for our test
executions here
right and stuffs actually they can
actually return the specific output here
like whatever the output you require so
that will be returned over here whatever
the inputs you provide that is going to
be processed by this one and the desired
output will be provided to you over here
in this one now these Tabs are used to
reduce the complexities right so that
occur while creating the real object so
that's also the complexity which is
going to be reduced when we talked about
the uh these specific steps as such here
so whenever we talk about these tabs we
talk about the implementation so this is
where the complexities get reduced when
we talk about the replication or the
marking of the real objects here
right so let's talk about like how we
can uh see the stub in real action so
that we can get a better understanding
because from there we will be able to
know like what is the mean importance of
stuff in the whole mocking approach here
so let's go ahead with that in this demo
we are going to talk about uh like how
we can create some prerequest for
testing out a stub here so I'm going to
create a required Maven project and a
couple of class files over here to make
a kind of environment so that we can
test it out the stub implementation in
mochito so first what I need to do is
like uh I need to just go ahead with the
maven project so Maven project is what I
need to create a very basic project I
want to create over here uh you don't
have to do much of the changes like not
uh much things you need to talk about
over here so uh the package Direction I
can make it like okay I just want the
particular package if if you don't want
to have the package and you would want
to directly store The Source Code in
source me in Java and you want to put
the class directly over there without
having any kind of particular comment
all that stuff so you can do that also
over here in this case so that will be
much faster so you then you can just go
for the finish here
and you will be able to see like a
project created like a source main Java
then this particular package name is
there and so test Java is also there so
here is the test file here is the main
file I I can go ahead with this one I
can create a file over here you can
pretty much do that stuff also so or you
can change like in this existing one
also so what I'm going to do is like I'm
going to create a new class file here so
I'm going to say like okay create new
class file and in this one I'm going to
put the particular class name and the
specific content so uh let's see like
how exactly we can go so we can go for a
particular
class Creations as a chair or we want to
create so one class and one interface we
want to create so that we will be
creating over here so I'm going to
create a interface here
right so
to
to surface so that's the interface name
which I'm trying to provide here
and uh in this one
I'm just pasting the content
this is already
configured here so
you just have to
confide so uh then I'm just going to
resolve
this one so the
java.util.list is also resolved so this
is the to do service.java which is
available there now what I have to do is
like I I'm just trying to create it over
here and I'm just uh trying to create an
another class file over here in this one
so which is like my to do business impl
over here which will be using this
interface right so I'm going to create
a particular class file in this one
and we are going to create it
okay great so in this one again I'm
going to paste this content so I have to
just sync this one so this is what so I
have to just rename it little bit of
this one so
I have to just
rename as in particular
this as a 2 over here
great
so now I'm pretty much done here so
whatever the Imports are required I can
actually go it just this Delta I want to
remove it
and here we go so we are creating a
particular to do service mechanism over
here in this one so we are also talking
about
the uh list here so these lists where I
can go for the auto resolution here so
I'm just going to save it and uh then
I'm going to see like for to do here so
to do is something which is coming up as
in a particular uh service here so a
little bit changes in this uh interface
also so
I can just you just have to sync it on
the names so whatever name you are
following you are using so that you need
to change over here in this case so here
also in to-do service I have got it
renamed so that's where it got
successfully resolved and as far as the
error list is confirmed so I can just
import that also so I'm just done here
so if you by chance change this class
name then you change the Java file name
also calling there so that you will be
there in in proper sync up over here so
that's uh something uh which is
available there which we can use to see
like how the implementation can be done
and that's a basic output which you're
getting over here now this is where we
have got all the required source code
available there when we will be testing
out this tab so at that time we can
actually use these one interface and one
class over here so this class is
basically going for the interface call
over here in this one and that's how
it's going on the implementation so
we'll come back during the testing
during the verification of this stuff at
that moment of time this will act as a
kind of basis for us here so this is a
kind of basic structure that how you
create a basic uh program or a basic
source code over here in this one so
what I'm going to do is like I'm going
to just create these tabs over here in
this one to test it out to validate that
the things there so last time we created
the Java Source course here now the
steps we will be creating over here in
this one
then we are just trying to
create first one is for the to-do
service so to do service
stop so that's the name which I'm going
to use and just finish it off and uh I'm
just going to put the content over here
so I'm just in order to try out the
particular matching over here in this
one so uh to do stub is what we are
trying to implement so that's what we
are going to see here so I'm just going
to remove uh this mechanism so I'm able
to see like all the Imports is working
fine
in this case we are just trying to put
some a dummy information so you can see
like this is the array this is the error
list content which we are trying to
provide over here in this tab so we are
basically trying to understand like how
in the mocking activity we are trying to
Mark some particular inputs here so that
my steps will be able to pick those up
and they will be able to return those
there so that's what we are trying to do
here now as far as this uh stub is
configured this is done so we have to go
for another stop here which will be
there for the to do business impl so we
have to create uh this one for uh that
particular
implementation so we have to put the
content over here in this one to do to
put the two uh do business impl stuff
here right so I'm going to paste the
content here just to uh just to match up
the things so I have to uh just put this
content here so I have to just rename
this one because uh even if we create
some files sometimes we may have to
rename it so that keeping in mind I can
just put this one here and say okay and
uh I'm just going to remove this
component here and here we go so we have
got like uh this components like this is
something which is available there we
have got uh the implementations which we
are trying to do we have got to do
service and to do service stuff both
here but I can these are the kind of
wrong interfaces so ideally my
interfaces is com Dot
simply line dot stub so that's where we
have got the uh particular to do service
over there and uh similarly here also we
have got the particular ones which is
available so which is also there in the
uh specific com dot simply learn dot
stop dot to do service stuff here so
this is a mechanism where we will be
able to find out even if I don't give
this import that's totally fine because
I'm already there in that package so I
can just refer it from there and we also
have the junit related ones which is
available there so we are getting the
errors for the junit uh components over
here in this case so
we also have the pom.xml file here in
which my J unit is being utilized so uh
you know in this one we are basically
trying to use some references around the
J unit here so you can get it on board
on that case so I can just try to run on
the particular Maven build here to see
like if all the dependencies are getting
implemented so that we will be able to
download some required dependencies so
clean install again I'm going to just
refer it over here I can just run the
specific test also like if I feel but
I'm just trying to download some couple
of components over here in this case so
if there is any kind of issues which you
are getting during the execution so you
will be able to see over here for
instance like oig.j unit does not exist
over there right so uh since these
packages are not downloaded or not
installed so that's why you're getting
the issues as such over here in this
case
right so these are the uh references
which is available there I can just go
ahead and uh import some of the
chair unit related ones in this case
if I feel like I want to run it so I can
run this Java file also over here this
file also I can run it over here right
so those are different options which is
available which we can utilize in this
case
so I'm just adding the junit 4 Library
so that my uh all references related to
J unit should be resolved here and the
moment I picked up that one you can see
like all the errors related to J unit is
gone now I can run my build here to see
like if it's getting successful so uh
this time okay so uh it's it's going for
that particular mechanism so I can
change
the specific version as in 4.0 let's see
like uh it's getting resolved so it
should be able to download that
particular artifact so I just have to
find out that what is the version what
is the latest version we want to provide
and according to that the artifacts will
be there and it will be executed so uh
there are some cases when we are using
uh the default mechanism of creating a
junit or um even project in Eclipse
sometimes it actually uses an older
version so it was using 3.8.1 version
which is old version so I'm using 4.0 so
this source code is actually prepared
according to 4.0 and the moment I
started using that the moment I tried on
that one there so you can see like here
it got executed like both the its cases
got executed over here I have got the
response over here in this one like
these two test cases is being provided
over here so test run is two there is no
failure all good and then ultimately it
went on to the jar file preparation here
so this is a way like how the stuff is
actually going to uh particular uh you
know it's going to call the particular
specific classes but yes in this case we
are just trying to input some values
some static values which is not the real
objects but it's kind of a mock of an
real objects and that's how we are going
to continue with our test cases just to
see like you know some inputs if they
are not there we can still go for the
testing and we can do the verification
here so this is a mechanism like how we
can test out a stub to go to see like to
understand like how the overall mocking
is going to happen here so that was the
main uh implementation on how this stuff
can be implemented in the whole process
to see like how exactly we can cohort
with done now the next demo which we are
going to talk about is like how we can
full-fledged implement the complete
Market or code here so that the
end-to-end implementation of the mocking
of real objects is what we can get over
here in this one so this will give us
the complete insight about this whole
process now first we will be creating a
specific uh we are taking up a stock
inventory kind of example over here so
we are going to create a Java file over
here which is named as stock.java so I'm
just going to create a class file here
called
stock
and in that case we will be providing
the content here so I'm going to create
a stock class which is having certain
methods certain functions stock is the
mean function which is available there
now we have to create a particular
interface which is going to uh you which
is going to be used to get the stock
there and uh then ultimately at last we
will be getting a one test file which
will be testing out these things the
communication see like if the marketer
is getting passed or the test case is
getting passed or not so this is the
class file which is available there get
stock ID set stock ID so basic getter
and Setters are being used used over
here in this case
so now I have to create a particular
interface here with the name called
stock service
I have to
call the
get price over there so kit price is
basically configured over here in this
one
right so we are going to just call upon
on that to see like how exactly it goes
out there right so we will be utilizing
this one so this is the interface which
is calling up the class called
stock.java now once the Stock main class
in stock service or stock interface has
been created now we have to create a
particular portfolio class here this
portfolio is a kind of interface which
is going to
consume this uh specific stock here so
portfolio uh class is what we are going
to create here so I'm just going to use
it
and
test operation so I'm going to just
import the java.util also so that these
can be imported so these are some couple
of activities like under this one we are
also calling up these stock service
interface so that that can be calling up
the stock internally and this is kind of
a business logic which is happening so
portfolio.java is kind of a physics
logic business layer where I'm just
trying to call them the main class here
to fetch the details through an
interface and in this one we are
basically doing the all processing like
whatever the activities I'm trying to do
so here I'm doing the processing about
the data here right so this is what we
have from the source code perspective
now we will be moving on to the test
cases perspective where we will be
writing a test file to do the mocking
over here and to get the stocks and try
to do some verification so now I'm going
to create a particular portfolio tester
here which
will be testing this specific portfolio
here so that's what we are going to do
right so it's going to use some of the
mochito related jar files here and since
we already have those dependencies like
we already got those added up to our
password XML file so and these are also
being shown up as a maven dependency
here so both 4.0 and this Market
dependency is there in the maven
dependencies and that's why we are not
getting any errors for these Imports
here and we are getting some list
related errors so let me import those
also and uh we should be fine by now
okay so as you can see like here we are
when we are doing the verification right
so using this portfolio tester we are
actually inducing some Stacks so here
you can see like we are doing some setup
we are calling that stock service okay
so that we will be able to call upon or
we will be able to get the information
and here we are actually putting up some
content so the whole idea why we are
putting up this content just to uh have
the implementation we are just trying to
replicate our real objects here these
are not the actual real uh
configurations or real information which
we are getting from the uh end users but
these are the the dummy informations or
the dummy data which we are trying to
provide here and depending on that we
will be able to get like how it's going
on there so we are basically trying to
call a function called tester dot setup
there tester dot setup is what we are
trying to uh call upon over here which
will set up the initial information and
then we are calling the test market
value so my test market value will
basically give me a pass or fail kind of
uh result set here so that depending on
that I can decide that whether it's
successful or not and this test market
value only here we are putting up some
dummy informations and against these
dummy informations the test cases will
be executed so let's just run it my
build is already success so I don't have
to run it again there so what I need to
do is like I need to go for this
portfolio tester dot Java here so that I
will be able to get the results and here
we go we are getting the pass output
over here in this one
right so this is what we are trying to
do just to see like how the
implementation should be done there I
can go for a negative scenario like
where I can just a little bit modify uh
something over here in the output and
I'm just trying to change a little bit
of uh specific uh output so that's what
I'm trying to do here so um I can
definitely go and see like if this is
something going to uh process properly
or is there any kind of problem which we
are getting over here I can also remove
this decimal value just to see like if
uh I'm getting successful over here or
not so I'm just running the test cases
again
and here we go we got the response as in
Failure because the expected thing is
not coming up like whatever we are
returning so that's where the field uh
it's going down for the failure I'm
going to roll back my things here and
see like if it's again getting success
or not
so yes here we go we got the past
success over here the pass status over
here in this one so just like that you
can actually mock the objects you can
put some inputs and according to that
the responses will be coming up there
and you can go ahead with that
particular mechanism so this is the way
that how the things really gets moved on
when we talk about the Marketo and how
we can mark the real objects and we can
test out our application here so that's
what we do with the mochito here so that
was a complete uh Marketo code or you
can like the complete demo over here
like how the overall process really gets
implemented over here in this one
right now what are the different
benefits of mojito let's process that
one by one so
the main benefits of mochito is like
first of all we'll get started with the
very first one is like the no
handwriting so that's a very first
benefit which is coming up over here now
second one is the object creation
third one is the safe refactoring then
we have an exception support uh benefit
which we get over here then we have got
like The annotation support which is
available there and then the order
support so these are some couple of
benefits which we got over here to
completely understand like how exactly
the uh particular mosquito can be really
achieved over here in this one right
that is the top 10 Java project ideas
so the first project that we will deal
today is the Online Career management
system
so this particular project motto is to
deal with the career management system
the system will be used for day-to-day
activities like buy written booking
delivery and non-delivery and self pick
up Etc
it is not easy to build this particular
project all alone as the technicality of
the project is a little complex for a
single programmer I would suggest you
that you get a team with you and also
look out for some Automation in the
process by developing the relevant
software robotic process automation is
the new normal in today's life the web
enabled interface allows the user to log
in from anywhere in the world and track
their career and also view the customer
rating
the system is designed to integrate with
financial accounting to eliminate
duplication of data entry and is also
scalable to grow along with your company
the system needs to be built with
user-friendly screens rich and
functionality and features and finally
the major part it should maintain a high
level of data integrity
so with that abstract disgust now let's
look into the features offered by this
particular online Courier Service as
discussed in the abstract this
particular project should be providing
the features of order and dispatch of
the product information regarding the
customer delivery executive and followed
by the delivery executor we should be
also having a payment window which
manages the accounts and build reports
so having said that let's now move into
the software requirements
so the software used in this particular
project is the programming language
status Java database is the Microsoft
Access and some convenient RPA tools and
finally the IDE the ID for this can be
anyone which has a good support for Java
the most preferable one would be the
eclipse and then comes the IntelliJ
netbeans and many more now creating this
kind of a project will give you a
valuable experience based on building a
fully fledged e-commerce website or an
application I mean this is how the worst
leading applications like Amazon
flipkarts and Mato Etc are basically
planned and have reached Greater Heights
today this kind of project on your
resume could make a huge difference and
who knows tomorrow you might even get
into one of those companies and start
working on their projects or build a
company of your own
followed by the online Courier system we
have the online voting system
now thinking apart from getting a job or
starting a new company of your own this
is something that we all need today in
this pandemic situation especially in
the current scenario the internet has
brought all the ease to our living room
it has replaced physical banking to
internet banking ordering food online
buying movie tickets
buying clothes and household items to
consult your doctor for minor issues
bill payments and many more yet for
quite a long time going to polling booth
and standing in a long queue to cast a
vote has been persistent and it has been
challenging for the government to
motivate common people to participate in
the election system and cash their vote
just because there is no other way to do
such thing as such an online voting
system but all the credit can be
achieved by software Engineers who can
make it possible soon for everyone to
cast their oat to their respective
candidate as their own choice with an
unmatchable ease
this can be done just by click on their
fingers this is an advanced Java project
developed to show online voting
functionality followed by the abstract
we will get into the technicality of
this particular project so the first
phase of this particular project has the
admin phase where the admin has the
right to manage the candidates manage
the voters and their profiles and
passwords and finally election results
followed by the Admin we have the voter
or the user of this particular
application the voter or the user gets
to register himself or herself into the
application followed by that he can use
the login and logout options and next we
have the profile and password
managements so followed by that we have
the option to choose the positions to
vote and finally to cast the vote now
this particular project is an advanced
level Java project developed to show
online voting functionality it showcases
the use of java servlets HTML and CSS
again coming into the IDE the ID for
this can be anyone who has good support
for Java the most preferable one would
be eclipse and intelligent followed by
the online voting system we will now
continue with the online Healthcare
Management
named as the corporate Medicare
management this e-healthcare management
system is a web-based project developed
in Java the main aim of this particular
project is to provide effective
management of data related to staff and
patients in hospitals or clinics the
features offered by this particular
project should be as follows it should
optimize web occupation the project
should improve the use of operation
theaters awarding the cancellation of
operations to know how much emergencies
affect the administration of the
hospital departments or Services which
include cancellation of operations
to optimize the allocation of human and
material resources to watch and shifts
to detect the influence of certain
diseases in the hospital services and
finally to find clusters of patients
the software requirement for this
particular project are as follows
we need dhtml for the front end and Java
as the programming language and data
mining tool which is wake up
and Oracle for the database JavaScript
for the scripting language and finally
Tomcat as our server the e-healthcare
management system is a web-based
application that assess the management
of Staff doctors and patients in a easy
comfortable and effective way here the
concept of data mining plays a vital
role to develop an effective Healthcare
Management System the proposed
application aims to create a friendly
working environment for any Healthcare
centers to overcome the drawbacks in the
existing system of Healthcare Management
this system is very reliable and
flexible from all aspects so new
features and modules can be easily
integrated into the system in the future
followed by the e-healthcare management
system we have a new normal online
banking not interesting and arousing for
a normal person but for a hardcore
programmer it is as exciting as a roller
coaster ride in an amusement park
because this is how the major national
and Multinational Banks Implement their
banking facilities in a wide range so
that their customers could experience
the ease of banking at their fingertips
one such type of project on your resume
could bring major highlight to the
recruiter especially if the recruiter is
from a banking or financial based
company
online banking system project is a model
internet banking site this project
should enable the customers to perform
basic Bank transactions by sitting at a
corner of their home or office through a
phone or laptop the customers can access
bank's website for viewing the account
details and perform the transactions on
account as per the requirement Bank
employees can log in and add customer
and account information to perform
transactions with internet banking with
internet banking the brick and motor
structure of the Traditional Bank gets
converted into a click and portal mode
thereby giving the concept of virtual
banking a real Shake thus today's
banking is no longer confined to
branches e-banking facilities banking
transactions by customers around the
clock globally the features you can
offer through this particular project
are home page for online banking site
creation of new accounts login and log
out manage profiles and passwords view
the balance of the account deposit the
amount into the selected account with
Raman from the selected account transfer
the amount from one account to another
close the account so the software
requirements for this particular project
are Java programming language and and
JavaScript for scripting language and
Oracle for database and Tomcat for
server so followed by the online banking
project we have the online examination
project
online exams are normal for us nowadays
but this is totally limited to high-end
exams like CET GRE cat Etc the
requirement for this particular project
is increasing day by day because of the
current scenarios many schools and
colleges have now turned towards the
online education system and are looking
forward to hosting online exams for
student safety online examination is a
simple project developed to provide an
online platform for faculty and students
to conduct online examinations and their
evaluations
this particular project has two parts
first is the admin part
admin has the right to add students
create one-time login add in questions
receive answers and finally to evaluate
followed by the first part we have the
second part which belongs to the
students so the students can log in
update their profile and password select
answers for the mcqs write answers to
questions and finally closing the
session and log out this particular
project can be made at Grand success by
making use of simple Java servlets and
Java programming languages and server
like Apache Tomcat followed by the
online examinations we have the Smart
City Smart City Java project can be a
web-based software developed to store
the details of a particular City the
main purpose of the project is to help
tourists and other visitors to a city by
providing information about hotels
Transportation facilities air ticket
booking shopping details City News Etc
the Smart City Java project serves the
visitors as a guide of the city and
hence the project is called as city
guide project in Java using this project
the details of the city can be accessed
from anywhere at any time the
implementation of the city project
promotes tourism and business
effectively hotels can be searched more
easily from any bank with the help of
this online software students can look
out for academic institutes located in
the city you can view the complete map
of the city using this project
followed by the abstract we have the
features of this particular project the
features offered in this particular
project are login upload profile and
password search for the options select
an option like booking a ticket or hotel
or anything like
Transportation Etc and finally selecting
that particular option booking that
option and payment window finally the
confirmation of the order
this particular project can be fulfilled
by using the following software tools as
mentioned below there the Java
programming language non-cat server
scripting languages like JavaScript Etc
and database as Oracle for interactive
data storage
this could be escalated to an available
by following design drones that can act
like a cop act as a tourist guide for
the people touring the city a drone that
has capability to take pictures videos
of suspected activities and store it for
future reference a drone can intimidate
a cop if any suspected activities are
detected there can be many drones in the
city with different functionalities and
finally you are required to implement
the functionality of the Drone to the
users to interact with the Drone users
could be Travelers or cops or travel
agents or cab agents the code for all
these projects are provided in the
description box below followed by the
Smart City we have the bug tracking
system
the bug tracking system is a web-based
application developed by Java
programming language for software
companies the main aim of this project
is to manage the errors or bugs that
occur during the software development
phase and cycle after the implementation
of this project the employees can update
the issue details solve the issues and
update the system for any location with
internet access below are the features
of this project and source code of this
project is linked in the description box
below coming into features the software
is applicable in managing the bugs that
occur during the development of software
and tracking the older issues it
facilitates searching the facility to
bug history and solution the system is
fully secured and authentication method
is adopted to manage security it stores
the old bug reports so that they can
easily be solved when they reappear the
application helps the project manager in
evaluating The Works of the employees
and finally the proposed software is
capable of auto update when the latest
version is available
so the software requirements for this
particular project are
programming language which is Java
web-based applications such as jdbc jndi
servlets JSP and Oracle database or
access database as the database
followed by that the server deployment
is Red Hat JBoss es Etc and the
client-side scripting as the JavaScript
and the ID for this particular project
would be Eclipse with all the my Eclipse
plugins and finally the user interface
can be designed using HTML and CSS so
with this we can move ahead into the
next project which is the facial
recognition
the face recognition with opencv is an
open source computer vision library that
has tons of modules like object
detection face detection and augmented
reality
the major features that this particular
project offers are managing the user
faces facilitate phase identification
easy login and logout store face IDs
identify suspects with just images
enhanced way to find cyber criminals so
followed by the features now we should
look into the software requirements to
build this particular project so the
programming language we need for this
particular project is Java and followed
by the programming language we need the
Apache and framework Ming ww64 and
finally the cmake framework so followed
by the facial recognition project we
have the next project which is the
vehicle recognition
so Java anpr is a number plate
recognition software which implements
algorithmic and mathematical principles
from artificial intelligence Machine
Vision and neural networks so the
features offered by this particular
project are high level language for
numerical computation interactive
environment for iterative exploration
mathematical functions built-in Graphics
functions for integrating Matlab and
many more so this particular project can
be fulfilled by using opencv and Java
programming language along with some
natural language processing algorithms
so followed by vehicle recognition
project we have our last project which
is the speech recognition system so
speech recognizer converts audio to text
Java x dot speech dot recognition
package defines the recognizer interface
to build speech recognition plus a set
of supporting classes and interfaces so
the features are stages in this
particular project are to create a
speech recognizer allocate resources
load and enable grammar attach result
listener comment changes and finally
provide the process results
so this particular library is readily
available in Java and you can code this
project using the Java programming
language and an ID such as eclipse
at first we will start with the beginner
level interview questions
so in the beginner level interview
questions the first question we have is
what is jit
so the answer for this question is
jit is an abbreviation for Java in time
compiler it increases efficiency of The
Interpreter by compiling the bytecode in
the runtime
jit or just-in-time compiler compiles
code to Machine level directly for
higher speeds of code execution
so basically just in time compilation is
a feature added to The Interpreter of
java so this involves conversion of the
code directly to Machine level during
the compilation stage this improvises
the speed of execution of a Java program
now after the first question the second
question in the docket is
what is a class loader now let's discuss
the answer for this particular question
so basically class loader is the first
file to load when you execute any Java
program so the Java class loader is the
integrated part of java virtual machine
so the functionality of class loader is
to load the class to the Java virtual
machine while it is demanded to execute
a class
Java has bootstrap extension and
application type of class loaders so the
third question in the docket is what are
the memory allocations available in Java
so the answer for this particular
question is Java provides multiple types
of memory allocations but the five major
types of memory allocations which are
most frequently used are class memory
Heap memory stack memory program counter
memory native method stack memory
so the next question in the list is
will the program run if I write static
public avoid main so basically we write
public static word main but in case
imagine if I write the program as static
public void main will the program
execute properly so the answer for this
question is yes because Java does not
follow any specific rule for the order
of specifiers you place in your program
so when you execute the program with
such pattern in your specifiers then the
program will compile successfully also
it will run successfully
so the next question we have is
what is the default value stored in
local variables
so in C programming language when you
declare a local variable or a global
variable or any type of variable then
the first value which is stored inside
that variable will be a garbage value
unless you initialize the variable with
a personalized value for example if you
declare a variable I equal to 0 then you
are storing a value in that variable I
that is 0. if you just declare it as int
I then the value stored inside that I
variable will be a garbage value so
similarly when you declare some kind of
local variable in Java then what will be
the default value stored inside it so
the answer for this question is neither
the local variables or the global
variables or any parameters or any
object references do not have any kind
of default value stored in them
so followed by the fifth question we
have the sixth question
so what would be the output of the
following code segment is the sixth
question so this might happen sometimes
so basically what happens is your
interviewer will throw a question at you
which has a code segment so all you need
to do is decode that code in your mind
and provide the output so this would be
the code that we will be dealing with
so you can see our question has two
printf statements the first one has 100
plus 100 plus a string which is simply
learn and in the second printer
statement we have a string that is
e-learning company plus 100 plus 100 so
what will be the output of these two
printf statements
so the answer for this question is
really simple
so we'll be having 200 simply learn as
the first output and e-learning Company
one zero zero one zero zero as the
second output why
let's check out the code segment once
again
so when you see the code segment once
again so the first printf statement has
100 plus 100 plus simply learn so jvm
here understands 100 as an integer value
and the plus symbol as an addition
operator here so followed by the
addition operator we have another
integer value so what jvm does is it
adds the two numbers 100 plus 100 so
followed by that we have another plus
symbol here so followed by the plus
symbol we have a string value so here
the jvm considers the plus symbol AS
a concatenating operator but not as an
addition operator so that's why the
first two numbers got added and the
result was 200 and the next two values
were concatenated so it became as 200
simply learn similarly in the second
printer statement the jvm encountered
with a string value so it considered the
plus symbol as a concatenating operator
similarly it happened with the second
plus symbol as well so that's the reason
we had e-learning one zero zero one zero
zero as the second output
now followed by the sixth question we
have the seventh question
what is an association
so the answer for this question is an
association can be defined as a
relationship that has no ownership over
the other so to understand this
definition we can consider a simple
example
consider a person associated with
multiple Banks so consider person X who
has got accounts in Bank a bank B and
Bank C
and similarly a bank is associated with
person X that is a bank a bank B and
Bank C are associated with the person X
but no one has ownership over the other
a person X who is an account holder with
all the three banks that is a b and c
does not possess any kind of ownership
over the three Banks similarly
Banks a b and c who has the customer
which is the person X but the banks do
not possess any kind of ownership over
the customer
so the relationship between the person X
and the bank's ABC can be considered as
an association now followed by the
seventh question we have the next
question that is the eight the question
Define copy Constructor and Java so the
answer for this question is as follows
a copy Constructor in Java is a
Constructor that initializes an object
through another object of the same class
a copy Constructor in Java is really
helpful because when you want to copy a
complex object that has several fields
or when we want to make a deep copy of
an existing object then the copy
Constructor is the one which will help
you out in this situation
so followed by the eighth question we
have the ninth question
what is a marker interface
so the answer for this question is
an empty interface in Java is referred
as a marker interface serializable and
clonable are some of the popular
examples of marker interface
so basically a marker interface is just
another interface but normally in
interface we provide some signatures so
these signatures belong to particular
methods so in normal interface we just
have method signatures but not the
complete implementation or at least
we'll be having some variables but in a
marker interface we do not have any kind
of data manipulating method signatures
any data members nothing they have
special functionality unlike a normal
interface so followed by the ninth
question we have the tenth question what
is object cloning
I guess the word object cloning is
completely self-explanatory yet the
answer for this question is it is an
ability to recreate an object completely
similar to the existing object this
process is known as object cloning in
Java Java provides a built-in function
or method that is the Clone method to
clone an existing object offering the
same functionality that of the original
object
so followed by the 10th question we have
our 11th question why is Java not
completely object oriented so this
question might be a little confusing but
it's true Java is not completely object
oriented but what's the reason yes I'll
explain you why Java is not completely
object oriented
so the answer for this question is Java
is not considered as 100 object-oriented
programming language because of the data
types it uses
it still makes use of eight or more
primitive data types which are end float
double and few others so this is the
only reason why Java is not considered
as completely 100 percent object
oriented programming language so the
next question is Define wrapper classes
in Java so the answer for this question
is in Java when you declare primitive
data types that is the end flow double
Etc then the wrapper classes are
responsible for converting them into
objects or reference types just as we
discussed before Java is not 100 object
oriented programming language just
because of the primitive data types it
uses so when you include such primitive
data types then wrapper classes are the
ones which convert them into objects or
reference types for the ease of
compilation and execution of programs
without any issues so followed by this
question we have the next question
Define Singleton classes in Java so the
answer for this question is in Java when
you make the Constructor of a class as
private then the particular class can
generate only one single object this is
the reason why such type of classes are
called as Singleton classes
so followed by that we have our next
question that says Define package in
Java so if you use some of the popular
Ides that is the integrated development
Enterprises such as IntelliJ or Eclipse
then you might be familiar with projects
packages source files and then the class
file so basically you create a project
first and inside the project you will be
having your Source folder and then you
will be creating your own package using
the source folder and inside the package
you will create a class file and inside
the class file is where you write your
Java program so here the question is
Define package in Java so the answer for
this question is as follows
package is a collective bundle of
classes and interfaces along with
necessary libraries and Java files the
use of packages helps in code
reusability so basically when you create
a specific package inside that package
you will store all the class files that
you will be using in your Java program
so not only class files in case if you
use any kind of connectors or any kind
of Jar files or any kind of dependencies
for your Java program you will include
all those inside the package so that the
requirements and the class files are
bundled together and this helps out
encode reusability making sure that the
program files or the Java files for any
dependencies are not juggling between
one package to the other or one file to
the other so using a package is
basically a good practice
so followed by this we have our next
question
can you implement pointers in Java
program
so if you remember C programming
language we had pointers there
so we use pointers to directly access
the memory
so similarly can you use pointers in a
Java program this is a little tricky
question for beginners but basically
it's really simple
now the answer for this question is
no because Java virtual machine
personally takes care of memory
management implicitly so Java's major
motto was to keep programming simple so
accessing memory directly through
pointers is not a recommended action so
the answer is a big no you cannot
Implement pointers in Java program
so followed by that we have our next
question
differentiate between instance and local
variables
so the answer for this question is
really simple instance variables are
declared inside a class and the scope is
limited to only a specific object inside
which an instance variable is created so
followed by the instance variable we
have the local variable so the local
variable can be anywhere inside a method
or a specific block of code also the
scope is limited to the block of code
where the variable that is the local
variable is declared
now followed by the 16th question we
have our next question
explain Java string pool so the answer
for this question is a collection of
strings in Java's Heap memory is
referred as Java's string bone so for
example you wanted to create a new
string
consider your name so your name might be
some x y z so if you wanted to create
XYZ string then you provide that
particular code to your jvm so what does
jvm do it will not directly create that
particular string first it will search
for the XYZ string in your string Port
if that is already existing in your
string pole then it will provide a
reference to that particular string in
case if XYZ is not there then the jvm
will create a new string that is the XYZ
string
so followed by this we have our next
question that is
what is an exception
so the answer for this question is an
exception in Java is considered as an
unexpected event that can disrupt the
normal flow of the program
so for example just consider that you
are going to write a program for
division operator
so after you finish your program your
evaluator might want to test your code
to the extreme levels so instead of
providing a proper number imagine that
your evaluator is providing a wrong
input such as special symbols sometimes
0 or any other sort of input so if this
kind of input is provided to your
program then your program might crash so
you can avoid this kind of Crash by
using exception handling so basically
you can use try and catch blocks so you
can embed your code inside the try block
and say to your program that if any kind
of wrong input such as special symbol or
0 is provided by the evaluator then send
a message saying wrong input or divide
by zero exception so this kind of
approach will provide an output but this
kind of approach will avoid your program
from crashing so this is how exceptions
are handled in real time so followed by
is we have our next question
what is final keyword in Java
so the answer for this question is the
term final is a predefined word in Java
that is used while declaring values to
variables when a value is declared using
the final keyword then that particular
value of that particular variable will
remain constant throughout the execution
of program so sometimes if you include a
normal variable and provide an operation
on that particular variable then the
value of that particular variable will
change after the execution of program
but when you declare the same variable
using final keyword then no number of
operations or any kind of manipulations
Applied onto that variable will not
change the value of that particular
variable so that's the specialty of
final keyword in Java so followed by
that we'll dive into the next question
that is what happens when the main
method is not declared as static
so the answer for this question is when
the main method is not declared a static
then the program may be compiled
perfectly but ends up with a serious
ambiguity and throws a runtime error
that says no such method error so when
you basically declare a main method
don't forget to specify the static
keyword
so with this we finish the beginner
segment of questions followed by the
beginners segment we have the next
segment that is the intermediate level
segment
so the first question in the
intermediate level is what is jdk and
mention the variance of jdk
so the answer for this question is so
jdk is basically an abbreviation for
Java development kit this is a combined
package of JRE that is the Java runtime
environment and developer tools used for
Designing Java applications and applets
Oracle has the following variants for
Java development kit so the first one is
the jdk standard edition which is
normally used by beginners and
intermediate developers next after the
jdk standard edition we have the Java
development kit for Enterprise so this
particular Enterprise Edition is used by
professional Java developers for
developing Java based applications and
Frameworks now the last one is the Java
development kit micro Edition now
followed by 21st question we will dive
into the next question that says brief
access specifiers and types of access
specifiers in Java so the answer for
this question is as follows
basically access specifiers are
predefined keywords used to help a Java
virtual machine to understand the scope
of a particular data member or data
manipulating method within a class or
outside the class so in Java we have
four types of access specifiers the
first one is Public Access specifier so
when you declare a data member or a data
manipulating method as public then that
particular data member or method can be
accessible by any class or object
throughout the package
followed by that we have the private
access specifier so unlike the public
access specifier when you provide the
private access specifier then the
accessibility of that particular private
data member or the data manipulating
method will be provided to specific
classes and specific objects only and
finally we have the protected access
specifier so the protected access
specifier is a bit more secure than the
private access specifier so the access
for this particular protected data
member or protected data manipulating
method could be a little more difficult
to access unless you are going to
implement everything which is present in
that particular package so basically if
you are trying to access the protected
data member or protected data
manipulating method of a different
package then you need to First import
the package into your existing package
so that's how the protected access
specifier box practically so finally
after the major three axis specifiers we
have the default access specifier so
default access specifier will be
provided by the Java virtual machine so
in case if you declare a variable or a
data manipulating method without using
any specific access specifiers that are
public private and protected then jvm
implicitly considers the default access
specifier so there is no much of a
difference between the public access
specifier and the default access
specifier both have the same
functionality and accessibility so
followed by this question we enter into
the next question that is
can a Constructor return a value
so the answer for this question is as
follows yes
a Constructor can written a value it
basically Returns the current instance
of a class implicitly you cannot make a
Constructor written a value explicitly
but automatically it Returns the
instance of a class
so the next question is explain this
keyword in Java so in Java we do have a
keyword which is called as this so what
does the keyword this mean in Java is
the question
so the answer for this question is the
term this is a special keyword
designated as a reference variable so
the term this keyword is used to refer
to the current class properties like
data manipulating method instance data
member and Constructors so followed by
the 24th question we have our next
question that says
explain super keyword in Java so the
answer for this question is as follows
the term super is a special keyword
designated as a reference variable so
similar to this keyword even super
keyword acts as a reference variable but
the difference is super keyword is used
to refer to the immediate pairing class
object so followed by the 25th question
we have our next question that is
explain method overloading in Java so
basically method overloading and Method
overriding Etc are the concepts of
polymorphism so now let's have a correct
answer here
so the process of creating multiple
method signatures using one method name
is called as method overloading
so for example consider that you wanted
to include an addition operation in your
program that performs addition operation
so the first method will be having the
name add and inside the method
parameters you'll be having two integer
types of parameters similarly you wanted
to perform another addition operation
with the same name add so here you will
provide the method name completely same
to the first method but inside the
parameters there is a difference you are
adding three parameters here so when you
pass the values to the add method then
which method to be overloaded that's the
confusion right so should I overload or
should I execute the first add method or
the second add method so this completely
depends on the number of parameters you
pass if you are passing two parameters
then the first method will be executed
if you are passing three parameters then
the second method will be executed so
this is how the method overloading
happens in Java so the process of method
overloading can be achieved by using two
different ways the first way is to
change the number of arguments so that's
what exactly you've discussed before now
the second way is varying the return
type of the method
so with this let's enter into the next
question
can we overload a static method
so as discussed before the values of the
variables or data manipulating methods
will not be changed when we have used
the keyword static in front of it so the
question is can we overload a static
method now let's discuss the answer for
this
the answer is no Java does not support
overloading of static method the process
worked through an error reading static
method cannot be referenced so followed
by this we have our next question
so the next question is Define late
binding the answer for this question is
binding is a process of unifying the
method called with the methods code
segment
late binding happens when the methods
code segment is unknown till the method
is called during the runtime
so followed by this we have our next
question Define dynamic method dispatch
so the answer is the dynamic method
dispatch is a process where the method
call is executed during the runtime the
overridden method is called through a
reference variable of superclass so this
process is called as runtime
polymorphism
now we have our next question why is
delete function faster in linked list
than an array so basically linked list
and array are the Java Collections or in
other words it's also considered as data
structure so to answer this question you
need to understand the analogy of linked
list and array so basically an array is
um complete memory block of consecutive
memory locations so consider that your
memory location starts from 100 and your
array has 10 locations so it's a
complete reserved block of from 100 101
102 to 1.9
so you have 10 memory blocks so in case
if you wanted to add a number or a
delete a number then you had to make
changes to the complete memory block but
when you come into linked list
you have the memory blocks used from the
memory Heap so basically what you do
here is you basically connect the nodes
through addresses
so in case if you wanted to eliminate a
number then what you do is just to
manipulate the addresses so the address
of the consecutive node will be changed
so that's the only change what you make
so now
this is the reason why the delete
function or any kind of manipulation
function is faster in length list
compared to array
so now let's have a briefed answer on
this delete function is faster and
linked list as the user needs to make a
minor update to the point of value so
that the node can point to the next
successor in the list
now followed by this we have our next
question
give a briefing on the life cycle of a
threat
so the life cycle of a threat includes
five stages which are as mentioned below
newly born state runnable state that is
it provides the jvm with a feedback that
I'm ready to run now followed by that
the running stage where the threat is
actually running followed by that the
block stage so basically the thread will
be blocked for some reasons for some
intermediate output or something if the
thread is waiting for an input from
another source or as something similar
so that's where the blocked State comes
to existence and finally the dead State
once after everything is processed the
thread is eliminated by jvm now followed
by this we have our next question that
says
explain the differences between
The Operators provided here
so the operators might look similar but
they are different now let's understand
about these operators in a much better
way through the answer so the answer for
this question is although they look
similar but there's a huge difference
between them so the first operator which
looks like two greater than symbols
perform the operation of right shift
thing so when you provide a binary
number or binary value then the bits
will be shifted towards the right and
the second symbol or the second operator
which is having three greater than
symbols is used to shift out the zero
filled bits so this is the functionality
of these two operators now followed by
that let's have the 33rd question brief
the life cycle of an applet so the
answer for this question is the life
cycle of an applet basically involves
the following stages the first stage is
the initialization stage next is the
start stage third is the stop stage
fourth is try and finally we have paint
now the next question is why are
generics used in Java
so the answer for this question is
compile time type safety is provided by
using generics in Java so this approach
allows the users to catch unnecessary
invalid inputs at the time of
compilation generic methods and classes
help programmers to specify a single
method declaration a set of related
methods or with a single class
declaration a set of related types
so followed by this we have our next
question
explain
externalizable interface
so the answer for this question is the
externalizable interface helps with the
control over the process of
serialization the externalization
interface incorporates read external and
write external methods so we have
listened to a new term here which is
serialization so what exactly is
serialization
serialization is a process of sending
your Java code or Java project from one
computer system to a different computer
system so basically if you wanted to
execute some kind of java program from a
different location then you serialize
this particular code to a different
location where you actually want to
execute and this particular process of
transferring your code is called as
serialization
now the next question is explain demon
thread so the answer for this question
is the demon threat can be defined as a
thread with least responsibility the
demon threat is designed to run in a
background during the process of garbage
collection in Java the set Daemon method
is used to create the demon thread in
Java programming language
so we have our next question now explain
the term enumeration in Java
so the answer for this question is
enumeration or enum is an interface in
Java enum allows the sequential axis of
elements stored in a collection in Java
now the next question is
why is Java considered as a dynamic
programming language
so the answer for this question is Java
was designed to adapt to an evolving
environment Java programs include large
amount of runtime information that is
actually used to resolve access to the
objects in real time so this is the
reason why Java is considered as dynamic
programming language now followed by
this we have our next question
can you run a code before executing the
main method so the answer for this
question is yes we can execute any code
even before the main method we will be
using the static block of code in the
class when creating the objects at load
time of the class any statements within
the static block of the code will
execute it once while loading the class
even before the creation of objects in
the main method
now the last question in the
intermediate section is how many times
the finalized method is called so the
answer for this question is the
finalized method is called by the
garbage collector so for every object
the garbage collector calls the
finalized method just for once
now with this let's enter the advanced
segment of interview questions based on
Java
so the first question in the advanced
segment is can the keywords this and
super be used together so the answer for
this question is
no this and super keywords should be
used in the first statement in the class
Constructor so the following code
segment will give you a better idea
so you can see that we have used the
keyword super and this in the class
Constructor that is the first class
Constructor
now this is how you can use super
keyword and this keyword together in
case if you wanted to use so with this
let's continue with the next question in
the advanced level
so the next question says explain JSP
page so the answer for this question is
JSP is basically an abbreviation for
Java servlet page so the Java servlet
page consists of two types of text the
first is the static data and the second
one is Java servlet page elements
now the next question is
explain
jdbc so the answer is jdbc is an
abbreviation for Java database connector
jdbc is an abstract layer used to
establish connectivity between any
existing database and to a Java
application
next question is
explain the various direct tests of JSP
so the directives are instructions
processed by JSP engine after the JSP
page is compiled into a servlet
directives are used to set base level
instructions insert data from external
files and specify custom tag libraries
directives are defined between the
following symbols so these are the
symbols that are used to specify the
directives in a JSP page the different
types of directives are shown as below
there are three types of directives they
are include directive page directive and
taglab directive so include directive
includes a file and merges the content
of the file with the current page the
page directive is used to define
specific attributes in the JSP page like
error page and buffer the taglib
directory is used to declare a custom
tag Library which is used in the JSP
page followed by that we have the next
question
what are Observer and observable classes
so the answer for this question is
objects that subclass the observable
class maintain a list of observers when
an observable object is updated it
invokes the update method of each of the
observers to notify that The Observers
that it has changed its state The
Observer interface is implemented by
objects that observe observable objects
might be a little confusing but you need
to read this answer once again you can
pause it and you can read this answer
once again so that you can get a brief
understanding of this
followed by that we have the next
question what is session Management in
Java so the answer for this question is
a session is essentially defined as the
dynamic stage of a random conversation
between the client and the server the
essential Communication channel includes
the string of responses and requests
from both sides typically the most
popular way of implementing session
management is the employment of a
session ID in the communicative
discourse of the client and the server
the next question is brief about spring
framework spring framework is basically
the framework of Frameworks now the
answer for this question is spring is
essentially defined as the application
framework and inversion of control
container for Java basically the chief
purpose of spring framework is to create
Enterprise applications in Java also it
is especially useful to keep in mind
that the central features of the Sprint
framework are essentially conductive to
any Java application
so the next question is explain jca in
Java so the answer for this question is
jca is basically an abbreviation for
Java cryptography architecture so jca
provides a platform that gives
architecture and apis for encryption as
well as decryption jca is used by the
developer to combine the application
with the security measure it also helps
in performing the third-party security
rules it uses the hash table encryption
message digest Etc to implement the
security so the next question is explain
j p a in Java so the answer for this
question is jpa stands as an
abbreviation for Java persistence API
the jpa is enabling us to create the
persistence layer for desktop and web
applications
jpa deals with the following
Java persistence API query language Java
persistence criteria API object mapping
metadata Etc
so the last question in our list is
explain the different authentications in
Java servers so the answer for this
question is authentication options
available in servlets are as follows the
first one is basic authentication so the
basic authentication consists of
username and password provided by the
client to authenticate as the user the
second one is form based authentication
in this particular type of
authentication the login form is made by
the programmer by using HTML
followed by that we have the third type
of authentication that is digest
authentication digest authentication is
similar to basic authentication but in
this the passwords are encrypted using
hash formula this makes digest more
secured and lastly we have the client
certificate authentication the client
certificate authentication requires that
each client accessing the resource has a
certificate that it sends to
authenticate itself this requires SSL
protocol and that calls for a wrap hope
this session was interesting and helpful
should you have any questions or needed
the resources like PDF demo code
documents project source code and
detailed answer for the interview
question feel free to let us know in the
comment section below among with your
mailing address and our team of experts
will be more than happy to resolve your
questions and concerns
foreign
hi there if you like this video
subscribe to the simply learning YouTube
channel and click here to watch similar
videos turn it up and get certified
click here