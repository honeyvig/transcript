hey everyone i welcome you all to this
junit full coast by simply learn in this
complete course we will learn everything
we need to know about junit and mokito j
unit
we have anuch to guide us through this
journey we shall begin with
understanding the basics of junit and
have a look at different aspects of
junit
in these aspects we shall understand the
relevance and features of junit
moving forth we shall learn the working
of junit with java and eclipse with the
help of a hands-on demo
after we have a complete knowledge about
junit and it's working we shall go on to
explore mokito
in mokito j unit we shall understand
what mocking is and how we can perform
it
while we are at it we shall know about
the basics of stub and how to create it
to better understand the mokito j unit
we shall see all these processes and the
entire working of mokito with a hands-on
demo
but before we begin make sure you have
subscribed to our youtube channel and
don't forget to click on the bell icon
so you never miss an update from simply
learn
welcome everyone to yet another topic on
j unit tutorial now in this one we are
going to talk about
what exactly is in junit uh tool all
about and how we can do various kind of
test implementations with the help of
junit so let's talk about the agenda
which we are going to cover here now in
this one specifically we are going to
talk about like what exactly is j unit
uh what is this particular framework all
about then we are going to talk about
junit installation how we can do the
installation of junit and what are the
different steps we can get involved on
that and then we are going to talk about
like the features of junit what are the
different uh typical features of junit
are all about then junit annotations
we're going to talk about and then junit
in java and the actual implementations
some tutorials or some demos on how to
implement junit with eclipse so these
are some of the main topics which we are
going to cover all together over here as
such
now let's talk about what exactly is the
junit tool all about like what are the
different things we can implement with
the help of this tool here
so junit is basically a kind of unit
testing framework which is there for the
java
so it's kind of a default offering for
the java programming language that we
can use the junit for the unit testing
framework for performing the unit
testing now the main benefit of the
junit is like it's using the same syntax
like a java programming language so it
makes it very easy for a java developer
to write and execute the test cases so
most of the times when the developers
are going to work on the java
programming languages so they prefer
that junit as a default unit testing
framework for them because they get the
language advantage they get the easily
integrations and the eclipse so those
benefits helps the developers to decide
junit specifically for writing the test
cases and running the test cases there
now whenever these test cases are
actually being executed whenever you add
up a new piece of source code so uh all
the unit test cases will be executed
will be again executed there every time
when you run a new belt so all the unit
test cases gets executed but you also
need to take care that if you are adding
up a new functionalities you also have
to add the corresponding test cases to
that so increasing more and more code
will uh will be done by the developers
but at the same time you have to sync or
you have to keep your test cases up to
date also and as a part of every build
each and every test cases will be
re-executed every time you're doing the
build five times
six times a day every time the
all unit test cases will be executed
over there and the response will be
given back
right now let's talk about what exactly
is the unit testing now unit testing
refers to the testing of these small
small modules or the small piece of
chunks or the codes here now it's
basically used to have the early
identification of the defects and the
bugs because you cannot simply rely on
the
qa team to perform the testing and then
provide the feedback whereas on the with
the help of this unit testing framework
we can immediately get the feedback
right away once we are running the test
cases immediately we will be able to
know like these are the different test
cases which we have got over here now
the developers don't even have to spend
more time on fixing the bugs and issues
because these test cases will help them
with the easy and the fast feedback so
according to that they can fix the bugs
and they can take the decision whether
the source code is working fine as
expected or there is any kind of issues
as such present with this one so unit
test casing is something which is very
important from the developer's
perspective also because it helps the
developers to understand that they
whether they have written a successful
code or if there is any kind of scope of
issues or bugs over here
also it uh the successful unit test
cases uh increases the overall
confidence of the developers because it
uh increases the overall uh performance
and the quality of the product also so
by having the successful executions of
the unit test cases developers can
understand that yes the source code is
working fine as expected and there is no
scope of bugs or any issues as such with
this source code here so that's the main
benefit which we get with unit testing
that with this fast feedback channel we
will be able to take uh the decisions
whether the source code is ready for the
production environment deployment or not
so that's a main benefit which we get
with the
unit testing here
now of course this can be done in two
ways manual testing and automatic
testing now in case of manual testing
you have to do this thing manually
within a manual tester or a manual
testing approach and in this one you
will not be depending on any kind of
automated tool which can be scheduled or
which can be executed in non-interactive
manner on the other hand automatic test
case is something which
is used to be executed using the tool
and it is something which is being done
so that you will be able to get the
complete automation there is no manual
efforts which is required as such you
are going to have like complete uh
deployment and automations being done as
such in this case so automated testing
is something in which you will be giving
more focus on the automated automation
tools you may be having one or a couple
of tools which using which you can write
the automated test cases and you can
perform the complete automation in case
of manual testing it's quite a you know
less reliable because you are dependent
on the uh a particular tester which can
ha perform the testing according to his
efforts and it's quite a time consuming
also because you can only run the test
cases for probably eight to nine hours
per a day
whereas on the other hand the automated
test case is something which is quite
reliable because it does not depends on
a human so so requirements so it can be
done like 24 crore seven so anytime you
can run those uh test cases and that's
the reason why these test cases are
quite faster as compared to any other
manual testing approach here
so junit test cases and the automated
test cases really helps the developers
and the qa professionals to test the
source code much faster as compared to
the manual testing now let's talk about
the genuine installation now as part the
of the installation of junit you don't
require to install any exe file or any
kind of program there there are a couple
of jar files which is required which
needs to be there into the a class path
so that every time when you write some
junit test cases you should be able to
refer those jar files because without
having those jar files into your class
part of your project you will not be
able to run the change in test cases so
that's the only dependency you require
if you are running a maven build then
these dependencies will be added up into
the powered xml file if you are
referring or doing the build from the
eclipse or doing the development from
the ecrips then you have to put up these
jar files into the
class part of the project so that these
jar files can be loaded up and the junit
can be referred over here so the
installation is pretty straightforward
but let's see like what are the
different steps we need to follow now as
a pre-request of understanding the demo
about junit the first initial two things
is like you require a jdk to be
installed now you can download the jdk8
over here from this oracle website and
uh this is something which you can
download for the windows or whatever
platform you have you can pretty much
install it for whatever platform is
there so for windows platform you can
download for 32-bit and the 64-bit both
option over here and once it's installed
so you should be able to use the eclipse
latest tool now um all you need to do is
that you need to go to eclipse.org and
there you can download the latest
version of the eclipse now these two
main things which you require because
eclipse will be required for creating
the change unit test cases and of course
how a kind of id where you can run some
test cases changing test cases and all
and then oracle is something which is
required as a runtime for running the
jdk also and the junit
test cases also and eclipse here
so that's a pre-request which we got
over here in this one so i have already
got these two things installed into my
system and i have
eclipse there so let's move on to the
eclipse and see that how it goes on
there but before that you also require
the junit jar files because in order to
have a particular junit framework loaded
up we require some uh particular files
jar files over here in this case so i
can just search for junit
4 over here and when you search for j
unit 4 so what happens like this
particular page
will help you or give you all the
details about the junit 4.
now you can go for the
version notes of the different different
versions but uh if you want to download
all you need to do is like you can say
like download and install and the moment
you go there so it will give you the
details now there are two jar files
which is required junit dot jar file is
required over here
j uh hamcrest hyphen code.jar file these
two jar files are required here if you
want to download it into the test class
path if you feel that you want to uh use
a maven based project then in that case
you have to specifically go for this
dependency into palm file and according
to that that particular version will be
downloaded and will be referred over
there so these are the ways that how you
can get the particular software's the
required things into the place so i'm
going to put up these jar files into a
location so that i should be able to get
the particular details
stored and i can refer to them into my
eclipse so i'm going to download this
one here from the maven central
so i'm going to download this jar file
and then i'm going to go back
and create hyphen code so that also i
want to download
download chart
so these two jar files i have uh
downloaded and i will be referring these
ones into my project because these are
the ones which has been required into my
project as such so let's go back to the
eclipse and uh let's place this jar
files into a location so that into my
class i can refer the complete folder
with all these two jar files inside that
so let's go ahead with that so let's
create a particular new project over
here so we'll go for new
java project
and here i can give it like a simple one
a simple project name i can provide here
and uh jdk i'm using like 1.8 so that's
the jdk version which i have utilized
over here
and then finish
so this is the project which i have got
like in the source directory now i'm
going to create a simple uh file over
here a new class file over here so i'll
create it like
j
unit class so i'm going to create a
class over here in this one and of
course i need to have a particular white
main also over here in this
specific class over here because this is
the initial class i'm trying to create
over here in this one i can create a
custom
particular methods also over here but
let's see like if we can execute or we
can run some particular functions as
such over here now i'm going to declare
a function over here public
void
j junit
method
so i'm just going to create a method
over here
i'm just going to run a particular
print
statement over here
executing
j unit
test
cases right
now this is a kind of a method which is
there which of course i can run into my
uh public void main and this function
will be executed uh will be called upon
over here now the thing is that uh right
now uh since it's just a normal function
but the moment i convert it like i
have uh at the rate test mentioned over
here so what will happen like this will
be converted into the form of a test
cases
now of course like right now there is no
imports which is available there as part
of this one so you can see that the uh
the the time i have added this
annotation at the rate test i will be
able to see like yes add junit 4 library
to the build path is something which is
coming up over here or it's saying like
add junit 5. so whatever the library you
feel that you want to add you can do
that and that particular library will be
added up over here now let's go for the
junit 4 library here the moment i do
that what will happen
you will see some changes first you will
see the changes in the top saying that
import orj dot junit dot test that's a
first import and second import will be
like junit 4 you will see like these two
jar files is automatically being picked
up by the eclipse now even if you don't
download these jar files this is the
main benefit of the eclipse that these
are already a part of the plugins you
can see their paths that these are
already installed in plugins directory
so the moment you use these particular
methods that you want to use the junit
these will be automatically imported
over here into your system now you can
just simply call this method into the
main void main and then the
specific method will be executed as a
form of test cases
so this is the mechanism that how you
will be
setting up the project initially you got
the imports you got the uh particular
annotations configured and with that the
uh specific jar files will be
automatically being added up into your
class path whatever the java files we
added up we downloaded previously we can
also have that added up into the custom
class path we can modify this build path
of junit 4 which is coming up
automatically we can just simply say
right click
build path and configure so this jf unit
4 we can actually import we can remove
it from our system and we can add our
external jar files also into the uh
build path or the class path over here
so that depends upon you that how you
want to perform the customizations
around that part but yes the particular
main benefit of using the
eclipse is that it's already having the
junit plugin installed both four and
five version is installed whatever
version you feel that you want to
include it will be included and the
plugins are already installed so you
don't even have to download the jar
files manually so that's how you will be
able to do a very basic initial setup of
junit and how a basic project can be
created over here in case of chair unit
in the upcoming demos we'll see like how
we can execute these uh particular test
cases and we'll get the response we'll
come to that point so let's go back to
the main content right so that was the
uh junior installation demo which we saw
and we saw like how we can put up or
load the jar files relative change unit
into a class path and we can resolve the
basic uh you know features about the
chair unit about the test cases now
let's talk about some of the certain
features of the chair unit here now
there are a lot of features which we get
primary with the chair unit let's
discuss about that one by one so the
very first feature about junit is that
it's an open source network
now it's something which is available as
an open source to you uh we have also
seen the installation so you don't have
to really go for any kind of uh
license or something like that so you
can do any number of test cases with
this particular tool and this uh
specific automation tool here you can
automate it into jenkins no way you
require any kind of license around this
so um these can be easily integrated
these are already a part of most of the
latest eclipse installation so you don't
even have to configure these manually
because it's already a part of your
system
right second is that it provides
annotations now
main annotation we have already seen in
the previous case that when we converted
a normal function or a normal method
into the test method by using an
annotation called at the rate test so it
provides a mechanism to identify that
which particular method is a test method
and which method is a normal method
according to our classes so these
annotations really help us to identify
the methods also and it provides us the
flexibility that these uh particular
methods are not the normal methods we
need to execute you need to uh run it in
the form of test cases so that
identification is something we will be
able to do with the help of these
annotations here uh also it provides the
associations uh to identify like what
exactly the results are there because uh
definitely when we are running the test
cases test cases we need to assert that
what should be the value so using the
assert uh you know we can ascertains we
can actually compare that okay this
method is giving this value suppose
there is an addition uh
method which is available there which is
giving like a plus b is equal to c so c
is like 5 plus 15 is 20. so with the
help of asset i'm saying like uh
whatever the response i'm going to get
from the function when i give the values
a and b as 5 and 15 so that should be 20
value so in the asset i can hard code
like okay this is the value this is the
response which i should be getting and
once the function is executed i should
be able to get this particular output as
in 20 over here so that comparison when
you do you will be able to understand
easily that yes when we are doing the
asset i'm getting the proper response
i'm getting the proper output over here
so assertion is something which is very
important to compare the things to
compare the inputs which we are getting
from the application source code
it provides the test runner so we can
basically run the test runners over here
to execute the test cases so you can
configure this within the pipelines you
can configure it with eclipse and
various automations during the build
automations also you can configure it so
that flexibility you will be able to get
with these test runners here and it also
allows you provide a better feedback
channel because it acts like a very good
feedback provider because the moment you
are done with the development you will
be able to get an instant feedback so
the overall quality of the code is going
to be increased in this case and that's
definitely helpful for you because with
this uh approach with this junit uh
framework you will be able to get a
quite faster and a perfect uh code
writing tool or a quality tool which is
available there so definitely the
overall quality of the code is going to
improve with the help of this junit
framework
and it provides the automations also
because these unit uh test cases are
having the flexibility that you can
configure it within the pipelines you
can automate it with the help of this
framework that you can completely help
or you can have a complete automated
workflow with the help of this
particular framework and it provides you
an instant feedback the feedback channel
is quite instant in case of this j unit
now let's talk about the junit
annotations we have already seen like
the main benefit of the annotation is to
define uh to provide the metadata about
the methods to the different ones so
annotations also refer to the
synthetical uh method data added to the
java source code so having a particular
better of feasibility and
identification is also quite easy so
also the overall structure of the source
code can be done in a better way and the
readability is also good when we talk
about the annotations here the biggest
main difference between the uh j unit
and dj unit 3 was the in the
introduction of the junit annotations so
uh earlier before j2 unit 3 we were not
able to identify like if this is in kind
of a test method or this is a kind of a
source method over here so that
identifications is quite easy after the
involvement or the introduction of the
junit 4 framework over here
also like this is something which is
really helpful to us to see like how
exactly we can overall read the overall
source code because you have so many so
many source code there present to your
project so annotation should be able to
uh you know help you to identify the
that these are the main portions with
these are the components which is part
of the unit test cases not the actual
source code so at the rate test is
something which is um uh you know going
to tell us that uh the the specific
method with the public void declaration
can be a run or can be executed as a
test cases this is not a simple method
this is not an application source code
method this is a test method over here
now at the date before is something
which is uh used to run some statement
before each and every test case is
executes maybe having some additional or
initial connectivity is something you
can do with the help of at the rate
before
at the rate after is something which you
can do after the execution of the test
cases like some statements which you
want to execute after the uh test cases
so that's something you can do or you
can go with the help of at the rate
after
and at the rate ignores is something
which you can configure if you feel like
during the test execution you feel to
ignore some statement so that's the way
you can use the ad that it ignores there
so add that it ignores add the date
after add that it before and at the rate
test these are the four annotations
which is being used most of the time
into your junit test cases
right let's talk about some bit more now
after it before is something which is
being used to execute the classes uh
some statement before even you know any
kind of test class executes so not only
uh
you know before executing any method
this is something before even loading up
any kind of uh test classes so before at
the at the rate before class is being
used
similarly at the rate after will be
there to execute it after all the test
classes and uh if we have a timeout
configured so what will have that we
will be able to set up a timeout while
executing the test cases so timeout
value can be configured over here
and then uh if you feel like if you want
to handle some exceptions during the
test execution so that's where we can
use this custom annotations over here to
have the exceptions handled or
configured over here in this one so
these are some of the very important
annotations which is available there on
the chair unit perspective
now let's talk about some another demo
on chair unit testing in the java like
how we can pretty much configure the
test cases in junit for a programming
language called java and how we can get
along or get execute those things so now
we are going to see like how exactly we
can you know go for the uh execution of
some java files onto our command line
and how we can
using the command line run some
execution of the test cases typically we
do it from the eclipse but uh from the
command line also we are going to see
like how
exactly uh you know we are performing
the setup and the executions over here
now what we really need to do is like we
need to see like how we can proceed
further with the execution so i'm going
to open this uh particular java file
over here so to get a better
understanding here so i'm going to use
the uh oj.unit junit uh class over here
in this case so we are having a couple
of imports these are the standard
imports so you can do like
orj.jstar also if you don't want to go
for the specific imports here now here
we are going to create a test unit as an
uh sample class and in this one we got
the
void main over here which is the main
portion of any kind of class here the
only thing which we got over here is
that we have created a test method over
here called test print
message so we are assigning a value
called message a variable over here as
and simply learn now what happens like
we will be able to uh like you know do
the assert equals over here that if the
value of message is like simply learn
so it will be able to help us with the
proper output and uh there will be no
errors as such over here so everything
will be smooth and that's what we are
trying to execute over here in this case
and we are running into the null void
that these are the test cases we want to
run or we want to execute over here now
all we need to do is we need to compile
this one we really need to compile this
scale uh test cases over here this file
and then we have to run that one so for
that let me open the command prompt
so now in this case we will be using the
java c command prompt here and we will
be copying the junit into the class path
so that we will not be able to get any
kind of class not found issues over here
so test unit junit.java we are going to
run so if there is no exceptions as such
we will be able to get no errors here
now i'm going to run the particular
class file with the help of java command
because java c is to convert the dot
java file to the dot class file the
compile format and then in order to run
the dot class file we have to go for the
java command line here now this means
that uh there is no issues as such with
the test cases and everything is working
fine as expected over here in this one
so the assert equals is going to help
you to identify that if the
execution is proper and let's say like
if we put up some content like some
different content over here in this
asset equals so i'm going to again
execute this one so that i will be able
to see like if you know what will happen
that if this message value and this
value does not matches like in normal
situations it will say like okay uh the
uh particular uh you know output is
going up and there is no errors as such
right so let's see like what exactly uh
it will happen that if we go for the
executions like if we save this file in
such a way that we are providing some
wrong inputs and what will happen to our
asset equal over here so i'm going to
again compile the file here so again a
new class file will be available and
this time i'm going to execute this
class file again over here in this case
and the moment you did it the asset will
give you the uh comparison over here
saying that there is a failure of the
comparison why there is a failure of the
comparison because according to the code
base it was expecting the value called
simply learn but it simply got the value
called simplylearn12
which means that your test cases over
here got failed down so this is the real
way that how you will be providing the
comparison like what you should be
putting up to the application and what
kind of response you should be getting
in in return of that so that's where you
will be able to provide a proper and a
complete comparison here which will help
you to understand that what exactly
output you're going to get over here and
that's where the output will be
completely uh available to you and you
will be able to get a proper output as
such here
right so this is the way that how the
comparison will be performed and how you
will be able to see like these two
comparison being done here as such so
this is the way that how you're going to
run the test cases in the form of the uh
from the command line here so let's go
back to the main document right now the
next one which we got over here is the
json test cases using the eclipse
because from the command line we saw
like using the comma line we can do but
we got like so many test cases which is
available there so it's not easy for us
to run those one by one so we will be
doing it through the eclipse so that we
can see like how the execution can be
really done and we can get a hold of
those particular components so let's go
back to the eclipse and this time we are
going to run the test cases in the
eclipse here now let's create a new
project again here
j
[Music]
unit
project
right and finish so a new j project a
junit project will be created now in
this one you can see like there is no
executables libraries for the junit but
you can include it now also but i'm
going to do it later on so i'll go for
the
j unit
project class right so this is a kind of
a test class here so i'm not going to
put the null the public void mean over
here in this one so finish
now in this case what i'm going to do is
like i'm going to you know replace this
content over here so uh with this uh
particular ones
and uh going to have some basic core
base added up over here so i'm going to
import some particular junit
libraries over here so over here like
oj.j unit i'm going to import these ones
and i got like this class over here
junit uh you know project so i just have
to rename it a little bit so that it can
be the name of the actual class name
here so that's fine so everything is
fine but the only thing is that we are
getting some failures and problems over
here because it's not able to identify
these specific junit related executables
like the functions and the methods for
this one again the previous like
previous case you have to do the uh
particular addition of the
library to the build path so that you
will be able to have like these
automatically resolved over here in this
one right so you can see now that the
unit 4 started reflecting over here in
this case and you did not got any kind
of errors now over here in this one so
you can simply save this and now you can
you are good to go for running the
executions over here so you can simply
say like right click over here run s and
change unit test
and when you do that on the left hand
side you will be able to get a little
bit different viewpoint over here which
says like yes test unless code junit is
something which is executed perfectly
fine if for any reason let's say like i
change the value of string one here as
in string one just an typo error i'm
trying to do here so that i can show you
that how the test cases really fails so
assert equals is basically helping to
find out that if the comparison between
the two attributes is correct that means
that uh you know the inputs which we are
putting up and whatever the output we
are getting it's both the same here when
you do that you will say like there is
an failure over here to the test cases
now i'm seeing the failure trace over
here so i'll just move this one to the
console view so it says like it should
be like string but i got like string one
over here which is causing the problem
here because of the type of error which
i did the whole execution of the test
cases got failed so i'm just going to
revert my changes back here and again
run the test cases
it will all be okay right now again over
here so that's a main reason that how
the execution really happens in the
overall mechanism and the system can be
implemented over here in this case so
that's how we basically go on and we
execute some junit test cases here now
in this one we are going to talk about
like how exactly we can use both
marketer and junit here to go for the
unit testing but before even talking
about these two tools here let's focus
on to understand like what is exactly a
unit testing here now there are various
kind of testing which is actually
available into our particular industry
and into our software testing world
there but yes there is a very important
scope and a position of the unit testing
here so unit testing is something which
we also call is an kind of a component
uh
testing is actually a software testing
technique in which single component of a
software is being tested we are not
talking about like how exactly our
application is going to interact with
other applications and it's going to
interact with uh it's not a complete
full-fledged application testing
so
in this case what we are looking forward
is like it this is something in which we
are focusing on how exactly we can only
validate and test out a single component
a single component is what we are
basically talking about over here right
and uh when we say like how exactly uh
we want to perform we want to achieve
the setup here so this is the main uh
mechanism or this is the main kind of
testing which an individual developer
performs at its own end to see like
whatever the piece of source code he's
writing whether it's working fine as
expected or not
so this is where we are able to see like
uh
the exactly what we are trying to
achieve here and how a full-fledged or a
basic testing validation can be done now
the main objective of this unit testing
is to
pick a unit a very basic small small
unit of the source code to verify it so
that it will be uh
the moment the developer develops the
code base at that moment of time only
this thing will be validated and will be
fixed on so this is something which we
are looking forward over here to achieve
like how the automation needs to be done
and needs to be achieved over here in
this case
next thing is what exactly is the
marking here now we talked about like j
unit here but next one is like what
exactly we are talking about as in a
particular marking over here now when we
talk about mocking so we are basically
uh trying to understand like what
exactly uh we are performing for what
purpose we are going for the mocking
process here so mocking refers to the
development of objects which are mock or
clone of real objects they are not the
exact uh objects or we can say like
that's not the exact scenario which we
are going to implement but it's kind of
a duplicate or just kind of a temporary
marks which we are creating so that we
will be able to get it implemented so
mocking is something which is kind of a
reference or a kind of a clone of an
existing or a real object here
so in this technique what happens that
the mock objects are being used instead
of the actual real object so it's not
like we are directly or we are going to
access the exact real objects over here
so we are talking about like uh using or
going through the uh specific mock
objects over here in this one so that's
where we are putting up the main focus
right and mock objects actually give a
particular output uh
for each and every input whatever the
inputs you pro you are going to provide
you are going to get any particular
desired output so the marking is going
to process all these inputs give you the
desired output and to understand like
how the implementations and the setups
can be done right so for this kind of
mocking process mocking a framework is
something which is quite popular so uh
marketer is one of the framework which
is available there which uh is desired
for this kind of uh work or this kind of
approach only where we are trying to see
like how we are we want to perform a
mocking implementation over here right
so let's talk about the marketer tool
because that's a primary tool which is
there for the mocking activity and we
have already focused on like marketing
is and process in which we are trying to
uh process uh the mock objects rather
than the real objects so that's kind of
uh verification here so marketo is a
kind of a job-based framework which is
being used for uh doing the unit testing
on the job application so if you have
written the source code in java
programming language then marketer is a
kind of a framework for you
so this is something which is helpful
for validating the development of the um
kind of application source code here so
you will be able to validate it how your
application is going to behave and it's
going to work so when we talk about
market market over here so it basically
gives you a variety of information like
what exactly approach you are looking
forward and what is the end result you
are trying to establish over here so
that's the main focus of the marketo
which we are going to get and it's for
the basic uh approach over here
so java reflection api is basically used
internally to generate the mark objects
that's a core component you can say like
the backbone of this whole uh mocking
approach over here mokito is used to
simplify the test development by marking
the external dependencies and using them
in the source code so it's kind of a
blending in the whole environment there
so that your application is going to get
the desired
environment and uh
being in that environment it can start
processing the inputs and then give the
desired output accordingly so this is
what we are trying to uh
you know implement as such over here to
see like how exactly this mocking can be
done and makito can really help us in
this approach here
right now what are the different
prerequisites which we require to learn
more
so we basically need two important p
request over here first of all we need
the hands-on experience in java
programming language so java programming
language is very important because
mokito is something which we can write
in the java programming language it uses
the java programming language syntax so
that's a very important thing there to
be considered and second one is the
junit framework implementation so these
two things we basically require for
performing a complete full-fledged
market approach or mocking testing over
here so these are the two important uh
components or you can say like uh the
two core prerequisites which we need to
process before going for the mokito
implementation
right so let's go to see understand like
how mokito framework can be configured
in eclipse because eclipse is the prime
tool for creating the uh development
source code for the java programming
language so we need to see like how we
can configure the emojito framework over
there because that's the one that's the
single id which will be utilized by the
developers there so let's go ahead in
that
in this demo we are going to talk about
like how we can create a simple uh junit
and mokito related uh program over here
so that we can have a basic project
created and we can also have some basic
program created on that part so let me
open the eclipse here now in this one
what i'm going to do is like first of
all i'm going to create a maven project
once my maven project is created then
i'm going to include marketer and junit
related dependencies and after that i'm
going to write a very small source code
up just to see like how exactly our
dependencies are getting dissolved and
my source code which will come up as an
error earlier will come up as unhealthy
over there
so all i have to do is i have to just
right click over here
new
and here i need to go for project like i
want to go for a particular maven
project here so i can expand the maven
over here and go for maven project
here it will basically ask me certain
values uh i want to use the default
workspace location so i'll just say next
um then i want to have it uh like i want
to go ahead with this uh overall process
so these are all projects like what
exactly uh you know archetype you
architecture type you want to go so i
can just go for the default whatever is
selected i can just go with that
and here i will be providing like what
is a group id so i can provide a group
id called com.simplylearn or depending
on your organization you can actually
provide it so here i can provide makito
and the version will be like this and
this is the same way like how the
project will also be created the package
will be created in case of the project
here so then i'll just say finish
and uh on the left hand side i will be
able to see like my uh specific
source code which is available there so
this is something which is
uh going to come up over here so it's
actually trying to uh resolve some of
the uh particular uh options like some
of the uh you know like uh the
components like test executions those
are required over here so i'll just
uh go for this uh particular reservation
later on
right so i'll just open this pound.xml
file here
and this is the bom xml file right so
it's basically looking forward for
certain changes like this
jar file so this jar file is not
actually available over here so
once i ran the build and you know those
kind of setup can be done then it will
be able to download those particular
dependencies so if you right click on
this one you will be able to see that a
particular maven build option here so i
can just run the maven build or you can
just run the movement clean here
so according to that the maven will be
downloading certain plugins and it's
just trying to do some uh particular
process over here so
on the left hand side the source main
test
the same package which is available
there the same packages is coming up
there so
app test is available there so here the
test
is being available here i can see like
some couple of junit related test cases
is already being there like i created a
kind of a sample project so in here a
basic java and a basic uh class file or
a test suite is already being available
here so all i have to do is like i have
to just try to see like if i can go
ahead with this uh executions there now
it's using like junit uh 3.8.1 over here
so i can definitely go for a version
which is uh higher like around junit
four or five there but let me try to do
a clean build over here maven build over
here so uh to see like if it really
works on there so uh what are the goals
i need to do i need to go for the goals
called clean install so that's a goal
which we need to do here so uh mvn will
automatically be resolved there but
clean install is the goal which i want
to look forward over here so let's see
like what it really happens so it's
going to download some couple of plugins
whatever the plugins i'm trying to
provide here some dependent plugins will
be downloading so all that stuff will be
downloaded this is the first time we are
running there so that's why it made
download some little bit more uh jar
files than expected ones not you must
have seen like these are all jar files
is not like something we are using into
our project but these are kind of for
jar files which is being used by the
plugins by the maven itself so for that
purpose it's actually going to that
particular level but once these are
cached up there next time if you do the
run if you do any kind of burst there
you are not going to see all these
entries so let me rerun the build here
to show you like how clean the output
would be there
so i can just go for clean install again
and say run
and this time the output which will be a
little bit less there so in this case as
you can see
if i expand the output
so here first of all it ran like it
performed the clean activity
then it compiled my source code here it
also compiled my test cases here in this
one then my test cases got executed over
here so you can see like it's something
which got xx
executable over here so this is the test
which is available i can click on that
and i can see that
and after that uh it went on and
prepared the final artifact here which
also means like it performs both the
compilation and the test cases execution
and this is what we are doing in any
kind of even project and on top of that
i'm using a j-unit related frameworks so
this is a mechanism where we can have
some dependencies like i can go for
j-unit here i can increase the
dependencies i can try out the pair so
all that stuff i can do here
right and one more dependency which i
can include is of the mokito here so i
can uh include the marketo related
dependency also over here so that uh we
can see like how exactly the response is
coming up there so
you can see like it's uh you know
when i go for the resolution over here
like clean build
clean install so i can just go ahead
with this
so this time it's actually going for the
mokito one so you can see like all the
steps has been executed and we have got
the end result so the build is
successful and i have got the test cases
also so this is a test file where i'm
actually loading up some junit related
uh
executables there so i can just go with
that and
whatever the activity assert we are
using over here so uh using which we can
do the comparison so this is a way like
how a basic project can be created in
maven and on top of that how we can
manage the dependencies for mokito and
for change unit here right so that was a
demo in which we talked about like how
exactly we can configure mokito into our
eclipse here now let's see like when
exactly we uh require the marketer to be
implemented now in this case
what happens like uh when when exactly
you feel like you need to have a mokito
implementation or how we can go for the
moketo uh implementation all together
here
so for example when a component is to be
tested or a single unit needs to be
tested so this unit or component
actually depends on some other component
which is a kind of uh in interval
process or maybe some other developer
owns that component and you are not
exactly validating that component you
are validating your own component but
since it's actually dependent on other
component or some other
unit of the of the whole application so
that's the reason where you may not be
going you may not be able to perform the
end-to-end testing but yes with the help
of mokito you will be able to get the
mock objects so that you can perform the
testing there you don't have to held up
with that other component dependency you
can resolve all these dependencies like
that and you can just proceed further
with your verification and your
implementation so this is the main
benefit which you get when you talk
about the marketer so that you can get
see that a full-fledged understanding
like how exactly these different
components are going to be processed
here
right and uh when there is any kind of
concern like uh if if uh you know like
if you feel like there are some
infrastructure components which is
making the testing impossible so in that
case also we can use the marketer to
mark some infrastructure components so
that we can proceed further with the
validation and the testing here so all
the hindrances and all the problems
which we normally face when we talk
about the implementation all those
things can be really implemented with
the help of mokito here so that's the
main benefit which you get over here in
this one
now let's talk about the next concept so
the next concept which we have is what
exactly is a stub very important concept
here so stub is a kind of object
which holds up a predefined information
a predefined data we cannot do a kind of
a dynamic verification in case of unit
testing because we have to
uh
limit the scope of testing we are
putting up some inputs over here just to
see like how our application is going to
behave
these predefined data will act like a
inputs and uh the test cases are going
to process these inputs and give us the
desired output so these outputs we will
be then analyzing to understand that how
our application is going to behave or in
other terms like how application is
reacting to these inputs so that we can
get an end-to-end desired output as such
here
also it can be referred to as an object
that looks like
exactly a carbon copy of a real object
of course it's not a real object it's a
kind of
uh
mock object over here in this one but it
will give you the exact different
details or you can say like things that
output as such over here in this one so
that's a main benefit which we get with
the stuff that it helps us to get a mock
object instead of the real object so
that we can get ahead with the testing
and we can get all our environment for
our test uh executions there
right and stubs actually uh
they can actually return the specific
output here like whatever the output you
require so that will be returned over
here whatever the inputs you provide
that is going to be processed by this
one and the desired output will be
provided to you over here in this one
now these stuffs are used to reduce the
complexities right so that occur while
uh creating the real object so that's
also the complexity which is going to be
reduced when we talked about the uh
these specific stubs as such here so
whenever we talk about these tabs we
talk about the implementation so this is
where the complexities get reduced when
we talk about the uh replication or the
marking of the real objects here
right so let's talk about like how we
can uh see the
stub in real action so that we can get a
better understanding because from there
we will be able to know like what is the
mean uh importance of stub in the whole
mocking approach here so let's go ahead
with that in this demo we are going to
talk about like how we can create some
pre-request for testing out a stub here
so i'm going to create a required maven
project and a couple of class files over
here to make a kind of environment so
that we can test it out the stub
implementation in mokito so first what i
need to do is like i need to just go
ahead with the maven project so movement
project is what i need to create a very
basic project i want to create over here
you don't have to do much of the changes
like not uh much things you need to talk
about over here
so uh the package
direction i can make it like
uh okay i just want the
particular package if
if you don't want to have the package
and you would want to directly store the
source code in source meaning java and
you want to put the class directly over
there without having any kind of uh
particular comm and all that stuff so
you can do that also over here in this
case so that will be much faster so then
you can just go for the finish here
and you will be able to see like a
project created like a source main java
then uh this particular package name is
there and source test java is also there
so here is the test file here is the
main file
i i can go ahead with this one i can
create a file over here
you can pretty much do that stuff also
so or you can change like this existing
one also so what i'm going to do is like
i'm going to create a new class file
here so i'm going to say like okay
create new class file and in this one
i'm going to put uh the particular class
name and a specific content
so uh let's see like how exactly we can
go so we can go for a particular uh
class creations as a chair or we want to
create so one class and one interface we
want to create so that we will be
creating over here so i'm going to
create a interface here
right so
to
to
surface so that's the interface name
which i'm trying to provide here
and uh
in this one i'm just pasting the content
so this is already configured here so
i just have to configure like this
right
so uh
then i'm just going to resolve
this one so the
java.util.list is also resolved so this
is the to do service.java which is
available there now what i have to do is
like i i'm just trying to create it over
here and i'm just uh trying to create an
another class file over here in this one
so which is like my to do business impl
over here which will be using this
interface
right so i'm going to
create
a particular class file in this one
and
we are going to create it
okay great so in this one again i'm
going to paste this content so
i have to
just sync
this one so this is what so i have to
just rename it a little bit of this one
so
i have to just
rename as in particular
this as over here
great
so now uh i'm pretty much done here so
whatever the inputs are required
i can actually go it just this delta i
want to remove it and uh here we go so
we are creating a particular to do
service
uh mechanism over here in this one so
we are also talking about
the uh list here so these list where i
can
go for the auto resolution here so i'm
just going to save it
and then i'm going to see like for to do
here so to do is something which is
coming up as an uh particular uh
service here so a little bit changes in
this uh
interface also so
i can just you just have to sync it on
the names
so uh whatever name you are following
you are using so that you need to change
over here in this case so here also in
due to service i have got it renamed so
that's where it got successfully
resolved and as far as the error list is
confirmed so i can just import that also
so i'm just done here so if you by
chance change this class name then you
change the java file name also calling
there so that you will be there in
proper sync up over here
so that's uh
something uh which is available there
which we can use to see like how the
implementation can be done and that's a
basic output which you're getting over
here now this is where we have got all
the required source code available there
when we will be testing out the stub so
at that time we can actually use these
one interface and one class over here so
this class is basically going for the
interface call over here in this one and
that's how it's going on the
implementation
so we'll come back during the testing
during the verification of this stuff at
that moment of time this will act as a
kind of basis for us here so this is a
kind of basic structure that how you
create a basic uh program or a basic
source code over here in this one so
what i'm going to do is like i'm going
to just create these stubs over here in
this one to test it out to violate the
things there so last time we created the
java source codes here now the stubs we
will be creating over here in this one
then we are just trying to
create first one is for the to do
service so to do
service
stop so that's the name which i'm going
to use and just finish it off and uh i'm
just going to put the content over here
so just in order to try out the
particular matching over here in this
one so to do stub is what we are trying
to implement so that's what we are going
to see here so i'm just going to remove
uh this mechanism so i'm able to see
like all the imports is working fine
in this case we are just trying to put
some a dummy information so you can see
like this is the array this is the error
list content which we are trying to
provide over here in this stuff so uh we
are basically trying to understand like
how in the mocking activity we are
trying to mark some particular inputs
here so that my stubs will be able to
pick those up and they will be able to
return those there so that's what we are
trying to do here now as far as this uh
stub is configured this is done so we
have to go for another stub here which
will be there for the to do business
impl so we have to create uh this one
for uh that particular
implementation so we have to put the
content over here in this one to do to
put the two uh do business impl stop
here right so i'm going to paste the
content here just to just to match up
the things so i have to uh just put this
content here so i have to just rename
this one
because uh
even if we create some files sometimes
we may have to rename it
so that keeping in mind i can just put
this one here and say okay and uh i'm
just going to remove this component here
and here we go so we have got like uh
these components like this is something
which is available there we have got
the implementations which we are trying
to do we have got to do service and to
do service stuff both here but i can
these are the kind of wrong interfaces
so idly my interfaces is com dot
simply learn dot stub
so that's where we have got
the uh particular to do service over
there and uh similarly here also we have
got
the particular ones which is available
so which is also there in the uh
specific com dot simply learn dot stop
dot to do service stub here so this is a
mechanism where we will be able to find
out even if i don't give this import
that's totally fine because i'm already
there in that package so i can just
refer it from there and we also have the
junit related ones which is available
there so we are getting the errors for
the j unit uh components over here in
this case so
we also have the pom.xml file here in
which my junit is being utilized
so uh you know in this one we are
basically trying to use some references
around the j unit here so you can get it
on board on that case
so i can just try to run on the
particular movement build here to see
like if all the dependencies are getting
implemented so that we will be able to
download some required dependencies so
clean install again i'm going to just
refer it over here
i can just uh run the
specific test also like if i feel but
i'm just trying to download some couple
of components over here in this case
so if there is any kind of issues which
you are getting during the execution so
you will be able to see over here for
instance like oij.junit does not exist
over there right so uh since these
packages are not downloaded or not
installed so that's why you're getting
the issues as such over here in this
case
right so these are the uh references
which is available there i can just go
ahead and
import some of the
junit related ones in this case
if i feel like i want to run it so i can
run this java file also over here this
file also i can run it over here right
so those are different options which is
available which we can utilize in this
case
so i'm just adding the junit 4 library
so that my uh all references related to
junit should be resolved here and the
moment i picked up that one you can see
like all the errors related to j-unit is
gone now i can run my build here to see
like if it's getting successful so this
time
okay so uh it's it's going for that
particular mechanism so i can change
the specific
uh version as in 4.0 let's see like
it's getting resolved so it should be
able to download that particular
artifact so i just have to find out that
what is the version what is the latest
version we want to provide and according
to that the artifacts will be there and
it will be executed so uh there are some
cases when we are using uh
the default mechanism of creating a j
unit or um even project in eclipse
sometimes it actually uses an older
version so it was using 3.8.1 version
which is old version so i'm using 4.0 so
this source code is actually prepared
according to 4.0 and the moment i
started using that the moment i tried on
that one there so you can see like here
it got executed like both the test cases
got executed over here i have got the
response over here in this one like
these two test cases is being provided
over here so test run is two there is no
failure all good and then ultimately it
went on to the jar file preparation here
so this is a way like how the stub is
actually going to uh particular you know
it's going to call the particular
specific classes but yes in this case we
are just trying to input some values
some static values which is not the real
objects but it's kind of a mock often a
real object and that's how we are going
to continue with our test cases just to
see like you know some inputs if they
are not there we can still go for the
testing and we can do the verification
here so this is a mechanism like how we
can test out a stub to go to see like to
understand how the overall mocking is
going to happen here
so that was the main uh implementation
on how this a stub can be implemented in
the whole process to see like how
exactly we can go ahead with that now
the next demo which we are going to talk
about is like how we can full-fledge
implement the complete marketer code
here so that the end-to-end
implementation of the marking of real
objects is what we can get over here in
this one so this will give us the
complete insight about this whole
process now first we will be creating a
specific
uh we are taking up a stock inventory
kind of example over here so we are
going to create a java file over here
which is named as stock.java so i'm just
going to create a class file here called
stock
and in that case we will be providing
the content here so i'm going to create
a stock class which is having certain
methods certain functions stock is the
main function which is available there
now we have to create a particular
interface which is going to uh you which
is going to be used to get this talk
there and uh then ultimately and last we
will be getting a one test file which
will be testing out this thing the
communication and see like if the
marketer is getting passed or the test
case is getting passed or not so this is
the class file which is available there
get stock id set stock id so basic
getter and setters are being used i used
over here in this case
so now i have to create a particular
interface here
with the name called stock service
and in this case
i have to
call
the
get price over there
so git price is basically configured
over here in this one
right so we are going to just call upon
on that to see like how exactly it goes
out there right
so we will be utilizing this one so this
is the interface which is calling up the
class called stock.java
now once the stock main class in stock
service or stock interface has been
created now we have to create a
particular portfolio class here this
portfolio is a kind of interface which
is going to
consume this specific stock here so
portfolio
class is what we are going to create
here so i'm just going to use it
and
it's using some list operations so i'm
going to just import the java.util also
so that these can be imported so these
are some couple of uh activities like
under this one we are also calling up
these
uh stock service interface so that that
can be calling up the stock internally
and uh this is kind of a business logic
which is happening so portfolio.java is
kind of a business logic business layer
where i'm just trying to call the uh the
main class there to fetch the details
through an interface and in this one we
are basically doing the all uh
processing like whatever the activities
i'm trying to do so here i'm doing the
processing about the data here right so
this is what we have uh from the source
code perspective now we will be moving
on to the test cases perspective where
we will be writing a test file to
do the mocking over here and to get the
stocks and try to do some verification
so now i'm going to create a particular
portfolio tester here
which
will be testing this specific uh
portfolio here so that's what we are
going to do
right
so
it's going to use some of the mokito
related uh jar files here and uh since
we already have those uh dependencies
like the we already got those added up
to our palm.xml file so and these are
also being shown up as an maven
dependency here so both 4.0 and this
market to dependency is there in the
maven dependencies and that's why we are
not getting any errors for these imports
here
and we are getting some list related
errors so let me import those also and
we should be fine by now here
so as you can see like here we are when
we are doing the verification right so
using this portfolio tester we are
actually inducing some stacks so here
you can see like we are doing some setup
we are calling that stock service over
here so that we will be able to call
upon or we will be able to get the
information and here we are actually
putting up some content so the whole
idea why we are putting up this content
just to uh have the implementation we
are just trying to replicate uh real
objects here uh these are not the actual
real uh
configurations or real information which
we are getting from the uh end users but
these are the the dummy informations or
the dummy data which we are trying to
provide here and depending on that we
will be able to get like how it's going
on there so we are basically trying to
call a function called tester.setup
there tester.setup is what we are trying
to call upon over here which will set up
the initial information and then we are
calling the test market value so my test
market value will basically give me a a
pass or fail kind of uh result set here
so that depending on that i can decide
that whether it's successful or not and
this test market value only here we are
putting up some dummy informations and
against these dummy informations the
test cases will be executed so let's
just run it my build is already success
so i don't have to run it again there so
what i need to do is like i need to go
for this portfolio tester dot java here
so that i will be able to get the
results and here we go we are getting
the pass
output over here in this one
right so this is what we are trying to
do just to see like how the
implementation should be done there i
can go for a negative scenario like
where i can just a little bit modify uh
something over here in the output and uh
i'm just trying to change a little bit
of a specific
output so that's what i'm trying to do
here so
i can definitely go and see like if this
is something going to uh process
properly or is there any kind of problem
which we are getting over here
i can also remove this decimal value
just to see like if uh i'm getting
successful over here or not so i'm just
running the test cases again
and here we go we got the response as in
failure because uh the expected thing is
not coming up like whatever we are
returning so that's where the failed uh
it's going down for the failure i'm
going to roll back my things here and
see like if it's again getting success
or not
so
yes here we go we got the pass success
over here the past status over here in
this one so just like that you can
actually mock the objects you can put
some inputs and according to that the
responses will be coming up there and
you can go ahead with that particular
mechanism so this is the way that how
the things really gets moved on when we
talk about the uh marketo and how we can
mark the real objects and we can uh test
out our application here so that's what
we do with the market okay so that was a
complete uh marketo code or you can see
like a complete demo over here like how
the
overall process really gets
implemented over here in this one
right now what are the different
benefits of mokito let's process that
one by one so
the main benefits of mokito is like
first of all we'll get started with the
very first one is like the no
handwriting so that's the very first
benefit which is coming up over here now
second one is the object creation
third one is the safe refactoring
then we have an exception support uh
benefit which we get over here
then we have got like the annotation
support which is available there and
then the order support so these are some
couple of benefits which we got over
here to completely understand like how
exactly the uh particular mokito can be
really achieved over here in this one
right so this is the real benefits of
marketer here that brings us to the end
of this video i hope this was
informative and interesting if you have
any questions regarding this video
please feel free to drop them in the
comment section below we will be happy
to help you thank you stay safe and keep
learning
hi there if you like this video
subscribe to the simply learn youtube
channel and click here to watch similar
videos to nerd up and get certified
click here