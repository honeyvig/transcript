hi guys welcome to this video that will
tell you everything you need to know
about the class-based object-oriented
programming language Java Java is an
object-oriented programming language
that is used in a distributed
environment on the internet it is a high
level language that is easy to read and
understand Java is popularly used in
console graphical user interface web and
mobile applications game development and
also to make embedded systems apart from
these Java is also used to develop
software for devices it is used not only
in computers and mobiles but even in
electronic devices like televisions
washing machines air conditioners and so
on online forms Banking and shopping are
possible because of java Java is a
computer-based programming language
invented by James Gosling and Sun
Microsystems in 1991. he had a single
motor while creating the language it was
right once run anywhere this meant that
the code would have to be written only
once but it could be used anywhere they
named this language Oak because of the
oak tree outside Gosling's Office later
it was named to Green then to Java
Coffee which was named after the coffee
from Indonesia and finally to Java in
1995. there are three editions of java
each programmer can learn any of these
editions based on the application they
want to make firstly we have Java
standard edition this Edition contains
core libraries like java.lank java.tutil
Etc secondly we have Java Enterprise
Edition this Edition has apis like JMS
ejb JSP servlets Etc and lastly we have
Java micro Edition which is used to
program Java and cell phones setup boxes
handhelds and so on Java is an
object-oriented programming language
based on C and C plus plus however it is
improved and simplified to solve the
errors in programming Java files are
converted to bit code format using a
compiler and then executed by the Java
interpreter the whole Java code is run
on the Java virtual machine which
provides a runtime environment now the
main Concepts in Java are its methods
and classes a method is a block of code
that performs a task only when it is
called consider this example while
watching TV you use the TV remote to
change channels each button on the
remote performs a different task methods
in Java are the same we can have methods
to add two numbers or email a person or
to convert kilometers to meters a group
of methods make a class classes are used
to organize code just like how fruits
vegetables and clinical products are
divided into different sections in a
supermarket there are a lot of features
in Java let's start by looking at them
one by one it has a simple syntax and is
very easy to understand and learn Java
language is robust it eliminates errors
that occur in the C and C plus plus
languages Java also has features like
garbage collectors and exception
handling this makes Java very unique the
most popular feature of java is that it
is platform independent here compilation
happens in byte code and because of this
Java can run on any machine it is a very
secure language as it contains no virus
Java has a feature of multi-threading
feature of multi-threading helps Java do
multitasking Java is a portable language
as it can run on any platform and data
type sizes are set permanently so Java
program has a fixed size of the code the
last of all Java is not as fast as C and
C plus plus but provides higher
performance than any other language now
let's see oops Concepts in Java Java has
four Concepts abstraction encapsulation
inheritance and polymorphism in Java we
use objects and classes related to the
real world that makes the code easier to
make and understand abstraction means
showing the relevant information that is
needed for a task encapsulation makes
the Java code secure data is stored
within the classes and it is not easy to
access the data the next feature is
inheritance as the name suggests the
attributes and characteristics of one
class can be inherited by another class
because of this coders take less time to
create the code lastly we had
polymorphism which means using the same
method for different tasks in Java we
can use the same object or variable in
two different places where their tasks
will differ so now let's download Java
let's go to Google and search for Java
download we'll go to the link we see
here oracle.com so now here we have the
web page here we can see Java se13 so
this is version 13 but this isn't the
one we are going to download we're going
to download the 8th version version 8.
which is here now we're doing this
because 8 is one of the more commonly
used versions of java so let's click
this and here we'll go down we need to
accept the license agreement before we
can download it
now we have two versions here x86 and
x64. now you can download it depending
on what version your operating system is
now if you do have a Windows 10
operating system it's highly likely you
have a 64-bit version of Windows now if
you do have a 32-bit version of Windows
you can take the x86 so let's download
this
so we've actually already logged in so
we just need to run the installer file
now let's go to downloads
and run the file
so here we have the installer we go to
the next step
we'll select this to next here we can
see where the file is being installed to
we'll go to next
now if you want to change where you want
to install Java we can press the Change
option I'm just going to keep it here
we'll press next and let's commence with
installation
and there we go the installation is now
complete so we don't need any tutorials
or API documentation so we'll just
finish off and go to close
now to see if Java is installed in your
system we can go to command prompt
and type the term Java C which refers to
the Java compiler
now as you can see here this shows a
number of different options you can
choose from this also indicates that
Java has been successfully installed in
your system now if the installation was
not successful you'll see something like
Java C is not recognized as an internal
or external command operable program or
batch file but since we've done it
successfully this is what will be shown
now
and now we're going to set an
environment variable now what exactly is
an environment variable now assume you
have a file which has a DOT Java
extension this environment variable
tells the computer that the Java program
needs to be called to run this
particular file
so to set the environment variable we'll
need to go to control panel
here go into system and security
go to system and select Advanced system
settings and then this shows up now
before we go into environment variables
we'll need to go to where the Java file
was installed so let's go to this PC C
drive
program files and here let's go to Java
so let's go to jdk which is the Java
development kit let's go to bin here
and copy this path
we'll go back to environment variables
select path here
and then press on new
paste this and okay now we'll go back
and go to JRE to the path of GRE which
is Java runtime environment if you click
on this pin again
and copy this path
select this one
new
and paste that
and there we go the environment
variables are now set
now let's talk about running that simple
program I told you about now this is
possible with the help of an IDE an IDE
or integrated development environment
will give us a platform to code Java we
will be using eclipse and IntelliJ as
they are popular and commonly used that
being said there are several other Ides
that are available in the market so now
let's work with Eclipse let's go to
Google and search for eclipse
we'll go to this link
press download and then this shows up
let's click on download
now we've already downloaded the
software so I'm just going to directly
go into the install phase
downloads and select Eclipse with this
you can see that there are multiple
options for you to choose from so we're
going to select Eclipse IDE for Java
developers now you have other options
like for CNC plus plus JavaScript PHP
and so on let's go to the first one and
here you have the details you can change
them if you want but I'm just going to
go ahead with installation now
you press accept now
here we remember accepted licenses and
press accept
and then here as well we'll remember
accepted certificates select this one
and accept selected
and there you go the installation is now
complete let's click on launch now
so here we are setting up a directory as
a workspace uh I'm not changing it here
so I'm just going to go with launch
here we have the eclipse workspace now
let's close this first and here we have
the package Explorer now in case this
doesn't show up you can go to window
Show view and select on package Explorer
so now let's go to file
new and Java project we need to set up a
project name I'm going to call it my
project
one
click next we'll go to source so this is
where the source code for your program
is going to be stored then let's finish
and now we'll click on my project one go
to Source I click new and create a class
we'll clean unlame the class my class
and created and here we have it so now
let's write a simple program to multiply
two numbers
so now let's write the main function
open
bracket
now we're going to initialize the first
number
now the second one
and finally the output
and finally the variable that will store
the output
now we'll just give them a simple print
statement
now let's run The Code by clicking this
option here
using myclass.java and there we have it
here the product is shown to be 100
indicating that the program is running
successfully now we're done with Eclipse
now let's move on to the other idea I
was talking about which is IntelliJ so
for that again we'll have to go back to
Google so that we can download it
search for IntelliJ download go to this
link here so here you can see that we
have two options the ultimate edition
and the community version now here the
ultimate version has way more options as
you can see here but it's a paid version
and only has a free trial now the
community version is free so that's what
we're going to take so we'll click on
download here so I've already downloaded
the software so I don't need to do it
again
so I'm going to go downloads and so here
we go let's just click on next select
the location where you want to install
it press next now we will add a 64-bit
launcher shortcut on the desktop
and create Association so basically this
means that these are the different file
extensions that this will support so dot
Java dot groovy and now let's go to the
next step we'll install now and we'll
wait and there we go the installation is
now complete let's not import any
settings
we'll accept the privacy policy we'll
set defaults
now let's create a new project so here
make sure your project SDK is set to the
version of java you've installed make
sure this isn't blank we'll go to next
here you need to select this option
which is the create project from
template and we are now going to create
a command line application
press next
name the project which I'm going to call
my Approach
to
you can change the location if you want
I'm just going to keep it the way it is
and then click on finish
so now we're going to create a simple
program through which based on the
user's input we can determine whether a
number is even or odd first we're going
to import the package scanner
through which we can take the user's
input
next let's go inside here let's create
the available reader
now let's ask for the user's input
foreign
we're taking in the value now
in the variable num
reader
dot next int
so this is with which we'll be taking in
the value from the user
so we're going to set up a condition to
determine whether the number is even or
not so if the number
and when divided by 2 provides the
remainder 0 it indicates that it's an
even number
show them then
now for the else case
foreign
or in this case odd
there we go
we're done so let's run this program
so let's enter 12
the number is even and there we go we
have a successful output this indicates
that the program is running successfully
so what is Java it is a fast reliable
and secure programming language that can
be used in several websites and
applications it can be used to create
applications in a single computer or one
that could be distributed across several
servers and clients Java can be used in
several scenarios independent of the
system that it is used on
so let's look into what Java development
kit means
all the Java applications and applets
are developed using the Java development
kit that is jdk now the jdk consists of
the Java runtime environment an
interpreter a compiler an archiver and a
document generator and a few more tools
that go into developing a Java program
so now let us have a look at the
components of jdk
Java runtime environment JRE primarily
is a part of jdk and it can also be
termed as Java RTE
the jdk provides the minimal amount of
requirements needed to write and compile
a Java program
JRE consists of the jvm supporting files
and the core classes the jvm is key to
both jdk and the JRE because it is
embedded into them now whichever Java
program is being run the jvm is that
component of java that executes a
program line by line thus giving itself
the work of an interpreter
we are now in a position to Deep dive
into the process with which jdk JRE and
jvm work let's take a source file and
save it with the extension.java
this file is compiled and converted into
a set of byte code which changes the
file extension into dot plus this is
done specifically by the jdk now here
are the steps that follow class loader
it makes sure that all the necessary
classes are loaded in the time of the
execution of a program next byte code
verifier that is jvm the byte code
verifier checks the code for errors or
irregularities based on access rights on
objects or implementation of pointers it
makes sure that the code fulfills the
specifications of jvm and does not break
the system integrity and finally
interpreter which is jvm now while
running the program The Interpreter
loads checks and runs the code the
implementation is made by the JRE which
is a final process
the latest release is jdk9 and it was
released in October 2017 but it was in
jdk 8 that a new feature called the Java
Lambda expression was introduced that
changed the face of java now Java Lambda
expression is a kind of function which
does not need any class to be created
it has been included in the latest
version of GDK as it provides a clear
concise way to pass functions around
this also replaces earlier bulky
Anonymous classes and reduces code
verbosity that is the length of the code
the Syntax for the Lambda expression is
this argument list Arrow token body
now the syntax consists of three
components which are argument list
can be empty or non-empty next the arrow
token now this is used to link argument
to body and finally body this contains
the statement that works with the
function
let us now just see an example of using
Lambda expression and contrasting it
with how code would have been written
with Anonymous classes
this is the old method
and this is the new method with Lambda
expression
just have a look at how Lambda
expression syntax has been used over
here the jdk 9 has been released
recently and it seems promising with
respect to new features and abilities
here are some of the features
the first one is Java platform module
system
this module allows strong encapsulation
and declare explicit dependencies
next J shell with the help of J shell
one can directly start writing the code
on the console and execute them
improve Java dock
Java docs have got the search right in
the API documentation and as an added
bonus the output is also compliant to
HTML5
next stream API
the stream API also introduced in Java 8
allows programmers to easily paralyze
code for improved concurrency and
introduces functional programming
abilities to the language the stream API
in conjunction with Lambda Expressions
also comes in handy while iterating
filtering and extracting large amount of
data the release of multi jar makes it
possible for coats to be run on the
newer versions of GDK to be released
so to sum up it can be said that Java or
jdk is one of the Giants amongst all the
programming languages available in the
market given the fact that it's being
widely you being used in the industry
with the latest release of jdk Version 9
and the interesting new features it
brings along it is pretty evident that
Java is going to break newer grounds in
the world of programming so what are
objects and object is an instance of a
class let's have a look at an example in
this example animal is a class and dog
is its object the object dog has States
and behaviors we can have dogs with
different breeds sizes and colors these
are considered as the states of object
dog on Behavior side dog has Behavior
like barking eating and wagging tail so
an object has its own States and
behaviors now let's look at an example
using Java code there are many platforms
to run Java program so for this video
I'll be using IntelliJ so let's create a
new project let's name it as project 1
and finish there we go we have a new
project with we have a class with Main
and we have a main function so the code
that we write should always be written
in the main function so let's create a
new class to understand how the object
is used let's name it as student we need
variables so that we can access the
variables of this class so I'm gonna use
student ID with the integer type student
name
and students age
there we go now we have these three
variables that we can use so let's go to
our main program and start our coding so
we have a class named student now let's
see how to create a object of a class
this is the syntax to create object now
the object here is s i created an object
s of class student now let's assign
values to the variables for this we use
the object as and use the dot operator
and we have options from which we can
choose from that we declared in the
class student so for this I'll use ID
and give a value similarly I'll give age
and give a value and finally let's give
a name
now we'll print its value
now we are going to run this program
let's see what output we'll get
and there it is we have name that's
simple learn we have age and we have ID
now let us see an example how we can use
multiple objects for a single class so
let's get started let's create a new
project and I'm gonna name it as
Vehicles because I'm going to use cars
and bikes in this program so I'm going
to use Vehicles as a combined form and
yes here we have a class mail and a
function mean now I need two classes for
this program so I'm gonna create two
classes first I'm gonna name it as bikes
and the second class I'm gonna name it
as cars so let's create variables for
these classes so in cars first I need
string name and I need the cost of the
car so cost can be integer as well
because I'm gonna use dollar sign in
that so I'm gonna use string because of
that so same thing I'm gonna do with
bikes
now that our classes are created let's
create objects for this class so the
process is same but we are going to use
different names for the object first the
car class and I'm gonna name as car one
and yes we have created the first object
not to create the second object
similarly I am going to create five
objects of the Class Cars
and I'm gonna change the name for them
so I created five objects of the same
class so I'm gonna create five objects
of the bikes class as well so bike one
will be a bit longer so I'm gonna use B1
till B5
and I'm gonna name them two from B1 to
B5 so now I'm gonna assign values to the
variables that I created in classes bike
and cars so first I'm going to go with
cars and let's name it as Lamborghini
similarly Car 2 Ferrari
so I'm gonna use names of the cars that
are very famous and costly so that
anyone over the world can understand
this so let's name car 3
I'm gonna name it as Bugatti
similarly car 4
Pagani and Ka 5.
now I'm gonna give names for bikes
I hope everyone will understand the
names that I give
B4
and B5 last one Yamaha
now let's assign the cost for bikes and
cars as well so the procedure is same so
let's do it 130 000. same B2 so B1 goes
for Harley Davidson B2 for Ducati B3 for
Suzuki B for E cos and B5 for Yamaha I
am going to assign values for these
values accordingly for Ducati to thirty
two thousand
dollars
for Suzuki 200 000
300 000.
and the last one Yamaha 500 000.
now similarly I'm gonna assign values
for carbon.cost till card Five Dot cost
two hundred three thousand dollars for
Lambo I think I can copy paste these as
well so let's copy paste it a lot faster
and easier to do
car two car three car four and car five
we don't need this uh as per car 2 let's
take it as 252
000 and let's make it it's 3 million
uh let's put this let's keep it as 1
million
four hundred thousand and lastly uh
let's say yes 293. now that we have
assigned all the values for all this now
let's print it and get the value I'm
going to create a very simple program
but a very user friendly program so it's
gonna be interesting for you guys so we
are going to ask the users what would
they like either bikes or cars so we
need to give them the options and our
next program will be based on the
options that the users select not the
options we give as the command so let's
do it
let's give the options one
[Music]
bikes
and two cars I need to take the value
that user gives for this I'm gonna write
this command
so I have not used scanner yet so let's
import scanner
and let's create a object for scanner
and yes let's get back so the data type
of choice variable is integer that's why
I'm using next int if the data type was
string then I would have used next line
so now that we have Choice from the user
let's use this value
if the user chooses the first value that
means bikes so the next thing we display
is we have models and we are going to
give five models for bikes to the user
here I am giving options to the users so
that they can choose easily from number
one to five
now we can show these options to the
users so that they can choose from one
of these value so let's use one more if
statement so that we can find out
whether they have this value or not
before that I am going to ask which one
would you like to choose
to enter the choice I'm gonna use one
more variable let's say n so I'm gonna
store n
if n is equal to equal to 1 that means
Harley Davidson then I'm gonna show the
cost of Harley Davidson
this is the syntax to print the value
for the cost or any of the variable that
we use in class
what if the user says second or third or
fourth or fifth so for that we are going
to use else if statements
if n is 2 that means Ducati so we have
to show the rate of Ducati or the cost
of Ducati to the user
now similarly I'm gonna do for n is
equal to 3 n is equal to 4 and N is
equal to 5.
now I'm gonna do for n is equal to 4
and lastly n is equal to 5 that is our
last bike Yamaha
what if the users put a number that is
not between one to five so for that I'm
going to use else statement and put a
message that please enter the value from
1 and 5.
so now we have code for bikes and the
same thing what if the user selects that
he wants to find the car so for that we
have this the choice is equal to is
equal to one so the same thing we are
going to do for choice is equal to is
equal to 2
and the same thing we are going to tell
to user that we have five models
same names that I gave to variables I'm
gonna give this to here
second one Ferrari
third book RT
fourth equals
and the last one
posh
now we are going to ask the users the
choice that which number do they want to
choose
now we need one more value so that we
can have it as a variable which can
store the choice of the user so for this
I'm going to use C
now if C is equal to equal to 1 that
means if the user wants to see the cost
of Lamborghini that he puts the choice
as one so we're going to display this
message the cost of Lamborghini
and we are going to use else if Loop to
enter the next values for C from 1 to 5
if C is equal to is equal to 2 that
means the user wants to know the rate of
Ferrari then we are going to show the
cost of the Ferrari
same thing if the user enters 3 as the
choice
if user enters 4 as a choice then we go
for ecos
and the last one if user enters the
Choice S5
then we have to display the cost of posh
now what if the user enters none of the
values from 1 to 5 then we have to
display a message
showing that
please enter the value
between one to five now remember the
first choice that you wanted from user
to enter either bikes or cars so what if
the user do not enter either one or two
so for that we need one more else
function to tell the user that either
enter 1 or 2.
and with this we have completed our code
so now let's run this program for this
we need to go to run and then run main
there's a shortcut for it that is shift
plus F10 so let's run the program
and yes we have successfully executed
the program Let's test this program now
so enter your choice I'm going to enter
one and yeah we have five models Harley
Davidson Ducati Suzuki Pagani and Yamaha
so enter your choice I'm gonna enter one
and yeah we have a result the cost of
Harley Davidson is 130 000 so with this
we have completed our code and please
feel free to type this code in your own
computer and try out all the permutation
and combinations that you can with this
program so with this let's move on to
classes and understand the classes and
their concept then we'll have a new
program on classes now let's see what is
a Class A Class is a blueprint from
which objects are created a class
describes state or behavior of an object
in this example dog is a class the
variables in this class are breed and
color the functions or methods of the
class dog are barking hungry and
sleeping we use objects of a class to
use variables and functions of the class
with this let's understand classes with
a simple Java code let's create a new
project
next tick the box and let's name it as
automobiles
let the base package be student and yes
we have a class main now let's create
some classes to do code on
I'll create a new Java class as cars
and then I'll create one more class with
the name bikes
and then one more class automobiles
so I'm gonna connect cars and bikes with
automobiles so that we can use that
program in Main and see what can we do
with the classes that we create in
automobiles I need some variables
I'll take private double and let's say
Fuel and then same thing private double
and then year and let's take one more
private string and brand now let's have
Getters and Setters for this so these
are used to get the value and set the
value for the variables inside the class
there we go we have the Getters and
Setters for it now let's go to class
cars so public Class Cars extends
automobiles
so in it I'm gonna create one more class
or a Constructor
and I'm gonna print a message say a new
car has been created car has
now the same thing I'm gonna do with
Bikes let's go to bikes and I'm gonna
use the same thing extends automobiles
this is because I can inherit all the
variables from the automobiles class so
I created a Constructor and I'm gonna
print a message a new bike has been
created
so I have created Class Cars bikes and
Automobiles so let's go to main program
so this is where we should write our
code so I'm going to start with the code
now it's a very simple code I'm gonna
first I'm gonna create the variables or
the objects of the class with private
bikes bike so one is car and one is bike
both are objects for the classes so I'm
going to use this objects
bikes bike is equal to new bike
this is so that my object can function
really well and now I'm gonna run it it
will take some time to run
and yes there we go our program has
executed and the things that I typed a
new car has been created a new bike has
been created are done now let's try
something else using the classes so I'm
going to bikes so I'm going to create a
new method or a new function public void
kick for bike so I'm gonna print message
the bike has been started with kick bike
has been started with Kik now the same
thing I'm gonna do with cars now how
does a car start with the key so I'm
gonna make a function public key and
inside it I'm gonna print the same
message car has been started with key so
I should write void there to give the
return value as wide so let's print the
message car has been started with key
rotation let's write that as well so in
the main program I'm gonna use objects
to use those functions and let's see
what changes they will do to our program
Pike dot cake and car dot cake let's run
this
and there we go first we used to have
this two messages but now these two
messages are also there as well because
we invoked those functions and methods
that are there in class cars and bikes
so if I write bike dot key or car dot
kick this won't work this is because key
is not a method of bike or kick is not a
method of car so that's why I gave
private static for the functions
what is an abstract class
the answer is abstraction is one of the
keys to achieving an object-oriented
programming approach and designing a
software
here the programmer tries to hide the
complicated implementation of the code
which makes the software run smoothly
most of the time the user isn't
interested to know how the code is being
implemented so through abstraction we
can just hide it
to do so we use an abstract loss or
sometimes an interface based on the
requirement
so abstract class in Java is considered
as a template of methods and variables
which are used in a program remember
abstract classes cannot be instantiated
directly now moving ahead we will next
learn the important features of abstract
classes
so the first one is template the main
reason programmers prefer to use
abstract methods is because they act as
a predefined template for any future
specific class that you might use
next loose coupling is a procedure where
an internal object gets the necessary
method or a different object from the
external world that is other than the
current working project the use of
abstract classes makes this process
possible
after that we have the code reusability
implementation of the abstract classes
provides the developers with one of the
greatest features that saves time which
is none other than the code reusability
followed by code reusability we have
abstraction as discussed earlier data
abstraction is the process of hiding
certain details and showing only
essential information to the user
abstraction can be achieved with either
abstract classes or interfaces
last but not the least
Dynamic method resolution
the abstract classes enable us with
Dynamic method resolution or the dynamic
method dispatch process
the dynamic method resolution is a
mechanism by which a call to an
overwritten method is resolved at
runtime this is how Java implements
runtime polymorphism
when an overwritten method is called by
reference Java determines which version
of that method to execute based on the
type of object it refers to
now these were the few important
features of abstract classes next in the
docket is the crucial rules to be
followed to use abstract classes
all right let us go through the rules
one by one as mentioned below
the first one is the keyword abstract is
mandatory to declare an abstract class
followed by that the next rule says that
abstract classes cannot be instantiated
directly
the third one is an abstract class must
have at least one abstract method next
to that we have another rule which says
an abstract class includes final methods
next an abstract class may also include
known abstract methods it's not
mandatory that an abstract class should
only include abstract methods so the
last rule says that an abstract class
can include Constructors and static
methods
so these were some crucial rules to be
followed to use abstract classes in Java
so far we have discussed the definition
of abstract classes its features and the
rules to use abstract classes in Java
now we will learn how to achieve
abstraction in Java
so basically there are two different
ways to achieve abstraction in Java the
first way is by using abstract classes
and the next one is by using an
interface
now this brings us to our next topic
that is the syntax to be followed to use
an abstract class and an abstract method
to declare an abstract class we use the
keyword called abstract followed by that
we use the keyword called class then
after that we declare the name of our
class the name of the class is up to the
user's choice for example I have named
my class as simply learn as shown here
followed by the abstract class we have
the abstract method to declare an
abstract method we use the keyword
called abstract then the written type of
the method as of now I have used void
then later we have the name of the
method that is based on the user's
Choice as you can see I have used simply
learn as the name of the method
so this was by using abstract class
method the next one is by using an
interface method
now what exactly is an interface
so interface can be defined as a
boundary between the method and the
class implementing it in Java we use
interface to achieve abstraction in
other words we can also consider
interface as a container which saves the
signatures of the methods used in a
program
now we will move ahead and understand
the syntax to use an interface to
achieve abstraction in Java
to declare an interface we use the
keyword call interface followed by that
we declare the name of a class
the class name is up to the user's
choice for example I have named my class
as simply learn as shown below
as discussed earlier interface acts just
as a container that stores only the
signatures of the method we cannot have
a complete method defined inside it all
we can do is just declare an interface
now that we have a detailed explanation
about the abstract class and the
interface
let us look into some example programs
based on abstract classes
now we have successfully booted the
Eclipse IDE now let's create a new
project
so to create a new project just click on
create a project
and this should give you a dialog box
wherein you have to select Java project
click next
now let us give a name to our project
so simply learn will be the name of my
project here now let me click on finish
to finish this process
as you can see the project has been
successfully created and inside the
project simply learn we have the source
file and right clicking the source file
will give us a Dropbox where you can
just select new and inside new you can
select a new package
now let's name the package as
abstraction and click on finish to
create the package
moving further let's right click on the
package and select new and from new
select a class to create a new class
so the name of my class will be employee
let's click on finish to create the
class
now we have our employee class ready
now let's right click on the package and
select new and inside that
let us select another class
and the name of this particular class
will be person which will act as our
abstract class
so as you can see we have declared this
particular class with the keyword
abstract and the name of the class is
person
so our first example which is based on
employees where we will have an abstract
class called person and this person
class will be inherited by the employee
class and gets executed to generate
employee details
now let us try to execute this program
and see the output
to execute the program just right click
on the package and go to the Run option
and select the first one that is Java
application
now you can see we have the employee
name pavitra and the gender is female
and the employee has logged in
successfully so these are the details
which we were expecting to be presented
on the output console now moving ahead
we shall execute our next example which
will be based on students
foreign
so here
the class student is the abstract class
and three different student classes
namely Raju pranitha and punat will
inherit the student class and generate
the output that displays their
particular ranks
so you can see our abstract class that a
student has been declared using the
keyword abstract and inside that we have
an abstract method which is get rank
and these classes that are Raju pranita
and Punit will inherit the abstract laws
student and display their ranks
now let us try to execute this program
and see the output
as you can see the three classes have
successfully inherited the abstract
class and displayed their ranks on the
output console
now let us move ahead and try to execute
one last example
based on abstract classes
so the third and last example is based
on interest rates provided by different
banks
here we have an abstract loss named loan
and all the banks described in the
program will inherit the loan abstract
class to calculate the rate of interest
on the loans provided by them
as you can see we have the abstract
class that is loan and inside that we
have the abstract method which is
interest so we have the classes Andhra
Bank bank of Baroda idbc Bank State Bank
of India which are inheriting the
abstract class called loan and the
method interest to display their rates
of Interest now let us try to execute
this program and see the output
as you can see the program got
successfully executed and the rate of
interest for loans from different banks
is been displayed in the output console
so with this we have entered into our
next topic where we understand the
differences between an abstract class
and an interface
so the first difference between the both
is the keyword while we declare an
interface we use the keyword called
interface on the other hand when we
declare an abstract class we use the
keyword abstract
followed by that the second difference
is when you use an interface the
subclasses basically Implement an
interface
while on the other hand when you use
abstract classes the subclasses extend
an abstract class and inherit the
properties of the abstract class
followed by that the third difference is
multiple interfaces can be implemented
but on the other hand only one abstract
class can be extended at one particular
instance
and the final difference between the
both s interface is capable to support
multiple inheritance whereas on the
other hand abstract classes are not
capable to support multiple inheritances
multiple inheritance is none other than
the diamond problem which is not
supported in Java
now that we have understood the
differences between the both let us
understand the major advantages and
disadvantages of using an abstract class
now first we will discuss the advantages
so the advantages of using an abstract
class in Java are the abstract classes
are highly beneficial in writing shorter
codes the abstract classes avoid code
duplication they enable code reusability
which is a major advantage
and finally the last Advantage is
changes to the internal code
implementation can be done without
affecting the classes
so these were few of the major
advantages of using an abstract class
now moving ahead we shall discuss the
disadvantages of using abstract classes
few of the disadvantages of using an
abstract class in Java are abstraction
is expensive as sometimes you need to
handle cases and situations which are
not necessary
followed by that the second disadvantage
is object relational impedance must
match in the case of rdbms and the last
disadvantage is object relational
mapping in case a Frameworks like
hibernate so these are the few important
disadvantages of using abstract classes
in Java that you need to consider before
using them into your project what is
Java interface
an interface is a container that stores
the signatures of the methods to be
implemented in the code segment it's
really hard to Define interface because
it's the meta of meta it's basically a
control object
and so you see these in projects where
whoever is in charge needs to have a
very high level of control what
everybody else is doing do you have to
have an interface when you're doing
programming no but if you're in a large
project you probably want one as
director or if you're receiving it you
might get the interface which you're
supposed to use in your programming
so when we talk about the need for our
interface in Java it's a total
abstraction and it's only the methods
we're not talking about any variables or
anything like that just the methods
you can do multiple inheritance so you
can inherit from different interfaces
and you can do loose coupling
and when we talk about loose coupling
you can think of a hundred programmers
working on a huge huge software package
and they really don't know what the
other programmers are doing they can't
meddle with it they can't mess with it
they have like a nice direct place they
can do and they have the information
they need in the interface
so we'll talk about the syntax of the
Java interface the interface then you
have your interface name and then you
declare your constant Fields declare
your methods default method
and really to understand this we just
need to take a look at an example in
Java interface and we're going to do the
Java interface to find area just kind of
a fun little code for this I'm going to
jump into eclipse
we'll go and create a new
package there we go and we'll call this
interface
and we're going to go ahead and add in
Java and it won't let you do just
straight interface because that's a
reserved word we'll go ahead and create
that and then underneath our package
interface Java
we want to go ahead and actually add in
an interface
and so we go underneath here new
interface
and let's go ahead and call this one
we'll call it area interface area
and finish
so now we have our package and we have
our area and this is just the same
package we did with our polymorphism and
inheritance so now we have a package and
we've added the object of interface
and note that the interface is always
public you never have a private
interface because it's a meta file so
it's always going to be accessed by
other people and by other classes
and as we're creating these methods
um this works just like you would any
other method I could easily put integer
and then we have a maybe integer side
one integer side two
so you can see how you can do like for
the setup this is going to be just like
you do the rest of your class and the
rest of your methods but we're going to
keep it simple
and we're just going to do void
square and let's go ahead and do public
void rectangle we'll put a rectangle in
there too
foreign
so now we have a basic interface in this
case for area one of the cool things
about interface is I can go in here to
create another let me go back into my
interface Java and we'll do another new
another interface
and we'll call this
um
area
curves I don't know just making that up
so we have area curves and maybe in this
one
this one happens to be for
a circle so we have our curved areas let
me just go back in here
and maybe we'll do not only a circle
but a noble
there we go so now we have our circle
oval or Eclipse depending on what you
want to use on here and I can go back to
my area
and just like you can in classes this
extends
area
curves so now I can also do the extends
or in the case of inheritance same as in
a class
exactly the same it just makes it easier
if you have you know a hierarchy of
stuff coming down in your interface
now we'll go back in here to the
packages oops we're going to go back
here and create a class and let's go
ahead and do that in here under our
interface new
class
and we'll go ahead and call it shape
area and so now we have our new class
shape area how the heck do we use our
inheritance area in here
well we just go ahead and do implements
area
and so once we do that we now have area
which happens to extend area under
curves
and let's go back in here to um
our shapes area the class
and what I want you to notice in Eclipse
is the shape area has an underline red
and if I hover my mouse for it it's kind
of hard to see here a little bit I'll
give you some options there which will
say bring in your implements your
implementing area but you didn't do
anything with it that is what interfaces
are all about it's about forcing someone
to show an error here now in Eclipse I
have it set so I won't throw an error if
I run the program but it's going to tag
it so even if I compile it right now let
me just go ahead and run this even
though it doesn't do anything it still
has the shape area underlined and then
it comes up here and also puts a little
exclamation point at the top when I
actually do some actual coding in here
let me go ahead and do that so you can
see what that looks like there we go
we'll put in our main and we'll initiate
our instance of shape area
and we'll go ahead and run this
doesn't actually do anything it's going
to compile all our different pieces on
here and you still see the shape area is
got the red light underneath of it when
it pops up it says hey you have some
unimplemented methods make type shape
area abstract or you know different
solutions on there it's because we don't
have the actual code of saying hey you
were told to use what's an area and
you're not using it
again this is all about being in control
and so we have in here when we go back
into area
oops that's area curves let's go all the
way to area we have to have square and
rectangle in there and because this
extends area curves we also have to have
Circle and oval
and so when we put that in there we have
to do an override
just so our package actually does
something let's go ahead and bring in
the scanner utility this is just
capturing your keyboard that's what
that's for the Java utility scanner
uh and then we're going to go ahead and
do our override use the at symbol
override
there we go uh and then we go ahead and
take a look at what we had in area well
an area we had Square so let's go ahead
and grab the square
this of course is just being very lazy
and not having to retype it so we have
our public void Square
and then we wanted to do something in
here in this case we want to go ahead
and create a scanner
for the keyboard
and we'll do a new
scanner
system in
that's all that is is we're going to do
we're creating an object so we can
capture keyboard input and request
information from people
uh and since this is a square let's see
we're not going to get too caught up in
the code here oops
there we go
and we'll go ahead and do geometry of a
square and compile it and run it it
still lets me compile and run it and you
can see down here it actually says Hey
enter the length of the side of square
we'll put in five and the area of the
square is 25.
so when we look at just this part we
have it accesses the square
prompts as far input does the math of
the square and it's fully functional but
I want you to look up here it still says
this still has an error it still says
hey you're missing the stuff in here you
don't have all the pieces you're
supposed to have in here
so if we're missing the pieces in the
Implements of area we need to go ahead
and put those in
now we're not going to go through and do
all the different areas and walk through
each piece and we're going to look at
this when I put in our rectangle which
is you know we have the square and the
rectangle and then we had the circle and
the oval you can see that the air goes
away so I no longer have a shape area
with an error on it and if I run it it
of course will still compile
there we go and if I come down here I
forgot I got to put in the put in
something for the square we could also
instead of square just do you know
whatever it is you'll see that Circle
still functions although it's just going
to do a printout as opposed to what we
had before where it takes in all the
information computes the area
this is what implements is about it's
about taking all this stuff and pulling
it in and forcing the programmer or the
people in the team to use the different
methods that they need for that
particular class
and there's one more thing that we want
to do and I'm going to oh I'm going to
take this extends out here
and then we're going to go back to the
shape area and you're going to see it's
going to give me another error on here a
slightly different error and the reason
is is that I did overrides but these
don't exist so they don't know what I'm
overriding or what the setup is
um and let's say instead of importing
area instead of having area inherit area
curves
we could also just Implement area and
area curves and then you'll see that the
error then goes away when I run the
compiler
there we go
and this should be should remind you
something we talked about in inheritance
inheritance we were discussing in
classes how you have a diamond effect
you can't inherit from two separate
classes
you can Implement two separate
interfaces
that means that if you have uh you're
the head of a project you can now say
hey this class needs these different
pieces so it's a very powerful tool and
it's one of the ways to force
programmers to put in the modules they
need and get around the diamond effect
let's take a look at interface nesting
in Java nested inner interface is a
procedure declaring a new interface
either an existing interface or inside a
class
uh and let's go back into here a little
play area let me just close these out
real quick
and let's go ahead and add another
package in and we'll do a new
package
and we're going to call this um instead
of an inner interfaces call it nested
nested interface there we go our nested
interface package Finish
and once you're underneath this package
we want to go ahead and add in an
interface
and we'll put a new interface in it
we're going to call this
is going to be a little confusing
interface outer
and then in our interface outer
we're going to go ahead and create an
interface enter
let me put that in this so here's our
interface outer here's our interface
Center and our void inner method
and then let's go ahead and add in a
class new class and we'll call this the
nested
oops
and we'll call this the nested if for
interface
let's go ahead and finish that so here's
our class
and in our class we're going to go ahead
and import enter interface dot interface
outer dot interface enter
whoops forgot I changed the name to
nested interface for the package so
we're going to import from our package
nested interface interface outer
interface enter and that just means that
we're going from here's our interface
outer and here's our interface enter
you can create a stack of interfaces so
that when you send the package out
instead of sending out 50 different
interfaces you can send one interface
out with all the sub interfaces embedded
in it
and you can see it highlighted there the
nested if still comes up with an error
because we haven't done our override and
we'll go ahead and put in a public here
and we'll just do
initiate our
our nested if class
I guess nested if there we go uh so
let's go ahead and initiate that we're
going to have our object
equals a new
nested if
and again if we compile it and go ahead
and run it and I'll do the compilation
here you can see that it compiles fine
it's not going to give you any errors
but when you hover over here it says hey
you need to add unimplemented methods
and you left some stuff out of here that
you were told you're going to include
which was this interface enter
and of course we can simply do that
um
there we go make it look a little nice
into our override
and once we have our override we need to
go ahead and create the method this is
telling us we have to have that method
in there we're going to get an error
and that was our inner method that we
included
and then it's whatever we decided to do
in here let's say we wanted to go ahead
and
we want to find the first 15 prime
numbers
and our team in the back put the other
little piece of code for that it's
always fun to throw something in
interesting so you're not just looking
at a print I did something really cool
here I can get boring after a while so
we'll go ahead and do integer we're
going to iterate equals zero number
equals zero x equals one y equals one
and then while number is less than 15 y
equals one and we iteration equals zero
so forth you can see here we're doing
what is if you divide is there any uh
leftover if there is no left over then
that means it's divisible we know we're
not that's not a prime otherwise if the
iteration equals two system out is going
to print the number
and then we're going to add another
number to it and just keep looping
through so you can see right here this
is just a simple set of code but there
goes my error my error is gone that's
what's important we have our inner
method there's no more error on here
because we've now included it that came
from our nested setup on here
and of course if we're going to put a
code in there to count the prime numbers
we should probably go ahead and do our
object method and run that
there we go and sure enough we have our
two three five seven eleven there's our
list of prime numbers
so just to kind of hammer at home what
is the difference between interface
versus class interface keyword used is
interface keyword used for classes class
interface does not include instructors
where class has its Constructors in
there interface doors only methods only
the method signature where class has the
storage of the actual definition so just
the signature versus a full method in
there there's no access specifiers in
the interface or of course there is
access specifies are needed in class no
data members includes data members in
class no static members include static
members in class so think of the
interface as being just instructions or
instructions on methods that's all they
are they say Hey you have to do this as
a programmer because you're head of your
department said this is what needs to be
in here or maybe you have a very
complicated code with a lot of the same
pieces that says hey don't forget these
pieces is because we're going to give
you an error if you don't
what are the advantages of interface
well using interfaces has increased the
Simplicity in programming some of the
advantages are complete abstraction is
achieved with no ambiguity and that is
very key that is a whole thing it's
saying hey we need these in this class
you have loose coupling between the data
and methods so now your team can have
what they need without having to go
through and understand what the whole
picture is they can build on small
pieces and really focus on it it
resolves a Daemon problem remember from
classes you can only inherit from one
class now I can come in and say hey
these procedures these methods all need
to be in here and I can have these many
methods as I want in there it resolves
the complexities in defining
dependencies uh so again you have this
whole archive and it's almost like
telling a story this is what we're
building this is what it looks like
disadvantages of interface using
interfaces has some disadvantages
obviously the first one I look at is if
you're working on a really small project
you've added a whole layer of complexity
to it so when you're working on smaller
projects you almost never see interfaces
the interface in the real world project
is used either extensively or not at all
and so you'll see instead of an
interface they'll just send you a list
of what you have to have in there that's
pretty common but with the interface it
forces the programmer so when it goes
back up the chain and everything needs
to be put together and so it gets a
little confusing because some people are
like oh I got to use an interface
tonight or I don't and the use of the
interface can reduce the execution speed
you're adding a whole another layer
there where it has to look that
information up and so if you're doing
like a huge multi-task process and
you're spreading it across multiple
processors and so now you have hundreds
of these classes that are pulling in
hundreds of these interfaces that's
going to add a little ding to your speed
and it might not be something you want
to do there for a process like that
which is very different where if you're
writing a game and each player and each
module for their character which has
certain things they have to do which is
move left move right move up down and
then they have their all the new games
always have a special thing they can do
that has to be embedded into that class
let's see the definition of
encapsulation encapsulation is like a
capsule the whole code and data is
bounded together into a single unit
another way to think about encapsulation
is it is a protective shield that
prevents the data from being accessed by
the code outside this Shield as you can
see variables and methods are defined
inside one class like a capsule now the
question is why do we need encapsulation
the main reasons are first better
control of class attributes and methods
second class attributes can be made read
only or write only third it makes Java
code very flexible this means the
programmer can change one part of the
code without affecting other parts apart
from these encapsulation is mainly used
to protect data and increase security of
the code as you can see to protect the
data variables must be private and they
can only be accessed through methods now
let's see Java code for encapsulation to
understand the cons except better so now
let's create a new project
next
and I'm gonna name it as
NCAP one
so here we have our main class we can
write the code here so before writing
the code let me create a new class
right click new Java class
and I'm gonna name it as employee
so in this program we are going to use a
classic example of employee using
employee Name ID and salary so in this
class let me create variables
first string name
then
integer ID
and then in salary
so I can easily use these variables in a
main program by creating object of the
class so let me just create the object
employee e is equal to new employee
now I can use e dot ID name or salary
anything I need to but this program is
about encapsulation so this is an easy
program we can do but in order to secure
our programs when we have a large number
of program and large number of lines in
a program so we need encapsulation at
that time so that data can be secured so
for that I'm gonna name it as private
now all three variables are private so I
can't use them see we can't see them
anymore if I write ID
we'll get a red color here so if we go
on it we can see ID has private access
so that means we can't use it directly
because of this we need Getters and
Setters that are normally methods that
are used for these so right click
generate and here you can see Getters
and Setters so just select all of them
and ok so now we can use these methods
instead of direct using the variables so
we can get in the starting then set then
get and again set so likewise it goes
like this so now we have set here so if
I want to declare variable and if I want
to put some value inside my variable so
how can I do that
here you can see get ID or get salary so
if I go for get ID sorry if I go for E
dot set ID and I set it as 6 so this
shows no error this means we can use
methods to access variables so let's
complete our program now first I'm gonna
set everything
and lastly e dot set salary let's get it
as thirty thousand maybe in dollars or
maybe in rupees let's just set it as 30
000 for now
so how I'm gonna print it for this I'm
gonna go to a print statement and then
name
and E dot not set name but this time I'm
gonna go with get name get name is to
return the value of the name that I have
given so in this case that's simply
learn
and next will be ID
and E dot get ID
and lastly salary
e dot get salary
so this is a simple program that is used
to Define encapsulation we don't use
private variables that becomes a normal
program so when we use encapsulation we
are going to use private every time
whenever we declare variables so that
it's secure and no one can access the
variables directly
so now let's run the program
and there we go we have our result we
have executed the program successfully
and as you can see name simply learn ID
6 and salary is 30 000. so I hope you
understood the concept of encapsulation
so the main concept of encapsulation is
all the variables can be accessed
through methods so for this we use
Getters and Setters that are inbuilt
functions for IntelliJ or netbeans or
eclipse what is inheritance
there are two other key terms which are
not going to be in this agenda but you
should also when you get to them make
sure you bundle them together as you're
understanding these structures and
that's the abstract class and the
polymorphism so what is inheritance
inheritance is an act through which a
new class gets created by acquiring the
variables and methods defined in the
previous parent class
so we look at what is inheritance we can
take an example of say food we have
veggies noodles fruits where food is the
parent and your veggies your noodles and
fruits are all subclasses of that
they're all kind of children of food
why do we need inheritance
we Implement inheritance for a multiple
of reasons like creating a possibility
to add or remove features
to reduce the code length as we reuse
the code more comfortable to develop and
maintain the project
and so if we start looking at let's say
we have a cell phone we make calls we
have our SMS texting our communication
on our phone we have our media we also
add a browser on there because now we
have a smartphone
when we look at that we have our phone
set up and then we have our full
smartphone media call SMS and browser
and we start to kind of Link these
instead of making them separate we can
have the call and the text and then we
can have them inherit we can actually
create a media that inherits their
quality so now you can text your media
now you can use the browser as part of
your call scenario
and I would even add one more example in
here and that is that all programming
languages that are object based are
built on inheritance uh Java python C
plus plus so this concept of building an
object and then that object then is
inherited by everything underneath of it
is important to understand even in these
most even as we're looking at more
specific cases
so we'll take a look at the components
of inheritance
and the most important two components in
inheritance the two major components
that are mentioned are parent class or
the superclass and the child class or
the subclass
and to see this let's go ahead and jump
into eclipse and take a look at what the
actual code looks like
so the first thing I want to do is go
ahead and add in a new
package
and we're going to go ahead and call
this package
inheritance because that's what we're
working with
oops
gave me a default Java tutorial in there
inheritance finish and I started off
with the Java tutorials just a um
went in and created a new project and
made sure it was Java based
so we have our package inheritance right
here we're going to go ahead and add in
a new class
and we'll go ahead and call this class
machine now one of the standards when
you're creating classes to capitalize
the first letter so always remember to
do that in some places people like to
have the whole word capitalized it
really depends on who you're working
with but it is kind of if it starts with
a capital letter it's probably a class
and so once we have our inheritance we
have our public class machine
let's go ahead and give it a little bit
underneath there to do something and
we'll start with um
protected
string brand and so whatever machine
we're working with these particular
machines are going to be we'll call them
it'll be a Samsung
free
they get some free vocab free marketing
right there for Samsung
uh so Samsung machines
and then we wanted to do something so
let's go ahead and put a procedure in
there and we'll make it public
voids it's not going to return anything
and we'll call this uh wash I guess
they're all washed machines
there we go there's our brackets a
little trouble finding the bracket on
there and let's just have it uh during
this we'll just have it do a Quick Print
line
and we'll say um
initiating
cycle
there and then of course our semicolon
on the end
all right so now we have a public class
machine and we're going to get into
where we start working with the actual
inheritance you can create an object
with this machine we haven't done
anything special to it it's like any
other class you might create in the Java
language and we've added in public void
wash a procedure with no return that's
what the void means and it's going to
print out and so let's go ahead and
create another class in here new class
and this one's going to be washing
machine
washing
machine
and uh
we'll go ahead and hit finish on here
and we come into our washing machine
this opened up a nice new tab for us
and we might have a private string model
name
and we'll change this to model type
model type equals
so the type of machine is is a top load
washing machine
so we have a Samsung as a main type of
machines we're looking at we have top
loader or top loading washing machine
and then we're going to add up here
extends
machine
and so this is the the key code we're
going to look for because we want this
to have the properties of the machine
so this comes in and says whatever is in
machine we now also have in our washing
machine
and then of course if you're going to do
all this we need to actually be able to
run it and if we're going to do that we
want to go ahead and add in the public
static
void main reserved keywords there and
this is just your standard main startup
you have your string of arguments
um there we go
and of course our bracket and then in
here
we're going to take and create a washing
machine object
so here's our wash machine
it's of course the type washing machine
and it's going to equal a new washing
machine so we're initiating a new object
in here there we go
and then we want to do something
and if we're going to have it do
something we wanted to go ahead let's
see what happens we have wash remember
our keyword up there was washing machine
Dot wash
and where did that come from well if we
go back into machine
here it is public void wash there's the
procedure and it's coming into the
washing machine and this is inherited
that way we don't have to retype that
every time we have a washing machine
this could be washing machine
uh maybe the next one is I don't know
different kind of washing machines I'm
not an expert on washing machines
we have to do a wash
and then specific to the washing machine
in here
we also had uh the type and so we can
come back up here or brand so we can
come up down here we can go system
dot print line
wash machine Dot
brand
Plus
I'll put a little Dash in there
um
Plus
and then we're going to go ahead and we
have our wash
machine Dot model type
that model type we put in there so the
brand where does the brand come from the
Brand's coming from our machine we have
our protected string which is going to
be Samsung
and then we have our washing machine
which has the model type which is a top
load machine and if we go ahead and run
this
after of course we make sure we have
that semicolon in on the end there
we come up there we'll see initiating
cycle initiating cycle is printed out
from machine and then the Samsung top
load washing machine is the second
printout line here and so when we have
our wash print out here also the wash
machine wash is initiating cycle and
then we have that's where that printout
comes from we can go back up here to
machine you can see right here
initiating cycle
and then we flip back over to the
washing machine we print out wash
machine.brand which is the machine class
and then wash machine dot model type
which is underneath the washing machine
so let's go over all that let's take a
look and see what we're talking about
here
so we saw on the code the extends
keyword the term extends is a pretty
defined keyword in Java that allows you
to create a new child class by deriving
the variables and methods from the
parent class to reduce code length and
improve the performance
and we see that right up here in our
public class washing machine extends
machine
so the next key thing to talk about is
access modifiers
and I kind of breezed over them when I
put together the code but we'll dig in
there a little deeper we talk about axis
modifiers there's four different words
you really need to know and that's
default
public protected and private
and I'm going to tell you right now
default equals public
so what is default default access
modifier is set implicitly whenever you
declare a class without a specific
access modifier by default the axis of a
class or method when declared without a
specific access modifier becomes
available to any other method or class
within the same package
and in Java the default is public so
public a certain class can be declared
as public by using the keyword public
any class or method when declared is
public becomes available to any class or
method declared in the same package but
if a different method or class needs it
it should be imported
and then we have protected certain
classes declared protected by using the
keyword protected this provides access
to the methods and variables of the
protected class only to the rightful
subclasses and protects the data from
any other classes which are not related
and then private a certain class is
declared protected by using the keyword
private this provides the ultimate
protection to the data members and the
methods of the private class this
procedure is implemented by class to
encapsulate the method and members
so uh we'll take a a little we're
actually going to do a different example
in here but I do like this underneath
the washing machine
you can see right here we have put in
private a private string
what this means is that only washing
machine can access that private string
where if you have protected the children
can access it so protective screen if
you're underneath a machine up here we
have protected
so that when I create the washing
machine and extend machine I can still
access it but if I create a sub class of
washing machine in a market as private
that subclass is not going to be able to
access it and so it has to do with what
layers of accessing
think of this as a big team project you
create something do you really want that
to Cascade down to the next class or who
do you want to have access to that
let's go a little deeper to really bring
this home because it's really important
to understand these terminology let's go
ahead and start a new class here and
we're just going to call this particular
class summation
go ahead and create that finish
and so our summation class it's going to
be pretty simple in here we'll go ahead
and do uh
public
so anything buddy can access it just
remember here's our public on there and
then we'll just do a integer because
that's what's going to return as an
integer we're going to call it add and
we're going to put integer X comma
integer y
and
we'll just return X Plus y so real
simple we're just adding two numbers
here's our two inputs they both have to
be integers and we're going to return an
integer and it'll be the summation of
the two so real simple class right there
and if we're going to have a summation
and let's go ahead and create a new
class and we'll call this one child
and in our new child class
we're going to go ahead and keep this
simple and we're just going to have our
public static main we're going to have
our summation a equals new summation and
then system out print line a DOT add 100
plus 200.
pretty straightforward everything's
public in here oops okay there's our
running and we see the answer is 300.
so this is public if you remember
correctly we're talking about public
and so when we use the public keyword
any class or method when declared as
public becomes available to any class or
method declared in the same package
but if in a different method or class
needs it it should be imported
so here we go it's that's our public
setup it's just open to everybody well
everybody that's under the package
inheritance so whoever's using that
package can now use the this particular
child
and let's go ahead and add a new class
in and this time we're going to do a
parent class
I'll just put that right in there
and we come in with our parent class you
can see right here the parent class
itself is public but we want to do
underneath the parent class is we want
to create a protected
void because we're not returning
anything and print so we're going to do
the print there and this protected print
let's go and put our brackets in there
and we'll do just a simple uh print line
hello world
and once we have that print hello world
we want to go ahead and add a child
class to this
and let's see we already well we had the
child class when it took it out a second
ago so we'll go ahead and put that back
in uh here's our child class
and for this childhood class we wanted
to go ahead and extend the parent
so inheritance there's our extend on
there oops let me retype that
all right extends parent so now the
chalk class is part of the parent class
foreign
there so that it will run it and execute
it and we'll create our child X
equals new
child class
let me go ahead and assign our variable
X and initiate it and then we'll do just
the print and see what happens here so
here's our print statement
and we'll go ahead and run this and
compile our child on there
and when it comes in there you see it
says print hello world and so the parent
has marked this as protected so it's
protected from objects that are not
inheriting it but the child can still
access that information and print it on
there
so here's protected this provides access
to methods and variables of the
protected class only to the rightful
subclasses and protects the data from
any other classes which are not related
and a lot of programming that's usually
where you end up is doing a lot of stuff
that is underneath your parent
that is protected either make them
public or protected a lot of people are
sloppy and just make them public but
most of the stuff you want to make sure
it's uh protected and then we finally
have our private and I'm going to go
back here to our child and we're going
to run this
and it's going to come up and say
proceed with launch errors in setup and
then it's going to give us an exception
thread Main
compilation error the method print from
the type parent is not visible and
that's because unless you actually
initiate the parent you're not going to
see this code because it's private it's
only private to the public to the parent
class so even if I extend it in child
it will not be available and that again
protects it that means it's something
that you don't want to inherit and
Cascade down because maybe it is a piece
of code that is going to be changed and
so you don't want all the children to
crash every time you make a change to it
so with private this provides the
ultimate protection to the data members
and the methods of the private class
this procedure is implemented by class
to encapsulate the methods and members
so very important we have private and we
have protected and we have public the
more access you want other pieces of the
software code to have and other
programmers to have the more public you
want to make it and of course the
default is public
now one of the common workarounds for
this because you're going to have
protected data but you still want it to
be used by the subclasses is to create
what they call like a get or a and we'll
do it up here we'll go ahead and do a
private
integer x equals five
and then instead of on your inheritance
instead of having it uh call it from
the child we might have a get thing or a
gith thing we might have a public
it's going to return an integer and we
might have it say get X
and this simply just return X
and what this means is that we have
something simple like this where it just
doesn't return X I can go back into my
child here
and instead of print X we'll do x dot
get X
and we'll go ahead and print this out
or you know something simple with that
we'll go ahead and do a
system print line on this
and when we run this
you'll see it come up it's going to
recompile and we get our five What's
Happening Here is now I've created
underneath the parent
private information you don't know
what's going on with it it's protected
you might have a procedure that's
protected in this case we had the print
procedure and then we access it from the
public and this could have easily have
been instead of um maybe we'll just call
it public
void
public print
kind of a goofy way of doing the code
there we go and then it could go in here
and access our print
and so we can actually still access this
print variable up here by wrapping it in
kind of a git or a public function this
allows us to protect whatever code is
going on in the parent class so it can't
be messed up it can't be accessed
indirectly it has to go through the
right processes and so when we get to
the child on here the child can then
still has the public processes but all
the other information isn't is protected
and is private it's really important to
remember that private right there
this brings us to Super keyword
and we talk about the super keyword uh
super keyword eliminates the confusion
between parent class method and subclass
method
super keyword is implemented to access a
method or Constructor that is defined in
the parent class
so back in Eclipse will go under parent
and we'll take this we're going to take
the private out of there so now we have
an integer five
and we'll go ahead and just remove the
print because we're not going to do that
in the parent
whoops and the public
there we go
and so let's create a parent that just
has one piece of information it has an
integer x equals five
and then we're going to go to the child
and let's go ahead and add in here
integer x equals 10. and these are by
default they're public we haven't set
anything on here telling it what it is
and so what I'd like to do is we'd like
to go ahead and create a
oops one more thing there we go create a
procedure here
and we'll just call this void Capital
print this is going to be a system out
print line and this is what I want you
to notice is we're going to print out X
and Super X so we have the child class X
and we have the parent class Super X and
if we come down here and we do X
um Dot
print
don't forget my semicolon
add a couple spaces in here to make it
uh look nicer when we print it and we'll
go ahead and run this and you can see
that the child class prints 10 and the
parent class is five and so this way you
can actually store different information
depending on what it is you're working
on and what you're doing and that's
where this super comes in you can see
right here where the super
underneath the clasp and the print
module now you can't just put it in down
here under print
let me explore what that looks like if I
just take this and I go ahead and
highlight it
and let's say I wanted to just instead
of doing X print
it's going to come up right here right
off the bat you see the super dot X I
can do x dot super dot X and it's still
going to give me an error right here it
has to be underneath a procedure in the
actual class and not under the main
this brings us to types of inheritance
and there's four main types we have
single inheritance which we've already
pretty much looked at but we'll go back
over we have multi-level inheritance we
have hierarchical inheritance and Hybrid
inheritance let's go ahead and just
start with the single inheritance single
inheritance consists of one parent class
and one child class here child class
inherits parent class methods and data
members
and let's go ahead and create a new
class up here just to change it up and
keep an interesting new
class and we'll call this one student
uh and under the student
will have a simple setup I'll just do an
enrolled and it'll say enrolled in
simply learn there we go so there's our
class student and then we'll create
another class uh we'll do it as a
because we have our student or base
student and then we'll call this one
new
class
okay we'll call this one uh computers
there we go so he's a rolled finish and
for computers let's go ahead and put in
a print line here
and we'll put down
studying
computers
and we want to go ahead and do the
extends extends
foreign
student so it's a student studying
computer subclass computers and this
would all look familiar because we've
been doing this for you know a lot of
the other setups this is your basic
inheritance
and we'll change that from enrolled to
studies
and then let's go ahead and put a main
in here so we can actually run it and we
have our P enrolled which comes from our
parent class and our P studies which
comes from the child or the one that
inheritance it the extends for student
and let's go ahead and run that there we
go run
and you can say enrolled in simply
learned studying computers
and then we can go on to the next setup
and this is where we look at multi-level
inheritance it is also apparent child
inheritance relation but the difference
is the child class is inherited by
another child class
this is the basic structure of most
programming languages right here you
have an object you have all the
different things under the object and it
gets all the way down to whether it's an
array you're working with whether even a
class is a sub-child that goes all the
way up to the object and we can simply
do that in our code in the eclipse
and we'll just go ahead and add a new
class in there we'll call this one uh
Java there we go
oops Java and under Java we want to go
ahead and
oh create some of the similar stuff and
then I want to go back to my student I
took out the main and student just
because I don't want it to run the main
in there
and in here we're going to have system
out
um
we have instead of studying computers
Focus
on Java which is what we're doing right
now
and maybe we'll call this classroom and
then we can come down here we have our P
equals new computers well instead of new
computers we want our Java
and it's going to be a Java object
and we need to put our extends in up
here
extends in this case we came from
computers
so there's our initial thing and then we
have our last print in here
and of course if we run this now we'll
see that it should if I did everything
correctly come up and say enrolled and
simply learn studying computers focus on
Java and we have the enrolled which is
the parent to computers and then we have
under computers well we have student and
computers and then Java and so each one
of these classes just Cascades all the
way down and this is your multi-level
from your class A to class b to class C
and if you can have multi-level
inheritance we can also have a higher
archaeal inheritance where your
parent-child relationship the only
difference is here are multiple child
classes inherit from one parent class
and that is pretty uh we'll do another
class here if you remember correctly we
had student computers maybe from student
we'll have a set of computers we'll have
project management
project
management so you're studying your idol
and all your other classes in there for
Cascade and for doing agile programming
and in here we can do that it's just the
same as we did before we just have a
second child coming in from here and so
this would go ahead and extend extends
extends
student
and of course whatever subcategory you
have one in here for running this
and so for here we'd have like our void
studies in this case instead of studying
computers we're studying project
management project
management one of the other wonderful
classes it is taught from the simply
learned team
and run that and you can see right here
we have computers oops of course uh
instead of computers I meant to do
project
management there we go and we have to
also initiate it as a new
and then when we run here we can see
this we're enrolled in simply learn and
we're studying project management
and then finally there is the um the
hybrid the name itself explains it to us
the Hybrid inheritance can be a
combination of any of the three types of
inheritance supported in Java and so
maybe we already saw that because we
have our a and our B
if we flip back on over to our
Eclipse we have our student our student
now has a computers project management
so there's our um hierarchical and then
they're mixed because we also have the
Java which is an extension of the
computer and so we have multiple layers
there
so one of the issues that comes up with
inheritance in classes is what they call
the diamond problem
and in the diamond problem the Java
programming language does not support
multiple inheritance as it ends up with
serious ambiguity and that is where we
have D which inherits from both B and C
which might both inherit from a
uh this is the Daemon Factor because as
you start tracking your supers going up
which one are you actually looking at B
or C or a and that's why they call this
a diamond problem it comes up more than
you would think you get very complicated
structures and you realize oh I need to
have both sets of instructions come down
to whatever I'm working on and you can
see where that can become a problem
let us take a look at is a relation and
has a relation now these I mean they're
vocabulary but they're more of a concept
understanding how things fit together
and so we talk about is a relation when
a class inherits methods and members
from a different class then the
relationship is said to be is a relation
examples orange is a fruit
and oh let's just jump back on over here
and we'll make a
new
class and we'll call this class customer
so we're going to have our customers
oops
here we go if I can remember how to type
so we have a class customer and we have
gone ahead and our team in the back went
ahead and prepped this for us let's just
take a quick look though we got public
string names so it's accessed publicly
if you leave this out it'll
automatically be public because that's
the default and then we have our
customer and the string which is a name
and a string is a city and then when you
do a customer and you send it the name
of the city it will do this name equals
name in this city equals City we could
have easily done this private we have a
call into it to create it so it wouldn't
really matter too much whether we did it
private or public I would actually be
more likely to do it private
and for this example we'll go ahead and
create another class and we'll call this
Thor
we'll have our store class we have
customers and we have a store
and then we'll go ahead and
set up in here and this time we did do a
private we're going to create a list of
customer customers and then the store
list coming down and then this customer
customers and public list customers
a quick look at this is we did make this
one private which is nice because now it
can't be accessed externally except from
store and then the store has the public
list customers so we can send it a list
of customers and then it go ahead and
Returns the customers from that list and
then we add it to the store it sets the
customers in the store this doc
customers equals customers
one of the reasons we have the airlines
in here is I haven't compiled it so it
doesn't see the customers are part of
our package
and we'll get to that in just a moment
here
and then let's go ahead and create
another class we'll call this is a
relation
since that's what we're working on
and here's there is a relation setup
and we're just going to put this as the
main so you have your main in there and
then we went ahead and prepared a series
of customers
and we'll just call that customer C1
equals a new customer customer C2 equals
a new customer and we're just creating a
list here that's all we're doing
and if we're going to have a list then
we need to go ahead and create a list of
customers
and we'll just do that with a simple
list setup
and then we got to add those customers
into the list so let's go ahead and do
that
so breaking this down we have a customer
one which is Raju Bangalore Shiva hyper
bad Sachin Mumbai and so on and then we
just created a list of customers a new
array of lists and then we add in each
of those customers so now we have a nice
list of all our different customers in
here and then we want to go ahead and
create our store
and we'll put in store and it'll be a
fruit smoothies franchise I put down
fruit smoothies French
maybe that's not a good abbreviation
because you might think it's a French
instead of franchise there'll be a new
store and then we have our new store
which is
um in this case we're going to put in
that new store customers and if you
remember we went back here into store
let me just flip back on over there
it's going to take that list of
customers
and put that into this customer so now
the private list is going to equal that
list of customers
and then of course we can come in here
and we do public list it's going to
return that list of customers so we have
public assets here and this door you can
add public at the beginning
we'll go ahead and do that just to make
it clear is it public is what's going to
run on there and let's go back into our
is a relation
and I hope to go back to store I'm going
to go ahead and just change this to
customer list so here's our list
customer list and it's going to return
the customers from this selection from
our private variable
uh so we come into here
we can come down here and we'll go ahead
and put that in there we'll do a loop on
this we'll have a list customer and
we're going to create a list of our
customers from our fruit smoothies
franchise
and we'll get the customer list from
there
and then for a customer in the um in our
four customer CST in customer
we're going to go ahead and just print
that name out there
now at this point if you have an error
showing up here under list and also
underneath the arraylist depending on
how you did your install you might have
to go ahead and import those your
arraylist from your Java utility not a
big deal and then once we go ahead and
we have this all set up
you'll see here the compiler goes
through and then we have the name of the
customer City and then it just lists the
customers going down here
so when we talk about our relationship
of our fruit smoothies uh franchise and
customers the customers they are a
relationship directly to the French
smoothies franchise
now the second idea is it has a relation
and let's go ahead and take a look at
that and see how that differs
and we'll go ahead and create a um oh
let's see we had customers so let's do
um
and we'll call this one
um we're doing with smoothies so we'll
have
flavors our favorite we'll do favorite
flavors favorite
flavors for class very strange class
and the Sea and favorite flavors we'll
go ahead and give it a couple things to
look at we'll have a private
string and a name
and then we'll have a public
string
um
get flavor
there we go and that's just going to
return
we'll just have that return the name of
the flavor
there we go and then we want to go ahead
and create
one more class and this class will call
Hazard relation
foreign
you're guessing where we're going with
this let's go ahead and put some code in
here to make it work
and let's go back to our favorite
flavors and put in a Constructor so that
we can load the flavors and then I
return uh this name so we can return the
flavors we'll go back into hazard
relation
and let's just create a customer we'll
call it cust
our new customers Toby Marshall from
Mumbai and our favorite flavors are
strawberry banana and peanut butter I
don't know it's a strange concoction
and then we run a print line we're going
to print the customer name from
customers and the flavors get flavor
and so when we're looking at this what I
want you to be aware of is that neither
the flavors nor the customer are in the
same class they're not it's not an
actual relationship but they have a
relationship because we have Toby who
happens to like strawberry and peanut
butter
and if you remember just a quick note we
were looking at the diamond problem you
can create a class that then has these
two subclasses in and that's how you go
around the diamond problem is you don't
inherit but you create classes inside
the class you're working with
what is polymorphism according to
chemistry the term polymorphism can be
defined as the ability of any element or
compound to exist in multiple
crystalline forms this is called
polymorphism for example if you have the
carbon atom it can come out in different
forms in Coal graphite and diamond
what is polymorphism in Java similarly
in the terms of Java programming
language polymorphism is defined as the
ability of any object in class in a
class to perform a particular task in
multiple methods this is known as
polymorphism in Java we're going to open
up our Eclipse editor and we're going to
do some animal sounds with cows cats and
dogs just kind of a fun almost kids like
example of polymorphism and you can see
I already have my inheritance in here
let's go ahead and create a new
package and we'll call this polymorphism
just to keep it simple
and once we have our polymorphism in
there we're going to go ahead and add a
class in
and if you were doing
um an abstract class we could live with
those abstracts we're not going to
directly access it and we'll call it
animal sounds maybe we will we'll see
how we load the program up but we'll
call this animal sounds
and let's create a public it's not going
to return anything but we'll call it
sound
on here and we just want to go ahead and
have it do a system out print
with our system out print line we'll
just have it say animals make
different sounds
there we go
so yeah it's really simple and
straightforward we're just going to have
it print something out and if we're
going to do that let's go ahead and just
a good thing I didn't make it abstract
let's go ahead and just test it out and
see what it looks like and we'll do oh
we'll call it animal Main Animal Main
and in here let's go ahead and test out
what we just put together we'll do our
our static void main so it's going to
run on here and we'll create our animal
sounds
we'll call it animal because we don't
know what kind of animal this is we'll
call it new animal
sounds
and we'll just take that animal and I
like to
put in capitalize but usually we do this
lowercase there we go and we'll just
have our
animal
Dot
sound
and let's go ahead and run this and see
what comes out
we can see here animals make different
sounds okay that's not too exciting uh
so let's jump in there and let's say we
have
um in this case we're going to add in a
couple of different animals We'll add in
a
oh let's start with a cow yeah why not a
cow
so we'll have our cow in here we'll go
ahead and click ok
and now we have our cow class but a cow
doesn't just it makes different noises
but it actually uh makes this you know a
very clear noise so we'll go ahead and
give the cow a sound
and we'll have the cow say moo moo and
the cow is going to
extend
there's our
and we'll put in our extends animal
sounds and then I want to go back here
to our animal Main
and now we have a class cow so in our
animal main we want to do a cow
cow
equals new
cow
and once we've created the new cow we
also need to go ahead and have the cow
sounds
there we go
and we run this
you can see it comes out here and it
says the cow says moo moo so if we go
back to Cal we're just going to do this
real quick and let's say we just take
this out of here the public void sound
and then we're going to go into our
animal Main and run that
recompiles animals make different sounds
because it doesn't know what sound a cow
makes
so this is really Central to
polymorphism is we're taking something
going on in the um
in one setup that we've brought in and
extended from our animal sounds and
we've changed it to the cow says moo moo
and we can also add in multiple animals
in here we'll go ahead and just add in
one more animal I will call this one
we'll do a dog why not
uh so here comes in our dog
and of course we want the dog to
actually say something
and we'll have the dog uh go Bow Wow and
then we'll go back to our animal main we
have to create a dog
and we'll say cow
simply dog dog uppercase for the class
lowercase for the actual object
and then of course we need the dog to
make a sound so we'll go down here and
go dog Dot
sound
and when we run this as you expect the
it's going to compile it there we go
animals make a different sound the cow
says moo moo the dog says Bow Wow
characteristics of polymorphism the
functionality of a method behaves
differently in different situations the
behavior of a method is dependent on the
data polymorphism is mainly used to
implement inheritance as we saw we did
the extends with the animal sounds
polymorphism is mainly used to implement
inheritance it allows same name for a
member method in a class with different
types which will cover briefly in a
minute polymorphism supports implicit
type conversion
types of polymorphism there are
basically two types of polymorphism that
can be occurred in Java programming
language they are mentioned as follows
compile time polymorphism runtime
polymorphism compile time polymorphism
gets executed during the compilation
stage here the overloading method gets
resolved in compilation stage so when
you saw me run those in eclipse and it
went through the compile time thus
looking at all the different changes we
made to those classes that's what we're
talking about here is during compile
time in method overloading in Java the
process of method overloading is
achieved when a class has two or more
methods with same name but the specific
method is selected based on the number
of parameters declared we'll now execute
a program based on the functionality of
additional operator in a different
situation and let's flip back on over to
our Eclipse so in here I'm going to go
back under the dog and let me just
highlight this and we're going to do do
the same thing so you see right here it
says public void sound so this is
identical public void sound but instead
of sending uh nothing we're going to
send it a string we're going to call it
Angry now at this point you should note
that what if it's a happy dog I would
have to add an if then if the string
angry said happy then we'd print happy
or something else but we're just keeping
it simple so we've entered another sound
identical to the first but we've added
string angry to it and this is going to
print out the dog says growl growl now
if we go back to our animal Main
and here's our dog same dog uh same
sound
but now we're going to add a string in
here
and we put that string in here we'll go
ahead and just call it Angry it doesn't
really matter what string you put in
here because we haven't sorted out what
the string means for now it just says
growl growl it's going to recompile it
so remember this is a polymorphism
during compile time and here we have it
the dog says growl growl so Doug says
Bow Wow and then the angry dog says
growl growl so there's another thing
called Operator overloading Operator
overloading is not supported in Java the
authors of java wanted to keep the
language less complicated explaining
operator overloading it basically is a
way of bundling operations into the call
statement and user procedures it's so
that it looks like a math on a paper you
have a plus add B plus C kind of thing
and it's all wrapped up in your call to
another statement this just gets
confusing it really isn't necessary so
the driver developers decided not to put
it in there so runtime polymorphism in
Java programming language runtime
polymorphism gets handled during the
program execution stage here the
overwriting method gets resolved in
execution
so far we've talked about compile time
polymorphism as you saw in the program
we just wrote when it's compiling it
does the extend and figures out which
overload method to use on there
in runtime polymorphism method
overriding in Java the method overriding
is a procedure where trial class is
allowed to implement a specific class
that is already provided in the parent
class
for runtime compilation code or
polymorphism we need to go and introduce
the super keyword now from inheritance
you should remember that we can look at
Super from before but we're going to use
it slightly different it's kind of doing
the same thing as when we did The
Inheritance but we're doing like what
they call an override during run time so
the term super is predefined keyword in
Java that is used to refer the immediate
parent class object or method defined in
the program in this procedure whenever
you create an instance of subclass then
automatically an instance a parent
classes also created that will be
implicitly referred by the super
reference variable so going back into
our animal sounds let's go in here to
dog
and if we add a super Dot sound
in here this is going to reference
whatever our extend is because we
extends the dog extends animal sounds
and so here's our super dot sound and if
we go ahead and apple run and compile
this
and you can see here that it comes down
and says the dog says growl growl
because that's what we had it system out
print line two and then the super
animals make different sounds and so if
we go back to our animal main this is
what it's calling right here it's going
back into sound under the animal Mains
and it's printing out or doing whatever
it does here at this point we usually
have it return something so you can look
up whatever the original class was using
so getting back to these two setups
whether you're using the super to use a
runtime polymorphism because that's
what's happening during run time versus
compile time polymorphism during compile
time polymorphism method call is handled
by the compiler itself so the program
maybe take a second more to compile but
it runs faster in the runtime the method
call cannot be handled by compiler in
the execution stage so if you have any
errors it's not going to show up either
during the compile time we have compile
time polymorphism is less flexible as it
needs handle all method calls in compile
time so you really in runtime
polymorphism your it exhibits higher
flexibility as a method call gets
handled at runtime coming in the
execution period for compile time
polymorphism is less that's what I was
just talking about it compiles it so the
compiling takes maybe a little bit more
but if you're executing the same program
over and over and over again once it's
distributed it's going to run faster
then of course with the runtime
polymorphism the execution period for
runtime polymorphism takes longer it's
just a little bit more usually in most
programs you don't notice this but if
you're executing the same script A
Thousand Times suddenly that 0.01 second
is a lot more it suddenly is adding up a
second each time it goes through the
Thousand iterations uh then with the
compile time polymorphism integrating
the right method call with the right
method is done in compile time and of
course in runtime integrating the right
method call with the right method is
done in runtime again it's another delay
because it has to figure out what it's
doing it's not already pre-mapped out
and finally compile time polymorphism
occurs during method overloading and
operator overloading where runtime
polymorphism occurs during the method
overwriting advantages of polymorphism
programmers code can be reused via
polymorphism a number one goal of a
programmer is to reuse the code as much
as possible so you're not Reinventing
the will over and over again
advantages of polymorphism supports
single variable name for multiple data
types reduces coupling between different
functionalities
and some of the disadvantages of
polymorphism that can come up is that
polymorphism ends up raising performance
issues in real time you can see whereas
you're loading all these different
things you might end up creating Loops
you didn't know you were doing
polymorphism reduces readability of the
code sometimes your actual code
everything you look at in Java is
polymorphism all based on a primary
object so you could have a very
complicated setup and then it actually
is very easy to read when you actually
put it your final variable in there but
when you're going through lines and
lines of code it can be really hard to
figure out what's going on as you Loop
through all these different inherited
modules or classes programmers find
polymorphism difficult to implement just
depends the more you use it the easier
it is
say you had to print hello all three
times you could do it by typing hello
all in the system three times but what
if you had to print a hundred times what
if you had to print a thousand times the
solution to this is the use of looping
statements
there are three types of Loops that are
used in Java for Noob while loop two
while loop when some condition evaluates
to be true these Loops execute a set of
instructions what exactly is a Java
collection a Java collection can be
generally defined as a collective unit
of objects in the form of a group for
example a group of numbers of integer
data type Etc moving forward we enter
into our next topic where we Face the
Java Collections framework this will
help us understand Java Collections in a
little more detailed way
a Java collection framework represents a
unified architecture for storing and
manipulating a group of objects its
architecture includes the following
an interface a class and the Java
Collections API to understand these in a
much better way we shall now go through
the Java Collections hierarchy the
utility package java.utel contains all
the classes and interfaces that are
required by a collection framework The
Collection framework contains an
interface named as an iterable interface
which provides the iterator to iterate
through all the collections
this interface can be extended by the
main collection interface which acts as
the route for the collection framework
all the collections extend this
collection interface they by extending
the properties of the iterator and the
methods of this interface the following
figure illustrates the hierarchy of
collection framework out of the
complexities we have the interface and
the classes as the major part of the
collections now let us understand each
one of them at one step at a time as you
can see on the screen we have the
iterable class which is implemented by
The Collection class and this particular
collection class is further implemented
by list queue and set and moving ahead
we have the following classes which have
implemented the list queue and set
classes in the list we have arraylist
linked list Vector stack and on the
other hand on the Queue we have priority
queue DQ and array DQ and finally on the
set we have the hash set lint hash set
sorted set reset Etc now moving further
we will enter our first Java collection
which is none other than the interface
so the first one is an interface an
interface can have methods and variables
but the methods declared in an interface
are by default abstract that is only the
method signature is available not the
body
interfaces specify what a class must do
and not how it must do it is a blueprint
of a class now a Java collection is a
foundation to the Java Collections
framework note that all the collection
interfaces are generic for example
public interface collection is the
Syntax for the generics and when we
declare the collection we should use it
to specify the type of object which it
can contain it helps in reducing runtime
Errors By type checking the objects at
compile time to keep the number of core
collections interface manageable the
Java platform doesn't provide separate
interfaces for each variant of each
collection type if an unsupported
operation is invoked a collection
implementation throws an unsupported
operation exception now under the
collection interface we have many
interfaces that we should use for data
manipulation a few of the major ones are
set interface list interface DQ
interface queue interface map interface
sorted set interface sorted map
interface don't worry those are a lot of
interfaces but we will discuss each one
of them in a detailed way along with a
practical example for a better
understanding so the first one in the
docket is the set interface a set is a
collection that cannot contain any
duplicate elements
this interface model is the mathematical
set abstraction and is used to represent
sets such as a deck of cards
the Java platform contains three general
purpose set implementations the hash set
tree set and linked hash set the set
interface does not allow random access
to an element in the collection you can
use an iterator for each Loop to
Traverse elements of a set now for a
better understanding let us go through a
practical example I have prepared a code
document for all the programs that I am
going to explain to just save time you
can always have access to it all you
need to do is just ask for it in the
comment section below so you can see on
my screen we have an example for set
interface in this particular example we
are going to store the elements 21 23 43
53 22 and 65. so let's try to execute
this program and see the output
so you can see the elements stored in
the set interface are 65 2153 22 and
23.43 so the sorted set is here which is
the 21 22 23 43 53 and 65 and the first
element being 21 and the last element
being 65. so this is how the set
interface practically works now let's
move ahead into our next type of
interface which is none other than the
list interface so what exactly is a list
interface the list interface is an
ordered collection that can contain
duplicate elements you can access any
element from its index the list is more
likely an array with Dynamic limb the
list is one of the most used collection
types an arraylist and linked list are
the implementation classes or the list
interface
the list interface provides useful
methods to add an element at a specific
index to remove and replace elements
based on the index and to get a sub list
using the index for a better
understanding let's check out an example
so this particular program is based on
list interface so we are going to add in
three names which are David John and
Stacy into our list and also we have a
fourth edition which is Stacy again
just to check if the statement is true
which says list interface also allows
duplicate elements unlike the set
interface so let's try to run this
program and see the output
so you can see the program got
successfully executed and the names
David John and Stacy are added into the
list now let's come back to our program
and remove this comment and try to run
again and check if the fourth element
which is the duplicate of the third
Stacy will be added into the list or not
so as you can see the program got
successfully executed and the fourth
element which is Stacy the duplication
of the first one got successfully
inserted into the list
so this is how the list interface works
now let's move ahead into our next type
of interface which is the queue
interface so what exactly is a queue
interface Q is a collection used to hold
multiple elements prior to processing
besides basic collection operations a
queue provides additional insertion
extraction and inspection operations
cues typically but do not necessarily
order elements in the fifo OR first in
first out manner among the exceptions
are priority cues which are the elements
according to a supplied comparator or
the elements in natural ordering
whatever the ordering used the head of
the queue is the element that would be
removed by a call to remove our pole in
a first and first out queue all new
elements are inserted at the tail of the
queue now for a better understanding
let's go through a practical example so
as you can see the program on my screen
is an example for queue interface so in
this particular queue we are going to
store the names of fruits apple mango
grapes and banana and apple being the
head of the queue and banana being the
tail of the queue now let's try to
execute this program and see the output
so we are also going to count the size
of the queue which is 4 basically in the
first after that we are going to remove
the element grapes from the queue so the
command SQ dot remove the element name
so after that the grapes element has
been removed from our queue we have the
latest size of the queue as three now
after that we are also going to check if
the element apple is included in the
queue or not so for that statement yes
the element apple is included in the
queue and the result is true so this is
how the queues work and let's move
further and in the next phase we have
the DQ interface so what exactly is a DQ
interface
so a linear collection that supports
element insertion and removal at both
the ends is called as a DQ interface the
name DQ is short for double ended queue
and is usually pronounced as deck most
DQ implementations place no fixed limits
on the number of elements they may
contain but this interface supports
capacity restricted dqs as well as those
with no fixed size limit this interface
defines methods to access the elements
at both the ends of the DQ
methods are provided to insert remove
and examine the element for a better
understanding let's check out an example
so you can see on my screen we have a
program for DQ interface so here we are
going to add in some elements into our
DQ and then also try to remove the first
element and print the updated DQ now
let's try to execute this program and
see the output
so as you can see the program got
successfully executed and the elements
which we try to push into the DQ are 50
to 10 and 21 52 is being the first
element and the 21 is being the last
element so we try to remove the first
element which is the 52 so after that
the updated DQ is having two elements
which are 10 and 21. so this is how the
eqs work now let's move ahead and learn
our next type of interface which is the
map interface so what exactly is a map
interface a Java map is an object that
Maps Keys along with its values a map
cannot contain duplicate Keys each key
can map to at most one value
the Java platform contains three general
purpose map implementations which are
the hashmap free map and linked hash map
the basic operations of a map are
contains key contains value size and is
empty for a better understanding let us
check out an example so this particular
example on my screen is an example for
map interface here we are going to add
three elements and map them as one as
Cricut 2s hockey and 3s archery
now let us execute this program and see
the output
so you can see the program got
successfully executed and the elements
are mapped with their keys and the
element Cricket is mapped with the key
one and similarly hockey with key 2 and
rcd with K3
so this is how the map interfaces work
now let's move further into our next
type of interface which is the sorted
set interface so what exactly is a
sorted set interface so a sorted set is
a set that maintains its elements in
ascending order
several additional operations are
provided to take advantage of the
ordering sorted sets are usually used
for naturally ordered sets such as word
list and membership roles
for a better understanding let's check
out an example based on sorted set
interface
so you can see the program on my screen
is an example for sorted set interface
so here we are going to add in Bob Sean
and Jennifer into our set and we are
going to print the same let's try to
execute this program and see the output
so you can see the program was
successfully executed and we have our
elements printed in the sorted set and
you can see the names have been arranged
in the form of ascending order according
to the alphabets which have started in
the first position so this is exactly
how the set interface works
so the last one in the interfaces is the
sorted map interface a map that
maintains its mapping and an ascending
key order
this is the map analog of assorted set
the sorted maps are used for naturally
ordered collections of key value pairs
such as dictionaries and telephone
directories now for a better
understanding let's check out an example
based on map interface or sorted map
interface so you can see the program on
my screen is an example for sorted map
interface so here we are going to add in
the elements John moly Aaron and Daisy
into the map interface now along with
the names we also have their aggregate
switches 76.5 for John 87.3 for Mali and
78.2 for Aaron and for Daisy we have
73.4 now finally we are going to fetch
the data of Molly which is the aggregate
of Molly now let's try to execute this
program and see the output
so you can see the program got
successfully executed and Molly's
aggregate is 87.3 so this is how the map
interfaces work now let's move ahead
into our next topic which is the Java
collection classes so now that we have
finished the Java collection interfaces
let us have a quick understanding of
java interface methods so the first
method is the add method the add method
is used to add an object to the
collection and next is the ease anti
method this method returns to true if
the collection contains no elements
followed by that we have the clear
method and this method is used to remove
all the elements from The Collection
followed by that we have the remove
method this method is used to remove the
given object from the collection if
there are duplicate values then this
method removes the first occurrence of
the object next to the remove method we
have the size method so the size method
is used to return the number of elements
in the collection so after the size
method we have the stream method the
stream method is used to return a
sequential stream with this collection
as its source so the next method we have
is the two array method so the two array
method is used to return an array
containing all the elements in this
collection
followed by that we have the hash code
method this method is used to return the
hash code value for this collection next
the equals method the equals method is
used to compare the specified object
with the remaining elements in the
collection followed by that we have the
iterator method so the iterator method
is used as an iterator over the elements
of the particular collection and finally
we have the contains method so the
contains method returns true if a
specified element is existing in the
collection and false if it is not
present so with this we finish the
collection interface and collection
interface methods now we will move ahead
into our next topic which is none other
than the Java collection classes so what
exactly is a class A Class is a
user-defined blueprint or prototype from
which objects are created it represents
a set of properties or methods that are
common to all the objects of one type
now start up with the first one which is
the hash set class so the Java hash set
is a basic implementation of the set
interface that is backed up by the hash
map it makes no guarantee for the
iteration order of the set and permits
null elements as well
so this class office constant Time
Performance for basic operations such as
ADD remove contains and size assuming
the hash function disperses the elements
properly among the buckets we can set
the initial capacity and load factor for
this collection the load factor is a
measure of how full the hash map is
allowed to get before its capacity is
automatically increased for a better
understanding let's go through an
example so on my screen you can see a
program which is an example for hash set
classes so inside this we are going to
store some names which are the names of
the manufacturers of bikes along with
null values so we have added in two null
values to just check if it allows two
null values at once so basically it only
should allow one null value so let's
check out how does it perform
so you can see the program was
successfully executed and the null value
is stored only once that too in the
first location
so this is how the hash set classes work
moving further we will deal with the
next type of class which is the three
set class
so a tree set class is a navigable set
implementation based on a tree map the
elements are ordered using their natural
ordering or by comparator provided at
set creation time depending on which
Constructor is being used this
implementation provides guaranteed log
time cost for the basic operations such
as ADD remove and contains note that the
ordering maintained by a set whether or
not an explicit comparator is provided
must be consistent with equals if it is
to correctly implement the set interface
now to understand in a much better way
let us go through an example now we are
going to add in some numbers into the
tree set using the add method now let's
execute this code and see the output
so you can see the numbers are added
into the preset and the numbers are
ordered in ascending order which is 0 18
88 748
983 8476.
now let's move further into our next
type of class which is the arraylist
class
so add a list in Java is a resizable
array that is an implementation of list
interface that allows null elements so
in this class we have three types of
arrays which are one dimensional arrays
two dimensional arrays and
three-dimensional arrays now let's check
out the one-dimensional array
so a one-dimensional array looks similar
to this where we have the array index
and the element present in the array so
here our indexes are a0123 and 4 and the
elements which are shown here to
understand one dimensional arrays in a
much better way let's go through a
sample program so you can see the
program written on my screen is an
example for one-dimensional array and we
are going to store the elements 10 20
and 30 into my array a
so you can see the program has been
successfully executed and the elements
have been added into my one-dimensional
array moving further we will discuss the
two dimensional arrays the two
dimensional arrays are completely
similar to one-dimensional array but the
only difference is the index numbers
earlier we had index number but now we
have index numbers now using these index
numbers we can represent the elements in
a matrix form
so to understand this in a much better
way let's go through a sample code
so you can see this particular program
in my screen is an example for
two-dimensional arrays so here we are
going to add in elements 1 2 3 and 4 in
The Matrix form and we are going to use
two for Loops to print that now let's
execute this program and see the output
so you can see we have the elements one
two three and four and the elements are
printed in The Matrix form add the array
index location 0 0 we have 1 0 1 we have
two and one zero we have three and one
one we have four so this is how the two
dimensional arrays work and finally
let's deal with the third type of array
which is the multi-dimensional or three
dimensional array so you can see the
three-dimensional area is completely
similar or a little bit similar to the
two-dimensional array but the only
difference is we have a third Vector
here so next up we have the linked list
linked lists also come under Java
collection classes
there are three types of linked lists
which are single linkless doubly linked
list and circular linked list now let's
check out each one of those so the first
one is the single linked list so you can
see in a singly linked list each memory
segment is divided into two parts so the
first half of the memory location is
given for the element and the second
half of the memory location is dedicated
for the address so this particular
address is used to point to the next
element or the next memory allocation
which stores the second element
similarly the third so this is how the
singly linked list works so the last
memory allocation is called as tail and
the last address will not store nothing
but null which indicates the end of the
single linked list now to understand
singly linked list in a much better way
let's try to execute a sample program
so you can see the program on my screen
is an example for singly Linked list now
we are going to add in the elements one
two three and four in the form of a
singly linked list now let's try to
execute this program and see the output
so you can see in the program got
successfully executed and the elements
are one two three and four now let's
move further and try to learn the next
type of linked list which is the doubly
linked list
so the doubly linked list is completely
similar to that of the singly linked
list but the only difference is we have
two address locations so the first
address location of the head stores null
and the last address location of the
tail stores null which indicate the
start and end of the doubly linked list
respectively so here in the second
memory location you have two addresses
so the first address points to the
previous element and the next address
points to the next element so to
understand doubly linked lists in a much
better way let's try to execute a sample
program
so as you can see the program on my
screen is an example for w linked list
and we have the node which has the data
and previous address next address now
let's try to execute this program and
see the output and the elements that we
are going to store in this particular
doubly linked list are one two three
four and five
so as you can see the program got
successfully executed and the nodes are
one two three and four and five so this
is how the W link list work and now
let's check out the third type of linked
list which is the circular linked list
so there are similarities between the
previous linked list and the circular
linked list
so the circular linked list makes it
circular based on the last address
location so this particular address
location points to the first element
back again so this is how it becomes a
circular linked list so to understand
this in a much better way let's check
out an example for it
so you can see
the program on my screen is an example
for circular linked list
now let's try to execute this and see
the output so you can see we have
successfully included one two three four
five six and seven and eight into our
circular linked list and they are
printed on the screen so this is how the
circular link list work so moving
further we will try to understand the
next type of classes in Java Collections
which is the hashmap class so hash table
is based on the implementation of map
interface
this implementation provides all the
optional map operations and permits null
values and the null key hashmap class is
roughly equivalent to Hash table except
that it has unsynchronized and permits
null this class makes no guarantee for
the order of the map now for a better
understanding let's go through a sample
program
so this particular program on my screen
is an example for hashmap class so here
we are trying to load the data which is
the name of the manufacturer and their
bike so let's execute this program and
see the output so you can see the
program got successfully executed and we
have the manufacturer and their made
bikes now moving further we will deal
with the next type of class in Java
collection which is the tree map class
so the tree map is based on navigable
map implementation the map is sorted
according to the Natural ordering of its
case or by a comparator provided at map
creation time depending on the
Constructor used now let's check out an
example for better understanding
so you can see the program written on my
screen is an example for train map class
so we have the role numbers and the
names of students here now let's try to
execute this program and see the output
so the program got successfully executed
and the result has been printed on the
output console
so we have the roll numbers of the
students and their names Amber
James wallet and Reynolds along with
their respective IDs so now with this we
complete the Java Collections classes
Now we move into our next topic which is
the collection API algorithms so the
first one is sorting sorting does the
job of ascending and descending numbers
based on the algorithm written by the
user for a simple example we shall
consider the bubble sort algorithm for
this one so you can see on my screen we
have an example for bubble sort
algorithm so we have the elements 289 39
48 6 28 1 2 and 33 which are ordered in
a unorderly manner let's try to execute
this program and order them
so you can see array before bubble sort
is 289 38 48 similarly 33 and after the
bubble sort we have the sorted array
which is 1 2 6 28 33 39 48 and 289 so
this is how the bubble sort works now
let's move further and understand the
next type of API which is the shuffling
algorithm so the shuffling algorithms
are designed to destroy the current
Arrangements they are employed on
creating Randomness in the list so for a
better understanding let's check out an
example so you can see the program
written on my screen is an example for
Shuffle algorithm so we have an array
which has the elements completely sorted
in ascending order which is 10 to 100.
now when we run the shuffle algorithm
these elements will be completely
shuffled according to a random order now
let's try to execute this program and
see the output so you can see the
elements which were in an ascending
order are now completely in Disorder so
this is how the shuffling algorithm
works now let's move further and
understand the next type of algorithm
which is the searching algorithm
searching algorithm is employed to
search an element in the list or array
based on the type of searching mechanism
used now for example let's use the
binary search now you can see a program
on my screen which is an example for
binary search so we have the elements 1
2 3 4 and 5 in our array now what we are
going to do is search for the element or
the key element to in our array using
the binary search algorithm now let's
execute this program and see the output
now you can see the program got
successfully executed and the output
says the element which you are looking
for is found in the index location 1. so
this is how the binary search algorithm
works now let's move further and
understand the next type of algorithm
which is the composition algorithm so
the definition says the frequency and
distance algorithms test some aspect of
composition of one or more collections
so the frequency counts the number of
times the specified element occurs in
this specified collection so the
disjoint determines whether two
collections are disjoint that is whether
they contain no element in common or not
now to understand it in a much better
way let's go through an example so you
can see on my screen there is an example
for composition now let's run this
program and say the output
so you can see the program was
successfully executed and
the elements are completely disjoint now
moving further we will enter into our
next topic which is based on the
benefits of Java Collections so there
are various benefits of Java Collections
out of those the major benefits are
software or code reusability so the Java
Collections enable code reusability to
save time followed by that the ease of
Designing apis so the next two ease of
Designing apis we have the Simplicity in
learning and using apis and finally
increased speed in programming so these
were the major benefits of Java
Collections what is an exception
so an exception is defined as an event
that arises due to an unexpected input
or logical failure in the program this
may not be considered merely as an error
but it surely does impact the normal
functioning of the program segment
now these types of exceptions are
resolved by the most efficient mechanism
called exception handling
exception handling is not any rocket
science but a simple mechanism that
drives the compiler to the next
statement by making the compiler
understand that the input obtained or
the malfunction that arise is just an
unexpected or an unnecessary event which
can be ignored by sending the user with
a relevant message about the exception
errors
for a better understanding let us go
through a small example
so as you can see on our screen we have
typed in a program so according to this
program we are going to access a file
called data.txt from the C drive so this
particular data.txt is not really
existing in the C drive so when we run
this program we will face an exception
that says file is not found so let's try
to run this program and see
so as expected so when we run this
program we get that this particular file
what you're looking for which is
data.txt is not found or in other words
it is not present in the specified
location so this is how the exceptions
work in Java now followed by this we
will move ahead into our next topic
where we will understand the meaning of
an error
so what exactly is an error
so here we are trying to learn about the
error just to eliminate the ambiguity
between an exception and an error also
further we will discuss the major
differences between them but now let us
go through the term error first unlike
an exception an error poses a serious
Potential Threat to the program or
sometimes it is even capable enough to
collapse an entire software
so basically an error is occurred due to
syntax error or some logical error while
coding
so we have a sound understanding of an
exception and an error now let us move
further and learn the differences
between the both
error versus exception
so some of the major differences between
an error and an exception are an error
is classified under unchecked type
whereas on the other hand an exception
is classified under both checked and
unchecked
the next difference is if a program
encounters an error then it turns out to
be completely irrecoverable until the
error is resolved whereas in the case of
an exception if the program encounters
an exception then the program is easily
recoverable
followed by that the third difference is
an error belongs to the package called
java.lang dot error on the other hand an
exception belongs to the class
java.lang dot exception
the fourth difference says that an error
can be encountered only during the
program's runtime whereas on the other
hand an exception can be expected both
during the runtime as well as the
compile time
finally we will mention an example for
both an error and an exception
we can consider the input and output
error as an example for error and on the
other hand we can consider divide by
zero exception as an example for
exception
so with the differences discussed we
will now move ahead and have a look at
the exception hierarchy in Java
the hierarchy of errors and exceptions
is really simple
there is one root class called the
throwable now the throwable class is
basically inherited from object which
comes from the superior root called
java.lank now the throwable class is
inherited by two chart classes which are
none other than the error and an
exception further an error is inherited
by different types of Errors for example
jvm or Java virtual machine error memory
error and also in some cases some of the
errors are caused by the incompatibility
of the IDE or the framework which are
you are using
next up is the exception now the
exception is inherited by few more
exceptions which are mentioned as below
the exceptions can be input output
exception SQL exception class node found
exception runtime exception and many
more further the runtime exception is
inherited by some more which are the
automatic exception number format
exception Etc
now that we have a good understanding of
the exception hierarchy let us move
ahead and check the differences between
checked and unchecked exceptions
so the first one which is the checked
exceptions
these are really simple exceptions and
can be defined as follows
an exception that pops up during the
compile time is called as the checked
exception it is not serious and is
completely ignorable
followed by the checked exceptions we
have the unchecked exceptions on the
other hand the unchecked exceptions are
defined as an exception that pops up
during the runtime is called as the
unchecked exception
it is considered as serious and is
caused by logical errors
so to understand checked exceptions in a
much better way we shall go through an
example
so this particular example is based on
checked exceptions
so basically we have a text document
called data.phxt in the location
documents username users C drive
so this particular data file has five
lines so we are going to access the
starting three lines of this particular
file and basically when we try to run
this program we will face some of the
major exceptions which are unhandled
exception type input output
and again the same exception and here
file not sound exception so these
exceptions are errors
so to understand checked exceptions in a
much better way we shall go through an
example
so this particular code segment here is
trying to read a document from C drive
which is data.pxt
so this particular data.txt has five
lines of text
so what we are going to do here is try
to type in a for Loop and try to read
the first three lines of this particular
document so basically when we run this
program
we will face some of the exceptions
called file not found exception input
output exception and another input
output exception
so we can resolve this particular
program with small modifications to the
program and then if we run this program
then we can find our lines
so the lines in the data.txt file over
hello welcome to Simply learn we are an
e-learning company our certification is
recognized by Major mnc's enroll and
so this particular example was for
checked exceptions
now we will also go through an example
for unchecked except ions to learn it in
a much better way
so this particular example is based on
unchecked exceptions this particular
program is really simple we have an
integer type array
Elements which are 1 2 3 4 5 6 7 8 9 and
10. so what we are going to do is we are
going to access the 11th element of the
array which is not really present so
this should throw an exception
so array index out of bond exception is
one of the example for unchecked
exception
exceptions so with this we will move
ahead into our next topic
now we know what exactly are checked and
unchecked exceptions moving further we
will slowly dive into the process of
exception handling in the process of
exception handling we have five major
keywords
so we will learn each one of them as
follows
so the first one is try keyword the try
keyword is used to specify the exception
block
in a program when you specifically type
the exception that you might expect to
face in your program then you describe
it using the keyword try followed by
that the solution for that exception
will be defined in the catch below so
the cash block is used to specify the
solution
finally the finally is a keyword which
has the executable code which is
completely mandatory for a program to
execute followed by finally we have a
throw keyword the throw keyword
basically throws the exception when it
is found during the runtime
followed by that we have the throws the
throws keyword is used to dictionary the
exception so basically this is where you
declare the kind of exception you are
going to expect a new program sometimes
you might try to type in your user
defined exception or sometimes you might
type in the exception that is default in
its way
or in other words it might be system
defined
now that we have a good understanding of
the implementation of the exception
handling in Java let us move further and
solve some of the most frequently faced
exceptions in Java
so with this we enter into our seventh
topic which is common exceptions faced
in Java
so the first one is the array index out
of bound
so if you try to store a value in an
array or try to access an element in an
array which has an address exceeding the
address maximum location value then this
particular exception is thrown so to
understand this particular exception let
us go through a crack practical example
so as you can see on our screen we
will be integer data type so we are
going to store the values 10 20 30 40
and 50 in five different locations of
the array which is 0 1 2 3 and 4. now we
are going to provide the address of the
required element so during that process
we are going to specify one location
which is more than the maximum location
of the array so here the maximum
location of the array is for and if we
try to provide the location file then
this program should throw us an
exception so let's try to run this
program and see the output
so as you can see we have our array here
now the program is requesting us to
provide the address of the element
required so what if we provide a file
so now it should throw an exception
so this exception is the array indexed
out of bound exception now let us try to
run this program and again and specify
the proper address
so for this time let's provide 4 and see
if we get the output so as you can see
at the address location we have The
Element 50 as we have defined here
now our program is running perfectly all
right
now let's move ahead into the next type
of exception which is none other than
our
null pointer exception
if you try to perform an operation on a
null value this particular exception is
thrown so might be a little ambiguous to
understand this particular exception in
a perfect way let us go through a
practical example
so here on your screen you can see that
we have a program and inside the program
we have a string called SDR which stores
a text called simply learning followed
by that we have another string type
which stores a null value which is ABC
as you can see ABC is equals to null now
here we are going to access the value of
ABC so here the string ABC has a null
value and we are trying to access it so
this particular code segment should
throw an exception called null pointer
exception now let's try to execute this
code
as you can see it has thrown an
exception called the null quantum
so whenever in Java if you
if the null values then the null pointer
exception is thrown
followed by this we have the next type
of the common exception which is the
number format
if you try to store a value with wrong
formatting then this particular
exception is thrown
not to understand this in a much better
way let us try to execute a sample
program
so here on the screen we have a sample
program where we are trying to cast a
string into integer so this kind of
operation should throw an exception
so as you can see the program has been
successfully compiled and we have our
exception here which says number format
exception
followed by this we have another most
commonly faced exception which is the
automatic expression
if you try to divide a number by C this
particular exception is strong now let
us go through a practical example
now you can see we have a sample program
on a screen where we have two particular
numbers and one is equals to zero and N2
is equals to 100. so here what we are
trying to do is we are going to divide
the number 100 by 0 which is practically
not possible so when we try to execute
this particular program then we should
be getting an exception that says you
cannot divide a number by saying
so there you have your personalized
message which says the divider cannot be
zero try a different number so this is
how the automatic exceptions work
so with this we have come to our last
topic which is the best practices to be
followed while working with exceptions
in Java
so the first one is use exceptions
conservatively
so exceptions have proven that they can
be costly if used recklessly or
unnecessary so it's better to use
Boolean values to indicate successful
implementation of smaller operations for
example if you specify a particular
operation and it successfully gets
executed then you can just notify the
user by specifying a Boolean value which
can be one or in the case of failure you
can just specify the number zero
next after that we have the customized
exceptions
is a very good practice of customizing
your exceptions in the design time
rather than planning them on the go
so in other words we can consider this
as if you're planning to design a
software then in that particular stage
itself you must also evaluate the kind
of exceptions you might face on the
process of Designing so tomorrow if you
completely design a software and
suddenly an exception is fog in your
head then designing or including that
particular exception in your furniture
software might be difficult so it's
better you start planning your
exceptions
followed by that we have exception
logging keep track of the exceptions and
this process comes handy as the user
user stands why exactly a particular
exception has bought them
followed by that we have early through
and early field the next section should
be thrown as early as possible and
should be resolved in the same pace
and then we have the closing resources
since exceptions halt the complete
program we must make sure that the
system resources are shut so as to save
the resources Java projects so in our
agenda we will get started with the top
10 project ideas for 2022 followed by
that we will learn the core Java
projects so we will go through some
exciting core Java projects for example
online banking system and ATM Java
project and many more followed by the
core Java projects we will create an
advanced Java project along with string
framework so I hope I made myself clear
with the agenda now without further Ado
let's get started with Java projects for
2022
over to our experts
the top 10 Java project ideas
so the first project that we will deal
today is the Online Career management
system
so this particular project motto is to
deal with the career management system
the system will be used for day-to-day
activities like buy written booking
delivery and non-delivery and self pick
up Etc
it is not easy to build this particular
project all alone as the technicality of
the project is a little complex for a
single programmer I would suggest you
that you get a team with you and also
look out for some Automation in the
process by developing the relevant
software robotic process automation is
the new normal in today's life the web
enabled interface allows the user to
login from anywhere in the world and
track their career and also view the
customer rating
the system is designed to integrate with
financial accounting to eliminate
duplication of data entry and is also
scalable to grow along with your company
the system needs to be built with
user-friendly screens rich in
functionality and features and finally
the major part it should maintain a high
level of data integrity
so with that abstract disgust now let's
look into the features offered by this
particular online Courier Service as
discussed in the abstract this
particular project should be providing
the features of order and dispatch of
the product information regarding the
customer delivery executive and followed
by the delivery executor we should be
also having a payment window which
manages the accounts and build reports
so having said that let's now move into
the software requirements
so the software used in this particular
project is the programming language
status Java database is the Microsoft
Access and some convenient RPA tools and
finally the IDE the ID for this can be
anyone which has a good support for Java
the most preferable one would be the
eclipse and then comes the IntelliJ
netbeans and many more now creating this
kind of a project will give you a
valuable experience based on building a
fully fledged e-commerce website or an
application I mean this is how the worst
leading applications like Amazon
flipkarts and Mato Etc are basically
planned and have reached Greater Heights
today this kind of project on your
resume could make a huge difference and
who knows tomorrow you might even get
into one of those companies and start
working on their projects or build a
company of your own
followed by the online Courier system we
have the online voting system
now thinking apart from getting a job or
starting a new company of your own this
is something that we all need today in
this pandemic situation especially in
the current scenario the internet has
brought all the ease to our living room
it has replaced physical banking to
internet banking ordering food online
buying movie tickets buying clothes and
household items to consult your doctor
for minor issues bill payments and many
more yet for quite a long time going to
polling booth and standing in a loan
queue to cast a vote has been persistent
and it has been challenging for the
government to motivate common people to
participate in the election system and
cast their vote just because there is no
other way to do such thing as such an
online voting system but all the credit
can be achieved by software Engineers
who can make it possible soon for
everyone to cast their oat to their
respective candidate as their own choice
with an unmatchable ease
this can be done just by click on their
fingers this is an advanced Java project
developed to show online voting
functionality followed by the abstract
we will get into the technicality of
this particular project so the first
phase of this particular project has the
admin phase where the admin has the
right to manage the candidates manage
the voters and their profiles and
passwords and finally election results
followed by the Admin we have the voter
or the user of this particular
application the voter or the user gets
to register himself or herself into the
application followed by that he can use
the login and logout options and next we
have the profile and password
managements so followed by that we have
the option to choose the positions to
vote and finally to cast the vote now
this particular project is an advanced
level Java project developed to show
online voting functionality it showcases
the use of java servlets HTML and CSS
again coming into the IDE the ID for
this can be anyone who has good support
for Java the most preferable one would
be eclipse and IntelliJ
followed by the online voting system we
will now continue with the online
Healthcare Management
named as the corporate Medicare
management this e-healthcare management
system is a web-based project developed
in Java the main aim of this particular
project is to provide effective
management of data related to staff and
patients in hospitals or clinics the
features offered by this particular
project should be as follows it should
optimize web occupation the project
should improve the use of operation
theaters awarding the cancellation of
operations to know how much emergencies
affect the administration of the
hospital departments or Services which
include cancellation of operations
to optimize the allocation of human and
material resources to watch and shifts
to detect the influence of certain
diseases in the hospital services and
finally to find clusters of patients
the software requirement for this
particular project are as follows
we need dhtml for the front end and Java
as the programming language and data
mining tool which is wake up
and Oracle for the database JavaScript
for the scripting language and finally
Tomcat as our server the e-healthcare
management system is a web-based
application that assess the management
of Staff doctors and patients in a easy
comfortable and effective way here the
concept of data mining plays a vital
role to develop an effective Healthcare
Management System the proposed
application aims to create a friendly
working environment for any Healthcare
centers to overcome the drawbacks in the
existing system of Healthcare Management
this system is very reliable and
flexible from all aspects so new
features and modules can be easily
integrated into the system in the future
followed by the e-healthcare management
system we have a new normal online
banking not interesting and arousing for
a normal person but for a hardcore
programmer it is as exciting as a roller
coaster ride in an amusement park
because this is how the major national
and Multinational Banks Implement their
banking facilities in a wide range so
that their customers could experience
the ease of banking at their fingertips
one such type of project on your resume
could bring major highlight to the
recruiter especially if the recruiter is
from a banking or financial based
company
online banking system project is a model
internet banking site this project
should enable the customers to perform
basic Bank transactions by sitting at a
corner of their home or office through a
phone or laptop the customers can access
bank's website for viewing their account
details and perform the transactions on
account as per the requirement Bank
employees can log in and add customer
and account information to perform
transactions with internet banking with
internet banking the break-in motor
structure of the Traditional Bank gets
converted into a click and portal mode
thereby giving the concept of virtual
banking a real shape thus today's
banking is no longer confined to
branches e-banking facilities banking
transactions by customers Round the
Clock globally the features you can
offer through this particular project
are home page for online banking site
creation of new accounts login and log
out manage profiles and passwords view
the balance of the account deposit the
amount into the selected account with
Raman from the selected account transfer
the amount from one account to another
close the account so the software
requirements for this particular project
are Java programming language and and
JavaScript for scripting language and
Oracle for database and Tomcat for
server so followed by the online banking
project we have the online examination
project
online exams are normal for us nowadays
but this is totally limited to high-end
exams like CET GRE CAD Etc the
requirement for this particular project
is increasing day by day because of the
current scenarios many schools and
colleges have now turned towards the
online education system and are looking
forward to hosting online exams for
student safety online examination is a
simple project developed to provide an
online platform for faculty and students
to conduct online examinations and their
evaluations
this particular project has two parts
first is the admin part
admin has the right to add students
create one-time login add in questions
receive answers and finally to evaluate
followed by the first part we have the
second part which belongs to the
students so the students can log in
update their profile and password select
answers for the mcqs write answers to
questions and finally closing the
session and log out this particular
project can be made at Grand success by
making use of simple Java servlets and
Java programming languages and server
like Apache Tomcat followed by the
online examinations we have the Smart
City Smart City Java project can be a
web-based software developed to store
the details of a particular City the
main purpose of the project is to help
tourists and other visitors to a city by
providing information about hotels
Transportation facilities air ticket
booking shopping details City News Etc
the Smart City Java project serves the
visitors as a guide of the city and
hence the project is called as city
guide project in Java using this project
the details of the city can be accessed
from anywhere at any time the
implementation of the city project
promotes tourism and business
effectively hotels can be searched more
easily from anywhere with the help of
this online software students can look
out for academic institutes located in
the city you can view the complete map
of the city using this project followed
by the abstract we have the features of
this particular project the features
offered in this particular project are
login update profile and password search
for the options select an option like
booking a ticket or hotel or anything
like
Transportation Etc and finally selecting
that particular option booking that
option and payment window finally the
confirmation of the order
this particular project can be fulfilled
by using the following software tools as
mentioned below there the Java
programming language non-cat server
scripting languages like JavaScript Etc
and database as Oracle for interactive
data storage
this could be escalated to an available
by following design drones that can act
like a cop act as a tourist guide for
the people touring the city a drone that
has capability to take pictures videos
of suspected activities and store it for
future reference a drone can intimidate
a cop if any suspected activities are
detected there can be many drones in the
city with different functionalities and
finally you are required to implement
the functionality of the Drone to the
users to interact with the Drone users
could be Travelers or cops or travel
agents or cab agents the code for all
these projects are provided in the
description box below followed by the
Smart City we have the bug tracking
system
the bug tracking system is a web-based
application developed by Java
programming language for software
companies the main aim of this project
is to manage the errors of bugs that
occur during the software development
phase and cycle after the implementation
of this project the employees can update
the issue details solve the issues and
update the system for any location with
internet access below are the features
of this project and source code of this
project is linked in the description box
below coming into features the software
is applicable in managing the bugs that
occur during the development of software
and tracking the older issues it
facilitates searching the facility to
bug history and solution the system is
fully secured and authentication method
is adopted to manage security it stores
the old bug reports so that they can
easily be solved when they reappear the
application helps the project manager in
evaluating The Works of the employees
and finally the proposed software is
capable of auto update when the latest
version is available
so the software requirements for this
particular project are
programming language which is Java
web-based applications such as jdbc jndi
servlets JSP and Oracle database or
access database as the database
followed by that the server deployment
is Red Hat JBoss as Etc and the
client-side scripting as the JavaScript
and the ID for this particular project
would be Eclipse with all the my Eclipse
plugins and finally the user interface
can be designed using HTML and CSS so
with this we can move ahead into the
next project which is the facial
recognition
the face recognition with opencv is an
open source computer vision library that
has tons of modules like object
detection face detection and augmented
reality
the major features that this particular
project offers are managing the user
faces facilitate phase identification
easy login and logout store face IDs
identify suspects with just images
enhanced way to find cyber criminals so
followed by the features now we should
look into the software requirements to
build this particular project so the
programming language we need for this
particular project is Java and followed
by the programming language we need the
Apache and framework Ming ww64 and
finally the cmake framework so followed
by the facial recognition project we
have the next project which is the
vehicle recognition
so Java anpr is a number plate
recognition software which implements
algorithmic and mathematical principles
from artificial intelligence Machine
Vision and neural networks so the
features offered by this particular
project are high level language for
numerical computation interactive
environment for iterative exploration
mathematical functions built-in Graphics
functions for integrating Matlab and
many more so this particular project can
be fulfilled by using opencv and Java
programming language along with some
natural language processing algorithms
so followed by vehicle recognition
project we have our last project which
is the speech recognition system so
speech recognizer converts audio to text
Java x dot speech dot recognition
package defines the recognizer interface
to build speech recognition plus a set
of supporting classes and interfaces so
the features are stages in this
particular project are to create a
speech recognizer allocate resources
load and enable grammar attach result
listener comment changes and finally
provide the process results
so this particular library is readily
available in Java and you can code this
project using the Java programming
language and an ID such as Eclipse so in
this session we are going to focus on a
particular project and the project we
are going to focus is is about an ATM
application
so you might have interacted with
different ATM Stores in your cities
where you go in you insert your card you
enter your PIN and then you can view the
balance you can withdraw some amount you
can also deposit some amount from the
ATM
so we will try to look at it from that
perspective and and we will see what
kind of different uh Java and oops
Concepts we can use to build such ATM
application this is not a super
versatile application but this is just
to give you the idea of how to use those
oops Concepts to build a simple or a
complex Java application so let's start
from the options menu class because that
will give us the understanding of what
kind of functionality I'm using and here
you will use that I am using different
concepts which I have taught you so far
in this particular series
so for example we are using the IU
exception we are using the hashmap class
we are also using a scanner class which
is used to take input from the command
line
so this option menu class is extending
the account class and I will come to the
account class in a while but let's see
what this option menu class is doing
this particular class has uh it is using
a decimal format money format class
which is to denote what kind of format
of money you have
then we have a hash map which is storing
the couple of records of account number
to pin mapping so we create a map and
inside the get login method we add
couple of entries to the map here the
first entry the first integer is
pointing to the customer number
and the second integer is pointing to
the pin of the account of this
particular customer number
so if we call the get login method this
method will insert the data
after that it will ask the customer to
enter the customer number which has to
be one of these two if you provide any
other value then there should be a logic
in the application to reject the input
so whatever a customer number the
customer inputs we pass that inside this
particular method called set customer
number again I will come back to that
and once we have provided a valid
customer number then this method is
going to ask you to enter a PIN number
and remember I told you this is the
customer number to the pin number
mapping so whatever customer number you
select from here you will be providing
the corresponding pin number and again
if you provide an invalid pin number you
will get an error
so that will all happen inside this try
block and if you enter any invalid
characters in the pin number or of the
ATM customer number then you will get an
exception which I am writing inside the
catch block
this is all what we have seen so far
after the successful enter of the
customer number and the pin number I
fetch those values from these two
methods again I will talk about what
these methods are doing and again I'm
doing some basic validation checks but
things get interesting in this method
so what we covered so far was the get
login method let me close this method
here
so we covered the get login method the
second method which is defined in this
particular class is the account type so
here the we will ask the once the
customer has provided the customer
number and the pin number we will ask
the customer to provide the account type
this application supports two different
account types which are checking account
or a savings account so whatever so the
customer has to choose one of them again
we will be taking the input from the
command line using the scanner class
and then I'm using a switch case if the
customer entered one then I will execute
some code for the checking account which
is defined here in the case one
and if the customer entered two then the
case 2 will be executed
and if the if it enters 3 then I will
exit the application by just printing
assist out
so here I'm using the switch case
construct to provide different options
to the customer
there's also a default case specified
here which says invalid choice
so this is what is happening in the get
account type method
the next method is if the customer has
used the option one
then we call the get checking method
so let's go to the get checking method
which is the next method which is
defined in this particular class so if
the customer has selected a checking
account then we provide the following
functionality to the customer
which is the customer can view the
balance customer can withdraw the funds
customer can deposit the funds to the
checking account or they can just exit
the application
and again I'm using a switch case here
based on the customer types one two
three or four the corresponding case
block will be executed for example if
the customer wants to view the balance
then this block will get executed and I
call the get account type method
if the customer selects the
2 as the withdraw fund then get
checkings with withdraw input method
gets called and then get account type
gets called
similarly if the customer enters 3 then
we deposit the fund and for that also I
have defined a method I will go to the
definition of these methods as we go
along but right now we are just building
the framework
so the get checking deposit input method
will be called to whenever the customer
selects the option three
and for option 4 we just exit the
application
so this is what is happening in the get
checking method
now if from the account selection if the
customer selected second option which
was savings account then we were calling
get saving method
so this is where the get saving method
is defined
and again it is following the exact same
format as we saw in the get checking
method
where we present the following options
like viewing balance withdrawing the
funds and depositing the funds in the
savings account
and I have some methods defined here for
example get saving withdraw input get
saving deposit input
so we Define the switch case here based
on the customer's choices here
and that is what is happening in the get
saving method so let me close this
method as well and that's all what is
defined inside the option menu class so
we ask the customer to enter the
customer number the pin number from this
get login method then based on that we
provide the customer the options to
choose the account type whether they can
choose the savings account or the
checking account
and based on that whatever account type
they use we call the get checking or get
saving method and inside this method we
provide the customer the other options
to either withdraw the money deposit the
money or view the balance that is what
is happening inside this option menu
class
now let's go to the account class and
all the methods which we saw here will
be provided a definition in the account
class
you also see this option menu is
extending the accounts class so an
inheritance concept is being used here
let's go to the account class now
so this is the account class where I
have defined some private member
variables like customer number so now
you will be familiar with the customer
number pin number which I just described
and also with the checking balance and
the savings balance
you can also divide this account class
into two child classes where you have a
savings account class and a checking
account class but for Simplicity I've
kept it to one class
I'm initializing a scanner input which
will be used at multiple places and then
I have the Setters and Getters for these
four
member variables so you see set customer
number get customer number if you
remember this set customer number was
called in the option menu class if I go
back to the get login
once we ask the customer to enter the
customer number we call the set customer
number which gets called here
similarly
we call the set PIN number
which gets called here
similarly once we have said that we then
we were fetching the values using the
get customer number and the get pin
number and that is that is also defined
here in terms of the Getters get pin
number and get customer number
similarly we also have the Getters for
the checking balance and the saving
balance member variables we do not have
the Setters for them because they are
not technically Setters but we have to
calculate the balance it's not a simple
Setter where you can just return the
value
so now let's look at some of the
business functions of the account class
how do you deposit how do you view the
balance how do you withdraw the balance
Etc
so you see these two methods which are
specifically when the customer is trying
to withdraw the money from their account
and these methods are basically called
internally by other methods so we will
come to that let's just understand that
we have two methods for calculating the
withdrawal amount or executing the
withdraw transaction
for the checking account account and the
savings account
similarly I have two more methods here
which are calculating the depositing for
the checking account and calculating the
depositing for the savings account
and then we get the the bigger methods
which are using these calculation
methods so I Define four calculation
methods so far calc checking withdraw
calc sharing withdraw calc checking
deposit and calc saving deposit
basically withdrawing and deposit for
both of the classes
and then we have these business
functions called get checking withdraw
input and get saving withdraw input
get checking deposit input and get
selling deposit input so these getter
methods are something which were being
called from the option menu class if you
remember
if you go back to the option menu class
and if you chose the checking account
you get these options and let's say you
chose option two which was withdraw
funds or option 3 which was deposit
funds
then the corresponding methods which
were being called were get checking
withdraw input and get checking deposit
input
and this is the exact same method get
checking withdraw input
and get checking deposit input
so if you see what is happening inside
this particular method is couple of
sellouts
then we take the scanner input amount
and which we convert that amount to the
double
after that we check if the amount which
the customer wants to withdraw is
smaller than the checking balance or not
and I'm running this condition to check
that
if the amount is smaller than the
checking balance then we call the calc
checking withdraw method which was
defined right here
remember I told you that these four calc
methods will be used and this is how
they are used so here I'm actually
subtracting the value so whatever amount
the customer wants to withdraw subtract
that from the main balance and then
return the new main balance
that's what you do right if you have
thousand rupees and if you want to
withdraw 500 you subtract 500 from
thousand and then you send back the
remaining balance
so that is what is happening when we
call this method and then we print the
new checking account balance
that is what is happening in the get
checking withdraw input method
similarly if you chose option 3 which
was
depositing funds to the checking account
then get checking deposit input gets
called
and it is defined right here get
checking deposit input and here instead
of subtraction we are doing the addition
so here I'm again doing a condition
check that the current balance plus the
new amount which has been supplied by
the customer from the command line
the total sum of it should be greater
than zero what if the customer entered
an amount minus 5000 I should not allow
that so that's the reason I'm putting
this condition in place and if the
current balance plus the new amount
which is supposed to be deposited to the
account the sum of it is greater than
zero then call the calc checking deposit
method
and this is where the calc checking
deposit method is present and where I'm
just doing present balance plus the new
amount and returning the new balance
that's all which is being done here
and you will see exactly similar logic
running for the savings account as well
if you look at the get saving withdraw
input which is used to withdraw money
from the savings account so I take the
input from the command line and I run a
condition check that the amount which
the customer wants to withdraw should be
less than the current saving accounts
balance if yes then call calc saving
withdraw method which is defined here
where I subtract the amount from the
current balance and I return the new
balance
and similarly you will see the exact
same functionality in the get saving
deposit where we add the money instead
of subtracting the money
and this is all what is defined in the
account class so we talked about the
option menu class
we talked about the account class and
now we have the ATM class which is the
entry point which basically initializes
the option menu class and calls the get
login method remember get login was the
first method which asked you to provide
the customer number and then get login
called the method to choose the account
type and the account type methods then
call the method to choose the option to
withdraw deposit or exit
so now we have built a fair
understanding of what is happening in
this application so let's run this
application
so I just ran this application and let
me bring the console here it's first
asking for a customer number so I will
go to the option menu class and I will
pick up one of the customer number which
I have hard coded here
so I will provide that customer number
and hit enter
then it asks me for the pin number
so remember you have to provide the
correct pin number corresponding to the
customer number so I'm taking this pin
number just copying it and pasting it
here
then this whole code got executed
and then it called the get account type
and the get account type method provided
you with these options which you see
here on the screen so based on what you
select the case block will get executed
and let's say I want to go for a
checking account so I press one
and I hit enter
once you select the checking account the
case one gets selected and it calls the
get checking method and the get checking
method again provides you with another
menu view withdraw or deposit or exit
so let's say I want to deposit funds so
I press three
and hit enter
it says the current balance is zero and
enter the amount you want to deposit
let's say I want to deposit 500.
and I hit enter
you get the message saying the new
checking account balance is 500 and you
have successfully deposited the money
and that is what I did for the checking
account
now let's try to withdraw something from
the taking account so you again get back
the same option because inside the get
checking method
we call the once we have successfully
done the business operation we again
call the account type method to display
the menu again to the user
so let's say again select the checking
account class
and this time I want to withdraw the
funds remember I've added 500 there
so let's say I want to withdraw so I
choose the option 2 as the choice
current balance is 500 and it's asking
me the amount you want to withdraw from
the checking account
so I enter let's say 100 and I hit enter
when I do that the new checking account
balance becomes 400 so the 100 got
subtracted from the 500 and the new
balance is shown to your screen
you can do exactly the same thing for
for the savings account as well and
let's also run a negative condition so I
again select the checking account
and I want to withdraw the funds I
choose the option to
current balance is 400 and I I would
like to withdraw thousand
what happens
if you do that we get a message saying
balance cannot be negative and this is
coming from the calc checking method
which which is defined here so what is
happening that I wanted to withdraw the
funds from the checking account
and here get checking withdraw input dot
called
here
this condition was checked so the
checking balance was
400 and the amount I wanted to withdraw
was 1000 so 400 minus 1000 is not
greater than equal to zero so it jumped
into the else block and it said balance
cannot be negative
so this is how you can also build some
error conditions in your code which are
mandatory and which should be built
otherwise your application will have lot
of bugs we can also exit the application
so if you just type three
and hit enter
you will exit from the application and
it will again call the login method
where it will again ask you to enter the
customer number
so this is how you can run this
application and this is this was a
simple use case for you to show how you
can use the different object-oriented
Concepts like classes objects methods
Setters Getters switch case
Etc to build the application with the
correct business logic
and this is all I want to cover in this
particular session
and in the next session we are going to
have a look at another interesting core
Java project just to build our
understanding more better about the core
Java concept choose from over 300
in-demand skills and get access to 1 000
Plus hours of video content for free
visit skillup by simply learn click on
the link in the description to know more
let's get started with walking through a
code Java project using all the
different oops concept we have learned
so far
so in this example we are going to have
a look at a calculator application and
this calculator application supports
primarily four different operations like
addition subtraction multiplication and
division
so let's see how do we build that app
so in front of me right now is open the
main class
so I have a main app class here which
has a public static void main method and
the first thing we see is a read input
class which is calling a read method
so if you go to the read input class
it has a simple static method here which
is the read method and it is using the
scanner class if you remember I talked
about the scanner class which is used to
take inputs from the command line from
the user
so we initialize the scanner class and
we start taking the inputs and whatever
the user inputs in terms of the
expression let's say the user entered
four plus five or whatever that whole
expression gets sent back into this
input line as a string and that comes
back here in that input expression
once we have captured the input
expression the next thing we do is
divide the input expression in the
numbers and The Operators basically an
expression would be either something
like
4 plus 5
into 3
divided by 2 let's say
let's say the user entered this
expression so this has either numbers
or operators
so that's what we are doing here we are
using the split method of the string API
the string class basically and this
split method is going to split the
numbers and operators into two different
string arrays and here I'm providing the
split expression that split at every
time you encounter one of these symbols
so this when you execute this particular
statement it is going to return a
numbers array which will be created
based on this expression so you will get
an array with 4 5 3 and 2. and similarly
in the operator array you are going to
split or pick out the elements every
time you receive a number so this
operator array is going to hold this
plus sign this multiply sign and this
divide sign
hope you get the understanding that we
are just splitting the whole expression
into two different arrays where first
array is holding only the numbers and no
mathematical expressions and second
array is just holding the mathematical
operators and no numbers
and we'll see why we need to do that in
the upcoming lines
once I've created the string array I
just want to store or convert these
string arrays into a queue so I convert
this array into a list by calling the
array dot as list so this expression is
going to return a list and then I'm
going to convert this normal list into a
linked list
and then going to store this linked list
into the queue of numbers
and I'm going to do exactly the same
thing for the operator array as well
converting this into a generic list
converting that generic list into a
linked list
and then storing this linked list as a
queue
so I have an operator's queue and I have
a numbers queue both of them have been
stored into a queue now
and then I am using the pole method if
you remember the pole method of the
queue is used when you want to fetch the
first front element the head element of
the queue so whichever element is
sitting at the head of the queue will be
taken out the moment you call the whole
method so I fetch the first number from
the numbers queue so in this case 4 will
be fetched here
in this variable and after that I run a
loop on the numbers queue and I'm going
to run this particular Loop till this
particular queue is not empty if you see
there's a negation here so I'm going to
pick up numbers one by one from this
numbers queue till the number Q becomes
empty
and inside the loop I do this exact same
pull operation for the operations queue
so this operations queue is holding all
these mathematical operations like plus
star and divide
so I'm going to pick the head of it so
in this case plus will be picked up and
will be stored in this variable called
opr
and then I am going to run a switch case
on this opr basically as I told you in
this particular calculator application
we are supporting four operations which
are addition
subtraction multiplication and division
so I Define a case for each of the
mathematical expression
so you see there are four different
cases here and for each case I am
initializing a class if it's a plus sign
then I'm initializing the add class
if it's a minus sign then I'm
initializing the subtractors for
multiplication I have a class called
multiply and for division I have a class
called divide
let's have a look at what these classes
are containing
so if I go to the add class first of all
it is implementing an interface called
operate
and this operate interface has just a
single method called get results which
is accepting a variable argument array
if you remember I told you that you can
also use a where ARG array this is
called a ARG expression this means that
this numbers will be an array of
arbitrary length it can be a one element
array it can be a two element array it
can be a Four Element array or whatever
you supply but it is still going to be a
fixed length array but the length is
going to be dependent upon how much
argument you supply to this particular
method
so that is what this interface operate
is doing it's it just has one method
declared which is called get result
which is accepting an array of numbers
so if the add class is implementing the
operate interface then it has to
override the get result method and here
it is just doing a summation of all the
numbers which have been supplied so if
you supply four numbers it is just going
to add up those four numbers and return
the sum
and the exact same kind of logic or
similar logic will be seen in other
operate classes so if I go to the
subtract class it runs the exact same
operation but it subtracts the values
if I go to the multiply class it is also
implementing the operate interface and
in the get result it is just multiplying
all the values
similarly in the Divide class
it is also implementing the operator
interface and it is dividing all the
numbers one by one so it's doing pretty
much the same thing in terms of the
expression and the logic
the only difference is whether you are
using an add operation or a subtract or
multiply or a divide
so we have checked all these classes and
the operate interface as well and let's
go back to the main app now
now you also see that I've defined a
reference of operate here and each of
the switch case block I am assigning the
object type to this interface reference
so I'm using the concept of dynamic
binding which we talked about when we
talked about interfaces that we can also
do Dynamic binding where we can assign
an object
to an interface type and the object type
will depend upon the expression
so once we have filled that based on the
case while
filtering out this expression and
picking up plus star and divide
sequentially then we go to the next line
outside the switch case block which is
to pick the next number from the queue
remember we already did one pole here
so as per this example 4 was here in
this race
and now when we do this number dot pull
again
5 will be picked up because that will be
the next head of the queue so we pick up
five here and then we call operate dot
get result now this get result will be
called based on the expression which was
encountered first in the queue
again looking at the example the first
expression encountered will be plus
so the expression was plus so the
operator type object is of add type
and when you call operate dot get result
the get result method of add class is
going to get invoked and it is going to
Sum 4 and 5 this rest is holding 4 right
now based on what I described here
numbers dot Pole and this num is holding
the the second operand basically
basically 5 here so 4 plus 5 gets
evaluated here in this case and then it
again goes back here and it checks if
the number Q is now empty no it is still
not empty because we still have 3 and 2
left there so again it does the
operations dot pole and it picks up
multiply sign here
then it again runs the switch case since
it's a multiply sign it will go here and
it will initialize the operate interface
reference as the object of multiply
class
then coming here it will do a numbers
dot pole and this time the numbers dot
pole is going to pick up three
so three will be picked up here and then
the current value of result which is
already 9 4 plus 5 was 9 the current
value of result will be updated here so
rest will be 9 here and num will be 3
here and when you call operate dot get
result the multiply classes get result
will get called and it will say 9 into
3. which will become 27
it will again go back here to this
particular line and it will check again
if the numbers queue is now empty no it
is still not empty because we still have
one element left
then it pulls uh the queue of the
operations where the expression divide
is present there which is the only
element left in this particular
operations queue
and since we have the opr value as
divide this case block gets called and
the New Divide class gets initialized
the Divide class basically gets
initialized and we come here and we do
numbers dot Pole now the last number
which is available in this queue is 2
which gets picked up here
and then we again call operate dot get
result this times is the operate object
refer object uh operate reference type
was of divide class type so when we call
operate dot get result The Divide
operation or the get result method of
the Divide class basically this method
will get invoked and it will divide the
current value of result which was 4 plus
5 9 into 3 which was 27 so it is going
to divide 27 by 2 which was the last
value of the numbers dot pole it is
going to execute 27 by 2 and whatever
value it gets it is going to store a
value back into the rest variable and
then it is again going to go back here
and again going to check the condition
if the numbers Q is not empty but now
the numbers queue is empty because 2 was
the last element so it is going to come
out of the loop and it is going to print
the final result
that is how this whole program is
working
now let's try to see this in action and
we'll try to execute the exact same
expression
so if I right click and go to run as and
run this as Java application
and I Supply an expression saying 4 plus
5
star 3 divide 2.
and if I now hit enter
I get the value as 13.5 which is exactly
what we ran through because 4 plus 5
will be evaluated first which will
result into 9 then 9 into 3 will be 27
and 27 divided by 2 will be 13.5 exactly
so this is how this whole program is
running where we first take the inputs
and then we divide the input into
numbers and operation arrays or in fact
queues and once we have those queues
built up then we pick up the first
number and we keep running this Loop
till the numbers Q is not empty inside
the while loop at each step we pick up
the first expression or the operator we
check what is the operator whether it is
an addition subtraction multiplication
or division operator and whatever kind
of operator we have we initialize the
corresponding class of it and then we
fetch the next value in the numbers
queue and then we call the get result
based on the expression and whatever
result we get from the get result we
store it back into the rest variable so
we keep updating the rest variable at
every step that's the reason the result
of 4 plus 5 gets stored in the rest and
next time you are calling the get result
for a multiply operation here the rest
value is 9 now and it says 9 into 3
again in the next time the rest value
will be updated to 27 because we are
storing the result back into the result
variable
so this is all I want to cover in this
particular session where we looked at an
example of a calculator application
purely from the console standpoint
obviously there can be lots more stuff
which we can do into this particular
application make it more error free and
cover a lot of corner cases like
validating the inputs
Etc also looking at putting some
conditions around the exception handling
handling the divide by zero scenario Etc
which is not here but this is just to
show you the basic idea of how you can
build simple to complex CLI applications
using the core Java Concepts so in this
example we are going to have a look at a
calculator application
and this calculator application supports
primarily four different operations like
addition subtraction multiplication and
division so let's see how do we build
that app so in front of me right now is
open the main class so I have a main app
class here which has a public static
void main method and the first thing we
see is a read input class which is
calling a read method so if you go to
the read input class it has a simple
static method here which is the read
method and it is using the scanner class
if you remember I talked about the
scanner class which is used to take
inputs from the command line from the
user so we initialize the scanner class
and we start taking the inputs and
whatever the user inputs in terms of the
expression let's say the user entered
four plus five or whatever that whole
expression gets sent back into this
input line as a string and that comes
back here in the input expression once
we have captured the input expression
the next thing we do is divide the input
expression in the numbers and The
Operators basically an expression would
be either something like
4 plus 5 into 3
divided by 2 let's say let's say the
user entered this expression so this has
either numbers or operators so that's
what we are doing here we are using the
split method of the string API the
string class basically and this split
method is going to split the numbers and
operators into two different string
arrays and here I am providing the split
expression that split at every time you
encounter one of these symbols so this
when you execute this particular
statement it is going to return a
numbers array which will be created
based on this expression so you will get
an array with 4 5 3 and 2.
and similarly in the operator array you
are going to split or pick out the
elements every time you receive a number
so this operator array is going to hold
this plus sign this multiply sign and
this divide sign hope you get the
understanding that we are just splitting
the whole expression into two different
arrays where first array is holding only
the numbers and no mathematical
expressions and second array is just
holding the mathematical operators and
no numbers and we'll see why we need to
do that in the upcoming lines once I
have created this string array I just
want to store or convert these string
arrays into a queue so I convert this
array into a list by calling the array
dot as list so this expression is going
to return a list and then I'm going to
convert this normal list into a linked
list and then going to store this linked
list into the queue of numbers and I am
going to do exactly the same thing for
the operator array as well converting
this into a generic list converting that
generic list into a linked list and then
storing this linked list as a queue so I
have an operator's queue and I have a
numbers queue both of them have been
stored into a queue now and then I am
using the poll method if you remember
the poll method of the queue is used
when you want to fetch the first front
element the head element of the queue so
whichever element is sitting at the head
of the queue will be taken out the
moment you call call the pole method so
I fetch the first number from the
numbers queue so in this case 4 will be
fetched here in this variable and after
that I run a loop on the numbers queue
and I'm going to run this particular
Loop till this particular queue is not
empty if you see there's a negation here
so I'm going to pick up numbers one by
one from this numbers queue till the
number Q becomes empty and in inside the
loop I do this exact same pull operation
for the operation skew so this
operations queue is holding all these
mathematical operations like plus star
and divide so I'm going to pick the head
of it so in this case plus will be
picked up and will be stored in this
variable called opr and then I am going
to run a switch case on this opr
basically as I told you in this
particular calculator application we are
supporting four operations which are
addition subtraction multiplication and
division so I Define a case for each of
the mathematical expression
so you see there are four different
cases here and for each case I'm
initializing a class if it's a plus sign
then I'm initializing the add class if
it's a minus sign then I'm initializing
the subtractors for multiplication I
have a class called multiply and for
division I have a class called divide
let's have a look at what these classes
are containing so if I go to the add
class first of all it is implementing an
interface called operate and this
operate interface has just a single
method called get results which is
accepting a variable argument array if
you remember I told you that you can
also use a where ARG array this is
called a ARG expression this means that
this numbers will be an array of
arbitrary length it can be a one element
array it can be a two element array it
can be a Four Element array or whatever
you supply but it is still going to be a
fixed length array but the length is
going to be dependent upon how much
argument you supply to this particular
method so that is what this interface
operate is doing it's it just has one
method declared which is called get
result which is accepting an array of
numbers so if the add class is
implementing the operate interface then
it has to override the get result method
and here it is just doing a summation of
all the numbers which have been supplied
so if you supply four numbers it is just
going to add up those four numbers and
return the sum and the exact same kind
of logic or similar logic will be seen
in other open rate classes so if I go to
the subtract class it runs the exact
same operation but it subtracts the
values if I go to the multiply class it
is also implementing the operate
interface and in the get result it is
just multiplying all the values
similarly in the Divide class it is also
implementing the operating interface and
it is dividing all the numbers one by
one so it's doing pretty much the same
thing in terms of the expression and the
logic the only difference is whether you
are using an add operation or a subtract
or multiply or a divide so we have
checked all these classes and the
operate interface as well and let's go
back to the main app now now you also
see that I've defined a reference of
operate here and each of the switch case
block I am assigning the object type to
this interface reference so I'm using
the concept of dynamic binding which we
talked about when we talked about
interfaces that we can also do Dynamic
binding where we can assign an object to
an interface type and the object type
will depend upon the expression so once
we have filled that based on the case
while filtering out this expression and
picking up plus star and divide
sequentially then we go to the next line
of outside the switch case block which
is to pick the next number from the
queue remember we already did one pole
here so as per this example 4 was here
in this race and now when we do this
number dot pull again 5 will be picked
up because that will be the next head of
the queue so we pick up 5 here and then
we call operate dot get result now this
get result will be called based on the
expression which was encountered first
in the queue again looking at the
example the first expression encountered
will be plus so the expression was plus
so the operator type object is of add
type and when you call operate dot get
result the get result method of add
class is going to get invoked and it is
going to sum for 4 and 5 this rest is
holding 4 right now based on what I
described here numbers dot pole and this
num is holding the the second operand
basically basically five here so 4 plus
5 gets evaluated here in this case and
then it again goes back here and it
checks if the number Q is now empty no
it is still not empty because we still
have 3 and 2 left there so again it does
the operations dot pole and it picks up
multiply sign here then it again runs
the switch case since it's a multiply
sign it will go here and it will
initialize the operate interface
reference as the object of multiply
class then coming here it will do a
numbers dot pole and this time the
numbers dot pole is going to pick up
three so three will be picked up here
and then the current value of result
which is already 9 4 plus 5 was 9 the
current value of result will be updated
here so rest will be 9 here and num will
be 3 here and when you call operate dot
get result the multiply classes get
result will get called and it will say 9
into 3 which will become 27 it will
again go back here to this particular
line and it will check again if the
numbers queue is now empty no it is
still not empty because we still have
one element left
then it pulls uh the queue of the
operations where the expression divide
is present there which is the only
element left in this particular
operations queue and since we have the
opr value as divide this case block gets
called and the New Divide class gets
initialized the Divide class basically
gets initialized and we come here and we
do numbers dot Pole now the last number
which is available in this queue is 2
which gets picked up here and then we
again call operate dot get result this
times is the operate object refer object
operate reference type was of divide
class type so when we call operate dot
get result The Divide operation or the
get result method of the Divide class
basically this method will get invoked
and it will divide the current value of
result which was 4 plus 5 9 into 3 which
was 27 so it is going to divide 27 by 2
which was the last value of the foreign
so it is it is going to execute 27 by 2
and whatever value it gets it is going
to store the result value back into the
rest variable and then it is again going
to go back here and again going to check
the condition if the numbers Q is not
empty but now the numbers queue is empty
because 2 was the last element so it is
going to come out of the loop and it is
going to print the final result that is
how this whole program is working now
let's try to see this in action and
we'll try to execute the exact same
expression
so if I right click and go to run as and
run this as Java application and I
Supply an expression saying 4 plus 5
Star 3 divide 2 and if I now hit enter I
get the value as 13.5 which is exactly
what we ran through because 4 plus 5
will be evaluated first which will
result into 9 then 9 into 3 will be 27
and 27 divided by 2 will be 13.5 exactly
so this is how this whole program is
running where we first take the inputs
and then we divide the input into
numbers and operation arrays or in fact
queues and once we have those queues
built up then we pick up the first
number and we keep running this Loop
till the numbers Q is not empty inside
the while loop at each step we pick up
the first expression or the operator we
check what is the operator whether it is
an addition subtraction multiplication
or division operator and whatever kind
of operator we have we initialize the
corresponding class of it and then we
fetch the next value in the numbers
queue and then we call the get result
based on the expression and whatever
result we get from the get result we
store it back into the rest variable so
we keep updating the rest variable at
every step that's the reason the result
of 4 plus 5 gets stored in the rest and
next time you are calling the get result
for a multiply operation here the rest
value is 9 now and it says 9 into 3
again in the next time the rest value
will be updated to 27 because we are
storing the result back into the result
variable
so this is all I want to cover in this
particular session where we looked at an
example of a calculator application
purely from the console standpoint
obviously there can be lots more stuff
which we can do into this particular
application make it more error free and
cover a lot of corner cases like
validating the inputs Etc also looking
at putting some conditions around the
exception handling handling the divide
by zero scenario Etc which is not here
but this is just to show you the basic
idea of how you can build simple to
complex CLI applications using the core
Java Concepts let's get started with
spring Boot and how we can build a
simple application using spring boot
before we go further let's understand
why we need spring Boot and the basic
idea of spring boot is to build restful
web services if you want to know more
about what a restful services please you
can read about the restful concept as a
concept what does rest stand for but the
basic idea is that if you are accessing
anything over HTTP then that particular
component can be built as a restful
component and spring boot is the most
popular choice for building restful web
services today and even in fact micro
Services which you might have heard
about so you can build microservices
which also run on https using spring
boot so what I'm showing you right now
is the official guide of spring which
you can use to build an application with
spring boot it will list down all the
requisites which you need in terms of
the jdk installations Maven on and how
to complete this guide etc etc you can
again use the same spring initializer
which I talked about in the previous
session you can use this to generate a
spring boot project for you specifically
so all those options are available here
so I've already done that and I'm not
going to repeat what I just did in the
previous session and will directly jump
to an IDE where I have created a sample
spring boot application and the
structure here you can see the structure
would look very similar with one change
that in the previous example when we
were dealing with MVC we had an SRC main
resources folder and that SRC main
resources folder was having all the web
components or the htmls but since in
restful web services you do not render
the HTML but you just send back the
response the response can be the
response body can be pure XML or it can
be pure Json but you do not send back
and View and that's the main difference
between spring MVC and spring boot that
in Spring MVC it will you are required
to return a view technology like in the
in the previous session we sent a die my
lift template which is basically in HTML
you can also written a GSP but with
spring boot you do not deal with the
view technology and that's the world we
are living in today when you write
spring boot you do not have to worry
about how this is going to be rendered
on the web page whether it is going to
be rendered using HTM ml or what not
what you need to take care of using
spring boot is to return the right
response body the exact text of the
response and that's it so with that in
mind the spring boot was born and the
structure apart from that the structure
would look very similar there's a
palm.xml here which will provide all the
list of jars and dependencies which are
required for this particular project so
you can see all the dependencies here
pretty much the similar ones we have a
starter web we have a starters test and
we have a spring boot Maven plugin and
we have an application file which is the
entry point again having a public static
void main method so you need to put the
at the red spring boot application at
the top of the class to make it an entry
point if you don't do this spring boot
will not run this class and spring boot
will it even not run your application so
what we are doing as part of this
example that we are just printing all
the beans which are provided by Spring
that's all we are doing like I said it's
a very lightweight end up introductory
session so we will keep the Logics to
minimum and I'm just getting all the
beam definitions sorting the beam
definitions and just printing them one
by one how do we get the beam definition
you get that with this application
context class which is returned when you
run the application and how you run the
application is basically using this line
where you say spring application dot run
and your Supply application dot class
with any command line arguments which
you might want to use once you do this
it is going to return an application
context object to you and the
application context object can be used
to get all the beam definitions by
calling this method which says get bean
definition names so that's the basic
logic which is being run in the main
class now we also have a controller but
this time it's not a web controller but
it's a rest controller so you see in the
previous example we just had written
something like this it was just a pure
controller but here we have become more
specific we are saying that hey this is
not a simple MVC controller but this is
a spring boot controller or technically
a rest controller so spring provides a
separate annotation for that which is at
the rate rest controller so you write
that particular annotation or that on
the top of the controller class which
you are creating and then you provide a
request mapping similar to what we did
in Spring MVC but while you return it
you do not return a view technology you
just return the raw response here I'm
just returning a string but you can
return a Json object you can written an
XML object or whatever you want to but
not a view technology that's what I'm
doing like like you can see there's
literally nothing I'm doing in this it's
just a simple string return statement
which I have printed here and that's all
the code I have right now here I just
have these two classes okay so that was
all about what I have written in the
project and now it's time to run the
project so I have just reached to the
location on inside my terminal where the
projects palm.xml was present and if I
just do an LS you will see that there is
a palm.xml available here and all the
code directly is also available here so
now I will just run this application and
to run this application I'm just going
to type mvn spring hyphen boot colon run
and hit enter once I do that the spring
application is going to Spring boot
application is going to get started and
let's go back to uh the controller and
actually the main app main endpoint and
see what we were doing there I did a sys
out here which said let's inspect the
beans provided by Spring Boot and then I
was printing all the beam names and if I
go back to the output I will see the
same line being written here which was
around let's inspect the beans so you
can see that message which says let's
inspect the beans provided by Spring
Boot and then all the beans which are
available in the application context are
printed here so that's that's the basic
idea which I want to give you that you
can actually build a spring boot
application and you can write your rest
controllers return a string body from it
and once this is run then you can also
run your application for from the web
browser as well so let's try to hit that
particular URL which I wrote here so the
URL of hello so for that let me
just open a new Cognito window and our
application is already running so if I
just say HTTP localhost 8080 slash I get
this message here which says greetings
from Spring Boot and this is the message
which we were sending from the rest
controller so this validates our
understanding that we can invoke or test
controller which is a spring boot rest
controller via the same method but this
time we are not getting an HTML but we
are just returning this particular
string now you can use the string in any
ways you want so it depends upon the
consumer so that's all I want to cover
uh as part of the spring boot now spring
boot is a huge huge topic and we can
spend hours and hours talking talking
about spring boot but since this is more
of an introductory session so I just
wanted the concept to get introduced and
remember the value proposition of why
you would need spring boot the basic
idea is to build restful web services or
build restful micro Services that's the
basic idea behind using spring boot in
your applications and also remember the
difference between webmv spring MVC
application and spring boot application
spring MVC is for building web
application spring boot is for building
restful applications which might not
have a web interface integrated with
them at that moment let's get started
with our demo of a project which is
using spring boot to build a restful web
service so a restful web service is
nothing but any endpoint which you can
access or you can consume the data from
via an HTTP layer or via a simply a web
layer because most of the web traffic
which we deal with is built on HTTP so
to take an example if you go to any
website where you sometimes see on the
top right corner you see today's weather
so how is that today's weather coming in
it's coming in Via our rest web service
the website which you are accessing is
basically hitting an HTTP endpoint which
is uh where the where the weather
application is sitting and it asks for
the weather data and addressed web
application just Returns the data and
that's how the website is able to show
you the current weather so restful web
services are everywhere and they are the
most popular way to build applications
today where you just build your restful
web service and you expose an HTTP URL
and then the consumers need to just
access that HTTP URL to consume the data
from your application and you see this
makes it very easy because there is no
data type restrictions there is no tight
coupling here it's just an HTTP endpoint
so that's the basic idea and we will
look at a project where we will be using
spring boot to build a restful web
service and then we will try to run that
web service to save some data and also
to return some data so here on the on
the package Explorer you see I have
created a project called rest service
and let's just walk through the
structure of it and then we'll go into
the details of it so we have an SRC main
Java where I have a package and I have
bunch of classes here and before we go
to the classes let's first also access
the dependency file because every
project needs some dependencies some
jars to execute it for example spring
itself is basically a jar so you need to
include the spring jar in your project
so that your project can become a spring
project and there are generally two
dependency tools one is Maven and one is
Gradle in this particular project I am
using Maven dependency tool for
downloading and managing the
dependencies which are needed to run
this project successfully and the way
you will find if it's a maven project or
if it's a Gradle project for a maven
project you will see a file called
pom.xml.com.xml and if it's a Gradle
project you will see a DOT Gradle file
that's how you can spot whether the
project is using Maven for dependency
management or it is using Gradle for
dependency management so let's open the
palm.xml since it's an XML file it will
be a bit verbose but if you just read it
piece by piece it will become easier to
understand first of all since this is a
spring project I need to include the
parent dependency which brings lot of
good defaults sensible defaults from
Spring boot automatically and this is
the jar name this is the artifact ID
which is spring boot starter parent so
any spring boot project you are starting
do include this parent this parent is
basically bringing all the dependencies
from some other jar and you can make
your project as a as a child of this
particular parent so all the spring boot
projects have this as a parent as a
standard practice after that you provide
your own details in terms of what is the
package name how do you want to see the
jar name and what is the jar actual name
what is the jar version etc etc you also
set the minimum required Java version to
an this application and then you in the
dependency sections you provide all the
jars which you need to run your project
successfully both compile and run your
project successfully so we added the
spring boot starter web on dependency
which basically brings all the
dependencies around making a controller
or making a repository count the context
component scan all the interesting
features which spring provides get
wrapped up inside the spring boot
starter jar and you can actually go to
the mvn repository and and have a look
at what all classes it provides it's a
lot of classes so I'm just telling you
in a brief that it provides all the
restful functionality then you have the
next dependency as spring boot starter
data jpa which is going to enable this
project to also have a database and if
it has a database then you need Java to
talk to the database and the Way Spring
suggests to talk to the database is via
using the spring boot data JPI Library
we will see this how this Library can be
used but based basically this provides
ways to represent your Java object in
the database and then you need to also
add the actual dependency of the
database and in this case we are using
an in-memory H2 database so I'm not
using an external database like MySQL or
Oracle or post SQL because that will
just make more configurations more
complicated I just wanted to keep it
simple and generally you in this H2
database you can easily access by adding
this dependency and it will be an
in-memory database created for you then
I've also added a spring boot starter
test here which will be used whenever
you are writing unit tests and you must
write unit test for your project and
then we need to add the plugin so that
spring boot can run this project that's
all I have in the palm.xml now let's
move to the interesting part the Java
section part let's start from the main
class
so this is how the main class looks like
where you have you just create uh any
any name with the class and then you add
a public static void main method inside
the public static white main method you
call Spring application dot run and this
run method is basically going to run
your application and you just provide
the same class name which you just wrote
here so you just say dot class and if
you're supplying any command line
arguments it can interpret that command
line arguments as well if you want so
you would always need an entry point in
an application and this is the entry
point which springboot supports and this
is if you see this code this is just
normal code to make spring be aware
about this class being treated as an
entry point you need to add add the red
spring boot application annotation on
top of the class this is one of The
annotation which is coming directly from
the spring boot Library you can see this
import so once you add this then only
spring will be able to treat this class
as an entry point otherwise spring
doesn't know where to start from so when
you run spring it will fi it will try to
find a class with an annotation spring
boot application and then inside the
class it will try to find a public
storage a static white main method and
once it has found both of them then it
will just run the application so it's
very simple nothing fancy here and what
we are dealing with here is a student
object so we will try to insert the
student object and we will try to
retrieve the student object so if you
ignore these annotations which I've
added it's just a pure pojo it's just a
plain old Java object you create a
student class Let's ignore this field as
well for now I'll just come back to this
annotation in this field but this is
just a student class it has three Fields
as name age and address an empty
Constructor and a parameterized
Constructor and some Getters
intentionally I have removed the Setters
because generally whenever you are
building any Enterprise grade
application you would like to keep your
objects immutable means once they have
been created you would not like somebody
to allow to change the values of the
object this just makes programming much
much more easy if you treat all the
objects in your application as immutable
that's why I have not added Setters here
it's just considered a good practice so
apart from the standard things which we
have already seen there are two things
here which I want to talk about let's
first talk about this one so at the rate
entity is The annotation which is coming
from java X persistent entity
persistence entity and this makes spring
boot save this particular object into
the database this is The annotation
which you need to put on your class so
that springboot knows that this class
represents a table in the database so
you need to add this to make sure that
this represents a table second thing a
table will have a ID it will have sort
of a primary key so I've created a new
column called ID which is basically
representing the student's row number or
something or maybe a registration number
and here I'm using couple of more
annotations if you see these annotations
are also coming from java X persistence
library and these annotations will
basically allow the a new ID to be
created every time you create a student
object so you don't have to specify the
value of this ID variable springboard
will automatically generate a new ID
value every time you create a new
student object and how does it generate
you you can provide the generation type
as well so currently I've just set that
set it as automatic but you can set it
as identity sequence or return or
controlled by table you can also see the
explanation of each of these here but
I've just kept it as Auto which
basically uh let the persistence
provider pick any appropriate strategy
for the particular database in our case
the database is H2 so that's about the
entity class let's call this as entity
class now let's move to the repository
so you need a repository class like I
explained in those in that three tier
architecture you always need a dow layer
or a repository layer to store your
student object into the database so we
have enabled the student object to be
saved but we need a Handler which can
save this particular file this
particular object into the database and
the repository classes are the classes
which will allow you to do that so you
create a very simple interface you what
you name whatever you want to name your
interface as and then you say extends
jpa repository the type of the object
and the unique identifier of the object
so the type of the object is student
here and the unique identifier of the
student object is the ID which is of
type long so you need to just Supply the
types type of the object type of the
primary key or the type of the unique
identifier and this annotation is coming
from Spring boot you can see
specifically spring boot data Library
which we added so you just need to
create an interface extend it from JP
repository and make sure that you add
this annotation as well spring heavily
uses the concept of annotations and this
will help spring understand that this is
a repository layer class and it will
apply some more metadata to this class
while this class is running in the jvm
so what happens here you just created an
interface it did not provide any method
to create or any method to delete or any
method to get a student object because
all of that is automatically provided by
springboot via the jpa repository class
if we go inside this class and if you
scroll down you will see the find all
method find all find all by ID save all
flush save and flush delete
Etc and if you go further up this also
extends the paging and sorting
repository which provides pagination and
sorting facilities but the interesting
one is that paging and sorting
repository again extends a curl
repository and if you go to the credit
repository you will find all the basic
methods to save an entity save multiple
entities find an entity by the ID that's
why it needed that long type to make
sure this that it can execute this
method you can check the existence of an
object find all the entries find all by
ID count them delete them so all the
basic grid functionality so we call them
as current because the reason it is
called crud because create read update
delete that's the basically the generic
acronym so because uh this credit
repository provides all the methods and
their implementations automatically we
do not need to write any code at all so
that's why spring boot is so awesome and
that's why spring boot is very popular
because it's zero code in the repository
and you still get all the credit
functionality so that's about repository
now we have covered the entity class we
have covered the repository class we
have covered the entry point class now
the only thing which is remaining is the
is the end point the HTTP endpoint which
I talked about and that you can create
by creating any class generally try to
suffix it with the controller so that
your co-developers can easily find this
class and make sure that you put add the
red rest controller annotation on top of
it this annotation will allow spring to
read this particular class as an
endpoint class then you can Auto wire
the student repository so if you
remember I talked about the whole
dependency injection and inversion of
control so here dependency injection is
in action so here you are just telling
student controller to Auto wire the
student repository and now what will
happen that at runtime student
controller or actually spring will
automatically create an object of the
student repository and Supply that
object of student repository to student
controller so you as developer do not
have to create an object of student
repository explicitly that's the benefit
and that's how the dependency injection
is working because you inverted the
dependencies now the dependency is just
injected into the class and as a
developer you don't have to take control
of creating the objects if the spring
which will automatically read the Auto
World annotation and will automatically
Supply an object whenever it is required
then I have two methods here since we
are talking about HTTP endpoints so I
have represented a post method here and
a get method here the way you will write
a post method is via did it post mapping
annotation and then you can provide the
URL path on which somebody should call
your endpoint to save something so for
example somebody can call it HTTP
localhost 8080 slash student slash
create whenever they hit that URL the
control or that request will directly
hit this particular method why because
you have provided the URL mapping here
in the post mapping annotation so since
it's a post method there would be
request body what is the actual request
body which the client is sending and you
can represent its request body with the
add direct request body annotation and
you can provide the type of the request
body and here I'm saying that hey if you
want to access this particular URL yes
all good but you need to supply me with
a text representation of the student
object or a Json representation of the
student object and then I inside the
method I'm calling student repository
dot Save which is going to save the
student object which is coming in so you
see this lot going on here I will I will
show you how the student is represented
in the request body as well and then I
will come back to how it got converted
from Json to Java but this is how you
can store this particular student object
you can hit this AP as many times as you
want and keep inserting a new student
object every time then if you want to
fetch a particular student then you can
do that by supplying the slash student
and then in the curly braces there is an
ID written here so basically you can
supply the value of the ID of the
student so generally there would be
another method here which would be find
all to see all the students and with
their ID and then you can pick a
particular students ID Supply that
student ID value here dynamically that's
why the curly braces curly braces
supports Dynamic value so here it can
insert One Two Three or whatever the
student ID you want to fetch the value
for you provide that value in the
student slash ID and all good then some
if somebody is hitting the URL with
saying localhost 8080 slash student
slash one then student with the ID 1
will be returned from the request and
you need to put advert get mapping to
make sure that this method is treated as
an HTTP get method and you can provide
the type you can set say get student and
here this Dynamic value is captured with
the add the rate path variable because
you need to know the ID right whatever
ID somebody has supplied it in the URL
you need to capture that IDE and then
use that IDE for calling the repository
so that's you can do that by using the
at the rate path variable so here I'm
just saying whatever ID is coming in I
will store that value inside this IDE
once I've done that then I can again
call student repository dot find by ID
which is again a built-in method
provided to me by the credit repository
I can supply the ID and this actually is
going to return an optional object which
is uh which is an object which may or
may not contain a value so it's a just a
types a defensive programming style so
this will return an optional and you can
call a get method to return the actual
student object this will return an
optional of student so option of student
means that this optional object may have
a student or may not have a student why
did spring do that because the ID
somebody is supplying that ID can be
invalid also right so optional object
create takes care of that that if there
is no student found then you will not
get a null pointer exception and if
there's a student found you can return
that so it's just a defensive
programming style which spring has
adopted by returning an optional of the
student object rather than directly the
student object but if you are confident
that this particular option of student
object does contain a student object
then just call optional.get which I've
called here which will return the actual
student object sitting inside the
optional object you can read more about
the optional object and its usage from
the official Java docs and there are
tons of examples available on it on
internet so this is about the controller
we have covered all the classes now it's
time to run the application so you go to
the command prompt you go to the
particular file folder location and
there you just say mvn spring hyphen
boot colon run so I just hit enter and
this is going to run the application
it's going to split some logs here and
if everything is fine you will not get
an error and you will just be getting a
message saying that application got
started and it's running on Tomcat
localhost 8080 with no context URL so
this is not a web application this is a
restful web service right this is a
restful service this is not a web
application so there is no web interface
so how do you access this you just have
an HTTP URL so you can use any of the
rest client available on the internet
there are probably hundreds of different
rest clients available on the internet
you can choose any one of them I am
using Advanced rest client which you can
also install as an extension from the
Chrome browser itself so if you just if
I just open the Chrome browser and I
just say rest client if you just write
this and hit enter you will get many
different options and the first option
you get is from Google Play Store's App
Store so you can go to the App Store
that basically the Chrome web store not
the play store but the Chrome web store
and you can just install this since this
is already installed you can click on
launch app and it will open this
interface for you so this is pretty uh
this is not a tutorial for advanced rest
clients so I'll just be quick here you
can choose the method type which you
want to hit so let's say I want to do a
post and then you can provide the URL
here so remember the URL which we put
here in the controller method this has
to exactly match so HTTP localhost slash
student slash create should be the URL
so let me just copy paste this one here
okay so the URL is good here it's a post
type of method which I want to do and I
want to hit this particular URL now I
need to supply the content type and the
body so in the content type you can
choose application Json because I'm
going to supply a Json object and in the
body this is how the Json object looks
like Advanced rest client also provides
a nice visual interface to basically
create this Json if you you are thinking
that Json creation is very tough it's
not actually tough It's just curly
braces and then you put key and value
key value comma let me just put an enter
here so that it's more readable so you
just put curly braces starting an end
and then you just put key value you put
a key which is the variable name and the
variables value variable name variable
value and these Keys have to exactly
match the students properties so the
student.java had this name page and
address right so it has to exactly match
otherwise this will request will fail so
this is all good now I can send this
particular request when you click Send
it is going to hit my spring boot
application which is running on
localhost 8080 it is going to call the
student slash create method it is also
going to convert this Json into a Java
object because here I am supplying a
Java object so it will convert the Json
which I'm sending from here to Java
object automatically and it is going to
automatically save it here because I've
called the repository.save method so
let's hit send here once I hit send I
get a 200 okay it means everything went
fine and in the response header I get
the object back because I have returned
the object here you see this save method
is going to return the same student
object which you created uh so
everything is good here my object has
been stored here and now it's time to
fetch the object so it has already been
saved in the into the H2 in memory
database and you can obviously go and
connect to the in-memory H2 database and
have a look at it but for Simplicity I'm
just gonna do this here and let's say
the first object is generally added as
the id1 by default by the H2 database so
let's hit this particular URL when I hit
this URL it is going to hit the student
controller here and in the student
controller it is going to hit the get
student method which is having a student
slash ID URL and it is going to find the
database with that ID and if it finds an
student object with that ID it is going
to return that so let's confirm that now
so let's hit this particular send button
and it's going to hit a get request with
this particular URL string boot is going
to find if a student with the id1 exists
in its database so once I hit send I get
a 200 okay and you see in the response
headers I get the same student object
back which I added let's try with two
now let's see what happens I see two and
I get 500 internal server error because
there is no object stored in the H2
database of the spring application with
the id2 yet because we only inserted one
object that's why only one student
object is there and the first ID which
H2 database created for it automatically
was one so when you hit for get request
with a student id1 you get the object
when you put any invalid value and you
hit this you get a 500 internal server
error you can also make it look nice by
not sending the 500 internal server
error and sending a nice exception from
the back end so from here you can also
send a nice exception that if this
object is not found you can say
something like that or else throw which
is again an optional object and here you
can supply a particular type of
exception which you want to supply
instead of just throwing 500 internal
server error but that's just additional
thing additional defensive programming
you can do you can add more and more
validation and constraints into this
project as you build this project in a
more complex Paradigm so this is
basically what I wanted to show you that
and that we have created a springer boot
application we have connected it to a
database we haven't created also an HTTP
endpoint with student controller we ran
that application we used any random rest
client in my case I used Advanced stress
client and we first did a post request
we provided the exact URL the URL has to
exactly match with the controller URL
and then the body the request body also
has to exactly match with the student
objects property especially the case of
the names have to exactly match so if
this all this matches then you will get
a response back that the object has been
created if you want to fetch the value
of the object you are going to use the
HTTP get method and you again provide a
URL which has to exactly match to some
method in some controller in the spring
boot application which is running on
localhost and if you provide the right
ID you are going to return get a valid
result if you provide an invalid ID you
are going to get a 500 internal server
error and from here on you can make this
controller as robust and as mature as
you want you can add find all methods
you can add update student method you
can add a delete student method you can
have all different kinds of filters like
for example return to me all the
students starting with the name a or
return all the first students with the
rule number one and hundred for between
100 so you can write as many endpoints
as you want and build this application
in as with as much maturity and as much
complexity as you want now with that we
have come to an end of this exciting
session on Java projects for 2022 I hope
you had a wonderful and interesting
session and if you have any queries
regarding any of the topics covered in
this session or if you require the
resources that we have used in this
session then please feel free to let us
know in the comment section below and
our team of experts will be more than
happy to resolve all your queries at the
earliest until next time thank you stay
safe and keep learning
hi there if you like this video
subscribe to the simply learning YouTube
channel and click here to watch similar
videos turn it up and get certified
click here