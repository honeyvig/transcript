with the decline of symmetric encryption
algorithms of private message encryption
new cypher suits came into light
the glaring issue with symmetric
algorithms was key exchange
having to pass secret keys is a risk on
its own right
and that we were unable to solve in a
lot of scenarios
thankfully dsl algorithm has managed to
solve this problem
the use cases for this cipher is rather
niche but crucial nonetheless
let's take a look at the topics we need
to cover in today's video
we first get a recap on what asymmetric
encryption is and how is it any
different from symmetric encryption
we learn what digital signatures are and
how they are used in today's world
next we understand the digital signature
algorithm and see how it works step by
step
finally we learn about the advantages
dsa provides when it comes to managing
digital signatures in a corporate and a
personal environment
let's take a look at asymmetric
encryption
asymmetric encryption uses a double
layer of protection
there are two different keys at play
here a private key and a public key
the public key is used to encrypt the
information pre-transit and the private
key is used to decrypt the data transit
this pair of keys must belong to the
receiver of the message
the public keys can be shared by a
messaging blog post or key servers since
there are no restrictions
as you can see in the image the two keys
working in the system
the sender first encrypts the message
using the receiver's private key after
which we receive the ciphertext
the ciphertest is then transmitted to
the receiver without any other key
on getting the ciphertext the receiver
can use his or own private key to
decrypt the information and get the
clear text back
there has been no requirement of any key
exchange throughout this process
therefore solving the most glaring flaw
faced in symmetry key
cryptography the public key known to
everyone cannot be used to decrypt
messages and the private key which can
decrypt messages need not be shared with
anyone
the sender and receiver can exchange
personal data using the same set of keys
for as often as long as possible
in this example we have two people nancy
and john
if nancy wants to send a message to john
john's public key should be used to
encrypt the information
the cipher text is then transferred to
john who can use his private key to
decrypt the data and get the plain text
back
this goes to highlight how we have
overcome the problem of key sharing when
it comes to asymmetric encryption
now that we have a proper revision let's
understand what digital signatures are
before moving on to the algorithm
the objective of digital signatures is
to authenticate and verify documents and
data
this is necessary to avoid tampering and
digital modification or forgery of any
kind during the transmission of official
documents
they work on the public key cryptography
architecture with one exception
typically an asymmetric key system
encrypts using a public key and decrypts
the private key
for digital signatures however the
reverse is true
the signature is encrypted using a
private key and is decrypted with the
public key
because the keys are inked together
decoding it with the public key verifies
that the proper private key was used to
sign the document therefore verifying
the signature's provenance
let's go through each step to understand
the procedure thoroughly
in step 1 we have m which is the
original plain text message
and it is passed on to a hash function
denoted by h
to create a digest
next it bundles the message together
with the hash digest and encrypts it
using the sender's private key
it sends the encrypted bundle to the
receiver who can decrypt it using the
sender's public key
once the message is decrypted it is
passed through the same hash function
each hash to generate a similar digest
it compares the newly generated hash
with the bundled hash value received
along with the message
if they match it verifies data integrity
in many instances they provide a layer
of validation and security messages
through non-secure channel
properly implemented a digital signature
gives the receiver reason to believe
that the message was sent by the claimed
sender
digital signatures are equivalent to
traditional handwritten signatures in
many respects but properly implemented
digital signatures are more difficult to
forge than the handwritten type
digital signature schemes in the sense
used here are cryptographically based
and must be implemented properly to be
effective
they can also provide non-repudiation
meaning that the signer cannot
successfully claim that they did not
sign a message while also claiming their
private key remains secret
further some non-repudiation schemes
offer a timestamp for the digital
signature so that even if the private
key is exposed the signature is valid
to implement the concept of digital
signature in real world we have two
primary algorithms to follow the rsa
algorithm
and the ds algorithm but the latter is a
topic of learning today
so let's go ahead and see what the
digital signature algorithm is supposed
to do
digital signature algorithm is fips
standard which is a federal information
processing standard for digital
signatures
it was proposed in 1991 and globally
standardized in 1994 by the national
institute of standards and technology
also known as the nist
it functions on the framework of modular
exponential and discrete logarithmic
problems which are difficult to compute
as a force brute system
unlike dsa most signature types are
generated by signing message digest with
the private key of the originator this
creates a digital thumbprint of the data
since just the message digest is signed
the signature is generally much smaller
compared to the data that was saying
as a result digital signatures impose
less load on processors at the time of
signing execution and they use small
volumes of bandwidth
dsa on the other hand does not encrypt
message digest using private key or
decrypt message digest using public key
instead it uses mathematical functions
to create a digital signature consisting
of two 160 bit numbers which are
originated from the message digest and
the private key
dc's make use of the public key for
authenticating the signature but the
authorization process is much more
complicated when compared with rsa
dsa also provides three benefits which
is the message authentication integrity
verification and non-repardiation
in the image we can see the entire
process of dsf validation a plain text
message is passed on to a hash function
where the digest is generated which is
passed on to a signing function
signing function also has other
parameters like a global variable g of
random variable k
and the private key of the sender
the outputs are then bundled onto a
single pack with a plain text and sent
to the receiver
the two outputs we receive from the
signing functions are the two 160 bit
numbers denoted by s and r
on the receiver end we pass the plain
text to the same hash function to
regenerate the message digest
it is passed on to verification function
which has other requirements such as the
public key of the sender global variable
g and snr received from the sender
the value generated by the function is
then compared to r
if they match then the verification
process is complete and data integrity
is verified
this was an overview of the way the dsa
algorithm works you already know it
depends on logarithmic functions to
calculate the outputs so let us see how
we can do the same in our next section
we have three phases here the first of
which is key generation
to generate the keys we need some
prerequisites
we'd select a queue which becomes a
prime divisor we select a prime number p
such that p minus 1 mod q equal to 0.
we also select a random integer g which
must satisfy the two formulas being
mentioned on the screen right now
once these values are selected we can go
ahead with generating the keys
the private key can be denoted by x and
it is any random integer that falls
between the bracket of 0 and the value
of q
the public key can be calculated as y
equal to g to the power x mod p
where y stands for the public key
the private key can then be packaged as
a bundle which comprises of values of p
q g and x
similarly the public key can also be
packaged as a bundle having the values
of p
q
g and y
once we're done with key generation we
can start verifying the signature and
this generation
repeat
once the keys are generated we can start
generating the signature
the message is passed through a hash
function to generate the digest h first
we can choose any random integer k which
falls under the bracket of 0 and q
to calculate the first 160 bit number of
our signing function of r we use the
formula g to the power k mod p into mod
q
similarly to calculate the value of the
second output that is s we use the
following formula that is shown on the
screen
the signature can then be packaged as a
bundle having r and s
this bundle along with a plain text
message is then passed on to the
receiver
now with the third phase we have to
verify the signature
we first calculate the message i just
received in the bundle by passing it to
the same hash function
we calculate the value of w
u1
and u2 using the formulas shown on the
screen
we have to calculate a verification
component which is then to be compared
with the value of r being sent by the
sender this verification component can
be calculated using the following
formula
once calculated this can be compared
with the value of r if the values match
then the signature verification is
successful and the entire process is
complete starting from key generation to
the signature generation all the way up
to the verification of the signature
with so many steps to follow we are
bound to have a few advantages to boot
this and we would be right to think so
dsa is highly robust in the security and
stability aspect when compared to
alternative signature verification
algorithms we have a few other ciphers
that aim to achieve the simplicity and
the flexibility of dsa but it has been a
tough ask for all the other suits
the key generation is much faster when
compared to the rsa algorithm and such
while the actual encryption and
decryption process may falter a little
in comparison a quicker start in the
beginning is well known to optimize a
lot of frameworks
dsa requires less storage space to work
its entire cycle
in contrast its direct correspondent
that is rsa algorithm needs a certain
amount of computational and storage
space to function efficiently this is
not the case with dsl which has been
optimized to work with weaker hardware
and lesser resources
the dsa is patented but nist has made
this pattern available worldwide royalty
free
a draft version of the speculation
fips1865
indicates that dsa will no longer be
approved for digital signature
generation but it may be used to verify
signatures generated prior to the
implementation date of that standard
hope you learned something interesting
today if you have any questions
regarding this topic please feel free to
ask us in the comments below and we will
be happy to answer your queries thank
you for watching
hi there if you like this video
subscribe to the simply learn youtube
channel and click here to watch similar
videos turn it up and get certified
click here